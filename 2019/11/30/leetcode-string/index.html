<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="string," />










<meta name="description" content="C++ string 用法初始化1234567string s;&#x2F;&#x2F;默认初始化，一个空字符串string s1(&quot;ssss&quot;);&#x2F;&#x2F;s1是字面值“ssss”的副本string s2(s1);&#x2F;&#x2F;s2是s1的副本string s3&#x3D;s2;&#x2F;&#x2F;s3是s2的副本string s4(10,&#39;c&#39;);&#x2F;&#x2F;把s4初始化string s5&#x3D;&quot;hiya&quot;;&#x2F;&#x2F;拷贝初始化string s6&#x3D;string(10,&#39;c">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode string">
<meta property="og:url" content="http://yoursite.com/2019/11/30/leetcode-string/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C++ string 用法初始化1234567string s;&#x2F;&#x2F;默认初始化，一个空字符串string s1(&quot;ssss&quot;);&#x2F;&#x2F;s1是字面值“ssss”的副本string s2(s1);&#x2F;&#x2F;s2是s1的副本string s3&#x3D;s2;&#x2F;&#x2F;s3是s2的副本string s4(10,&#39;c&#39;);&#x2F;&#x2F;把s4初始化string s5&#x3D;&quot;hiya&quot;;&#x2F;&#x2F;拷贝初始化string s6&#x3D;string(10,&#39;c">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg">
<meta property="article:published_time" content="2019-11-30T08:29:46.000Z">
<meta property="article:modified_time" content="2020-07-03T18:29:17.274Z">
<meta property="article:author" content="Zheng Xing">
<meta property="article:tag" content="string">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/30/leetcode-string/"/>





  <title>leetcode string | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode string</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T16:29:46+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/30/leetcode-string/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/30/leetcode-string/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="C-string-用法"><a href="#C-string-用法" class="headerlink" title="C++ string 用法"></a>C++ string 用法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br></pre></td></tr></table></figure>

<h2 id="特性描述"><a href="#特性描述" class="headerlink" title="特性描述"></a>特性描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;    <span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">s.substr(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// "bcd"</span></span><br><span class="line"></span><br><span class="line">s.append(<span class="string">"h"</span>);    <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">"cd"</span>);    <span class="comment">// 返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br><span class="line"></span><br><span class="line">s.rfind(<span class="string">"cd"</span>);    <span class="comment">// 从后往前找，还是返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)    <span class="comment">// val 转换成 string</span></span><br><span class="line"></span><br><span class="line">stoi(s,p,b)    <span class="comment">// 把字符串s从p开始转换成b进制的int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">os &lt;&lt; i;    <span class="comment">// 把 int 类型传递给 output string stream</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the data is "</span> + os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(<span class="string">"12"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">is &gt;&gt; i;    <span class="comment">// 把 input string steam 传递给 int 类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Python-string-用法"><a href="#Python-string-用法" class="headerlink" title="Python string 用法"></a>Python string 用法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str()    # 数字转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int()    # 浮点数转 int 或者整数字符串转 int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0xA1'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isalpha()    # 判断字符串是否全为字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdigit()    # 判断字符串是否全是数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is_integer()    # 判断浮点数是否为整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># join()    # separator.join(str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.count(substr, start, end)    # 计算 substr 在范围内出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.upper()    # 转大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.lower()    # 转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str[::-1]    # 以让列表反转</span></span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0516-最长回文子序列"><a href="#0516-最长回文子序列" class="headerlink" title="0516 最长回文子序列"></a>0516 最长回文子序列</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p>“bbbab”<br>Output:<br>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划： dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) </span></span><br><span class="line"><span class="comment">otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mat</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            mat[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; s.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                mat[i][i+k] = <span class="built_in">max</span>(s[i] == s[i+k]? <span class="number">2</span> + mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>] : mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>], <span class="built_in">max</span>(mat[i][i+k<span class="number">-1</span>], mat[i+<span class="number">1</span>][i+k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0151-翻转单词"><a href="#0151-翻转单词" class="headerlink" title="0151 翻转单词"></a>0151 翻转单词</h2><p>Given an input string, reverse the string word by word.</p>
<p>Example 1:</p>
<p>Input: “the sky is blue”<br>Output: “blue is sky the”</p>
<p>Example 2:</p>
<p>Input: “  hello world!  “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p>
<p>Example 3:</p>
<p>Input: “a good   example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一：使用 stringstream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is &gt;&gt; temp)&#123;</span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">int</span>(vec.<span class="built_in">size</span>())<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            os&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=os.str();</span><br><span class="line">        ans.resize(ans.<span class="built_in">size</span>()<span class="number">-1</span>);    <span class="comment">// 小技巧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：保证不开辟额外的 vector 来保存各个 word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以先把 leading, trailing 的零和中间过多的 0 给去除掉</span></span><br><span class="line"><span class="comment">然后 resize</span></span><br><span class="line"><span class="comment">然后左右翻转，这个容易，但是这时候每个单词本身也左右翻转了。</span></span><br><span class="line"><span class="comment">需要对每个单词本身左右翻转一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之后呢</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符替换和复制"><a href="#字符替换和复制" class="headerlink" title="字符替换和复制"></a>字符替换和复制</h2><p>删除一个字符串所有的 a, 并且复制所有的 b. 注意，字符数组足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析：先删除 a, 可以利用原来字符串的空间。</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] != <span class="string">'a'</span>)&#123;</span><br><span class="line">        s[n++] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        ++numb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再复制 b, 注意字符串要加长。</span></span><br><span class="line"><span class="comment">//     先计算字符串里有几个 b，得到复制后的长度。</span></span><br><span class="line"><span class="comment">//     然后“倒着”复制 --- 管用技巧。</span></span><br><span class="line"><span class="keyword">int</span> newLength = n + numb;</span><br><span class="line">s[newLength] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = newLength - <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">    s[i--] = s[j];</span><br><span class="line">    <span class="keyword">if</span>(s[j] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        s[i--] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0796-rotate-string"><a href="#0796-rotate-string" class="headerlink" title="0796 rotate string"></a>0796 rotate string</h2><p>We are given two strings, A and B.</p>
<p>A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是个巧妙地解法。避免了尝试去分析到底字符串 A 平移了多少个位置才得到 B.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rotateString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (A+A).<span class="built_in">find</span>(B) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>剑指offer: 表示数值的字符串<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0316-删除重复字符"><a href="#0316-删除重复字符" class="headerlink" title="0316 删除重复字符"></a>0316 删除重复字符</h2><p>[题目]</p>
<ul>
<li>给定一个仅有小写字母的字符串，只能删除一些字符而不能修改字符顺序；</li>
<li>任务是最终的字符串中原先的每种字符只出现一次，并且结果字典序最小。</li>
</ul>
<p>[分析]</p>
<ul>
<li>如果有 ‘a’, 但是 ‘a’ 的左右两边都存在 ‘b’，那么为了字典序较小，我们肯定是保留 ‘a’ 右侧的 ‘a’</li>
<li>但是如果只有 ‘a’ 的左侧有 ‘b’，那么没办法，只能保留左侧的 ‘b’</li>
</ul>
<p>[解法一：贪心法]</p>
<ul>
<li>延缓决定每种字符的位置，让每个位置字符尽可能小<ul>
<li>某字符在原始字符串中最后出现在位置 p, 它必须出现在结果中了</li>
<li>p 位置及其左边有“更小”的字符，则优先选取它们！</li>
</ul>
</li>
<li>细节<ul>
<li>有多个“最小值”，取最左边的，这样子给右边足够的空间</li>
<li>时间复杂度，大于 O(n)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>;    <span class="comment">// 记录每个字符在不在结果中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ) &#123;    <span class="comment">// 没有自动 i++, 需要在函数体里执行这一句</span></span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>( (num[c] == <span class="number">1</span>) &amp;&amp; (!in[c]) )&#123;    <span class="comment">// 这是字符 s[i] 最后一次出现了！并且它还不在 answer 中</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找到双闭区间 s[last...i] 中最小的那个字符，如果有多个，则是最左边那个</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = last; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( (!in[s[j] - <span class="string">'a'</span>]) &amp;&amp; ((x &lt; <span class="number">0</span>) || (s[j] &lt; s[x])) )&#123;</span><br><span class="line">                        x = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                answer += s[x];</span><br><span class="line">                in[s[x] - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[x] == s[i])&#123;    <span class="comment">// 只有当 s[i] 前面所有的不大于它的字符(包括自己喽)都加进去后，才会 i++</span></span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                last = x + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --num[c];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二：优化？]</p>
<ul>
<li>反思<ul>
<li>我们之所以不敢加一个字符，是怕后面出现了比它还小的字符，并且那个小字符的后面还有这个字符</li>
<li>但是如果我们不加，后面没有这个字符了咋办</li>
</ul>
</li>
<li>可以引入“后悔”</li>
<li>用一个“堆栈”临时保存结果字符串<ul>
<li>从栈底到栈顶 对应从左到右</li>
<li>一个字符如果右边还有，可以自由弹出堆栈</li>
<li>一个字符如果右边没有，<mark>卡住堆栈，它以及被它压住的那些元素均不能弹出</mark></li>
<li>字符 x 入栈前，把堆栈里可以弹出的比它大的字符弹出</li>
</ul>
</li>
<li>时间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>; </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            --num[c];</span><br><span class="line">            <span class="keyword">if</span>(!in[c])&#123;</span><br><span class="line">                <span class="keyword">while</span>( (!st.empty()) &amp;&amp; (st.top() &gt; s[i]) &amp;&amp; (num[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>) )&#123;</span><br><span class="line">                    in[st.top() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">                in[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; !st.empty(); st.pop())&#123;</span><br><span class="line">            answer = st.top() + answer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号系列"><a href="#括号系列" class="headerlink" title="括号系列"></a>括号系列</h2><h3 id="0032-最长有效括号"><a href="#0032-最长有效括号" class="headerlink" title="0032 最长有效括号"></a>0032 最长有效括号</h3><p>[题目]</p>
<ul>
<li>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</li>
<li>Example 1<ul>
<li>输入：”(()”</li>
<li>输出：2</li>
</ul>
</li>
<li>Example 2<ul>
<li>输入：”)()())”</li>
<li>输出：4 , 因为最长的子串为 “()()”</li>
</ul>
</li>
</ul>
<p>[方法一：使用 stack]</p>
<ul>
<li>这个题目相当于是 LeetCode 第 20 题 有效的括号 的升级版。</li>
<li>于是可以尝试借助 栈 这个数据结构去解决。</li>
<li>括号相关的问题首先可以尝试使用 栈 这个数据结构去解决，至于原因，想一想应该不难理解，如果进来一个右括号，也就是 ‘)’，它会和之前 最后一次遍历到的左括号 匹配，栈的 先进后出 的特性保证了这一要求。</li>
<li>对于这道题目，因为我们要求的是子串的长度，因此<mark>我们可以考虑在栈中保存 index，这样子我们不仅可以通过 index 找到对应的括号，还可以借此来求长度</mark></li>
<li>我们的思路可以分为下面几步：<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，意味着这并不能和前面遍历过的部分组成合法答案，此时我们只需要把当前 index 入栈即可</li>
<li>如果遇到的是 ‘)’，这时我们就要看栈顶保存的元素了，这里就会有几种情况：<ol>
<li>栈顶保存的是 ‘(‘<ol>
<li>表示当前元素和栈顶元素可以配对，这个时候我们需要把栈顶元素弹出栈，</li>
<li>记录答案则记录当前 index 和弹出配对元素后的新栈顶 index 之间的距离，</li>
<li>这个地方是重点，如果不理解，你可以思考下面两个例子：</li>
<li>“((()()”</li>
<li>“((())”</li>
</ol>
</li>
<li>栈顶保存的是 ‘)’，<ol>
<li>如果是这种情况，表示前面没有可配对的  ‘(‘，我们此时还是需要把当前 index 入栈，原因是</li>
<li>我们确定距离需要知道边界，如果不理解，还是有两个例子供你参考：</li>
<li>“))(())”</li>
<li>“())()()”</li>
</ol>
</li>
<li>栈是空的<ol>
<li>当然在第一种情况中，你弹出栈顶元素后也会使得栈变空，</li>
<li>为了避免这种情况，我们可以在最开始的时候推一个 -1 入栈，这样可以节省我们的判断次数，</li>
<li>并且当栈中的没有元素的时候，我们也可以用这个 -1 来计算当前子串的长度，你可以参考下面这两个例子：</li>
<li>“()”</li>
<li>“()(())”</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>[方法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mystack;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(<span class="number">-1</span>);    <span class="comment">// -1 用于处理边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// mystack.size() &gt; 1 表示栈不为空，而且我们必须保证栈顶元素是 '('</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; mystack.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[mystack.top()] == <span class="string">'('</span>)&#123;</span><br><span class="line">            mystack.pop();    <span class="comment">// 配对的 '(' 出栈</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, i - mystack.top());  <span class="comment">// 记录长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mystack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[方法二：动态规划]<br><mark>这个方法不是很容易理解！要好好体会! 感觉思想很类似求解回文子串的马拉车算法！</mark></p>
<p>我们可以<mark>定义 dp[i] 表示以 s[i] 结尾的最长的括号子串的长度</mark>，思路如下：</p>
<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，因为有效的括号串只能以 ‘)’ 结尾，所以 dp[i] = 0</li>
<li>如果遇到的是 ‘)’，要分情况讨论：<ol>
<li>如果 str[i - 1] 是 ‘(‘，<ol>
<li>那么 dp[i] = dp[i - 2] + 2</li>
</ol>
</li>
<li>如果 str[i - 1] 是 ‘)’，<ol>
<li>则我们需要看以 str[i - 1] 结尾的最长有效括号串 (很明显，它的长度为 dp[i-1])</li>
<li>然后我们要跳过这个括号串，找到它左边那个没有被匹配的字符 s[i - dp[i - 1] - 1]<ol>
<li>如果这个没有被匹配的字符是左括号，那么 s[i] 可以与它搭配成一个左右括号对，因此 <code>dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]</code> <ol>
<li>公式里面的 <code>2</code> 来自于 s[i] 和 s[i - dp[i-1] -1] 形成的括号对</li>
<li>公式右边第三项来自于: 看看当前的序列是否可以和之前匹配的序列链接起来，也就是加上 dp[i - dp[i - 1] - 2]</li>
</ol>
</li>
<li><mark>如果这个没有被匹配的字符是右括号，那么 s[i] 不能与它搭配成一个括号对，dp[i] = 0<ol>
<li>这个结论并没有很明显，你会怀疑，那不能与它搭配就不可以在与之前的搭配吗？</li>
<li>它是个右括号呀！我们跳过以它结尾的最长有效括号串，再找到左边的字符看看是左括号不行吗？？？</li>
<li>不行！！！</li>
<li>为什么呢？因为如果有以 s[i - dp[i-1] - 1] 结尾的最长有效括号串，那么这个括号串一定会和刚才跳过的那个以 s[i-1] 结尾的有效括号串连接起来形成一个更长的有效括号串！</li>
<li>换句话说，因为 dp[i-1] 表示的是以 s[i-1] 结尾的最长的有效括号串，那么我们跳过它之后，左边如果碰到了右括号，那么以这个右括号结尾的最长有效括号串长度为 0，不存在！</li>
<li>不需要再往左边查看了，直接让 dp[i] = 0 即可</mark></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 只需要考虑右括号，左括号对应位置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (sArr[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    <span class="comment">// 前一个位置是 '('，直接配对</span></span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;                      <span class="comment">// 前一个位置是 ')'</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 需要跳过以 sArr[i-1] 结尾的最长的有效括号串找到第一个没有被匹配的位置</span></span><br><span class="line">                <span class="comment">// 如果那个位置是 '('，则可以与 sArr[i] 进行匹配</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; sArr[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    </span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;    <span class="comment">// 没有越界的话就加上</span></span><br><span class="line">                        dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者更简洁的 C++ 代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">longest</span><span class="params">(s.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; i-longest[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-longest[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                longest[i] = longest[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-longest[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?longest[i-longest[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                curMax = <span class="built_in">max</span>(longest[i],curMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>[思路三：双指针法]</p>
<ol>
<li>使用了两个变量 Left 和 Right，分别用来记录到当前位置时左括号和右括号的出现次数。</li>
<li>当遇到左括号时，Left 自增 1，右括号时 Right 自增1。</li>
<li>对于最长有效的括号的子串，一定是左括号等于右括号的情况，此时就可以更新结果 res 了，一旦右括号数量超过左括号数量了，说明当前位置不能组成合法括号子串，Left 和 Right 重置为 0。</li>
<li>但是对于这种情况 “(()” 时，在遍历结束时左右子括号数都不相等，此时没法更新结果 res，但其实正确答案是 2，怎么处理这种情况呢？</li>
<li>答案是再 反向遍历一遍 ，采取类似的机制，稍有不同的是此时若 Left 大于 Right 了，则重置 0，这样就可以涵盖所有情况。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0301-最长合法括号系列"><a href="#0301-最长合法括号系列" class="headerlink" title="0301 最长合法括号系列"></a>0301 最长合法括号系列</h3><p>[题目]<br>给定一个括号序列（可能包括非括号），删除尽可能少的括号，使得剩余括号序列合法，求所有合法最长序列。</p>
<p>[Example]</p>
<ul>
<li>Input: “()())()”</li>
<li>Output: [“()()()”, “(())()”]</li>
</ul>
<p>[解法一思路]</p>
<ul>
<li>动态规划</li>
<li>前 i 个字符，左括号个数比右括号个数多 j 个的最长合法括号序列长度定义为 <code>dp[i][j]</code><ul>
<li>这里的“合法”啥意思？</li>
<li>长度不是指左右括号匹配的长度，而是左括号比右括号多 j 个的括号序列的长度</li>
</ul>
</li>
<li>递归<ul>
<li><code>dp[i][j]</code> = <ul>
<li><code>max(dp[i-1][j], dp[i-1][j-1] + 1) if s[i] == &quot;(&quot;</code>    第二项加 1 是因为要把 s[i] 也包括进来</li>
<li><code>max(dp[i-1][j], dp[i-1][j+1] + 1) if s[i] == &quot;)&quot;</code>    同上！</li>
<li><code>dp[i-1][j] + 1  if s[i] == 其他非括号字母</code></li>
</ul>
</li>
</ul>
</li>
<li>初值<ul>
<li><code>dp[0][0] = 0</code></li>
<li><code>dp[0][x&gt;0] = -infinity</code></li>
</ul>
</li>
<li>“偷懒”记路径<ul>
<li><code>set&lt;string&gt;</code> 记录所有中间字符串</li>
<li>同一个集合里所有的串长度相同</li>
</ul>
</li>
<li>空间优化<ul>
<li><code>dp[i][.]</code> 只与 <code>dp[i-1][.]</code> 有关</li>
<li>滚动数组</li>
</ul>
</li>
</ul>
<p>[解法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">better</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; a, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(b.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> &gt; b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>())&#123;    <span class="comment">// a 元素长度 + 1 大于 b 中元素长度时候，b 被清空</span></span><br><span class="line">            b.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> == b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>();  <span class="comment">// 此时 a 和 b 要 merge 到一起, 因为答案要全部的结果！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">have</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        have[<span class="number">0</span>].insert(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j<span class="number">-1</span>], have[j])) &#123;    <span class="comment">// better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j<span class="number">-1</span>].<span class="built_in">begin</span>(); it != have[j<span class="number">-1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">"("</span>);  <span class="comment">// have[j-1]</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j + <span class="number">1</span>], have[j])) &#123;  <span class="comment">// // better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j+<span class="number">1</span>].<span class="built_in">begin</span>(); it != have[j+<span class="number">1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">")"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator t = have[j].<span class="built_in">begin</span>(); t != have[j].<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">                        temp.insert(*t + s[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    have[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[<span class="number">0</span>].<span class="built_in">begin</span>(); it != have[<span class="number">0</span>].<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            answer.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二: BFS]</p>
<ul>
<li>先把原来的字符串(长度 n)放入一个队列中</li>
<li>每一次循环，从队列中取出一个字符串(长度为 k)，检查其是否合法<ul>
<li>如果合法，则将依次检查队列中剩下的所有元素，看其是否合法</li>
<li>如果不合法，则把这个字符串每个括号位置字符删掉后的结果(一共是 k 个长度为 k-1 的字符串)加到队列中，然后看下一个字符串</li>
</ul>
</li>
<li>所以此处 BFS 的思想是扫完全部的长度为 n 的后，再扫完全部的长度为 n-1 的字符串，etc.</li>
<li><font color="red">TODO: 有一点没有想明白就是它一旦找到一个合法的字符串，就会停止加入新的字符串，并且会把队列当中剩下的所有的合法的字符串放到结果中！我的问题是，它怎么保证结果里面不会同时含有长度为 max_len 的字符串和 max_len-1 的字符串呢？</font><ul>
<li><font color="red">看了 leetcode 讨论区才意识到，确实不会出现这种情况。因为 BFS 的每一层都比上一层的字符串少一个括号！如果你找到了一个结果之后，那么就意味着当前这一层的左括号与右括号匹配，意味着括号数量是偶数！那么队列中存在的下一层的字符串含有的括号数量是奇数！绝对不可能是答案！</font></li>
<li>其实也可以找到答案的时候把长度记录下来，然后队列里的元素拿出来的时候先判断一下长度是否符合，如果不符合，就不需要调用 <code>isValid()</code> 函数了。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(t)) &#123;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] != <span class="string">'('</span> &amp;&amp; t[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">string</span> str = t.substr(<span class="number">0</span>, i) + t.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!visited.count(str)) &#123;</span><br><span class="line">                    q.push(str);</span><br><span class="line">                    visited.insert(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者是使用 <code>unordered_set</code> 的数据结构，可以解决我上面的疑问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; cur&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!cur.empty()) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(a)) res.push_back(a);</span><br><span class="line">                <span class="keyword">if</span> (!res.empty()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] != <span class="string">'('</span> &amp;&amp; a[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    next.insert(a.substr(<span class="number">0</span>, i) + a.substr(i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty()) <span class="keyword">return</span> res;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法三:递归，DFS]</p>
<ul>
<li>这种解法首先统计了<font color="red">多余的</font>半括号的数量，用 cnt1 表示多余的左括号，cnt2 表示多余的右括号。<mark>“多余的”意味着需要把它们删掉，也就是说我们的目标是: 让 cnt1 和 cnt2 降为 0.</mark></li>
<li>因为给定字符串左右括号要么一样多，要么左括号多，要么右括号多，也可能左右括号都多，比如 “)(“。</li>
<li>所以 cnt1 和 cnt2 要么都为0，要么都大于0，要么一个为0，另一个大于0。</li>
<li>好，下面进入递归函数<ul>
<li>首先判断，如果当 cnt1 和 cnt2 都为0时，说明此时左右括号个数相等了，调用 isValid 子函数来判断是否正确，正确的话加入结果 res 中并返回即可。</li>
<li>否则从 start 开始遍历<ul>
<li>这里的变量 start 表示当前递归开始的位置，不需要每次都从头开始，会有大量重复计算。</li>
<li>而且对于多个相同的半括号在一起，只删除第一个，比如 “())”，这里有两个右括号，不管删第一个还是删第二个右括号都2会得到 “()”，没有区别，所以只用算一次就行了，通过和上一个字符比较，如果不相同，说明是第一个右括号，如果相同则直接跳过。</li>
</ul>
</li>
<li>此时来看如果 cnt1 大于0，说明此时左括号多，而如果当前字符正好是左括号的时候，可以删掉当前左括号，继续调用递归，此时 cnt1 的值就应该减1，因为已经删掉了一个左括号。</li>
<li>同理，如果 cnt2 大于0，说明此时右括号多，而如果当前字符正好是右括号的时候，可以删掉当前右括号，继续调用递归，此时 cnt2 的值就应该减1，因为已经删掉了一个右括号，参见代码如下：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1 == <span class="number">0</span>) cnt2++;</span><br><span class="line">                <span class="keyword">else</span> cnt1--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, cnt1, cnt2, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt1, <span class="keyword">int</span> cnt2, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s)) res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt1 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) &#123;    <span class="comment">// 删除左括号以使得 cnt1 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1 - <span class="number">1</span>, cnt2, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt2 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 删除右括号以使得 cnt2 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1, cnt2 - <span class="number">1</span>, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我的思考：</p>
<ol>
<li>这里的思路还是很明确的，计算 cnt1, cnt2 然后想办法删除左右括号来降低 cnt1, cnt2 使得它们都变成 0.</li>
<li>这里其实有一些删除是无意义的，多做了。比如 “(())))((“ 这里 <code>cnt1 = cnt2 = 2</code>，算法会从字符串最左边开始，发现是左括号，然后此时 <code>cnt1=2&gt;0</code> 所以会进入下一层 DFS! 但是这里的 cnt1 =  2 实际上是来自于最右边的两个左括号啊！你删除最左边的没有意义！</li>
<li>所以算法里面实际上是有一些多余的操作的。不过貌似也没有什么好办法去避免这些无意义的操作。</li>
</ol>
<p>[解法四：递归 DFS]</p>
<ul>
<li>本解法跟解法三一样都是 DFS 的思想，但是上面提到，解法三里面有不少操作是没有意义的多余操作</li>
<li>而这里的解法每一步的递归都会得到一个有效的结果！不存在无意义的递归！</li>
<li>思路解析：<ul>
<li>We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter. The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.</li>
<li>To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.</li>
<li>After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.</li>
<li>For this, we keep tracking the last removal position and only remove ‘)’ after that.</li>
<li>Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?<ul>
<li>The answer is: do the same from right to left.</li>
<li>However a cleverer idea is: reverse the string and reuse the code!</li>
</ul>
</li>
</ul>
</li>
<li>我的理解：<ul>
<li>为啥这个算法每次的递归都会产生一个有意义的结果呢？你看它的思路是，从左往右扫，一旦 stack 不满足大于等于 0 的时候（也就是 stack = -1 嘛）会从左边的 prefix 里面删除一个右括号，这样子左边的 prefix 就是一个有意义的结果了啊！</li>
<li>并且它删的时候也特别注意，对于每一段连续的右括号只会删除第一个右括号，保证了不会有重复的结果产生。</li>
<li>它还有一个技巧使用了 {‘(‘, ‘)’} 也特别惊艳！并且它是在 helper 函数最后这么用的，保证了对任何一个子串都会考虑这两种情况！</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> last_i, <span class="keyword">int</span> last_j, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_i; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[<span class="number">0</span>]) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == p[<span class="number">1</span>]) --cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = last_j; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == p[<span class="number">1</span>] &amp;&amp; (j == last_j || s[j] != s[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="comment">// Recursion: last_i = i 因为 i 左边的 prefix 正好是完全匹配的了。</span></span><br><span class="line">                    <span class="comment">// last_j = j 避免产生重复的结果。</span></span><br><span class="line">                    helper(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, p, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              不要小看这个 return.</span></span><br><span class="line"><span class="comment">              能到这里，说明这个字符串 s 在从左往右扫的时候，出现了右括号多于左括号的情况。</span></span><br><span class="line"><span class="comment">              你递归后就会去处理剩下的那部分了，因此不需要再继续往后执行了。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> rev = <span class="built_in">string</span>(s.rbegin(), s.rend());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">'('</span>) helper(rev, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;, res);</span><br><span class="line">        <span class="keyword">else</span> res.push_back(rev);    <span class="comment">// 能到这一步说明这里的 s 是原来的 s 翻转得到的，而这里的 rev 是 s 的翻转，所以就是与原来的顺序相同了！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*上面的两行可以稍微优化一下*/</span></span><br><span class="line">        <span class="comment">// if(cnt == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     res.push_back(p[0] == '(' ? s : rev);</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     if(p[0] == '(') helper(rev, 0, 0, &#123;')', '('&#125;, res);</span></span><br><span class="line">        <span class="comment">//     else res.push_back(rev);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>我突然发现这个算法是最适合没有计算机的时候，如果让你拿一支笔一张纸如何得到所有的结果！我自己试验了一下，真得非常棒！</li>
<li>一个例子 “()())()”<ol>
<li>第一次调用 helper, s = “()())()”</li>
<li>上面的调用会在内层 for loop 里面产生两次调用，一个传递 s = “(())()”，一个传递 “()()()”。并且不会执行外层 for loop 下面的任何语句了。即<ol>
<li>要么不分裂,cnt一直大于等于 0，会跑到外层 for loop 后面语句执行。</li>
<li>要么分裂了，产生了几个递归后直接返回，不会执行外层 for loop 后面的任何语句。</li>
</ol>
</li>
</ol>
</li>
<li>另外我发现上面的算法有一些多余的步骤，所以我修改了一点，参见上面的代码最后。<ol>
<li>主要就是如果 s 刚好是完美匹配了，即不需要删除任何东西，此时 cnt 等于 0，可以直接返回 s 或者 rev.</li>
<li>按照作者的思路，即使完美匹配了，还是会继续对 rev 来一遍操作(虽然操作只是简单地从头到尾遍历了一下每个字符，改变了cnt 的值，但是复杂度也是 O(N) 啊！此处 N 为字符串长度。)</li>
</ol>
</li>
</ol>
<h2 id="字符串全排列-permutation"><a href="#字符串全排列-permutation" class="headerlink" title="字符串全排列 permutation"></a>字符串全排列 permutation</h2><p>[题目]ku<br>给定字符串 S, 设计算法，枚举 S 的全排列。</p>
<p>[代码]<br>当字符串里面的字符互不相等的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;    <span class="comment">// 依次拿 n 之后每个字符与 n 位置交换</span></span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 把后面 i 位置上的字符与当前 n 位置字符交换。</span></span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 恢复回来。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abcde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有重复字符的时候的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDuplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &lt; t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[n] == S[t]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isDuplicate(S, n, i)) <span class="keyword">continue</span>;  <span class="comment">// 检查范围 [n,i) 中是否有元素与 S[i] 一样。</span></span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abbccde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>非递归算法</mark><br>参考 leetcode O(n) time complexity 一文中介绍的 next permutation 题目</p>
<p>[思路]<br>将给定的字符串 S 首先升序排序，然后依次调用 std::next_permutation 直到返回 false, 即完成了非递归的全排列算法。</p>
<h2 id="Permutation-Sequence-lc0060"><a href="#Permutation-Sequence-lc0060" class="headerlink" title="Permutation Sequence lc0060"></a>Permutation Sequence lc0060</h2><p>[题目]</p>
<ol>
<li>The set [1,2,3,…,n] contains a total of n! unique permutations.</li>
<li>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
</li>
<li>Given n and k, return the kth permutation sequence.</li>
<li>Note:<ol>
<li>Given n will be between 1 and 9 inclusive.</li>
<li>Given k will be between 1 and n! inclusive.</li>
</ol>
</li>
<li>Example 1:<ol>
<li>Input: n = 3, k = 3</li>
<li>Output: “213”</li>
</ol>
</li>
<li>Example 2:<ol>
<li>Input: n = 4, k = 9</li>
<li>Output: “2314”</li>
</ol>
</li>
</ol>
<p>[分析二]</p>
<ol>
<li>这个思路是第二次看的时候想出来的，是递归的思路，逐渐找到当前字串的首字母</li>
</ol>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res += (i + <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(res, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> res, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());    <span class="comment">// 这里注意一定要 sort, 使剩下的子串顺序正确！否则会出现比如 "123"，把 '3' 挪到第一位后变成 "321" 的错误（应该是 "312"）。</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> fac = calFactorial(res.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = (k - <span class="number">1</span>) / fac;        <span class="comment">// 看看应该把第几个位置上的数字放到最左边！！！</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; fac &lt;&lt; " " &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        swap(res[<span class="number">0</span>],res[temp]);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] + helper(res.substr(<span class="number">1</span>), k - temp * fac);    <span class="comment">// 递归！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calFactorial</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            ans *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0040-Wildcard-Matching"><a href="#0040-Wildcard-Matching" class="headerlink" title="0040 Wildcard Matching"></a>0040 Wildcard Matching</h2><p>[题目]</p>
<ul>
<li>判断字符串 s 是否与含有通配符 <code>?</code> 和 <code>*</code> 的串 p 匹配。<ul>
<li>其中 <code>?</code> 可以匹配任何的字母</li>
<li>而 <code>*</code> 可以匹配任意长的字母串（包括空串）。</li>
</ul>
</li>
</ul>
<p>[思路一: DP]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    二维DP。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态表示：</span></span><br><span class="line"><span class="comment">    res[i][j] records whether the first i characters of s can be matched by the first j characters of p.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态转移方程：</span></span><br><span class="line"><span class="comment">    res[i][j] = </span></span><br><span class="line"><span class="comment">      1) if p[j] == '?', then res[i][j] = res[i-1][j-1]</span></span><br><span class="line"><span class="comment">      2) if p[j] == '*'  then res[i][j] = true (if exist k in (0,1,...,i) for res[k][j-1]=true, 即p的前j-1个字符可以match某个长度的 s)</span></span><br><span class="line"><span class="comment">                                        = false (if no exist k ...)</span></span><br><span class="line"><span class="comment">      3) if p[j] is small letter, then res[i][j] == res[i-1][j-1] &amp;&amp; (s[i] == p[j]).</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">    优化：</span></span><br><span class="line"><span class="comment">    滚动数组方法</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[i] record whether the first i characters of s can be matched.</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个为啥置为 true 呢，因为初始的 res 数组 res[i] 代表 p 的前面 0 个字符能否 match s 的前 i 个字符。</span></span><br><span class="line">        <span class="comment">// res[0] = true 因为 p 的前面 0 个字符可以匹配 s 的前面 0 个字符。</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="literal">true</span>;                        </span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; p.<span class="built_in">size</span>(); col++)&#123;   <span class="comment">// loop the char of p, each time updates the whole res array</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); row &gt; <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[col] == <span class="string">'?'</span>)</span><br><span class="line">                    res[row] = res[row<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[col] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= row; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res[k]) &#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res[row] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    res[row] = (res[row<span class="number">-1</span>] &amp;&amp; p[col] == s[row<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要 p 当中出现了不是星号的时候，res[0] 就必须改成 false 了</span></span><br><span class="line">            <span class="comment">// 因为此时 p 的前 col+1 个字符就不能匹配上 s 的前 0 个字符了。</span></span><br><span class="line">            <span class="keyword">if</span>(p[col] != <span class="string">'*'</span>)</span><br><span class="line">                res[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个时间复杂度很慢，耗时 500ms, 超过了 5.53% 的提交</li>
<li>可以改成 int array 来实现，速度提高到耗时 160ms, 超过 11.28% 的提交。</li>
</ol>
<p>[思路二：贪心，有点 DFS 思想]</p>
<ul>
<li>这个问题的难点就在于星号的处理，它可以匹配 0 个，1 个，2 个，etc</li>
<li>此处的思路就是，我们先考虑星号匹配 0 个字符的情况，即跳过星号，接着进行匹配。如果发现不行了，就回溯检查，让星号匹配 1 个字符，以此类推。<ul>
<li>可以看出来有点 DFS 思想，和贪心的思想。</li>
</ul>
</li>
<li>代码里面 last_match 实际是表示 <code>s[last_match] == p[starj + 1]</code>, 即 last_match 指向的字符与 starj + 1 指向的字符分别作为开头进行的匹配。它们前面的 prefix 是匹配好的。<ul>
<li>如果 i 和 j 对应的字符不匹配了，就需要把 i 回溯到 last_match + 1 (last_match 同时也加一), 同时 j 也回溯到 lastj + 1</li>
</ul>
</li>
<li>平均时间复杂度可能是 O(M+N)</li>
<li>最坏的时间复杂度为 O(MN)<ul>
<li>eg. s = “aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”, p = <code>&quot;*aaaaaab&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">int</span> last_match = <span class="number">-1</span>, starj = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m)&#123;</span><br><span class="line">        <span class="comment">// 把两个指针都往前移动一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'?'</span>))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发现 '*' 则，只把 p 的指针前移一位。注意如果是多个星号连续出现，则会在这一步移动到最后一个星号。</span></span><br><span class="line">        <span class="comment">// 毕竟连续的星号作用也只相当于一个星号！因此可以只考虑最后一个！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starj = j;</span><br><span class="line">            j++;</span><br><span class="line">            last_match = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starj != <span class="number">-1</span>)&#123;</span><br><span class="line">            j = starj + <span class="number">1</span>;</span><br><span class="line">            last_match++;</span><br><span class="line">            i = last_match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 p 剩下的字符是否都是 *</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>) j++;</span><br><span class="line">    <span class="keyword">return</span> j == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>本来我有个疑问，万一有两个星号怎么办？<ol>
<li>我们只有一个 lastj 记录星号的位置，万一第一个星号我们考虑它匹配 3 个字符，然后后面匹配过程中碰到了第二个星号，我们让 lastj 指向了第二个星号。</li>
<li>这个时候我们没有办法再回到第一个星号考虑让它匹配 4 个，5 个，等字符的情况了啊？</li>
<li>万一正确答案是第一个星号匹配 6 个字符的情况咋办？</li>
</ol>
</li>
<li>举个例子<ol>
<li>s = <code>&quot;abxyzcdecdeijkmn&quot;</code></li>
<li>p = <code>&quot;ab*cde*kmn&quot;</code></li>
</ol>
</li>
<li>事实上，代码是没有问题的<ol>
<li>上面的例子中，我本来是想让第一个星号匹配 “xyzcde”, 第二个星号匹配 “ij”的。</li>
<li>但是，按照代码里面的话，第一个星号在匹配了 “xyz” 后，就走到了第二个星号了，然后把 lastj 指向第二个星号了。这个看起来会有问题，但是代码实际上还是 return true. 即得到了正确的结果！<ul>
<li>为什么呢？</li>
<li>因为这种情况下是存在多解的！</li>
<li>第一个星号可以只匹配 “xyz”，然后第二个星号匹配 “cdeij”。程序找到的就是这个解，因此返回 true.</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="0010-Regular-Expression-Matching"><a href="#0010-Regular-Expression-Matching" class="headerlink" title="0010 Regular Expression Matching"></a>0010 Regular Expression Matching</h2><p>[题目]</p>
<ul>
<li>实现正则表达式匹配<ul>
<li>支持 ‘.’: matches any single character</li>
<li>支持 <code>&#39;*&#39;</code>: matches 0 or more of the preceding element</li>
</ul>
</li>
<li>字符串 s 可能为空，并且只含有小写字母</li>
<li>模式串 p 可能为空，只含有小写字母，<code>.</code> 或者 <code>*</code></li>
<li>原理参见<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Leetcode</a></li>
</ul>
<p><font color='red'>[思路一：分治 Divide and Conquer]</font></p>
<ul>
<li>分治作为一种经典和重要的算法设计思路，是很多解题的出发点，练习分治的能力很重要！</li>
<li>考虑一般 p 和 s 都不为空的情况，从 p 和 s 的头观察：<ul>
<li>如果 p 的第二个字母不是 <code>*</code>，那么<ul>
<li>需要 (1) p[0] 和 s[0] 匹配, 此时 p[0] 可以是 <code>.</code> 或者字母</li>
<li>以及 (2) s.substr(1) 与 p.substr(1) 匹配</li>
</ul>
</li>
<li>如果 p 的第二个字符是 <code>*</code>，需要满足如下两个条件<ul>
<li>一是，p 去掉头两个字符剩下的 p.substr(2) 可以和 s 的某个后缀匹配</li>
<li>二是，p 的前两个字符能匹配 s 剩下的前缀 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 空的 p 只能匹配空字符串</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个字符为 '*'</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举所有能匹配前两个字符的前缀，剩下的部分是子问题</span></span><br><span class="line">        <span class="comment">// 这里用 do-while 而不是 while loop 是为了处理好 match empty prefix 的情况</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s.substring(k), p.substring(<span class="number">2</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k &lt; s.length() &amp;&amp; isMatch(s[k++], p[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>分治的方法不难理解，但是运行效率较慢</li>
<li>假设s的长度是n，p的长度是m，最坏情况下每一层recursion会产生O(n)个递归调用，而recursion的深度是O(m)，按照DFS的复杂度分析公式，时间复杂度高达O(n^m)</li>
</ol>
<p><font color='red'>[思路二：改进分治]</font></p>
<ol>
<li>在分治的过程中，核心的部分是 induction rule 的构建，而对于同一个分治的定义，是可以有不同的 induction rule 的，不同的 induction rule 带来的效率也是不同的。</li>
<li>对于 <code>*</code> 的情况，我们也可以只分成两种情况讨论：匹配空前缀，或者匹配非空前缀。<ol>
<li>如果 <code>*</code> 匹配空前缀，且 s 匹配 p.substr(2)，则 s 与 p 匹配。</li>
<li>如果 <code>*</code> 匹配非空前缀，且 s.substr(1) 匹配 p, 则 s 与 p 匹配。<ol>
<li>注意这种情况下没有改变 p 就传给了子问题，可以进一步匹配 s.substr(1) 的前缀（可为空）。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>改进后的分治每一层 dfs 最多可以产生两个递归调用，时间复杂度减少到了 O(2^m).</li>
</ol>
<p><font color='red'>[方法三：记忆化搜索]</font></p>
<ol>
<li>通过观察现有解决方案来找到效率不高的地方，继续利用对常见数据结构和算法的理解进行优化，是系统解决问题的过程中能够体现出的重要能力之一。</li>
<li>注意到 dfs 在搜索过程中有可能会对完全一样的参数（相同的子问题）计算多次。对于同样的参数，dfs 的计算过程和结果都是完全一致的，所以没有必要做重复的计算。避免重复的计算的方法就是把计算的结果按照 dfs 的参数存下来，这样以后遇到之前计算过得 dfs 时候可以直接放回上一次计算的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="built_in">string</span> p, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; memo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> i == s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            memo[i][j] = helper(s, i, p, j+<span class="number">2</span>, visited, memo) || (i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j, visited, memo));</span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"haha2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        memo[i][j] = i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>, visited, memo);</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  <span class="title">visited</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">memo</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>, visited, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>记忆化搜索只需要对代码做简单的改进，然而运行时间却有巨大的提升（leetcode ~12-20ms）.不同子问题的个数总共有 O(mn) 个，每个子问题只计算一遍。每个子问题的开销不包含任何循环，所以只有 O(1).</li>
<li>总的时间复杂度变成了 O(mn). 这是一个很好地空间换时间的策略。</li>
</ol>
<p><font color='red'>[思路四: 动态规划]</font></p>
<ol>
<li>上述三种方法里<ol>
<li>分治法本质上是在一个图上做一个深度优先搜索</li>
<li>而记忆化搜索本质上是按照这个图的拓扑顺序 (topological order) 的逆序填表。</li>
</ol>
</li>
<li>如果我们能用简单的循环描述出图的拓扑顺序，那么就可以用迭代的形式来完成填表的任务，这就是著名的动态规划。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(sLen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(pLen + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个代码在 leetcode oj 上有 4-8ms 的时间复杂度。</li>
<li>如果使用 C array 的话时间和空间复杂度更好。有时候 leetcode oj 给出 0ms 的运行时间。</li>
</ol>
<p>[思路五：动态规划空间优化]</p>
<ol>
<li>在上面的算法里面，我们是按照一行一行的顺序填表的，每填一行的时候只需要用到下一行的值。</li>
<li>也就是说只需要保存最近 2 行的值就能够完成填表的任务了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> dp[<span class="number">2</span>][pLen + <span class="number">1</span>] &#123;&#123;<span class="literal">false</span>&#125;&#125;;             <span class="comment">// 使用 C type array; 还进行了空间优化。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = dp[i%<span class="number">2</span>][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>[更早的思路：递归 DFS]</p>
<ul>
<li>核心就是看看第二个字符是不是 <code>*</code></li>
<li>分如下情况：<ol>
<li>p 为空<ol>
<li>如果 s 为空，则返回 true</li>
<li>如果 s 不为空，返回 false</li>
</ol>
</li>
<li>p 长度为 1<ol>
<li>若 s 长度为 1，并且 <code>p[0] == s[0] 或者 p[0] == &#39;.&#39;</code></li>
<li>否则返回 false</li>
</ol>
</li>
<li>p[1] 即第二个字符不是 <code>*</code><ol>
<li>若此时 s 为空返回 false</li>
<li>s 不为空的话则比较 s[0] 和 p[0], 并且从各自的第二个字符开始调用递归函数匹配</li>
</ol>
</li>
<li>p[1] 第二个字符为 <code>*</code>，进行下列循环，条件是若s不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配s和去掉前两个字符的p（这样做的原因是假设此时的星号的作用是让前面的字符出现0次，验证是否匹配），若匹配返回 true，否则s去掉首字母（因为此时首字母匹配了，我们可以去掉s的首字母，而p由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。</li>
<li>返回调用递归函数匹配s和去掉前两个字符的p的结果（这么做的原因是处理星号无法匹配的内容，比如 s=”ab”, p=”a<em>b”，直接进入 while 循环后，我们发现 “ab” 和 “b” 不匹配，所以s变成 “b”，那么此时跳出循环后，就到最后的 return 来比较 “b” 和 “b” 了，返回 true。再举个例子，比如 s=””, p=”a</em>“，由于s为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(s, p.substr(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s = s.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>【目的】字符串查找！给定文本串 text 和模式串 pattern, 从文本串 text 中找到模式串 pattern 第一次出现的位置。</li>
<li>【复杂度】KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。</li>
<li>【解释】因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</li>
</ul>
<h3 id="BF与KMP区别"><a href="#BF与KMP区别" class="headerlink" title="BF与KMP区别"></a>BF与KMP区别</h3><ul>
<li>假设当前文本串 text 匹配到 i 位置，模式串 pattern 匹配到 j 位置（模式串的开头与 text 串的 i 位置对齐）。</li>
<li>BF算法做法<ul>
<li>如果当前字符匹配成功，即 text[i+j] == pattern[j]，另 i++, j++, 继续匹配下一个字符；</li>
<li>如果字符匹配失败，即 text[i+j] != pattern[j], 另 i++, j=0, 即失败的情况下，模式串 pattern 相对于文本串 text 向右移动了一位。</li>
</ul>
</li>
<li>KMP 算法做法<ul>
<li>如果当前字符匹配成功，同上，i++, j++, 继续匹配下一个字符</li>
<li>如果匹配失败，另 i 不变，j=next[j](此处 next[j]&lt;=j-1), 即模式串 pattern 相对于文本串 text 向右移动了至少一位(移动的实际位数 j-next[j]&gt;=1)</li>
</ul>
</li>
</ul>
<h3 id="字符串比较机制"><a href="#字符串比较机制" class="headerlink" title="字符串比较机制"></a>字符串比较机制</h3><p>我们的想法是：不要出现回溯！如果已经匹配到了 text 串的 i+j 位置，即使没有匹配成功，接下来也要继续从当前位置匹配下去，不能回溯到 i+1 位置重新开始匹配！</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg" alt="Screen Shot 2019-12-22 at 11.22.19.png"></p>
<p><mark>如上图所示，pattern 串的绿色位置和 text 串的黄色字符不匹配，这个时候我们把 pattern 串往右移动，让 C 那个位置去和 text 串的黄色(就是上面提到的 i+j 位置)去比较！而这么比较的前提是，B 方块与 A 方块一样！这就是说 pattern 串在 d 之前的那一部分的 前缀串A 与 后缀串B 相同！</mark></p>
<h3 id="最大k前缀与k后缀"><a href="#最大k前缀与k后缀" class="headerlink" title="最大k前缀与k后缀"></a>最大k前缀与k后缀</h3><p>因此，问题就转化为如下问题</p>
<ul>
<li>对于模式串 pattern 的位置 j，考察 <mark>p[0]p[1]…p[j-2]p[j-1]</mark>，查找其<mark>最大相等的 k前缀 和 k后缀</mark>。<ul>
<li>注意！计算 next[j] 的时候，考察的字符串是模式串的前 j-1 个字符，与 p[j] 无关。</li>
</ul>
</li>
<li>即：查找满足条件的最大的 k，使得 <mark>p[0]p[1]…p[k-1] = p[j-k]p[j-k+1]…p[j-1]</mark></li>
</ul>
<p>[一个具体的例子如下]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg" alt="Screen Shot 2019-12-22 at 11.45.00.png"></p>
<h3 id="next的递推关系"><a href="#next的递推关系" class="headerlink" title="next的递推关系"></a>next的递推关系</h3><ul>
<li>对于模式串的位置 j, 有 next[j]=k, 即 p[0]p[1]…p[k-1]=p[j-k]p[j-k+1]p[j-1]</li>
<li>则，对于模式串的位置 j+1, 考察 p[j]</li>
<li>若 p[k]==p[j]<ul>
<li>则 next[j+1] = next[j]+1</li>
</ul>
</li>
<li>反之若 p[k]!=p[j]<ul>
<li>记 h=next[k]; 如果 p[h]==p[j], 则 next[j+1]=h+1, 否则重复此过程</li>
</ul>
</li>
</ul>
<p>[相等时候]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg" alt="Screen Shot 2019-12-22 at 11.58.12.png"></p>
<p>[不相等时候的递推]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg" alt="Screen Shot 2019-12-22 at 11.59.13.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 Next 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || <span class="built_in">text</span>[i] == pattern[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            ans = i - n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进一步分析-next"><a href="#进一步分析-next" class="headerlink" title="进一步分析 next"></a>进一步分析 next</h3><ul>
<li>文本串匹配到 i，模式串匹配到 j，此刻若 text[i] != pattern[j]，即失败的情况</li>
<li>若 next[j]=k, 说明模式串应该从 j 滑动到 k 位置；</li>
<li>若此时满足 pattern[j] == pattern[k], 因为 text[i] != pattern[j], 所以 text[i] != pattern[k]<ul>
<li>即 i 和 k 没有匹配，应该继续滑动到 next[k]</li>
<li>换句话，在原始的 next 数组中，若 next[j]=k 并且 pattern[j] == pattern[k], next[j] 可以直接等于 next[k].</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg" alt="Screen Shot 2019-12-22 at 12.37.22.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext2</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == p[k])&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[例子]</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="KMP-时间复杂度"><a href="#KMP-时间复杂度" class="headerlink" title="KMP 时间复杂度"></a>KMP 时间复杂度</h3><ul>
<li>考察模式串的”串头”和主串的对应位置，也就是暴力算法中的 i</li>
<li>不匹配：串头后移，保证尽快结束算法</li>
<li>匹配：串头保持不动，i++, j++, 但一旦发现不匹配，会跳过匹配过的字符(next[j])</li>
<li>最坏的情况，当串头位于 N-M 的位置时候算法才结束</li>
<li>因此，匹配的时间复杂度为 O(N)，算上计算 next 的O(M) 时间，整体时间复杂度 O(M+N)，其实一般就认为是 O(N) 了。</li>
<li>最好情况：当模式串的首字符和其他字符都不相等时，模式串不存在相等的 k前缀和 k后缀，next 数组全为 -1<ul>
<li>一旦匹配失败，模式串直接跳过已经比较的字符。比较次数为 N</li>
</ul>
</li>
<li>最差情况：当模式串的首字符和其他字符全都相等时候，模式串存在最长的 k 前缀和 k后缀，next 数组呈现递增样式: -1, 0, 1, 2, …<ul>
<li>每个周期中 m 1 1 1 …</li>
<li>周期 n/m</li>
<li>总次数：(2 - 1/M) * N &lt; 2N</li>
<li><mark>此时变种KMP 的运行情况比较总次数依然为 N.</mark></li>
</ul>
</li>
</ul>
<h3 id="一个应用-PowerString-问题"><a href="#一个应用-PowerString-问题" class="headerlink" title="一个应用 PowerString 问题"></a>一个应用 PowerString 问题</h3><p>[题目]<br>给定一个长度为 n 的字符串 S，如果存在一个字符串 T，重复若干次 T 能够得到 S，那么，S 叫做周期串，T 叫做 S 的一个周期。请设计一个算法，计算 S 的最小周期。如果不存在周期，返回空串。</p>
<p>[Examples]<br>字符串 abababab 是周期串，abab 和 ab 都是它的周期，其中 ab 是它的最小周期。</p>
<p>[思路]<br>使用 next，限行时间解决问题</p>
<ul>
<li>计算 S 的 next 数组<ul>
<li>记 k = next[length], p = length - k</li>
<li>若 len%p==0，则 p 为最小周期长度，前 p 个字符就是最小周期。</li>
</ul>
</li>
<li>说明<ul>
<li>使用的是经典 KMP 的 next 算法，不是变种的 next 算法</li>
<li>要”多”计算到 length, 即 next[length]</li>
</ul>
</li>
<li>思考：如何证明？<ul>
<li>考察字符串 S 的 k前缀 head 和 k后缀 tail</li>
<li>head 和 tail 的前 p 个字符</li>
<li>head 和 tail 的前 2p 个字符</li>
<li>head 和 tail 的前 3p 个字符</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg" alt="Screen Shot 2019-12-22 at 13.14.24.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPeriod</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;  <span class="comment">// 仿照KMP 求伪 next, next[0] = -1 是哨兵，串首标志</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || p[j+<span class="number">1</span>] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 恢复成逻辑上的 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLast = next[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n % (n-nLast) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-nLast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><ul>
<li>KMP 的 next，实际上是建立了 DFA</li>
<li>DFA: Deterministic Finite Automaton</li>
<li>以当前位置为 DFA 的状态，以模式串的字符为 DFA 的转移条件，建立确定有穷自动机。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg" alt="Screen Shot 2019-12-22 at 13.00.57.png"></p>
<p>具体算法细节请参考：</p>
<p><a href="http://note.youdao.com/noteshare?id=dda1246716d3e1f321ee1b637ad2b413" target="_blank" rel="noopener">KMP算法</a><br><a href="http://note.youdao.com/noteshare?id=13fe90f9adddde21b0d5f8f7880ebc1f" target="_blank" rel="noopener">史上最清楚的 KMP 算法介绍</a></p>
<h2 id="Robin-Karp-字符串匹配算法"><a href="#Robin-Karp-字符串匹配算法" class="headerlink" title="Robin-Karp 字符串匹配算法"></a>Robin-Karp 字符串匹配算法</h2><ul>
<li>核心思想是比较两个字符串的哈希值，而不是逐个字母进行比较。</li>
<li>需要巧妙地设计哈希函数<ul>
<li>比如使用字符串的和来做哈希值，这样就可以使用增量方法来方便计算。比如主串上右移了一位，那么就可以简单的把移调的字母值减掉，加上右移后cover到的那个字母值加上就行了！</li>
</ul>
</li>
</ul>
<h3 id="Longest-Duplicate-Substring-lc1044"><a href="#Longest-Duplicate-Substring-lc1044" class="headerlink" title="Longest Duplicate Substring lc1044"></a>Longest Duplicate Substring lc1044</h3><p>[题目]</p>
<ol>
<li>Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)</li>
<li>Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is “”.)</li>
<li>Example-1<ol>
<li>Input: “banana”</li>
<li>Output: “ana”</li>
</ol>
</li>
<li>Note:<ol>
<li>2 &lt;= S.length &lt;= 10^5</li>
<li>S consists of lowercase English letters.</li>
</ol>
</li>
</ol>
<p>[思路一]</p>
<ol>
<li>这个题目看起来很简单，找就是了！</li>
<li>可以对于长度为 1，2，3，4，… 的情况，一次对每个位置开始的子串考虑，一旦出现重复的，更新最长的子串</li>
<li>其实可以优化一下，从最长的长度往小的长度遍历，这样子第一个找到的重复子串就可以返回了。</li>
<li>！！！ 这个思路毫无疑问超时了！！！</li>
</ol>
<p>[思路二]</p>
<ol>
<li>这个问题其实就做了两个东西<ol>
<li>一个是遍历各种长度的情况</li>
<li>第二个是对于一个特定的长度，如何看这么多子串是否有重复的！</li>
</ol>
</li>
<li>对于第一个问题，上面的思路一用的是从大到小遍历的情况！其实我们可以优化一下，用二分查找啊！！！这样时间复杂度就从 <code>O(N)</code> 优化到 <code>O(logN)</code> 了。</li>
<li>！！！不过，加上这个优化后，还是超时了！！！</li>
</ol>
<p>[思路三]</p>
<ol>
<li>这个思路里面就需要深入到子字符串的比较情况了！具体就是如何设计 hash 算法来快速的比较这么多子串！</li>
<li>同时还要考虑，如何去从源字符串里面去获得这么多子串。</li>
<li>其思路的关键就是<ol>
<li><mark>不需要获得子串，只需要保存hash 值就行了啊！</mark></li>
<li><mark>使用混动的方式去计算 hash 值</mark></li>
</ol>
</li>
</ol>
<p>[思路三代码 - Python 版]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Explanation</span></span><br><span class="line"><span class="comment">#     Binary search the length of longest duplicate substring and call the help function test(L).</span></span><br><span class="line"><span class="comment">#     test(L) slide a window of length L,</span></span><br><span class="line"><span class="comment">#     rolling hash the string in this window,</span></span><br><span class="line"><span class="comment">#     record the seen string in a hashset,</span></span><br><span class="line"><span class="comment">#     and try to find duplicated string.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     I give it a big mod for rolling hash and it should be enough for this problem.</span></span><br><span class="line"><span class="comment">#     Actually there could be hash collision.</span></span><br><span class="line"><span class="comment">#     One solution is to have two different mod for hash.</span></span><br><span class="line"><span class="comment">#     Or we can use a hashmap to record the index of string.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Complexity</span></span><br><span class="line"><span class="comment">#     Binary Search in range 1 and N, so it's O(logN)</span></span><br><span class="line"><span class="comment">#     Rolling hash O(N)</span></span><br><span class="line"><span class="comment">#     Overall O(NlogN)</span></span><br><span class="line"><span class="comment">#     SpaceO(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        A = [ord(c) - ord(<span class="string">'a'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> S]</span><br><span class="line">        mod = <span class="number">2</span>**<span class="number">63</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(L)</span>:</span></span><br><span class="line">            p = pow(<span class="number">26</span>, L, mod)</span><br><span class="line">            cur = reduce(<span class="keyword">lambda</span> x, y: (x * <span class="number">26</span> + y) % mod, A[:L], <span class="number">0</span>)</span><br><span class="line">            seen = &#123;cur&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(L, len(S)):</span><br><span class="line">                cur = (cur * <span class="number">26</span> + A[i] - A[i - L] * p) % mod</span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">in</span> seen: <span class="keyword">return</span> i - L + <span class="number">1</span></span><br><span class="line">                seen.add(cur)</span><br><span class="line">        res, lo, hi = <span class="number">0</span>, <span class="number">0</span>, len(S)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            pos = test(mi)</span><br><span class="line">            <span class="keyword">if</span> pos:</span><br><span class="line">                lo = mi</span><br><span class="line">                res = pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> S[res:res + lo]</span><br></pre></td></tr></table></figure>


<p>[思路三的代码 - C++版]</p>
<ol>
<li>Rabin-Karp algorihm can be implemented in C++17 with <code>std::unordered_set&lt;std::string_view&gt;</code> if a custom hasher is supplied. </li>
<li>Check the second code block below for the custom hasher.</li>
<li><code>std::string_view</code> does not copy the whole string and <code>std::unordered_set</code> handles the logic of hashing and comparing <code>std::string_view</code>‘s.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">rabinFingerprint</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::string_view&amp; s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_clear)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pow = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i != s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                    m_pow = (m_pow * base) % p;</span><br><span class="line">                m_cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">                    m_cur = ((m_cur * base) % p + (c - <span class="string">'a'</span>)) % p;</span><br><span class="line">                m_clear = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_cur = ((<span class="keyword">ssize_t</span>(m_cur) - <span class="keyword">ssize_t</span>(m_pow * (m_first - <span class="string">'a'</span>))) % <span class="keyword">ssize_t</span>(p) + p) % p;</span><br><span class="line">                m_cur = (m_cur * base + (s.back() - <span class="string">'a'</span>)) % p;</span><br><span class="line">            &#125;</span><br><span class="line">            m_first = s.front();</span><br><span class="line">            <span class="keyword">return</span> m_cur;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; m_clear = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> p = <span class="number">19260817</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> base = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> m_clear = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">size_t</span> m_cur;</span><br><span class="line">        <span class="keyword">size_t</span> m_pow;</span><br><span class="line">        <span class="keyword">char</span> m_first;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wrapper</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::string_view&amp; s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_hasher(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rabinFingerprint&amp; m_hasher;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::string_view longest;</span><br><span class="line">        rabinFingerprint hasher;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::string_view, wrapper&gt; <span class="built_in">set</span>&#123;<span class="number">10</span>, wrapper&#123;hasher&#125;&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> beg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">end</span> = S.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> len = beg + (<span class="built_in">end</span> - beg) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != S.<span class="built_in">size</span>() - len + <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> [it, inserted] = <span class="built_in">set</span>.emplace(S.data() + i, len);</span><br><span class="line">                <span class="keyword">if</span> (!inserted)</span><br><span class="line">                &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    longest = *it;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (found)</span><br><span class="line">                beg = len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = len - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">clear</span>();</span><br><span class="line">            hasher.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> &#123;longest.<span class="built_in">begin</span>(), longest.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Boyer-Moore-算法-了解"><a href="#Boyer-Moore-算法-了解" class="headerlink" title="Boyer Moore 算法 (了解)"></a>Boyer Moore 算法 (了解)</h2><ol>
<li>1977年由德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明的字符串匹配算法。</li>
<li>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则<ol>
<li>即 坏字符规则 和 好后缀规则，来决定向右跳跃的距离。</li>
<li>基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</li>
</ol>
</li>
<li>效率很高，构思巧妙，拥有在最坏情况下 O(N) 的时间复杂度。实践中比 KMP 算法的实际效能高。</li>
<li>Ref:<ol>
<li><a href="https://mp.weixin.qq.com/s/7IZTuLrPSuxvFRqsv5PiXQ" target="_blank" rel="noopener">微信公众号:帅地玩编程</a></li>
</ol>
</li>
</ol>
<h2 id="Manacher-算法-了解"><a href="#Manacher-算法-了解" class="headerlink" title="Manacher 算法 (了解)"></a>Manacher 算法 (了解)</h2><h3 id="重心扩展算法"><a href="#重心扩展算法" class="headerlink" title="重心扩展算法"></a>重心扩展算法</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg" alt="Palindrom"></p>
<p>不过要注意，因为字符串可能是奇数长度或者偶数长度，所以我们要考虑的字符串重心有 n+n-1 个。</p>
<h3 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h3><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg" alt="undefined"></p>
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg" alt="undefined"></p>
<h3 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h3><p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p>
<p>例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p>
<h3 id="求每个-P-i"><a href="#求每个-P-i" class="headerlink" title="求每个 P[i]"></a>求每个 P[i]</h3><p>接下来是算法的关键了，它充分利用了回文串的对称性。</p>
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p>
<p>让我们考虑求 P [ i ] 的时候，如下图。</p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg" alt="undefined"></p>
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p>
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p>
<h4 id="超出了-R"><a href="#超出了-R" class="headerlink" title="超出了 R"></a>超出了 R</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg" alt="undefined"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<h4 id="P-i-mirror-遇到了原字符串的左边界"><a href="#P-i-mirror-遇到了原字符串的左边界" class="headerlink" title="P[i_mirror] 遇到了原字符串的左边界"></a>P[i_mirror] 遇到了原字符串的左边界</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<h4 id="i-等于-R"><a href="#i-等于-R" class="headerlink" title="i 等于 R"></a>i 等于 R</h4><p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p>
<h3 id="考虑-C-和-R-的更新"><a href="#考虑-C-和-R-的更新" class="headerlink" title="考虑 C 和 R 的更新"></a>考虑 C 和 R 的更新</h3><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 P 的最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = P[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">//最开始讲的求原字符串下标</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><ul>
<li>另有两个孩子，1 个孩子，0 个孩子的节点个数分别为 n2, n1, n0</li>
<li>所有节点的出度为 2<em>n2+1</em>n1+0*n0</li>
<li>除了根节点，其他所有节点的入度都是 1，从而所有节点的入度为 (n0+n1+n2)-1</li>
<li>总入度等于总出度，2<em>n2+1</em>n1+0*n0 = n2+n1+n0-1</li>
<li>化简得到 n0 - n2 = 1</li>
<li>也就是说二叉树叶子节点数目比拥有两个孩子的节点数目多 1</li>
</ul>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><ul>
<li>无损压缩编码方案</li>
<li>概率高的字符使用较短的编码，概率低的使用较长的编码，从而使得编码后的字符串长度期望最小</li>
<li>Huffman 编码是一种贪心算法：每次总选择两个最小概率的字符节点合并<ul>
<li>称字符出现的次数为频数，则概率约等于频数除以字符总长；因此概率可以用频数代替</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg" alt="Screen Shot 2019-12-22 at 15.13.26.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用数组来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(<span class="keyword">int</span> *pWeight, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; code)</span></span>&#123;</span><br><span class="line">    <span class="comment">// code 传进来时候是空的 vector&lt;vector&lt;char&gt;&gt; 引用，后面会修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * N - <span class="number">1</span>;  <span class="comment">// N个节点的 Huffman 树需要 2N-1 个节点</span></span><br><span class="line">    HuffmanNode* pHuffmanTree = <span class="keyword">new</span> HuffmanNode[m];  <span class="comment">// 在动态内存空间里建立这个 vector</span></span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 建立叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        pHuffmanTree[i].nWeight = pWeight[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次选择权值最小的两个节点，建树</span></span><br><span class="line">    <span class="keyword">for</span>(i = N; i &lt; m; i++)&#123;</span><br><span class="line">        SelectNode(pHuffmanTree, i, s1, s2);  <span class="comment">// 在前 i 个 nodes 里面找到权值最小的两个节点。用过的节点不会被再用。因为用过的节点有 nParent 信息了。</span></span><br><span class="line">        pHuffmanTree[s1].nParent = pHuffmanTree[s2].nParent = i;  <span class="comment">// s1 和 s2 的父节点是 i 节点</span></span><br><span class="line">        pHuffmanTree[i].nLeft = s1;</span><br><span class="line">        pHuffmanTree[i].nRight = s2;</span><br><span class="line">        pHuffmanTree[i].nWeight = pHuffmanTree[s1].nWeight + pHuffmanTree[s2].nWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据建好的 Huffman 树从叶子到根计算每个叶节点的编码</span></span><br><span class="line">    <span class="keyword">int</span> node, nParent;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">// code[i] 就是 node i 的编码！</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; cur = code[i];    <span class="comment">// 此时还是空的 vector</span></span><br><span class="line">        node = i;</span><br><span class="line">        nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        <span class="keyword">while</span>(nParent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHuffmanTree[nParent].nLeft == node)&#123;</span><br><span class="line">                cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            node = nParent;</span><br><span class="line">            nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用指针来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to allocate a new tree node</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node* left, Node* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    node-&gt;ch = ch;</span><br><span class="line">    node-&gt;freq = freq;</span><br><span class="line">    node-&gt;left = left;</span><br><span class="line">    node-&gt;right = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparison object to be used to order the heap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* l, Node* r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// highest priority item has lowest frequency</span></span><br><span class="line">        <span class="keyword">return</span> l-&gt;freq &gt; r-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line"><span class="comment">// in a map.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node* root, <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;huffmanCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        huffmanCode[root-&gt;ch] = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    encode(root-&gt;left, str + <span class="string">"0"</span>, huffmanCode);</span><br><span class="line">    encode(root-&gt;right, str + <span class="string">"1"</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and decode the encoded string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root, <span class="keyword">int</span> &amp;index, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;ch;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str[index] ==<span class="string">'0'</span>)</span><br><span class="line">        decode(root-&gt;left, index, str);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        decode(root-&gt;right, index, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builds Huffman Tree and decode given input text</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHuffmanTree</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// count frequency of appearance of each character</span></span><br><span class="line">    <span class="comment">// and store it in a map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        freq[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a priority queue to store live nodes of</span></span><br><span class="line">    <span class="comment">// Huffman tree;</span></span><br><span class="line">    priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a leaf node for each character and add it</span></span><br><span class="line">    <span class="comment">// to the priority queue.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: freq) &#123;</span><br><span class="line">        pq.push(getNode(pair.first, pair.second, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do till there is more than one node in the queue</span></span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the two nodes of highest priority</span></span><br><span class="line">        <span class="comment">// (lowest frequency) from the queue</span></span><br><span class="line">        Node *left = pq.top(); pq.pop();</span><br><span class="line">        Node *right = pq.top(); pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new internal node with these two nodes</span></span><br><span class="line">        <span class="comment">// as children and with frequency equal to the sum</span></span><br><span class="line">        <span class="comment">// of the two nodes' frequencies. Add the new node</span></span><br><span class="line">        <span class="comment">// to the priority queue.</span></span><br><span class="line">        <span class="keyword">int</span> sum = left-&gt;freq + right-&gt;freq;</span><br><span class="line">        pq.push(getNode(<span class="string">'\0'</span>, sum, left, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root stores pointer to root of Huffman Tree</span></span><br><span class="line">    Node* root = pq.top();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line">    <span class="comment">// in a map. Also prints them</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; huffmanCode;</span><br><span class="line">    encode(root, <span class="string">""</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: huffmanCode) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nOriginal string was :\n"</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print encoded string</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        str += huffmanCode[ch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree again and this time</span></span><br><span class="line">    <span class="comment">// decode the encoded string</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDecoded string is: \n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; (<span class="keyword">int</span>)str.<span class="built_in">size</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">        decode(root, index, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huffman coding algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span> = <span class="string">"Huffman coding is a data compression algorithm."</span>;</span><br><span class="line"></span><br><span class="line">    buildHuffmanTree(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Huffman总结：前缀编码"><a href="#Huffman总结：前缀编码" class="headerlink" title="Huffman总结：前缀编码"></a>Huffman总结：前缀编码</h3><ul>
<li>Huffman编码是<mark>不等长编码</mark><ul>
<li>字符的编码长度不完全相等</li>
</ul>
</li>
<li>不等长编码如果需要译码，必须满足<mark>前缀编码</mark>的条件<ul>
<li>任何一个字符的编码都不是另外一个字符编码的前缀</li>
</ul>
</li>
<li>从Huffman树的角度考虑，就是<mark>所有的待编码元素都位于叶子节点上</mark>！</li>
</ul>
<p>[思考]</p>
<ul>
<li>Huffman 编码是如何解决前缀编码问题的？</li>
<li>实际算法是由多个”小算法”堆砌而成<ul>
<li>空格压缩问题</li>
<li>取数组最大/小的两个数</li>
</ul>
</li>
<li>代码实现中并非直接使用指针形成的二叉树节点，而是实现开辟足够大的缓冲空间(2n+1)，每次从缓冲区获取一个节点，使用数组代替二叉树<ul>
<li>在堆排序，双数组 Trie 树结构等问题中会再次遇到</li>
</ul>
</li>
<li>最后，由于 Huffman 树的节点权值（频数）可能相等，因此对某些文本，Huffman 编码不唯一。<ul>
<li>左赋 1，右赋 0 或者 左赋 0，右赋 1 都可以。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/string/" rel="tag"># string</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/25/%E7%AE%97%E6%B3%95leetcode/" rel="next" title="算法leetcode">
                <i class="fa fa-chevron-left"></i> 算法leetcode
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/05/leetcode-%E6%95%B0%E7%BB%84/" rel="prev" title="leetcode 数组">
                leetcode 数组 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-string-用法"><span class="nav-number">1.</span> <span class="nav-text">C++ string 用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性描述"><span class="nav-number">1.2.</span> <span class="nav-text">特性描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串处理"><span class="nav-number">1.3.</span> <span class="nav-text">字符串处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">1.4.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">1.5.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python-string-用法"><span class="nav-number">2.</span> <span class="nav-text">Python string 用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题目"><span class="nav-number">3.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0516-最长回文子序列"><span class="nav-number">3.1.</span> <span class="nav-text">0516 最长回文子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0151-翻转单词"><span class="nav-number">3.2.</span> <span class="nav-text">0151 翻转单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符替换和复制"><span class="nav-number">3.3.</span> <span class="nav-text">字符替换和复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0796-rotate-string"><span class="nav-number">3.4.</span> <span class="nav-text">0796 rotate string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表示数值的字符串"><span class="nav-number">3.5.</span> <span class="nav-text">表示数值的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0316-删除重复字符"><span class="nav-number">3.6.</span> <span class="nav-text">0316 删除重复字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#括号系列"><span class="nav-number">3.7.</span> <span class="nav-text">括号系列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0032-最长有效括号"><span class="nav-number">3.7.1.</span> <span class="nav-text">0032 最长有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0301-最长合法括号系列"><span class="nav-number">3.7.2.</span> <span class="nav-text">0301 最长合法括号系列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串全排列-permutation"><span class="nav-number">3.8.</span> <span class="nav-text">字符串全排列 permutation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation-Sequence-lc0060"><span class="nav-number">3.9.</span> <span class="nav-text">Permutation Sequence lc0060</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0040-Wildcard-Matching"><span class="nav-number">3.10.</span> <span class="nav-text">0040 Wildcard Matching</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0010-Regular-Expression-Matching"><span class="nav-number">3.11.</span> <span class="nav-text">0010 Regular Expression Matching</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP-算法"><span class="nav-number">3.12.</span> <span class="nav-text">KMP 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">3.12.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BF与KMP区别"><span class="nav-number">3.12.2.</span> <span class="nav-text">BF与KMP区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串比较机制"><span class="nav-number">3.12.3.</span> <span class="nav-text">字符串比较机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大k前缀与k后缀"><span class="nav-number">3.12.4.</span> <span class="nav-text">最大k前缀与k后缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#next的递推关系"><span class="nav-number">3.12.5.</span> <span class="nav-text">next的递推关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码"><span class="nav-number">3.12.6.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进一步分析-next"><span class="nav-number">3.12.7.</span> <span class="nav-text">进一步分析 next</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP-时间复杂度"><span class="nav-number">3.12.8.</span> <span class="nav-text">KMP 时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个应用-PowerString-问题"><span class="nav-number">3.12.9.</span> <span class="nav-text">一个应用 PowerString 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓展知识"><span class="nav-number">3.12.10.</span> <span class="nav-text">拓展知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Robin-Karp-字符串匹配算法"><span class="nav-number">3.13.</span> <span class="nav-text">Robin-Karp 字符串匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Duplicate-Substring-lc1044"><span class="nav-number">3.13.1.</span> <span class="nav-text">Longest Duplicate Substring lc1044</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Boyer-Moore-算法-了解"><span class="nav-number">3.14.</span> <span class="nav-text">Boyer Moore 算法 (了解)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Manacher-算法-了解"><span class="nav-number">3.15.</span> <span class="nav-text">Manacher 算法 (了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重心扩展算法"><span class="nav-number">3.15.1.</span> <span class="nav-text">重心扩展算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manacher’s-algorithm"><span class="nav-number">3.15.2.</span> <span class="nav-text">Manacher’s algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求原字符串下标"><span class="nav-number">3.15.3.</span> <span class="nav-text">求原字符串下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求每个-P-i"><span class="nav-number">3.15.4.</span> <span class="nav-text">求每个 P[i]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#超出了-R"><span class="nav-number">3.15.4.1.</span> <span class="nav-text">超出了 R</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P-i-mirror-遇到了原字符串的左边界"><span class="nav-number">3.15.4.2.</span> <span class="nav-text">P[i_mirror] 遇到了原字符串的左边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i-等于-R"><span class="nav-number">3.15.4.3.</span> <span class="nav-text">i 等于 R</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑-C-和-R-的更新"><span class="nav-number">3.15.5.</span> <span class="nav-text">考虑 C 和 R 的更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-1"><span class="nav-number">3.15.6.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈夫曼编码"><span class="nav-number">3.16.</span> <span class="nav-text">哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的节点"><span class="nav-number">3.16.1.</span> <span class="nav-text">二叉树的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码思想"><span class="nav-number">3.16.2.</span> <span class="nav-text">编码思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-2"><span class="nav-number">3.16.3.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Huffman总结：前缀编码"><span class="nav-number">3.16.4.</span> <span class="nav-text">Huffman总结：前缀编码</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/11/30/leetcode-string/';
          this.page.identifier = '2019/11/30/leetcode-string/';
          this.page.title = 'leetcode string';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://githubio-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
