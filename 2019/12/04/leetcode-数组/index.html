<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="array," />










<meta name="description" content="面试题总体分析查找和排序     二分查找: 貌似都可以使用或者不使用递归！     元素交换     排序，中位数     归并     位运算     前缀和的应用 动态规划 排列组合c++ vectorpython list123456789101112131415# reverse()# list_a[::-1]    # 二者都可以让列表反转# list_a.sort()    # 排序">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode 数组">
<meta property="og:url" content="http://yoursite.com/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试题总体分析查找和排序     二分查找: 貌似都可以使用或者不使用递归！     元素交换     排序，中位数     归并     位运算     前缀和的应用 动态规划 排列组合c++ vectorpython list123456789101112131415# reverse()# list_a[::-1]    # 二者都可以让列表反转# list_a.sort()    # 排序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp_fenwick_tree_binary_index_tree.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-leetcode-315-binary-index-tree.png.png">
<meta property="article:published_time" content="2019-12-05T05:39:38.000Z">
<meta property="article:modified_time" content="2020-02-07T04:05:10.762Z">
<meta property="article:author" content="Zheng Xing">
<meta property="article:tag" content="array">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/04/leetcode-数组/"/>





  <title>leetcode 数组 | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode 数组</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-04T21:39:38-08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/04/leetcode-数组/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><pre><code>查找和排序
    二分查找: 貌似都可以使用或者不使用递归！
    元素交换
    排序，中位数
    归并
    位运算
    前缀和的应用
动态规划
排列组合</code></pre><h1 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h1><h1 id="python-list"><a href="#python-list" class="headerlink" title="python list"></a>python list</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse()</span></span><br><span class="line"><span class="comment"># list_a[::-1]    # 二者都可以让列表反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list_a.sort()    # 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于字典，字符串等数据结构，必须用 sorted 函数</span></span><br><span class="line"><span class="comment"># sorted(iterable[, cmp[, key[, reverse]]])</span></span><br><span class="line">dict_a = &#123;<span class="string">'a'</span> : <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line">sorted(dict_a, key = <span class="keyword">lambda</span> d: d[<span class="number">0</span>])    <span class="comment"># 按照 key 排序，换成 d[1] 就按照 value 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 1D list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1d = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2d = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>


<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="局部极小值-leetcode-162"><a href="#局部极小值-leetcode-162" class="headerlink" title="局部极小值 leetcode 162"></a>局部极小值 leetcode 162</h2><p>一个给定的不包含相同元素的整数数组，每个局部极小值的定义是一个值比左右相邻的（如果存在）都小的值。求它的一个局部极小值。</p>
<pre><code>分析：首先要问清楚边界条件如何处理，在这里假定边界条件是比它大的。

这里规定用数组下标 a[1, ..., n]表示那 n 个整数，定义 a[0] = a[n+1] = 无穷大。

递归的思路是，如果子数组 a[p, q] 满足条件 a[p] &lt; a[p-1], a[q] &lt; a[q+1]，则它包含一个局部极小值。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：不使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：使用递归思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[m+<span class="number">1</span>]) <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, m+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数值等于下标的元素"><a href="#数值等于下标的元素" class="headerlink" title="数值等于下标的元素"></a>数值等于下标的元素</h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<p>样例<br>输入：[-3, -1, 1, 3, 5]<br>输出：3</p>
<p>注意:如果不存在，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="循环有序数组查找元素-leetcode-153"><a href="#循环有序数组查找元素-leetcode-153" class="headerlink" title="循环有序数组查找元素 leetcode 153"></a>循环有序数组查找元素 leetcode 153</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1</p>
<p>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：二分法</span></span><br><span class="line"><span class="comment">找中间一个元素，因为数组有 shift，所以中间元素只有两种可能：</span></span><br><span class="line"><span class="comment">要么在左半段，中间元素数值大于两端的数值；</span></span><br><span class="line"><span class="comment">要么在右半段，中间元素数值小于两端的数值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，有个特殊情况就是如果 shift=0，那么只有一个左半段存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == j) <span class="keyword">return</span> <span class="built_in">min</span>(nums[i], nums[j]);</span><br><span class="line">        <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, m, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="循环有序数组查找元素-leetcode-154"><a href="#循环有序数组查找元素-leetcode-154" class="headerlink" title="循环有序数组查找元素 leetcode 154"></a>循环有序数组查找元素 leetcode 154</h2><p>TODO</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>【思路】<br>就是动态规划！注意空间复杂度可以不用建立二维数组，只使用两个一维向量就可以了。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>【思路】</p>
<ul>
<li>方法一：其实这一题可以转换为最长公共子序列的问题<ul>
<li>先对数组进行排序</li>
<li>计算排序后数组和原来数组的最长公共子序列，这个就是最长递增的子序列</li>
<li>复杂度为排序的复杂度 = O(nlogn)</li>
</ul>
</li>
<li>方法二：直接用动态规划<ul>
<li>方法很直接</li>
<li>时间复杂度是 O(n^2)</li>
</ul>
</li>
</ul>
<p>[方法三 贪心的算法]<br>这个方法比较难想出来，也难以表达清楚。这里先给出过程如下。</p>
<p>假设原来的序列是 3 4 5 1 2 3 4</p>
<p>逐个考察这些数</p>
<ul>
<li>考察 3 得到 [3]</li>
<li>考察 4 比 3 大，放到后面，得到 [3, 4]</li>
<li>考察 5 比 4 大，放到后面，得到 [3, 4, 5]</li>
<li>考察 1 比 3 还小，替换掉 3, 得到 [1, 4, 5]</li>
<li>考察 2 比 4 还小，替换掉 4， 得到 [1, 2, 5]</li>
<li>考察 3 比 5 还小，替换掉 5， 得到 [1, 2, 3]</li>
<li>考察 4 比 3 大，放到后面，得到 [1, 2, 3, 4]</li>
<li>最终得到的数组长度为 4，那么就代表最长的递增子序列长度为 4.</li>
</ul>
<p><mark>[上面构造的数组的意义]</mark><br>数组 temp 中第 i 个位置的数组 temp[i] 代表原数组中当前能够找到的，长度为 i 的递增子序列中末尾数子最小的是 temp[i].</p>
<p>比如考虑到上面考察到 2 的时候，得到的 temp 数组是 [1, 2, 5].</p>
<ul>
<li>这个 temp 数组中数字 1 表示长度为 1 的递增子序列中末尾数字最小的是 1</li>
<li>这个 temp 数组中数字 2 表示长度为 2 的递增子序列中末尾数字最小的是 2</li>
<li>这个 temp 数组中数字 5 表示长度为 3 的递增子序列中末尾数字最小的是 5</li>
</ul>
<h2 id="第一个缺失的正整数-leetcode-41"><a href="#第一个缺失的正整数-leetcode-41" class="headerlink" title="第一个缺失的正整数 leetcode 41"></a>第一个缺失的正整数 leetcode 41</h2><p>[题目]<br>给一个数组，找到从 1 开始第一个不在里面的正整数。</p>
<p>[例如]<br>输入：[3, 4, -1, 1]<br>输出：2.</p>
<p><mark>循环不变式</mark></p>
<ul>
<li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则钙元素即为所求。</li>
<li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li>
</ul>
<p><mark>利用循环不变式设计算法</mark><br>假定前 i-1 个数已经找到，并且依次存放在 A[1,2,…,i-1]中，继续考察 A[i]:</p>
<ul>
<li>若 A[i]&lt;i 且 A[i]&gt;=1, 则 A[i] 在 A[1,2,…,i-1] 中已经出现过，可以直接丢弃。<ul>
<li>若 A[i] 为负，则更应该丢弃它</li>
</ul>
</li>
<li>若 A[i]&gt;i 且 A[i] &lt;= N, 则 A[i] 应该位于后面的位置上，则将 A[A[i]] 和 A[i] 交换。<ul>
<li>若 A[i]&gt;=N, 由于缺失数据一定小于 N, 则 A[i] 丢弃</li>
</ul>
</li>
<li>若 A[i]=i, 则 A[i] 位于正确的位置上，则 i 加 1，循环不变式扩大，继续比较后面的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：数组下标从 0 开始，</span><br><span class="line">我们得目的是让 a[i] &#x3D;&#x3D; i + 1</span><br><span class="line">每次循环</span><br><span class="line">	1. 要么 i+1</span><br><span class="line">	2. 要么 n-1</span><br><span class="line">	3. 要么有一个数被放到正确的位置</span><br><span class="line"></span><br><span class="line">有一点要记住！一旦一个元素被放到正确的位置以后，那么它的位置就不会改变了！</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt; A, int n)&#123;</span><br><span class="line">    	for(int i &#x3D; 0; i &lt; n; )&#123;</span><br><span class="line">    		if(A[i] &#x3D;&#x3D; i + 1)&#123;  &#x2F;&#x2F; A[i]刚好位置正确</span><br><span class="line">    			++i;</span><br><span class="line">    		&#125; else if ((A[i] &lt;&#x3D; i) || (A[i] &gt; n) || (A[A[i] - 1] &#x3D;&#x3D; A[i]))&#123;  &#x2F;&#x2F; 当前元素可以丢掉了！</span><br><span class="line">    			A[i] &#x3D; A[--n];  &#x2F;&#x2F; 快速丢弃 A[i]，就是把最后一个元素移过来，同时长度减去一。</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">    			swap(A[i], A[A[i] - 1]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return n+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素最大间距-leetcode-164-“maximum-Gap”"><a href="#元素最大间距-leetcode-164-“maximum-Gap”" class="headerlink" title="元素最大间距 leetcode 164 “maximum Gap”"></a>元素最大间距 leetcode 164 “maximum Gap”</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:<br>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.</p>
<p>Example 2:<br>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.</p>
<p>Note:<br>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值x, 最小值y，如果 x==y 答案是0.</span></span><br><span class="line"><span class="comment">把数放进 n+1 个桶。</span></span><br><span class="line"><span class="comment">	每个桶大小是 d = (x-y)/(n+1) 浮点数</span></span><br><span class="line"><span class="comment">	每个桶区间是 [y + i*d, y + (i+1) * d) (i=0, 1, 2, ..., n)</span></span><br><span class="line"><span class="comment">		注意是左闭右开的区间，最后一个桶是双闭区间。</span></span><br><span class="line"><span class="comment">		最小的数在 0 号桶里，最大的数在 n 号桶里。</span></span><br><span class="line"><span class="comment">		第一个桶非空，最后一个桶非空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	【鸽笼原理】中间有空桶，空桶左右两侧肯定有元素。</span></span><br><span class="line"><span class="comment">	最大间隙出现在一个非空桶的最大值和下一个非空桶的最小值之间。</span></span><br><span class="line"><span class="comment">	如何判断数 r 出现在哪个桶里</span></span><br><span class="line"><span class="comment">		(r-y)*(n+1)/(x-y) （整数运算，注意 r==x 时候，答案取 n）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">code is from: https://leetcode.com/problems/maximum-gap/discuss/50644/Pigeon-hole-principle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxE = *max_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> minE = *min_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxA</span><span class="params">(n,INT_MIN)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minA</span><span class="params">(n,INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">        maxA[index] = <span class="built_in">max</span>(maxA[index],nums[i]);</span><br><span class="line">        minA[index] = <span class="built_in">min</span>(minA[index],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        gap = <span class="built_in">max</span>(gap,minA[i]-prev);</span><br><span class="line">        prev = maxA[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="出现一次的数"><a href="#出现一次的数" class="headerlink" title="出现一次的数"></a>出现一次的数</h2><h2 id="出现-3-次的数-leetcode-137"><a href="#出现-3-次的数-leetcode-137" class="headerlink" title="出现 3 次的数 leetcode 137"></a>出现 3 次的数 leetcode 137</h2><p>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,3,2]<br>Output: 3<br>Example 2:</p>
<p>Input: [0,1,0,1,0,1,99]<br>Output: 99</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个思路是最直接，最清晰的！就是把每一个 bit 位分开来看。</span></span><br><span class="line"><span class="comment">把当前 bit 位出现的 1 的总次数除以 3，如果可以整除，</span></span><br><span class="line"><span class="comment">那么最终结果在这个 bit 位上就是 0，如果不能整除，最终结果在这个 bit 位上就是 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To solve this problem using only constant space, you have to rethink how the numbers are being represented in computers -- using bits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you sum the ith bit of all numbers and mod 3, it must be either 0 or 1 due to the constraint of this problem where each number must appear either three times or once. This will be the ith bit of that "single number".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We can improve this based on the previous solution using three bitmask variables:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. ones as a bitmask to represent the ith bit had appeared once.</span></span><br><span class="line"><span class="comment">2. twos as a bitmask to represent the ith bit had appeared twice.</span></span><br><span class="line"><span class="comment">3. threes as a bitmask to represent the ith bit had appeared three times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">When the ith bit had appeared for the third time, clear the ith bit of both ones and twos to 0. The final answer will be the value of ones.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];</span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举一反三的思考"><a href="#举一反三的思考" class="headerlink" title="举一反三的思考"></a>举一反三的思考</h3><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers" target="_blank" rel="noopener">这里</a> 对于这类题目做了一个 generalization 的总结。</p>
<p>generalization 后题目变成：一个数组里面除了一个数字出现了 p 次，其他所有数字都出现了 k 次，那么请找出这个出现了 p 次的数字。</p>
<p>其思想也是对于每个 bit 位单独考虑，看看 1 出现了多少次保存在 count 中。并且保证 1 在出现了 k 次之后，count 会归零。</p>
<p>对于单独的一个 bit 位置来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 32-bit 的数字来说<br><img src="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png" alt="haha"></p>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 2, p = 1</span></span><br><span class="line"><span class="comment">k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 3, p = 1</span></span><br><span class="line"><span class="comment">k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = '11', then k1 = 1, k2 = 1, so we have mask = ~(x1 &amp; x2). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; x2);</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. </span></span><br><span class="line">                    <span class="comment">// If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 5, p = 3</span></span><br><span class="line"><span class="comment">k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = '101', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, x3  = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x3 ^= x2 &amp; x1 &amp; i;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">            x3 &amp;= mask;</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. </span></span><br><span class="line">                    <span class="comment">// If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2 | x3).</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-100-缺少的两个数"><a href="#1-100-缺少的两个数" class="headerlink" title="1-100 缺少的两个数"></a>1-100 缺少的两个数</h2><p>解方程？ 位运算？</p>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>找出超过一半的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：众数出现的次数大于其他所有数出现次数之和。</span><br><span class="line">	每次扔掉两个不同的数，众数不变</span><br><span class="line">		如果扔掉一个众数，和一个非众数</span><br><span class="line">		如果扔掉两个非众数</span><br><span class="line">	如何实现？和 x 不同就扔掉</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">int count &#x3D; 0, x;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">	if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		x &#x3D; a[i];</span><br><span class="line">		count &#x3D; 1;</span><br><span class="line">	&#125; else if (x &#x3D;&#x3D; a[i]) &#123;</span><br><span class="line">		++count;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		--count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意有的题目要数一下 x 出现次数是否确实超过一半（众数可能不存在）。</span><br></pre></td></tr></table></figure>

<p>TODO:<br>思考题：如何找到所有出现次数严格大于总数 1/k 的数？<br>提示：保存(k - 1)个数。<br>如何查找？hash? map?</p>
<h2 id="几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><a href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240" class="headerlink" title="几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240"></a>几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</h2><h3 id="leetcode-0011"><a href="#leetcode-0011" class="headerlink" title="leetcode 0011"></a>leetcode 0011</h3><p>题目：<br>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>
<p>分析：<br>这一题的解法比较巧妙，想通了后就特别简单。</p>
<p>绝妙的思路：<br>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.<br>In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.<br>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by —).</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p><mark>注意：上面划线部分没有细说，但是你必须要搞懂。<br>事实上，如果 2 3 4 5 的高度超过 1，那么由于 1 的高度的限制，水桶的整体高度不会超过 1 的高度。<br>同时又由于 2 3 4 5 距离 1 相对于 6 距离 1 更近，<br>所以<br>(1,2) (1,3) (1,4) (1,5) 肯定小于 (1,6)<br>另一种情形，如果 2 3 4 5 的高度小于 1，那么<br>(1,2) (1,3) (1,4) (1,5) 更小于 (1,6) 了。<br>因此这四种情形都不用计算了！！！！</mark></p>
<p> we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<h3 id="leetcode-0167-Two-Sum-2-Input-array-is-sorted"><a href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted" class="headerlink" title="leetcode 0167 Two Sum 2 Input array is sorted"></a>leetcode 0167 Two Sum 2 Input array is sorted</h3><p>题目：<br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>思路分析：<br>For those of you who are wondering how this works, here is a quick explanation:<br>Each sum is characterized by two indices (i, j), where 0 &lt;= i &lt; j &lt; n with n the length of the input array. If we were to compute them explicitly, we end up with an n-by-n matrix.<br>If the input array is not sorted, to search for the target, there is no good way but comparing it with elements from the above matrix one by one. This is the naive O(n^2) solution. Of course you can use a HashMap to memorize visited elements and cut down the time to O(n) so we have the classic space-time tradeoff.<br>Now if the input array is sorted, the n-by-n summation matrix will have the following properties:<br>Integers in each row are sorted in ascending order from left to right.<br>Integers in each column are sorted in ascending order from top to bottom.<br>To find the target, we do not have to scan the whole matrix now since it exhibits some partial order. We may start from the top-right (or bottom-left) corner, then proceed to the next row or previous column depending on the relationship between the matrix element and the target until either it is found or all rows and columns are exhausted. The key here is that we can get rid of a whole row or column due to the two properties of the matrix specified above.<br>If you have finished leetcode problem “240. Search a 2D Matrix II”, you will find that this is exactly the same problem, except now of the two indices, the first has to be smaller than the second. Time complexity for “leetcode 240” is O(m + n), while for this problem we have m = n, plus the indices constraint so the time complexity will be O(n). Also we do not need the HashMap now so space complexity will be O(1).</p>
<h3 id="leetcode-240-Search-a-2D-Matrix-II"><a href="#leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="leetcode 240 Search a 2D Matrix II"></a>leetcode 240 Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,<br>Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>Given target = 5, return true.<br>Given target = 20, return false.</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We start search the matrix from top right corner, initialize the current position to top right corner, </span></span><br><span class="line"><span class="comment">if the target is greater than the value in current position, then the target can not be in entire row </span></span><br><span class="line"><span class="comment">of current position because the row is sorted, if the target is less than the value in current position, </span></span><br><span class="line"><span class="comment">then the target can not in the entire column because the column is sorted too. </span></span><br><span class="line"><span class="comment">We can rule out one row or one column each time, so the time complexity is O(m+n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; matrix.<span class="built_in">size</span>() &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[m][n])&#123;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[m][n])&#123;</span><br><span class="line">                --n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p>其实对于二维的也可以分治啊！二维矩阵的中心点把矩阵分成了：左上 A, 右上 B，左下 C，右下 D 这四个小矩阵。</p>
<ol>
<li>根据中心元素 m 和 target 的比较情况<ol>
<li>如果 m &lt; target, 则 target 不可能在 A</li>
<li>如果 m &gt; target, 则 target 不可能在 B</li>
</ol>
</li>
<li>时间复杂度<ol>
<li>T(N) = T(N/2) + T(N/4) +O(1)</li>
<li>不好分析，可能在O(N^0.5) - O(N) 之间，这里 N 是全部的数组元素</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>((x1 &gt; x2) || (y1 &gt; y2))&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> midx = (x1 + x2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> midy = (y1 + y2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(a[midx][midy] == target)&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (target &lt; a[midx][midy]) ?</span><br><span class="line">    	(<span class="built_in">find</span>(a, x1, y1, midx - <span class="number">1</span>, y2, target) || <span class="built_in">find</span>(a, midx, y1, x2, midy - <span class="number">1</span>, target)) :</span><br><span class="line">    	(<span class="built_in">find</span>(a, x1, midy + <span class="number">1</span>, x2, y2, target) || <span class="built_in">find</span>(a, midx + <span class="number">1</span>, y1, x2, midy, target)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">find</span>(matrix, <span class="number">0</span>, <span class="number">0</span>, m<span class="number">-1</span>, n<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些题目的 算法复杂度优化 都是转化为矩阵分析。<br>本来要考虑的情况是矩阵的所有元素 O(m * n)，<br>但是每次计算其中一个元素，并做了比较以后，<br>可以排除一整行或者一整列的元素，<br>因此变成了 O(m + n) 的算法。</p>
<h2 id="Trapping-Rain-Water-leetcode-0042"><a href="#Trapping-Rain-Water-leetcode-0042" class="headerlink" title="Trapping Rain Water leetcode 0042"></a>Trapping Rain Water leetcode 0042</h2><p>题目：<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water"></p>
<p>分析：<br>我本来想的是这些水只能 trap 在两个“峰”中间，<br>所以我们可以从左到右找这些峰，<br>然后分别计算中间trap了多少水。<br>这个算法的复杂度也算是O(n),<br>但是实现起来应该比较复杂，<br>主要是在于山峰的寻找上。<br>比如说山峰的判断可以是当前高度大于左右两边，<br>但是如果有当前高度等于左边或者右边怎么办？<br>如果山峰在边界怎么办？<br>都不太好处理。</p>
<p>discuss forum 里面有个好算法<br>没有通过寻找山峰<br>就是分别看每个 bin<br>计算每个 bin 能存储的水量<br>为了达到这个目的<br>算法需要两个变量来记录 maxleft 和 maxright。<br>在保证右边有更高的 bin 的时候，<br>左边每个 bin 保存的水量等于 maxleft 减去 当前高度。<br>同理，<br>在保证左边有更高的 bin 的时候，<br>右边每个 bin 保存的水量等于 maxright 减去当前高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>, res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[left] &lt;= <span class="built_in">height</span>[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[left] &gt;= maxleft)&#123;</span><br><span class="line">                    maxleft = <span class="built_in">height</span>[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxleft - <span class="built_in">height</span>[left];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[right] &gt;= maxright)&#123;</span><br><span class="line">                    maxright = <span class="built_in">height</span>[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxright - <span class="built_in">height</span>[right];</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中第 10 行和第 17 行对 res 做了改变。</span></span><br><span class="line"><span class="comment">我好奇的是第 10 行用 maxleft 减，</span></span><br><span class="line"><span class="comment">如果 maxleft 大于 maxright的话，不应该拿 maxright 来减吗？？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事实上，maxleft 大于 maxright 的话，</span></span><br><span class="line"><span class="comment">left pointer 肯定指向了 maxleft，</span></span><br><span class="line"><span class="comment">这个时候程序按照逻辑，</span></span><br><span class="line"><span class="comment">会进入到 else 语句（14到19行），</span></span><br><span class="line"><span class="comment">所以达到目的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<mark>
第 10 行运行的时候 maxleft 一定是小于 maxright，准确说是小于 right pointer 指向的位置的高度 ,
第 17 行运行的时候 maxright 一定小于 maxleft，准确说是小于 left pointer 指向的位置的高度。
left 或者 right pointer 有一个肯定位于目前浏览到的所有 bin 的最高的那一个，然后保持不动，另外一个 pointer 移动.
</mark>


<h2 id="数组中连续一段和，绝对值最小"><a href="#数组中连续一段和，绝对值最小" class="headerlink" title="数组中连续一段和，绝对值最小"></a>数组中连续一段和，绝对值最小</h2><p>思路：先计算前缀和，然后排序。整体复杂度就是排序的复杂度 O(nlogn).</p>
<h2 id="最大子数组和-leetcode-53"><a href="#最大子数组和-leetcode-53" class="headerlink" title="最大子数组和 leetcode 53"></a>最大子数组和 leetcode 53</h2><p>[题目]<br>一个整数数组，一个非空的子数组（连续一段数），使得它的和最大。</p>
<p>[思路一]<br>暴利枚举。枚举子数组的起点 i，终点 j，计算 [i…j] 的和，时间复杂度为 O(N^3)。</p>
<p>[思路二]<br>聪明枚举。对于每一个起点 i，让 j 从 i+1 开始枚举，一遍枚举一边求和，时间复杂度为 O(N^2)。</p>
<p>[思路三]<br>分治</p>
<ol>
<li>Divide the given array in two halves</li>
<li>Return the maximum of following three<ol>
<li>Maximum subarray sum in left half (Make a recursive call)</li>
<li>Maximum subarray sum in right half (Make a recursive call)</li>
<li>Maximum subarray sum such that the subarray crosses the midpoint</li>
</ol>
</li>
</ol>
<p>The lines 2.1 and 2.2 are simple recursive calls. How to find maximum subarray sum such that the subarray crosses the midpoint? We can easily find the crossing sum in linear time.<br>Suppose the current range is [l, r] and the mid point is “m”.<br>The idea is simple, find the maximum sum starting from mid point “m” and ending at some point on left of mid, then find the maximum sum starting from “m + 1” and ending with sum point on right of “m + 1”. Finally, combine the two and return.</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> helper(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[l];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">max</span>(helper(arr, l, m), helper(arr, m+<span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">int</span> now = arr[m], may = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">    	may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now = may + arr[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">2</span>; i &lt; r; i++)&#123;</span><br><span class="line">    	now = now + arr[i];</span><br><span class="line">    	may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans, may);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路四-DP]</p>
<ol>
<li>dp[i] 表示以 a[i] 结尾的最大子数组的和</li>
<li>dp[i] = max(dp[i-1] + a[i], a[i])</li>
<li>初值 dp[0] = a[0]</li>
<li>答案是 dp 数组里面最大的那个</li>
<li>时间复杂度 O(n)，空间复杂度 O(n)</li>
<li>空间优化：不需要把 dp 数组存储下来<ol>
<li>endHere = max(endHere + a[i], a[i])</li>
<li>answer = max(endHere, answer)</li>
</ol>
</li>
</ol>
<p>[思路五：前缀和]</p>
<ol>
<li>计算前缀和 preSum</li>
<li>i 从 0 遍历到 n-1，保存 preSum[0…i-1] 这 i 个数的最小值 currentMin，当前的 preSum[i] - currentMin</li>
<li>整体的思想就类似于买卖股票一次，求最大的 gain 那道题</li>
<li>时间复杂度跟 DP 一样，都是 O(n).</li>
<li>空间优化：也可以一边求 preSum 一边做第二步，这样子就不需要保存 preSum 这个数组了。</li>
</ol>
<h2 id="Cantor-数组"><a href="#Cantor-数组" class="headerlink" title="Cantor 数组"></a>Cantor 数组</h2><p>[题目]</p>
<p>[思路]</p>
<ul>
<li>观察第一个元素，你就能知道思路了</li>
<li>第一个元素是 3，说明后面的元素中有三个小于这个元素，那么第一个元素只可能是 4 啊！！！</li>
<li>然后依次找到第二个，三个，。。。元素就可以了</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">CantorRecovery</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		temp.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(temp[j] &gt; <span class="number">0</span>) k--;</span><br><span class="line">        	<span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        		res.push_back(temp[j]);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="subset-sum"><a href="#subset-sum" class="headerlink" title="subset sum"></a>subset sum</h2><p>[题目]<br>Given a set of positive integers and an integer s, is there any non-empty subset whose sum is s.</p>
<p>[ref]<br><a href="https://www.techiedelight.com/subset-sum-problem/" target="_blank" rel="noopener">https://www.techiedelight.com/subset-sum-problem/</a></p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">	<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">	<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">	<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">	<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return true if we can get subset by including or excluding the</span></span><br><span class="line">	<span class="comment">// current item</span></span><br><span class="line">	<span class="keyword">return</span> include || exclude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>带记忆的算法代码</mark></p>
<ul>
<li>这里记忆的是：前面 n 个数里面能不能凑出来一个 sum.</li>
<li>算法是从右往前逐个看是否包括每个元素的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a map to store solutions of subproblems</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct a unique map key from dynamic elements of the input</span></span><br><span class="line">	<span class="built_in">string</span> key = to_string(n) + <span class="string">"|"</span> + to_string(sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if sub-problem is seen for the first time, solve it and</span></span><br><span class="line">	<span class="comment">// store its result in a map</span></span><br><span class="line">	<span class="keyword">if</span> (lookup.<span class="built_in">find</span>(key) == lookup.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">		<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">		<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">		<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">		<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// assign true if we can get subset by including or excluding the</span></span><br><span class="line">		<span class="comment">// current item</span></span><br><span class="line">		lookup[key] = include || exclude;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return solution to current sub-problem</span></span><br><span class="line">	<span class="keyword">return</span> lookup[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆序数有关"><a href="#逆序数有关" class="headerlink" title="逆序数有关"></a>逆序数有关</h2><h3 id="Count-of-Smaller-Number-After-Self-leetcode-0315"><a href="#Count-of-Smaller-Number-After-Self-leetcode-0315" class="headerlink" title="Count of Smaller Number After Self leetcode 0315"></a>Count of Smaller Number After Self leetcode 0315</h3><p>[题目]<br>给定一个数组，返回一个同样长度的数组，里面的数字表示原数组这个位置后面有多少个数字小于它。</p>
<p>[例子]</p>
<ul>
<li>Input: [5,2,6,1]</li>
<li>Output: [2, 1, 1, 0]</li>
</ul>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><ul>
<li>对每一个元素，逐个检查右边所有元素，看是否比它小</li>
<li>时间复杂度 O(N^2)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(numsSize, <span class="number">0</span>)</span></span>;<span class="comment">//用于储存nums[i]右边比它小的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">            <span class="comment">//寻找[i + 1, numsSize - 1]中小于nums[i]的元素个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    result[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改进暴力解法"><a href="#改进暴力解法" class="headerlink" title="改进暴力解法"></a>改进暴力解法</h4><ul>
<li>思路一的问题是，每次我们都要遍历右边所有的元素</li>
<li>如果我们从右往左看，看过的元素都排好序，那么可以使用二分查找来迅速找到小于每个数字的元素个数了</li>
<li>不过因为对 vector 进行插入复杂度是 O(N)，导致整体复杂度仍为 O(N^2)，但是不会出现 TLE.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s_num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(s_num.<span class="built_in">begin</span>(), s_num.<span class="built_in">end</span>(), nums[i]);  <span class="comment">// 二分查找比 nums[i] 小的数</span></span><br><span class="line">            <span class="keyword">int</span> pos = iter - s_num.<span class="built_in">begin</span>();</span><br><span class="line">            res.push_back(pos);             <span class="comment">// pos 就是小于 nums[i] 的元素个数</span></span><br><span class="line">            s_num.insert(iter, nums[i]);    <span class="comment">// 插入后要保持sorted_num排序，所以nums[i]插入到iter位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul>
<li>思路二的一个问题是：虽然查找有多少元素小于 nums[i] 的时候速度很快，但是把 nums[i] 插入到当前的已经排好序的数组里这一步骤耗时间。</li>
<li>因为 <code>vector&lt;int&gt;</code> 在中间位置插入元素需要把插入位置后面的元素都整体往后移动一位以获得一个空。</li>
<li>而解决这个问题就是使用 BST，它查找时间复杂度同样是 <code>log(N)</code>，然而插入步骤只是简单地 <code>O(1)</code> 复杂度。</li>
<li>BST 有个很好的性质：左子树所有节点都比根节点小，右子树所有节点都比根节点大</li>
<li>这个方法的最坏时间复杂度是 O(n^2). 也就是给定数组是递增，或者递减序列的时候，此时 BST 长得就是一根直线。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> val, smallerCnt;</span><br><span class="line">        TreeNode* left, *right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> v, <span class="keyword">int</span> s) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), val(v), smallerCnt(s)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(len, <span class="number">0</span>)</span></span>; </span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            root = insert(ret, nums[i], i, <span class="number">0</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把 val 插入到 node 为根节点的树中；</span></span><br><span class="line"><span class="comment">    preSum 是当前已经找到的比 val 小的数字的个数了；</span></span><br><span class="line"><span class="comment">    递归终止的条件是 val 放到了正确的位置，也就是第一个 if else 条件，此时会把最终的结果放到 ret[idx];</span></span><br><span class="line"><span class="comment">    val, idx 在递归调用中保持不变；</span></span><br><span class="line"><span class="comment">    递归调用中改变的东西只有 preSum 和 *node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, <span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="keyword">int</span> preSum, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(val, <span class="number">0</span>);</span><br><span class="line">            ret[idx] = preSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val &gt; val) &#123;</span><br><span class="line">            node-&gt;smallerCnt++;</span><br><span class="line">            node-&gt;left = insert(ret, val, idx, preSum, node-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;right = insert(ret, val, idx, preSum + node-&gt;smallerCnt + ((node-&gt;val &lt; val)? <span class="number">1</span>: <span class="number">0</span>), node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="平衡-BST"><a href="#平衡-BST" class="headerlink" title="平衡 BST"></a>平衡 BST</h4><ul>
<li>这个思路是对思路二的改进，为了让最坏情况下时间复杂度仍然是 O(NlogN)</li>
<li>需要时刻让 BST 保持平衡，也就是使用 AVL tree, RB-Tree 等数据结构。</li>
<li>此处每个节点包含以此节点为根的树的大小。</li>
<li>使用 AVL 树。</li>
<li>We traverse the array from right to left and insert all elements one by one in an AVL tree. </li>
<li>While inserting a new key in an AVL tree, we first compare the key with root. <ul>
<li>If key is greater than root, then it is greater than all the nodes in left subtree of root. </li>
<li>So we add the size of left subtree to the count of smaller element for the key being inserted. </li>
<li>We recursively follow the same approach for all nodes down the root.</li>
</ul>
</li>
</ul>
<p>代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, <span class="built_in">height</span>, <span class="built_in">size</span>, freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="keyword">this</span>-&gt;<span class="built_in">size</span> = <span class="keyword">this</span>-&gt;freq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateNode</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;<span class="built_in">size</span> = getSize(root-&gt;left) + getSize(root-&gt;right) + root-&gt;freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateLeft</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node *B = A-&gt;right;</span><br><span class="line">    Node *T2 = B-&gt;left;</span><br><span class="line">    A-&gt;right = T2;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateRight</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node* B = A-&gt;left;</span><br><span class="line">    Node* T2 = B-&gt;right;</span><br><span class="line">    A-&gt;left = T2;</span><br><span class="line">    B-&gt;right = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">balance</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    updateNode(root);</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;left) &gt;= <span class="number">0</span>) root = rotateRight(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;left = rotateLeft(root-&gt;left);</span><br><span class="line">            root = rotateRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;right) &lt;= <span class="number">0</span>) root = rotateLeft(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;right = rotateRight(root-&gt;right);</span><br><span class="line">            root = rotateLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node* root, <span class="keyword">int</span> data, <span class="keyword">int</span>&amp; count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == data)&#123;</span><br><span class="line">        root-&gt;freq++;</span><br><span class="line">        count += getSize(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; data)  root-&gt;left = insert(root-&gt;left, data, count);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        count += getSize(root-&gt;left) + root-&gt;freq;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, data, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        Node *root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) root = insert(root, nums[i], count[i]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>[这段代码来自 geeksforgeeks]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// An AVL tree node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> key; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>; </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// size of the tree rooted with this node </span></span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get height of the tree rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to size of the tree of rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">size</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &gt; b)? a : b; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Helper function that allocates a new node with the given key and </span></span><br><span class="line"><span class="comment">    NULL left and right pointers. */</span></span><br><span class="line"><span class="function">struct node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">node</span>*) </span></span><br><span class="line"><span class="class">                        <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span> </span><br><span class="line">    node-&gt;key   = key; </span><br><span class="line">    node-&gt;left   = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;right  = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;  <span class="comment">// new node is initially added at leaf </span></span><br><span class="line">    node-&gt;<span class="built_in">size</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span>(node); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to right rotate subtree rooted with y </span></span><br><span class="line"><span class="function">struct node *<span class="title">rightRotate</span><span class="params">(struct node *y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">x</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    x-&gt;right = y; </span><br><span class="line">    y-&gt;left = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update heights </span></span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to left rotate subtree rooted with x </span></span><br><span class="line"><span class="function">struct node *<span class="title">leftRotate</span><span class="params">(struct node *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">y</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    y-&gt;left = x; </span><br><span class="line">    x-&gt;right = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  Update heights </span></span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Get Balance factor of node N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Inserts a new key to the tree rotted with node. Also, updates *count </span></span><br><span class="line"><span class="comment">// to contain count of smaller elements for the new key </span></span><br><span class="line"><span class="function">struct node* <span class="title">insert</span><span class="params">(struct node* node, <span class="keyword">int</span> key, <span class="keyword">int</span> *count)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/* 1.  Perform the normal BST rotation */</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>(newNode(key)); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key) </span><br><span class="line">        node-&gt;left  = insert(node-&gt;left, key, count); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key, count); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// UPDATE COUNT OF SMALLER ELEMENTS FOR KEY </span></span><br><span class="line">        *count = *count + <span class="built_in">size</span>(node-&gt;left) + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 2. Update height and size of this ancestor node */</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>; </span><br><span class="line">    node-&gt;<span class="built_in">size</span>   = <span class="built_in">size</span>(node-&gt;left) + <span class="built_in">size</span>(node-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 3. Get the balance factor of this ancestor node to check whether </span></span><br><span class="line"><span class="comment">       this node became unbalanced */</span></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If this node becomes unbalanced, then there are 4 cases </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;left =  leftRotate(node-&gt;left); </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right); </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* return the (unchanged) node pointer */</span></span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The following function updates the countSmaller array to contain count of </span></span><br><span class="line"><span class="comment">// smaller elements on right side. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructLowerArray</span> <span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> countSmaller[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i, j; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">root</span> = <span class="title">NULL</span>;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize all the counts in countSmaller array as 0 </span></span><br><span class="line">  <span class="keyword">for</span>  (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">     countSmaller[i] = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Starting from rightmost element, insert all elements one by one in </span></span><br><span class="line">  <span class="comment">// an AVL tree and get the count of smaller elements </span></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">  &#123; </span><br><span class="line">     root = insert(root, arr[i], &amp;countSmaller[i]); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Utility function that prints out an array on a line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; </span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *low = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); </span><br><span class="line">  </span><br><span class="line">  constructLowerArray(arr, low, n); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Following is the constructed smaller count array"</span>); </span><br><span class="line">  printArray(low, n); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，有人提议可以使用 set (如果没有重复元素)，或者 multiset (有重复元素) 来做。set 的底层实现用的就是平衡二叉树。</p>
<ol>
<li>averse the array element from i=len-1 to 0 and insert every element in a set.</li>
<li>Find the first element that is lower than A[i] using lower_bound function.</li>
<li>Find the distance between above found element and the beginning of the set using distance function.</li>
<li>Store the distance in another array Lets say CountSmaller.</li>
<li>Print that array .</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSmallerRight</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="keyword">int</span> countSmaller[len]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        s.insert(A[i]); </span><br><span class="line">        <span class="keyword">auto</span> it = s.lower_bound(A[i]); </span><br><span class="line">        countSmaller[i] = distance(s.<span class="built_in">begin</span>(), it); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; countSmaller[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">    countSmallerRight(A, len); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>但是，这里跟上面的解法不一样的是：这里使用的 <code>std::distance()</code> 函数的时间复杂度为 O(size)，因此整体的复杂度是 O(N^2)，虽然 set 底层也用得平衡二叉树。</li>
<li>不过这个解法让我们学习了 STL algrorithm 的用法，而且写得很简洁，不错！</li>
<li>如果存在重复元素，只需要改成 multiset 就可以了！</li>
</ol>
<h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><ul>
<li>在 merge sort 的过程中多记录一些额外的东西。</li>
<li>例如考虑这个数组: <code>6 4 1 8 7 5 2 9</code></li>
<li>因为是递归调用，所以两个子数组是 <code>6 4 1 8</code> 和 <code>7 5 2 9</code></li>
<li>假定两个子数组分别处理好了<ul>
<li>第一个子数组处理结果是 <code>1(0) 4(1) 6(2) 8(0)</code></li>
<li>第二个子数组处理结果是 <code>2(0) 5(1) 7(2) 9(0)</code></li>
<li>括号里的数字表示当前子数组里面，排序前位置在右边的并且小于自己的数字有多少个。</li>
<li>比如 <code>4(1)</code> 就表示原来的第一个子数组中位置在 <code>4</code> 右边，并且值小于 <code>4</code> 的数字有 <code>1</code> 个。</li>
</ul>
</li>
<li>现在需要合并两个子数组了, 用 rightcount 来记录右边的子数组中拿出来多少个数字了，并初始化为 0.<ul>
<li>先从左边子数组中拿出 1(0 + rightcount) = 1(0)</li>
<li>再从右边子数组中拿出 2(0)，同时 rightcount = 0 + 1 = 1</li>
<li>再从左边子数组中拿出 4(1 + rightcount) = 4(1+1) = 4(2)</li>
<li>再从右边子数组中拿出 5(1), 同时 rightcount = 1 + 1 = 2</li>
<li>再从左边子数组中拿出 6(2+rightcount) = 6(2+2) = 6(4)</li>
<li>再从右边子数组中拿出 7(2), 同时 rightcount = 2 + 1 = 3</li>
<li>再从左边子数组中拿出 8(0 + rightcount) = 8(0+3) = 8(3)</li>
<li>再从右边子数组中拿出 9(0)</li>
</ul>
</li>
<li>可以看出来，我们只需要更新左边子数组中括号里面的个数记录</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Pii;</span><br><span class="line">    <span class="keyword">typedef</span> Pii::iterator Pit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">Pii <span class="title">nums_</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            nums_[i] = &#123;nums[i], i&#125;;</span><br><span class="line">        merge(nums_.<span class="built_in">begin</span>(), nums_.<span class="built_in">end</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Pit <span class="built_in">begin</span>, Pit <span class="built_in">end</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span> - <span class="built_in">begin</span> &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        merge(<span class="built_in">begin</span>, mid, res);</span><br><span class="line">        merge(mid, <span class="built_in">end</span>, res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="built_in">begin</span>, j = mid; i != mid; ++i)&#123; <span class="comment">// 对于每一个 i</span></span><br><span class="line">            <span class="keyword">while</span>(j != <span class="built_in">end</span> &amp;&amp; i-&gt;first &gt; j-&gt;first)   <span class="comment">// 把 j 往右移动到最后一个满足条件: i-&gt;first 大于 j-&gt;first</span></span><br><span class="line">                ++j;                                 <span class="comment">// 此时相当于 merge 时候把右边的子数组中到 j 位置的所有元素</span></span><br><span class="line">            res[i-&gt;second] += j - mid;               <span class="comment">// 都移动到汇总数组里面了，下一个就是把 i 位置元素放到汇总数组里。</span></span><br><span class="line">        &#125;</span><br><span class="line">        inplace_merge(<span class="built_in">begin</span>, mid, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-Index-Tree"><a href="#Binary-Index-Tree" class="headerlink" title="Binary Index Tree"></a>Binary Index Tree</h4><ul>
<li>也叫做 Fenwick Tree，中文是“树状数组”</li>
<li>TODO: BIT 的介绍参考<a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">这里</a></li>
<li>BIT 方法与下面的 Segment tree 方法相比，都是 log n 时间复杂度，然后需要的空间更小，更容易写代码。</li>
</ul>
<h5 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h5><p>[问题背景]</p>
<ol>
<li>树状数组的提出主要是为了较好的平衡计算前缀和，以及修改某项的值这两个操作。<ol>
<li>如果你使用普通的数组保存每项的值，那么计算前缀和的复杂度就是 O(N), 而修改某项的值这个操作复杂度是 O(1)；</li>
<li>如果你使用的数组里面保存得是前缀和，那么计算前缀和复杂度为 O(1), 修改值变成了 O(N).</li>
<li>而 binary index tree 可以使得这两个操作的复杂度都是 O(logN).</li>
</ol>
</li>
</ol>
<p>[初始化]</p>
<ol>
<li>\(nums[i] = arr[i]\)</li>
<li>\(BIT[i] = \sum_{k = i - lowestbit(i) + 1}^{i} arr[k]\)</li>
<li>注意，上面的 <code>lowestbit(i)</code> 是指将 <code>i</code> 转为二进制后，最后一个 <code>1</code> 的位置所代表的数值。如 <code>lowestbit(1) = 1</code>, <code>lowestbit(6) = 2</code>, 具体的实现可以通过 <code>(i &amp; -i)</code> 获取。</li>
<li>代码可以参考本文例题 Leetcode 0307 里面的 Python 代码。</li>
</ol>
<p>[一个好图胜过千言万语！！！]<br><mark>下图即为初始化后的情况，横轴为数组的下标（记为 i）,纵轴为下表数值对应的 <code>lowestbit (i &amp; -i)</code>, 长方形表示 <code>BIT[i]</code> 涵盖的求和范围。</mark></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp_fenwick_tree_binary_index_tree.jpg" alt="Binary Index Tree"></p>
<p>从图中可以看到:</p>
<ol>
<li>每一个 <code>BIT[i]</code> 覆盖的范围都是 2 的指数！即要么只覆盖自身，要么覆盖两个，四个，8个元素！</li>
<li>图中描黑的那些节点在形态上构成了一棵树的形状，这也是为什么这个算法被叫做 Binary Index Tree 的原因。</li>
<li>对于每个下表的 lowestbit 表示成的 tree node 有以下特性<ol>
<li><mark>假如 i 是左子节点，那么其父节点下标为 <code>i + lowestbit(i)</code></mark></li>
<li><mark>假如 i 是右子节点，那么其父节点下标为 <code>i - lowestbit(i)</code></mark></li>
</ol>
</li>
</ol>
<p>[更新一个数值]<br>假如要修改原始数组中下标为 i 的值，那么需要修改 <code>nums</code> 数组中对应下标的值。除此之外还要修改 <code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值。结合上图可以知道，<code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值为下标 i 及其所有的父节点（它在父节点的左边）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    BIT[i] = BIT[i] + new_value</span><br><span class="line">    i = i + (i &amp; -i)</span><br></pre></td></tr></table></figure>

<p>[求前缀和]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    count = count + BIT[i]</span><br><span class="line">    i = i - (i &amp; -i)</span><br></pre></td></tr></table></figure>


<p>[理解]</p>
<ol>
<li>树状数组的构造过程是这样的<ol>
<li>对于一段序列 A[1…n]，把所有奇数项偶数项分开得到数组 P Q，</li>
<li>偶数项每项加上其左边的奇数项得到 (P + Q)，偶数项求一遍树状数组得到 T(P + Q)，</li>
<li>最后把 P 和 T(P + Q) 交替排列出来。</li>
</ol>
</li>
<li>举例：<ol>
<li>1 3 5 6 8</li>
<li>3   6    分离偶数项</li>
<li>4   11   每个偶数项加上其左边的奇数项</li>
<li>4   15   递归求树状数组</li>
<li>1 4 5 15 8 把奇数项交替排列回去</li>
</ol>
</li>
<li>树状数组一个数 n 能当偶数项 k 次，进入 k 次递归中，那么 n 的二进制最后有 k 个 0，因为每“当”一次偶数项，它所管辖的区间就会加倍，所以它的值就是原数组里以 n 结尾长度为 2^k 的一段区间。注意到 lowbit(n) = 2^k。如果区间写成左开右闭的，那么树状数组里第 n 项就是原数组 (n - lowbit(n), n] 的和。</li>
<li>举例。要查询前 10 个数的前缀和，二进制是 1010，我们可以将其拆成如下两个区间：(8, 10] 和 (0, 8]。</li>
<li>（2017-01-21 接近半夜，修改了修改操作的解释）</li>
<li>修改的话，观察构造树状数组的过程，观察原数组的某下标上如果被加上了一个变化量 d，那么这个 d 会怎样传播。</li>
<li>在某一层，如果这个下标 n 是偶数项，那么它左边的奇数项被加过来，这两项原本应该是 a 和 a + b 的，变成了 a 和 a + b + d，恰好就是第 n 位被改了；但是如果是奇数项的话，a 和 a + b 要变成 a + d 和 a + d + b，也就是说 d 被传播到了 n 右边的偶数项。当然影响是要传递的。所以我们修改的下标 n 在某一层作为奇数项的时候，它影响到了它在这一层右边的偶数项 n’，n’ 又会影响到 n’’，以此类推。</li>
<li>举例：10 在第 2 层的时候，它在这层的编号是 5，很不幸地影响到了这层编号是 6，即原编号 12 的元素。</li>
<li>我们来看一下二进制表示。10 = 1010 在第 2 层是 5 = 101，影响到的是 5 + 1 = 6 = 110。（此处感谢 UOJ 用户 rabbit_lb 提醒修改）在第 2 层，加的这个1，应该对应原数组上的 1 * 2^1 = 2，就是 lowbit(10)！</li>
<li>这是为什么呢？因为一个二进制最后有 k 个 0 的下标 n 会在第 k + 1 层，作为 n / 2^k 影响到 1 + n / 2^k，在原数组上的下标就是 n 影响到 2^k + n = lowbit(n) + n。</li>
<li>当然影响是要传递的，所以修改的时候就是不停加 lowbit 改就行了</li>
</ol>
<h5 id="本题的代码"><a href="#本题的代码" class="headerlink" title="本题的代码"></a>本题的代码</h5><p>为什么一个用来快速计算 range sum 的数据结构可以用来解决目前的这个问题呢？</p>
<p>主要是因为一个巧妙地转换：</p>
<ol>
<li>第一步先把数组中数字转换成 rank <ol>
<li>比如 [2, 5, -3, 6, 2, 4] 变成 rank 就变成了 [2, 4, 1, 5, 2, 3]</li>
<li>原数组里面 2 出现了两次，在 rank 数组里面它们的 rank 都是 2 (-3 是最小的数字)</li>
</ol>
</li>
<li>接下来就是关键的了，新定义一个数组 freq (长度为 n+1, 所有元素初始化为 0) 用来记录每个 rank 出现的数字的次数，然后从右到左扫描 rank 数组<ol>
<li>最先碰到的是 3, 此时我们把 freq[3]++，代表 rank=3 的数字碰到了一个, 而此时 freq[1] = freq[2] == 0，因此 freq[3] 左边的数字求和为 0， 代表原数组中 4 右边有 0 个数字比它值小。</li>
<li>接下来碰到 2，此时把 freq[2]++，而 freq[1] == 0，所以原数组中倒数第二个数字 2 后面有 0 个元素比它小。</li>
<li>接下来碰到 5，此时把 freq[5]++, 而 freq 数组中 freq[5] 前面有 freq[2] = freq[3] = 1, 因此说明原数组的 6 右边有两个元素比它小。</li>
</ol>
</li>
<li>思路还是很清晰的<ol>
<li>因为我们是从右往左遍历 rank 数组</li>
<li>如果右边数字的 rank 小于左边某个数字的 rank，也就是说原来的数组中右边的数字小于左边的数字了。</li>
<li>同时！右边先被遍历，也保证了如果右边有 rank 小的数字，freq[右边数字的 rank] 会更新，这样子再扫到左边的数字的时候，我们就可以直接把 freq[左边数字的 rank] 左边的数字全部加起来，这个和就是左边数字有多少个小于它的数字在右边！</li>
</ol>
</li>
</ol>
<p>下图也有个例子<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-leetcode-315-binary-index-tree.png.png" alt=""></p>
<p>代码参考<a href="https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> &#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n): sums_(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sums_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sums_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sums_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Sort the unique numbers</span></span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sorted</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Map the number to its rank</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ranks;</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> num : sorted)</span><br><span class="line">            ranks[num] = ++rank;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="function">FenwickTree <span class="title">tree</span><span class="params">(ranks.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Scan the numbers in reversed order</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// Chechk how many numbers are smaller than the current number.</span></span><br><span class="line">            ans.push_back(tree.query(ranks[nums[i]] - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// Increse the count of the rank of current number.</span></span><br><span class="line">            tree.update(ranks[nums[i]], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>下面的代码来自 geeksforgeeks，可以得到右边小的数字个数或者左边大的数字个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ implementation of the approach </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to return the sum of arr[0..index] </span></span><br><span class="line"><span class="comment">// This function assumes that the array is preprocessed </span></span><br><span class="line"><span class="comment">// and partial sums of array elements are stored in BITree[] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// Initialize result </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traverse ancestors of BITree[index] </span></span><br><span class="line">	<span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123; </span><br><span class="line">		<span class="comment">// Add current element of BITree to sum </span></span><br><span class="line">		sum += BITree[index]; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Move index to parent node in getSum View </span></span><br><span class="line">		index -= index &amp; (-index); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Updates a node in Binary Index Tree (BITree) at given index </span></span><br><span class="line"><span class="comment">// in BITree. The given value 'val' is added to BITree[i] and </span></span><br><span class="line"><span class="comment">// all of its ancestors in tree. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBIT</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// Traverse all ancestors and add 'val' </span></span><br><span class="line">	<span class="keyword">while</span> (index &lt;= n) &#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add 'val' to current node of BI Tree </span></span><br><span class="line">		BITree[index] += val; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update index to that of parent in update View </span></span><br><span class="line">		index += index &amp; (-index); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Converts an array to an array with values from 1 to n </span></span><br><span class="line"><span class="comment">// and relative order of smaller and greater elements remains </span></span><br><span class="line"><span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line"><span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// Create a copy of arrp[] in temp and sort the temp array </span></span><br><span class="line">	<span class="comment">// in increasing order </span></span><br><span class="line">	<span class="keyword">int</span> temp[n]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		temp[i] = arr[i]; </span><br><span class="line">	sort(temp, temp + n); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traverse all array elements </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">		<span class="comment">// lower_bound() Returns pointer to the first element </span></span><br><span class="line">		<span class="comment">// greater than or equal to arr[i] </span></span><br><span class="line">		arr[i] = lower_bound(temp, temp + n, arr[i]) - temp + <span class="number">1</span>; </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to find smaller_right array </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findElements</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// Convert arr[] to an array with values from 1 to n and </span></span><br><span class="line">	<span class="comment">// relative order of smaller and greater elements remains </span></span><br><span class="line">	<span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line">	<span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line">	convert(arr, n); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a BIT with size equal to maxElement+1 (Extra </span></span><br><span class="line">	<span class="comment">// one is used so that elements can be directly be </span></span><br><span class="line">	<span class="comment">// used as index) </span></span><br><span class="line">	<span class="keyword">int</span> BIT[n + <span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// To store smaller elements in right side </span></span><br><span class="line">	<span class="comment">// and greater elements on left side </span></span><br><span class="line">	<span class="keyword">int</span> smaller_right[n], greater_left[n]; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Traverse all elements from right. </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get count of elements smaller than arr[i] </span></span><br><span class="line">		smaller_right[i] = getSum(BIT, arr[i] - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add current element to BIT </span></span><br><span class="line">		updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Smaller right: "</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print smaller_right array </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; smaller_right[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find all left side greater elements </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get count of elements greater than arr[i] </span></span><br><span class="line">		greater_left[i] = i - getSum(BIT, arr[i]); </span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add current element to BIT </span></span><br><span class="line">		updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Greater left: "</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print greater_left array </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; greater_left[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Function call </span></span><br><span class="line">	findElements(arr, n); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">Smaller right: 6 1 1 1 0 1 0 </span></span><br><span class="line"><span class="comment">Greater left: 0 1 1 1 4 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="Segment-Tree-线段树"><a href="#Segment-Tree-线段树" class="headerlink" title="Segment Tree 线段树"></a>Segment Tree 线段树</h4><ul>
<li>TODO: 代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        idx += n;</span><br><span class="line">        tree[idx] += val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=idx; i&gt;<span class="number">1</span>; i&gt;&gt;=<span class="number">1</span>) tree[i&gt;&gt;<span class="number">1</span>] = tree[i] + tree[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (l+=n, r+=n+<span class="number">1</span>; l&lt;r; l&gt;&gt;=<span class="number">1</span>, r&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) sum += tree[l++];</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) sum += tree[--r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) temp[i] = a[i];</span><br><span class="line">        sort(temp, temp+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i] = lower_bound(temp, temp+n, a[i]) - temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), N = n+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> result;</span><br><span class="line">        compress(nums);</span><br><span class="line">        <span class="keyword">int</span> tree[N&lt;&lt;<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = query(tree, <span class="number">0</span>, nums[i]<span class="number">-1</span>, N);</span><br><span class="line">            update(tree, nums[i], <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h4><ul>
<li>TODO: 参考<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76630/Evolve-from-brute-force-to-optimal-a-review-of-all-solutions" target="_blank" rel="noopener">这里</a>的解法6，和<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76729/onlogn-divide-and-conquer-java-solution-based-on-bit-by-bit-comparison" target="_blank" rel="noopener">这里</a>的思路解释</li>
</ul>
<h3 id="Reverse-Pairs-Leetcode-0493"><a href="#Reverse-Pairs-Leetcode-0493" class="headerlink" title="Reverse Pairs Leetcode 0493"></a>Reverse Pairs Leetcode 0493</h3><h3 id="Count-of-Range-Sum-Leetcode-0327"><a href="#Count-of-Range-Sum-Leetcode-0327" class="headerlink" title="Count of Range Sum Leetcode 0327"></a>Count of Range Sum Leetcode 0327</h3><p>[使用 Binary Index Tree 方法]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums[:]</span><br><span class="line">        self.count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            self.initialize(i, nums[i])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(self.nums)+<span class="number">1</span>:</span><br><span class="line">            self.count[i] += val</span><br><span class="line">            i += (i &amp; -i)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diff = val - self.nums[i]</span><br><span class="line">        self.nums[i] = val</span><br><span class="line">        self.initialize(i, diff)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_sum</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            total += self.count[i]</span><br><span class="line">            i -= (i &amp; -i)</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        sum of elements nums[i..j], inclusive.</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.left_sum(j) - self.left_sum(i<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># numArray = NumArray(nums)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(0, 1)</span></span><br><span class="line"><span class="comment"># numArray.update(1, 10)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(1, 2)</span></span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/array/" rel="tag"># array</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/30/leetcode-string/" rel="next" title="leetcode string">
                <i class="fa fa-chevron-left"></i> leetcode string
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/07/leetcode-stack-queue/" rel="prev" title="leetcode stack queue">
                leetcode stack queue <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面试题总体分析"><span class="nav-number">1.</span> <span class="nav-text">面试题总体分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-vector"><span class="nav-number">2.</span> <span class="nav-text">c++ vector</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python-list"><span class="nav-number">3.</span> <span class="nav-text">python list</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题目"><span class="nav-number">4.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#局部极小值-leetcode-162"><span class="nav-number">4.1.</span> <span class="nav-text">局部极小值 leetcode 162</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值等于下标的元素"><span class="nav-number">4.2.</span> <span class="nav-text">数值等于下标的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环有序数组查找元素-leetcode-153"><span class="nav-number">4.3.</span> <span class="nav-text">循环有序数组查找元素 leetcode 153</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环有序数组查找元素-leetcode-154"><span class="nav-number">4.4.</span> <span class="nav-text">循环有序数组查找元素 leetcode 154</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长公共子序列"><span class="nav-number">4.5.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最长递增子序列"><span class="nav-number">4.6.</span> <span class="nav-text">最长递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一个缺失的正整数-leetcode-41"><span class="nav-number">4.7.</span> <span class="nav-text">第一个缺失的正整数 leetcode 41</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素最大间距-leetcode-164-“maximum-Gap”"><span class="nav-number">4.8.</span> <span class="nav-text">元素最大间距 leetcode 164 “maximum Gap”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出现一次的数"><span class="nav-number">4.9.</span> <span class="nav-text">出现一次的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#出现-3-次的数-leetcode-137"><span class="nav-number">4.10.</span> <span class="nav-text">出现 3 次的数 leetcode 137</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#举一反三的思考"><span class="nav-number">4.10.1.</span> <span class="nav-text">举一反三的思考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-100-缺少的两个数"><span class="nav-number">4.11.</span> <span class="nav-text">1-100 缺少的两个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#众数问题"><span class="nav-number">4.12.</span> <span class="nav-text">众数问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><span class="nav-number">4.13.</span> <span class="nav-text">几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode-0011"><span class="nav-number">4.13.1.</span> <span class="nav-text">leetcode 0011</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted"><span class="nav-number">4.13.2.</span> <span class="nav-text">leetcode 0167 Two Sum 2 Input array is sorted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode-240-Search-a-2D-Matrix-II"><span class="nav-number">4.13.3.</span> <span class="nav-text">leetcode 240 Search a 2D Matrix II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一"><span class="nav-number">4.13.3.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二：分治"><span class="nav-number">4.13.3.2.</span> <span class="nav-text">方法二：分治</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.13.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trapping-Rain-Water-leetcode-0042"><span class="nav-number">4.14.</span> <span class="nav-text">Trapping Rain Water leetcode 0042</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中连续一段和，绝对值最小"><span class="nav-number">4.15.</span> <span class="nav-text">数组中连续一段和，绝对值最小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大子数组和-leetcode-53"><span class="nav-number">4.16.</span> <span class="nav-text">最大子数组和 leetcode 53</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cantor-数组"><span class="nav-number">4.17.</span> <span class="nav-text">Cantor 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subset-sum"><span class="nav-number">4.18.</span> <span class="nav-text">subset sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逆序数有关"><span class="nav-number">4.19.</span> <span class="nav-text">逆序数有关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Count-of-Smaller-Number-After-Self-leetcode-0315"><span class="nav-number">4.19.1.</span> <span class="nav-text">Count of Smaller Number After Self leetcode 0315</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#暴力解法"><span class="nav-number">4.19.1.1.</span> <span class="nav-text">暴力解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进暴力解法"><span class="nav-number">4.19.1.2.</span> <span class="nav-text">改进暴力解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">4.19.1.3.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡-BST"><span class="nav-number">4.19.1.4.</span> <span class="nav-text">平衡 BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge-sort"><span class="nav-number">4.19.1.5.</span> <span class="nav-text">merge sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Index-Tree"><span class="nav-number">4.19.1.6.</span> <span class="nav-text">Binary Index Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法介绍"><span class="nav-number">4.19.1.6.1.</span> <span class="nav-text">算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#本题的代码"><span class="nav-number">4.19.1.6.2.</span> <span class="nav-text">本题的代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Segment-Tree-线段树"><span class="nav-number">4.19.1.7.</span> <span class="nav-text">Segment Tree 线段树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bit-manipulation"><span class="nav-number">4.19.1.8.</span> <span class="nav-text">bit manipulation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reverse-Pairs-Leetcode-0493"><span class="nav-number">4.19.2.</span> <span class="nav-text">Reverse Pairs Leetcode 0493</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Count-of-Range-Sum-Leetcode-0327"><span class="nav-number">4.19.3.</span> <span class="nav-text">Count of Range Sum Leetcode 0327</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/';
          this.page.identifier = '2019/12/04/leetcode-数组/';
          this.page.title = 'leetcode 数组';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://githubio-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
