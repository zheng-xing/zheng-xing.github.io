<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="tree, graph," />










<meta name="description" content="基础知识总结数的基本操作有  插入 删除 查找 前序遍历 中序遍历 后序遍历  类的实现1234567891011121314151617181920212223242526272829typedef struct tagSTreeNode&amp;#123;    int val;    tagSTreeNode* left;    tagSTreeNode* right;    tagSTreeNod">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode tree">
<meta property="og:url" content="http://yoursite.com/2019/12/09/leetcode-tree/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础知识总结数的基本操作有  插入 删除 查找 前序遍历 中序遍历 后序遍历  类的实现1234567891011121314151617181920212223242526272829typedef struct tagSTreeNode&amp;#123;    int val;    tagSTreeNode* left;    tagSTreeNode* right;    tagSTreeNod">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png">
<meta property="article:published_time" content="2019-12-10T04:20:05.000Z">
<meta property="article:modified_time" content="2020-03-01T23:15:26.358Z">
<meta property="article:author" content="Zheng Xing">
<meta property="article:tag" content="tree, graph">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/09/leetcode-tree/"/>





  <title>leetcode tree | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/leetcode-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode tree</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T20:20:05-08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/leetcode-tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h1><p>数的基本操作有</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    tagSTreeNode* left;</span><br><span class="line">    tagSTreeNode* right;</span><br><span class="line"></span><br><span class="line">    tagSTreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; STreeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STreeNode* m_root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(STreeNode* root)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> _Insert(STreeNode* root, <span class="keyword">int</span> val);    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">bool</span> _Insert2(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> _PreOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">void</span> _PreOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder3(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _PostOrder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于任何的树，算法复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Iterative 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* BinaryTree::Find(int v) const &#123;</span><br><span class="line">    if(!m_root) return nullptr;</span><br><span class="line"></span><br><span class="line">    TreeNode* res &#x3D; m_root;</span><br><span class="line">    while(res)&#123;</span><br><span class="line">        if(v &lt; res-&gt;val)&#123;</span><br><span class="line">            res &#x3D; res-&gt;left;</span><br><span class="line">        &#125; else if (v &gt; res-&gt;val) &#123;</span><br><span class="line">            res &#x3D; res-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加一个节点"><a href="#添加一个节点" class="headerlink" title="添加一个节点"></a>添加一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Insert: BST的插入过程是一个递归过程，如果插入结点值比插入位置结点值小，则插入到左子树。反之则插入到右子树中。若插入位置结点的左子树或者右子树为空，则直接插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTree::Insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Insert(m_root, val);    <span class="comment">// 递归算法</span></span><br><span class="line">    <span class="comment">// return _Insert2(val);        // 非递归算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert(TreeNode* root, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// val 已经在 tree 里面了，插入失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert2(<span class="keyword">int</span> val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root)&#123;</span><br><span class="line">        m_root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* pnode = m_root, pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exhausively 找到待插入的位置(nullptr)</span></span><br><span class="line">    <span class="comment">// 此时 pnode 就是那个 nullptr, pcur 是此节点的父节点。</span></span><br><span class="line">    <span class="keyword">while</span>(pnode)&#123;</span><br><span class="line">        pcur = pnode;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// while 执行完后 pnode = nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; pcur-&gt;val)&#123;</span><br><span class="line">        pcur-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pcur-&gt;val) &#123;</span><br><span class="line">        pcur-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除一个节点</span><br><span class="line"></span><br><span class="line">思想就是：</span><br><span class="line">    递归寻找待删除的 node</span><br><span class="line">    找到以后</span><br><span class="line">    如果node 没有左子树，就把右子树提上来</span><br><span class="line">    如果node 没有右子树，就把左子树提上来</span><br><span class="line">    如果node 既有左子树，又有右子树，这个情况比较复杂</span><br><span class="line">        可以把左子树最大的数字拿过来，也可以把右子树最小的拿过来！</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    /*<br>    方法一：左子树的最右边的 node 替换上来！！！<br>    */</p>
<pre><code>TreeNode* deleteNode(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* maxNode = findMax(root-&gt;left);
        root-&gt;val = maxNode-&gt;val;
        root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
    }

    return root;
}

TreeNode* findMax(TreeNode* node){
    while(node-&gt;right)
        node = node-&gt;right;
    return node;
}


/* 
方法二：右子树的最左边的 node 替换上来
*/

TreeNode* deleteNode_way2(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* minNode = findMin(root-&gt;right);
        root-&gt;val = minNode-&gt;val;
        root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
    }

    return root;
}

TreeNode* findMin(TreeNode* node){
    while(node-&gt;left)
        node = node-&gt;left;
    return node;
}
*/</code></pre><p>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的3种遍历(include iterative and recursive)</span><br><span class="line">1. 下面四种情况中，只有 2 和 3 能唯一决定一棵树。More generally, if a node has only one child, preorder and postorder do not contain enough information to determine whether that child is a left child or a right child.</span><br><span class="line">    1. preorder and postorder</span><br><span class="line">    2. inorder and postorder</span><br><span class="line">    3. preorder and inorder</span><br><span class="line">    4. level order and postorder</span><br><span class="line"></span><br><span class="line">技巧</span><br><span class="line">1. 二叉搜索树的 in-order traversal 输出一个 sorted array</span><br><span class="line">2. 二叉搜索树的 pre-order traversal 输出一个 array，这个 array 不是 sorted，但是它有个特点就是，右子树的值肯定都大于当前节点。(leetcode-255, verify pre-order sequence of Binary Search Tree)</span><br><span class="line"></span><br><span class="line">### 前序遍历</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">void BinaryTree::PreOrder(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    _PreOrder(m_root, visited);</span><br><span class="line">    &#x2F;&#x2F;_PreOrder2(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归思想去做前序遍历</span><br><span class="line">void BinaryTree::_PreOrder(TreeNode* root, vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!root) return;</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _PreOrder(root-&gt;left, visited);</span><br><span class="line">    _PreOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归方法的前序遍历</span><br><span class="line">void BinaryTree::_PreOrder2(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!m_root) return;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(m_root);</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        pcur &#x3D; s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        visited.push_back(pcur-&gt;val);</span><br><span class="line">        if(pcur-&gt;right) s.push(pcur-&gt;right);</span><br><span class="line">        if(pcur-&gt;left) s.push(pcur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二插查找树中序遍历的结果是升序的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::InOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _InOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _InOrder2(visited);</span></span><br><span class="line">    <span class="comment">// _InOrder3(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _InOrder(root-&gt;left, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _InOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历</span></span><br><span class="line"><span class="comment">  注意，这一个不是按照上面的思路！每次拿出一个节点，把右放进去，再放自己，再放左。</span></span><br><span class="line"><span class="comment">  这样子需要额外记录一下节点是不是第一次访问的信息，写起来麻烦！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的解决思路是每次弹出一个节点，需要一直找左子树，</span></span><br><span class="line"><span class="comment">  走到头，把过程中碰到的节点都压入栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pcur || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(pcur)&#123;        <span class="comment">// 找最左孩子</span></span><br><span class="line">            s.push(pcur);</span><br><span class="line">            pcur = pcur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            pcur = s.top();    <span class="comment">// 访问左海子为空的节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">            pcur = pcur-&gt;right;    <span class="comment">// 转向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历 第二种思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放自己，再放左子树节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::PostOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _PostOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _PostOrder2(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_PostOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _PostOrder(root-&gt;left, visited);</span><br><span class="line">    _PostOrder(root-&gt;right, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的后序遍历（与中序遍历的第三个方法代码区别就只有一行！）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放左子树节点，再放自己。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据前序中序，计算后续"><a href="#根据前序中序，计算后续" class="headerlink" title="根据前序中序，计算后续"></a>根据前序中序，计算后续</h3><p>[例如]<br>前序遍历: GDAFEMHZ<br>中序遍历: ADEFGHMZ</p>
<p>[思路]<br>两个步骤</p>
<ul>
<li>根据前序中序，构造二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InPre2Post</span><span class="params">(<span class="built_in">string</span> InOrder, <span class="built_in">string</span> PreOrder)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> n1 = InOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n2 = PreOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> helper(InOrder, <span class="number">0</span>, n1 - <span class="number">1</span>, PreOrder, <span class="number">0</span>, n2 - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; InOrder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; PreOrder, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        res.push_back(InOrder[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">while</span>(InOrder[k] != PreOrder[p])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(InOrder, i, k<span class="number">-1</span>, PreOrder, p+<span class="number">1</span>, p+k-i, res);</span><br><span class="line">    helper(InOrder, k+<span class="number">1</span>, j, PreOrder, p+<span class="number">1</span>+k-i, q, res);</span><br><span class="line">    res.push_back(PreOrder[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据后续和中序，计算前序"><a href="#根据后续和中序，计算前序" class="headerlink" title="根据后续和中序，计算前序"></a>根据后续和中序，计算前序</h3><p>思路跟上面的 InPre2Post 基本一模一样。只不过：</p>
<ul>
<li>一个是 InOrder 的第一个元素作为根节点，</li>
<li>一个是 PostOrder 的末尾元素作为根节点。</li>
</ul>
<h3 id="前序遍历是否合法-leetcode-331"><a href="#前序遍历是否合法-leetcode-331" class="headerlink" title="前序遍历是否合法 leetcode 331"></a>前序遍历是否合法 leetcode 331</h3><p>[题目]</p>
<p>[分析]</p>
<ul>
<li>如何还原这个树？</li>
<li>建立每个节点<ul>
<li>顺着树往“左”走</li>
<li>遇到叶子(#)就回退，往右走</li>
</ul>
</li>
<li>维护每个节点的孩子</li>
<li>更巧的方法<ul>
<li>不需要知道“父子关系”</li>
<li>当前节点插入空位</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> space = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[i] == <span class="string">','</span>) preorder[i] = <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--space &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="string">"#"</span>)&#123;</span><br><span class="line">                space += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (space == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的写法有问题，一定要先减去一，再考虑是否要加上2</span></span><br><span class="line">    <span class="comment">/*bool isValidSerialization(string preorder) &#123;</span></span><br><span class="line"><span class="comment">        int space = 1;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 0) return true;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 1) return (preorder[0] == '#');</span></span><br><span class="line"><span class="comment">        if(preorder[0] == '#') return false;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; preorder.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">            if(preorder[i] == ',') preorder[i] = ' ';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        stringstream s(preorder);</span></span><br><span class="line"><span class="comment">        string temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        while(s &gt;&gt; temp)&#123;</span></span><br><span class="line"><span class="comment">            if(temp == "#")&#123;</span></span><br><span class="line"><span class="comment">                space--;</span></span><br><span class="line"><span class="comment">                if(space &lt; 0) return false;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                space++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; space;</span></span><br><span class="line"><span class="comment">        return (space == 0);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="复杂的树结构"><a href="#复杂的树结构" class="headerlink" title="复杂的树结构"></a>复杂的树结构</h2><ul>
<li>AVL 树：最早的平衡二叉树之一。应用相对其他数据结构比较少。Windows 对进程地址空间的管理使用到了 AVL 树。</li>
<li>红黑树：平衡二叉树，广泛用在 C++ 的 STL 中。如 map 和 set 都是用红黑树实现的。</li>
<li>B/B+ 树：用在磁盘文件组织，数据索引，和数据库索引。</li>
<li>Trie树（字典树）：用在统计和排序大量字符串，如自动机。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ol>
<li>Trie 树是一种哈希多叉树，又称字典树、单词查找树、或者前缀树，用于在大量字符串中快速检索。<ol>
<li>英文字母的字典树是一个 26 叉树。</li>
<li>数字的字典树是一个 10 叉树。</li>
</ol>
</li>
<li>典型应用<ol>
<li>统计和排序大量的字符串（但不仅限于字符串），经常被文字处理系统用于文本词频统计。</li>
<li>优点：利用字符串的公共前缀来节约存储空间，最大限度地减少无畏的字符串比较，查询效率比哈希表高。</li>
<li>缺点：如果存在大量字符串且这些字符串基本没有公共前缀，则相应的 Trie 树将非常消耗内存。</li>
</ol>
</li>
<li>基本性质<ol>
<li>根节点不包含字符。除根节点以外每一个节点都只包含一个字符。每个节点有 26 个指针指向子节点，同时自身还有个 bool 变量用来记录当前位置是否可以作为一个字符串的结束位置！</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该根节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
</li>
</ol>
<p>[题目]<br>给定一棵边的权值都是正整数的数，求某两个节点间的路径，使得该路径所包含的所有边权的异或值最大。</p>
<p>[例子]<br>中心点 B 有三个无向边指向 A, C, D，权值分别为 3, 4, 6<br>那么最优的答案就是路径 A-B-D，结果就是 3^4 = 7</p>
<p>[思路]</p>
<ol>
<li>思路一：朴素解法<ol>
<li>枚举所有节点对，求得所有路径异或权。时间复杂度O(n^2).</li>
</ol>
</li>
<li>思路二：<ol>
<li>问题分析<ol>
<li>异或的性质: a^b = (a^c)^(b^c)</li>
<li>因此可以选择一个点作为根节点建立一个数。然后任意两个节点之间的路径的权重的异或值，等于两个节点分别到跟节点的路径的权重异或值，这两个结果再异或一下就可以了。</li>
<li>从根节点到每个节点的异或值可以通过一次深度优先搜索解决，时间复杂度 O(n)</li>
<li><mark>问题转化为求 n 个数中异或值最大的两个数字。</mark></li>
</ol>
</li>
<li>利用 Trie 树的解法<ol>
<li>将数字看成二进制的 0/1 串，先将所有数字从最高位起放入一个二叉 Trie 数中 (这里如果数字的长度不一样，可以使用最大的数字的有效长度，比如最大的数字是 100，那么用 7 个 bit 位就可以表示了。其他的数字也都用 7 个 bit 位表示，不到的话左边补 0)</li>
<li>枚举每个数字 a，从最高位开始，寻找尽量与 a 对应位不同的数字；时间复杂度 O(len)</li>
<li>总体时间复杂度 O(N * len)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png" alt=""></p>
<p>[总结]</p>
<ol>
<li>Trie 树逻辑结构清晰简练，在海量数据中查找某数据，和海量数据规模无关，只和待查找数据长度本身有关，时间复杂度为 O(len)，常认为是 O(1)。<ol>
<li>可以看做是以数据元素为关键字的多 Hash 结构</li>
<li>海量数据的复杂度分析未考虑内存调度问题。</li>
</ol>
</li>
<li>双数组的存储结构比较难，增删困难。实践中，往往离线将海量数据建立 Trie 树双数组结构，少量删除时可以继续使用。若大量删除，则离线建立新的 Trie 树双数组结构，适时替换。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="0117 Populating Next Right Pointers in Each Node II"></a>0117 Populating Next Right Pointers in Each Node II</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一题实际上就是 level order traversal</span></span><br><span class="line"><span class="comment">使用 queue 就很好做了</span></span><br><span class="line"><span class="comment">但是 queue 的空间复杂度是 O(n)</span></span><br><span class="line"><span class="comment">而题目要求是 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决的关键就在于 每一个 node 里都有一个 next pointer</span></span><br><span class="line"><span class="comment">它的存在使得我们没有必要用queue 记录一层所有的 nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法关键：</span></span><br><span class="line"><span class="comment">    在扫描当前level的节点的 children nodes 时候</span></span><br><span class="line"><span class="comment">    更新这些 children nodes 的 next 指针</span></span><br><span class="line"><span class="comment">    这样子，在扫描下一个 level的时候，</span></span><br><span class="line"><span class="comment">    就可以使用这些 next pointer 了！！！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">二刷关键：</span></span><br><span class="line"><span class="comment">    引入一个 dummy node 可以使得代码更简洁！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode *cur; <span class="comment">// cur 指针扫描下一层 的节点;</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;                          <span class="comment">// root 指针用于扫描当前 level</span></span><br><span class="line">            cur = dummy;                        <span class="comment">// cur 指针扫描下一层 的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root) &#123;                       <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;left;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;right;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            root = dummy-&gt;next;                <span class="comment">// root 指针跳到下一层的 dummy 后面第一个有效节点</span></span><br><span class="line">            dummy-&gt;next = <span class="literal">nullptr</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 一刷的代码，不够简洁</span></span><br><span class="line"><span class="comment">    void connect(TreeLinkNode *root) &#123;</span></span><br><span class="line"><span class="comment">        TreeLinkNode *cur = root;         //current node of current level</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while (cur) &#123;</span></span><br><span class="line"><span class="comment">            TreeLinkNode *head = NULL;   // head of the next level</span></span><br><span class="line"><span class="comment">            TreeLinkNode *prev = NULL;   //the leading node on the next level</span></span><br><span class="line"><span class="comment">            while(cur) &#123;       //iterate on the current level</span></span><br><span class="line"><span class="comment">                if (cur-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev  = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                if (cur-&gt;right) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //move to next node           </span></span><br><span class="line"><span class="comment">                cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //move to next level</span></span><br><span class="line"><span class="comment">            cur = head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Find-k-th-smallest-number-of-binary-search-tree"><a href="#Find-k-th-smallest-number-of-binary-search-tree" class="headerlink" title="Find k-th smallest number of binary search tree"></a>Find k-th smallest number of binary search tree</h2><p>==适用于binary search tree 的递归的方法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements;</span><br><span class="line">        recurse(root, elements, k);</span><br><span class="line">        <span class="keyword">return</span> elements[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; elements, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(elements.<span class="built_in">size</span>() == k) <span class="keyword">return</span>;        <span class="comment">// 技巧，提前停止</span></span><br><span class="line">        recurse(root-&gt;left, elements, k);</span><br><span class="line">        elements.push_back(root-&gt;val);</span><br><span class="line">        recurse(root-&gt;right, elements, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==适用于BST的非递归，使用stack的方法！！！（这个非常棒！！！）==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = mystack.top();</span><br><span class="line">                mystack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE BEGIN</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE END</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                </span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>==适用于任何的二叉树(binary tree, not necessarily BST)：先输出所有点(iterative 或 recursive)到array，然后找第 k 个==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 iterative 的方法，输出所有点到 array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    dq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">        TreeNode* temp = dq.front();</span><br><span class="line">        myvec.push_back(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left) dq.push_back(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right) dq.push_back(temp-&gt;right);</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 recursive 的方法，输出所有点到array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    helper(root, myvec);</span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.push_back(root-&gt;<span class="keyword">int</span>);</span><br><span class="line">    helper(root-&gt;left, vec);</span><br><span class="line">    helper(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Common-Ancester-总结"><a href="#Common-Ancester-总结" class="headerlink" title="Common Ancester 总结"></a>Common Ancester 总结</h2><p>注意</p>
<ol>
<li>这些题目的有些解法对问题的定义实际上是做了修改的！但是却巧妙地得到了正确答案。</li>
<li>注意经常犯的把问题复杂化的一个习惯是分别对如下情况考虑<ol>
<li>root 的左右子树分别含有 p 和 q</li>
<li>p 是 root, 子节点立面有 q</li>
<li>q 为根的子树里面有 p</li>
</ol>
</li>
</ol>
<h3 id="leetcode-0235"><a href="#leetcode-0235" class="headerlink" title="leetcode 0235"></a>leetcode 0235</h3><p>[题目]</p>
<ol>
<li>p 和 q 节点不相同，且一定存在！</li>
<li>BST 节点里的数值互不相同。</li>
</ol>
<p>[思路]</p>
<ol>
<li>[不好的思路]<ol>
<li>如上所述，对几种情况分别考虑，代码很长，时间也不低。</li>
</ol>
</li>
<li>好的思路，充分利用 BST 树的性质来做。<ol>
<li>其 LCA 节点的值一定在给定的两个节点的值中间。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; maxVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; minVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterative 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; maxVal)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; minVal)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;    <span class="comment">// 这一句不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-0236"><a href="#leetcode-0236" class="headerlink" title="leetcode 0236"></a>leetcode 0236</h3><p>[题目]</p>
<ol>
<li>本题的变化是树不再是 BST 了</li>
<li>同样的，仍然有<ol>
<li>所有节点的值都不相同</li>
<li>p 和 q 不同，且一定存在</li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ol>
<li>递归解法一个核心的思想是: <mark>我们找到一个节点 p 后，就不需要再递归找另一个 q 了，直接返回这个 p 就行！因为如果节点 q 在下面的话，那么二者的 LCA 一定是 p</mark>.</li>
<li>在这个前提条件下，我们的判断条件是，左子树上找到了一个点，右子树上找到了一个点，那么当前 root 就是 LCA.</li>
<li>为啥说这个解法对题目做了修改呢，因为我们没有去直接找两个点，而是找到一个就返回了！但是判断条件决定了我们可以找到正确的答案。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncester</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lintcode-578"><a href="#lintcode-578" class="headerlink" title="lintcode 578"></a>lintcode 578</h3><p>[题目]</p>
<ol>
<li>主要区别是两个节点有可能不在这个树上！！</li>
</ol>
<p>[思路一]</p>
<ol>
<li>可以先遍历一遍看看两个节点是否在树上啊！！！</li>
<li>然后就可以使用上面的代码了哎！</li>
</ol>
<p>[思路一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasNode</span><span class="params">(TreeNode* root, TreeNode* p, <span class="keyword">bool</span>&amp; flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hasNode(root-&gt;left, p, flag);</span><br><span class="line">    hasNode(root-&gt;right, p, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasP = <span class="literal">false</span>, hasQ = <span class="literal">false</span>;</span><br><span class="line">    hasNode(root, p, hasP);</span><br><span class="line">    hasNode(root, q, hasQ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个节点至少有一个不存在</span></span><br><span class="line">    <span class="keyword">if</span>( !hasP || !hasQ ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明两个节点一定存在了</span></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestorHelper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncestorHelper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestorHelper(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：</p>
<ol>
<li>我这个代码算是一个非常好的代码！时间复杂度不高，空间复杂度 leetcode 上显示，小于百分百提交的代码！</li>
<li>我这个代码看似是遍历了三遍树，实际上每次都没有遍历完！<ol>
<li>我定义的辅助函数 hasNode 在找到节点后就停止递归了！网上有不好的实现方法是递归同时找两个节点！这样子你找到一个后不可以停止，导致必须遍历完全部的树节点才可以！</li>
<li>由于知道两个节点后才调用 lowestCommonAncestorHelper，这个函数找到一个节点后也会停止递归！</li>
<li>空间复杂度这么好是因为没有递归遍历所有的节点，导致使用的 stack memory 较少所致！</li>
</ol>
</li>
</ol>
<p>[思路二]</p>
<ol>
<li>因为可能有无效的节点，所以上面的那个解法就不 work 了，我们需要真得去找到 p 和 q 才行！</li>
</ol>
<p>[思路二代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> a_exist, b_exist;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    ResultType(<span class="keyword">bool</span> a, <span class="keyword">bool</span> b, TreeNode* n) &#123;</span><br><span class="line">        a_exist = a;</span><br><span class="line">        b_exist = b;</span><br><span class="line">        node = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ResultType rt = helper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rt.a_exist &amp;&amp; rt.b_exist)</span><br><span class="line">            <span class="keyword">return</span> rt.node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ResultType <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root 不存在，则 p, q 一定不在树里面。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ResultType(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        ResultType left_rt = helper(root-&gt;left, p, q);</span><br><span class="line">        ResultType right_rt = helper(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> a_exist = left_rt.a_exist || right_rt.a_exist || root == p;</span><br><span class="line">        <span class="keyword">bool</span> b_exist = left_rt.b_exist || right_rt.b_exist || root == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四种情况</span></span><br><span class="line">        <span class="comment">// 一：p, q 至少有一个等于 root</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二：</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span> &amp;&amp; right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 三：p, q 同属 root 的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, left_rt.node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四：p, q 同属 root 的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, right_rt.node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultType(a_exist, b_exist, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="节点含有父节点指针"><a href="#节点含有父节点指针" class="headerlink" title="节点含有父节点指针"></a>节点含有父节点指针</h3><p>[思路]</p>
<ol>
<li>面试中，面试者一般不直接告诉你树的节点是否含有父节点的指针，能否自定义树的 node，因此需要主动询问。</li>
<li>如果有指向父节点的指针的话，这道题就类似于 Y 链表那道题目。<ol>
<li>先分别求出 p 和 q 到 root 的距离，假定 p 到 root 距离是 q 到 root 距离多 N steps.<ol>
<li>当然如果 p 和 q 可能不属于同一棵树的话</li>
<li>这里可以判断两个 root 是否相等，如果不相等说明 p 和 q 来自不同的树！</li>
</ol>
</li>
<li>让 p 向上走 N steps</li>
<li>p 和 q 同时向上走，直到相遇！</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树是最重要的数据结构，没有之一！</li>
<li>从根节点到叶子的过程，是逐渐细化精确的过程，所以，实践中往往作为海量数据索引。</li>
<li>数只是数据结构，非存储结构。实践中，可以使用数组来存储树。<ul>
<li>思考实例 Huffman 编码、堆排序、并查集等。</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/tree-graph/" rel="tag"># tree, graph</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/08/leetcode-linked-list/" rel="next" title="leetcode linked list">
                <i class="fa fa-chevron-left"></i> leetcode linked list
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="prev" title="排序算法总结">
                排序算法总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识总结"><span class="nav-number">1.</span> <span class="nav-text">基础知识总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类的实现"><span class="nav-number">1.1.</span> <span class="nav-text">类的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算节点个数"><span class="nav-number">1.2.</span> <span class="nav-text">计算节点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">1.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加一个节点"><span class="nav-number">1.4.</span> <span class="nav-text">添加一个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中序遍历"><span class="nav-number">1.4.1.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后序遍历"><span class="nav-number">1.4.2.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据前序中序，计算后续"><span class="nav-number">1.4.3.</span> <span class="nav-text">根据前序中序，计算后续</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据后续和中序，计算前序"><span class="nav-number">1.4.4.</span> <span class="nav-text">根据后续和中序，计算前序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前序遍历是否合法-leetcode-331"><span class="nav-number">1.4.5.</span> <span class="nav-text">前序遍历是否合法 leetcode 331</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂的树结构"><span class="nav-number">1.5.</span> <span class="nav-text">复杂的树结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL-树"><span class="nav-number">1.5.1.</span> <span class="nav-text">AVL 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树-RB-Tree"><span class="nav-number">1.5.2.</span> <span class="nav-text">红黑树 RB-Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">1.5.3.</span> <span class="nav-text">B 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树-1"><span class="nav-number">1.5.4.</span> <span class="nav-text">B+ 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie-树"><span class="nav-number">1.5.5.</span> <span class="nav-text">Trie 树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题目"><span class="nav-number">2.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="nav-number">2.1.</span> <span class="nav-text">0117 Populating Next Right Pointers in Each Node II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Find-k-th-smallest-number-of-binary-search-tree"><span class="nav-number">2.2.</span> <span class="nav-text">Find k-th smallest number of binary search tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Common-Ancester-总结"><span class="nav-number">2.3.</span> <span class="nav-text">Common Ancester 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode-0235"><span class="nav-number">2.3.1.</span> <span class="nav-text">leetcode 0235</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leetcode-0236"><span class="nav-number">2.3.2.</span> <span class="nav-text">leetcode 0236</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lintcode-578"><span class="nav-number">2.3.3.</span> <span class="nav-text">lintcode 578</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点含有父节点指针"><span class="nav-number">2.3.4.</span> <span class="nav-text">节点含有父节点指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/12/09/leetcode-tree/';
          this.page.identifier = '2019/12/09/leetcode-tree/';
          this.page.title = 'leetcode tree';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://githubio-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
