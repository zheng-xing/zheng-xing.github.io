<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="cpp," />










<meta name="description" content="面向对象高级编程一些基础的点constructor initialization list initialization list 要注意，是证明你是 C++ 老手的一个点。 它的执行顺序是按照你在 class 里面定义的顺序来得； 它跟在函数体里面实现的区别在于 函数体里的实现是赋值操作，编译器还是需要先进行初始化操作，然后进入函数体执行赋值操作。 initialization list 里面是">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-summary">
<meta property="og:url" content="http://yoursite.com/2020/01/04/cpp-summary/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面向对象高级编程一些基础的点constructor initialization list initialization list 要注意，是证明你是 C++ 老手的一个点。 它的执行顺序是按照你在 class 里面定义的顺序来得； 它跟在函数体里面实现的区别在于 函数体里的实现是赋值操作，编译器还是需要先进行初始化操作，然后进入函数体执行赋值操作。 initialization list 里面是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overloading-function-different-names.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-template.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-function-template.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-explicit-keyword.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-relation-delegation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-composition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance-and-composition.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-const-intro.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-static-intro.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-uniform-initialization.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png">
<meta property="article:published_time" content="2020-01-05T01:28:42.000Z">
<meta property="article:modified_time" content="2020-03-28T03:37:48.398Z">
<meta property="article:author" content="Zheng Xing">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overloading-function-different-names.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/04/cpp-summary/"/>





  <title>cpp-summary | Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/cpp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cpp-summary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T17:28:42-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/cpp-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/cpp-summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="一些基础的点"><a href="#一些基础的点" class="headerlink" title="一些基础的点"></a>一些基础的点</h2><h3 id="constructor-initialization-list"><a href="#constructor-initialization-list" class="headerlink" title="constructor initialization list"></a>constructor initialization list</h3><ol>
<li>initialization list 要注意，是证明你是 C++ 老手的一个点。</li>
<li>它的执行顺序是按照你在 class 里面定义的顺序来得；</li>
<li>它跟在函数体里面实现的区别在于<ol>
<li>函数体里的实现是赋值操作，编译器还是需要先进行初始化操作，然后进入函数体执行赋值操作。</li>
<li>initialization list 里面是初始化操作，避免了多余的赋值操作。</li>
</ol>
</li>
<li>对于 primitive types，写在函数体里面进行赋值也不会有太大损失；不过最好也是统一写到 initialization list 那里吧！</li>
<li>有时候不仅仅是时间上的考虑，对于 const member data 来说，你必须放在 initialization list 那里，函数体里面不能进行赋值！</li>
</ol>
<h3 id="object-数据初始化顺序"><a href="#object-数据初始化顺序" class="headerlink" title="object 数据初始化顺序"></a>object 数据初始化顺序</h3><ol>
<li>对于类的数据来说，永远是先初始化基类的数据，然后对于当前子类来说，按照定义的顺序来初始化！</li>
<li>The relative order of initialization of non-local static objects defined in different translation units is underfined.<ol>
<li>A <code>translation unit</code> is the source code giving rise to a single object file. It’s basically a single source file, plus all of its <code>#include</code> files.</li>
<li>设想你需要初始化 static object B 和 A, 但是呢，B 的初始化需要先让 A 去初始化才行。这个时候你完全没有办法保证编译器会先初始化 A。怎么办？</li>
<li><mark>解决办法就是类似于 Singleton 设计得思想，把 B 的初始化放到一个函数里面，然后在函数体里面先去调用另一个函数去获得 static A object 的 reference，这样子就可以保证 A 会在 B 之前初始化了。</mark></li>
</ol>
</li>
</ol>
<h3 id="overloading"><a href="#overloading" class="headerlink" title="overloading"></a>overloading</h3><p>编译器是如何处理 overloading 的。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overloading-function-different-names.png" alt=""></p>
<p>此处注意如果你的参数列表都有默认值，有可能看起来跟其他同名函数不同，实际上却可能一样。</p>
<h3 id="big-three-三个特殊函数"><a href="#big-three-三个特殊函数" class="headerlink" title="big three 三个特殊函数"></a>big three 三个特殊函数</h3><p><mark>如果类里有指针，必须有(1) copy constructor (2) copy op= 拷贝赋值函数 (3) destructor. 三大函数</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.h 文件 ///////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    ~<span class="keyword">String</span>();</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_data&#125;;    <span class="comment">// 这里还需要提一句！这个函数须是 const 类型的！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.cpp 文件</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];    <span class="comment">// strlen 不会考虑字符串末尾的 '\n' 字符</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定初值时候</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];    <span class="comment">// 注意这里直接取另一个 instance 的私有数据！！因为同一类的不同 instance 互为 friend.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;    <span class="comment">// 检测自我赋值(self assignment)，这个能写出来就是高手！！！</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;    <span class="comment">// 不止是效率问题，是会出错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    os &lt;&lt; str.get_c_str();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="default-delete"><a href="#default-delete" class="headerlink" title="=default, =delete"></a>=default, =delete</h3><p>我们知道，对于 big three 这些函数，如果你没有定义，那么编译器会帮你生成一个！</p>
<p>而如果你自行定义了一个 ctor, 那么编译器就不会再给你一个 default ctor.<br>如果你强制加上 <code>=default</code>, 就可以重新获得并使用编译器给你的 default ctor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Zoo(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2): d1(i1), d2(i2) &#123;&#125;;</span><br><span class="line">    Zoo(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;    <span class="comment">// copy constructor</span></span><br><span class="line">    Zoo(Zoo&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// move constructor</span></span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Zoo() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++标准库里面使用 <code>=delete</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-1.png" alt=""></p>
<p>C++标准库里面使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-2.png" alt=""></p>
<p>C++标准库里面 destructor 使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-3.png" alt=""></p>
<p>具体的实例！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-5.png" alt=""></p>
<p><mark>非常棒的用法！！！</mark><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-7.png" alt=""></p>
<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 编译器如何对待 new</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化为</span></span><br><span class="line"><span class="keyword">String</span>* ps;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="keyword">String</span>));  <span class="comment">// 分配内存, 内部会调用 malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;<span class="keyword">String</span>*&gt;(mem);    <span class="comment">// 转型</span></span><br><span class="line">ps-&gt;<span class="keyword">String</span>::<span class="keyword">String</span>(<span class="string">"Hello"</span>);    <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 编译器如何对待 delete</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化成</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>(ps);    <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;    <span class="comment">// 释放内存，内部调用 free(ps);</span></span><br></pre></td></tr></table></figure>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-2.png" alt=""></p>
<p>注一</p>
<ol>
<li>那一大块 32 byte 灰色区域是 debug mode 才会有的，Release mode 不存在这一块。图中左一左三对应 debug mode 下的空间；</li>
<li>绿色部分是实际的数据；</li>
<li>VC 里面实际分配的区间长度一定是 16 的倍数，所以这里要加上 padding 使得长度由 52 变成 64;</li>
<li>00000041 代表这一块区间有多长，这个数字是16进制的，因此是 64 byte</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-3.png" alt=""></p>
<p>注二：</p>
<ol>
<li>这里主要强调 array 情况下的内存分配</li>
<li>注意清楚 array 的空间一定要使用 delete[] ps 而不是 delete ps<ol>
<li>使用 delete ps 会造成内存泄漏，但是这个内存泄漏跟想得不太一样，不是 ps 直接指向的那一块空间泄露了，而是 ps 指向的空间里面的保存的指针二次指向的内存出现了泄露。</li>
<li><font color="red">如果这里不是 String 类，而是 Complex class，那么因为 Complex 的私有数据没有指针，所以就不会出现上面的情况。也就是说，即使你没有使用 deletep[] pc，其实也不会造成内存泄漏问题！</font></li>
</ol>
</li>
</ol>
<h4 id="重载-new-amp-delete"><a href="#重载-new-amp-delete" class="headerlink" title="重载 ::new &amp; ::delete"></a>重载 ::new &amp; ::delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-0.png" alt=""></p>
<h4 id="重载-operator-new-amp-operator-delete"><a href="#重载-operator-new-amp-operator-delete" class="headerlink" title="重载 operator new &amp; operator delete"></a>重载 operator new &amp; operator delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-5.png" alt=""></p>
<h4 id="重载-new-amp-delete-1"><a href="#重载-new-amp-delete-1" class="headerlink" title="重载 new() &amp; delete()"></a>重载 new() &amp; delete()</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-8.png" alt=""></p>
<h5 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h5><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-9.png" alt=""></p>
<h3 id="类的大小-sizeof"><a href="#类的大小-sizeof" class="headerlink" title="类的大小 sizeof"></a>类的大小 sizeof</h3><ol>
<li>[易错易忽略] 一定要注意，不要说类的大小，而要说类的对象的大小。<ol>
<li>类的大小是什么？确切地说，类只是一个类型定义，它没有大小可言。</li>
<li>用 sizeof 对一个类型名操作，得到的是具有该类型实体的大小。</li>
<li>如果 <code>Class A; A obj</code>，那么 <code>sizeof(A) == sizeof(obj)</code></li>
</ol>
</li>
<li>一个对象的大小 <mark>大于等于</mark> 所有 非静态成员 大小的总和。为什么是大于等于而不是正好想等呢？超出的部分有如下两方面：<ol>
<li>C++对象模型本身 对于具有虚函数的类型来说，需要有一个方法为它的实体提供类型信息(RTTI)和虚函数入口，常见的方法是建立一个虚函数入口表，这个表可为相同类型的对象共享，因此对象中需要有一个指向虚函数表的指针，此外，为了支持RTTI，许多编译器都把该类型信息放在虚函数表中。但是，是否必须采用这种实现方法，C++标准没有规定，但是这几户是主流编译器均采用的一种方案。</li>
<li>编译器优化 因为对于大多数CPU来说，CPU字长的整数倍操作起来更快，因此对于这些成员加起来如果不够这个整数倍，有可能编译器会插入多余的内容凑足这个整数倍，此外，有时候相邻的成员之间也有可能因为这个目的被插入空白，这个叫做“补齐”(padding)。所以，C++ 标准紧紧规定成员的排列按照类定义的顺序, 但是不要求在存储器中是紧密排列的。</li>
</ol>
</li>
<li>基于上述两点，可以说用sizeof对类名操作，得到的结果是该类的对象在存储器中所占据的字节大小，由于静态成员变量不在对象中存储，因此这个结果等于各非静态数据成员（不包括成员函数）的总和加上编译器额外增加的字节。后者依赖于不同的编译器实现，C++标准对此不做任何保证。</li>
<li>C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch1; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="keyword">char</span> ch2; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> in;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象c扩充为2个字，但是对象b为什么没扩充为1个字呢（空类的对象一个字节，含一个char的类类对象也为一个字节。）？</span></span><br><span class="line">    <span class="comment">// 因为B类只有一个成员变量，普通成员函数不占用内存。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">    <span class="comment">//对象c实际上只有6字节有用数据，但是按照上面第二点编译器优化，编译器将此扩展为两个字（add charles 字节对齐），即8字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<ol>
<li>一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。</li>
<li>对象大小= vptr(可能不止一个，这个很难确定，不过试过，类中定义了一个virtual函数，仍然为占用4个字节) + 所有非静态数据成员大小 + </li>
<li>类a，b明明是空类，它的大小应该为为０，为什么编译器输出的结果为１呢？这就是我们刚才所说的实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址．所以a，b的大小为１．</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></span><br><span class="line">pivate: </span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span>&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">int</span> b::data1=<span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(a)="</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么类b多了一个数据成员，却大小和类a的大小相同呢？因为：类b的静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员．但是它不影响类的大小，不管这个类实际产生　了多少实例，还是派生了多少新的类，静态成员数据在类中永远只有一个实体存在，而类的非静态数据成员只有被实例化的时候，他们才存在．但是类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在．可以这么说，类的静态数据成员是一种特殊的全局变量．<br>所以a，b的大小相同．</p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>这里讨论 <code>sizeof</code> 一个 <code>struct</code> 时候的结果。</p>
<p>[三大规则]</p>
<ol>
<li>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节,则要从４的整数倍地址开始存储。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</li>
</ol>
<p>[举例]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;             <span class="comment">//[0]...[3]</span></span><br><span class="line">    <span class="keyword">double</span> weight;      <span class="comment">//[8]...[15]　　　　　　原则１</span></span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">height</span>;       <span class="comment">//[16]..[19], 总长要为８的整数倍,补齐[20]...[23]　　　　　原则３</span></span><br><span class="line">&#125;BB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aa</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">2</span>];     <span class="comment">//[0],[1]</span></span><br><span class="line">    <span class="keyword">int</span>  id;          <span class="comment">//[4]...[7]　　　　　　　　　　原则１</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> score;     <span class="comment">//[8]....[15]　　　　</span></span><br><span class="line">    short grade;      <span class="comment">//[16],[17]　　　　　　　　</span></span><br><span class="line">    BB b;             <span class="comment">//[24]......[47]　　　　　　　　　　原则２</span></span><br><span class="line">&#125;AA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AA a;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="keyword">sizeof</span>(BB)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是: 48 24</span></span><br></pre></td></tr></table></figure>

<p>[#pragma pack()]<br>在代码前加一句#pragma pack(1),你会很高兴的发现,上面的代码输出为</p>
<p>32 16<br>bb是4+8+4=16,aa是2+4+8+2+16=32;</p>
<p>这不是理想中的没有内存对齐的世界吗.没错,#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.</p>
<p>明白了不? </p>
<p>那 <code>#pragma pack(2)</code> 的结果又是多少呢?对不起,５分钟到了,自己去测试吧.</p>
<p>ps:Vc,Vs等编译器默认是#pragma pack(8)，所以测试我们的规则会正常；注意gcc默认是#pragma pack(4)，并且gcc只支持1,2,4对齐。套用三原则里计算的对齐值是不能大于#pragma pack指定的n值。</p>
<h3 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h3><p>C++ 里面模板的使用一共有四种情况：</p>
<ol>
<li>函数模板</li>
<li>类模板</li>
<li>成员模板</li>
<li>模板参数</li>
</ol>
<h4 id="class-template"><a href="#class-template" class="headerlink" title="[class template]"></a>[class template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-template.png" alt=""></p>
<h4 id="function-template"><a href="#function-template" class="headerlink" title="[function template]"></a>[function template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-function-template.png" alt=""></p>
<p>注意：</p>
<ol>
<li>class template 里面 template 后面方括号里面的关键字是 Typename</li>
<li>function template 里面 template 后面方括号里面的关键字是 class T</li>
<li>对于 class template, 在实际生成具体数据的时候，需要指明数据的类型, 比如 vector<int> 指明了这是一个 int 类型的 vector</li>
<li>而对于 function template，在实际调用执行这个函数的时候，并没有显式地说明输入数据的类型, 比如 min(a, b)<ol>
<li>此时如上图所示，编译器会自动推导该调用哪个（argument deduction）.</li>
</ol>
</li>
<li>最后想说明的是，STL 里面一大块就是 algorithm 算法，它们都是用 template 来实现的！！！<ol>
<li>这样子保证了解耦，比如上面的 min(a, b) algorithm 里面会使用”&lt;” 运算符，而这个运算符会由各个 class 的设计者去实现 &lt; operator 的重载！！</li>
</ol>
</li>
</ol>
<h4 id="member-template"><a href="#member-template" class="headerlink" title="member template"></a>member template</h4><p>成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;U1, U2&gt;) :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个具体例子，假设我们有两个父类，每个父类都一个子类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们打算这么用</span></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p);   // 这个操作可以吗？？？</span><br></pre></td></tr></table></figure>

<p>上面的操作是可以的！</p>
<p>在看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>:</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span> : __shared_ptr&lt;_Tp&gt;<span class="params">(__p)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体用的时候是这样子</span></span><br><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;    <span class="comment">// 这个叫做指针的 up-cast</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Base1&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>;    <span class="comment">// 模拟 up-cast</span></span><br></pre></td></tr></table></figure>

<h4 id="template-template-parameter"><a href="#template-template-parameter" class="headerlink" title="template template parameter"></a>template template parameter</h4><p>模板模板参数是指：模板的参数又是一个模板。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&gt;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        elems.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::pop empty!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> elem = elems.back();</span><br><span class="line">        elems.pop_back();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这段代码几个要注意的地方：</p>
<ol>
<li>模板的第一个参数是T类型，第二个参数的类型是一个模板，而这个模板具有一个类型参数。此处因为这个形参名字没有被使用，所以省略了。</li>
<li>第二个参数那里按照规定只能用 <code>class Container</code> 不能是 <code>typename Container</code></li>
<li>第二个参数有默认值，是 <code>std::vector</code></li>
</ol>
<p>那么如何使用它呢？有两种方法</p>
<ol>
<li>第一个是只提供一个参数，第二个参数使用默认的。<code>Stack&lt;int&gt; mys</code></li>
<li>如果要提供两种参数的话，第二个参数要提供一个模板类。  <code>Stack&lt;int, some_user_defined_template&gt;</code></li>
</ol>
<p><font color = 'red'>Warning!!!</font><br>有了上面的定义，我们期望可以这样使用 Stack：<code>Stack&lt;int, std::deque&gt; intStack</code>，但编译器却给了我们一个教训。</p>
<p>std::deque类模板在stl库中的定义有两个类型参数，第一个参数是元素类型，第二个参数是分配器allocator的类型。虽然std::deque的第二个类型参数有默认值，但是当编译器使用std::deque替换Container时却会严格匹配参数，默认值被忽略了。</p>
<p>需要将代码修改成如下的样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;Elem&gt;&gt; class Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&gt;</span><br><span class="line"><span class="comment">// class Stack 的内容如上，没有变化</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>Stack&lt;int, std::deque&gt; intStack</code> 就可以编译通过了。</p>
<p>下面再考虑一个问题？如下的定义还算是模板模板参数吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = <span class="built_in">list</span>&lt;T&gt;&gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从使用方法上考虑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用方法有两种：</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure>

<p>第一种，只指定了第一个模板参数，使用第二个默认的模板参数。</p>
<p>第二种，指定了两个模板参数。</p>
<p>但是！这不是模板模板参数。因为，一旦指定了第一个模板参数，那么第二个参数的类型就会确定，而真正的模板模板参数，第二个模板参数和第一个模板参数的类型是没有关系的，可以指定为第一个模板参数的类型，也可以指定为其他类型。因此，这不是模板模板参数!!!</p>
<h3 id="variadic-templates-C-11"><a href="#variadic-templates-C-11" class="headerlink" title="variadic templates (C++11)"></a>variadic templates (C++11)</h3><p>侯捷老师说，这个东西是 C++11 里面类似于核弹级别的东西，需要好好体会！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates.png" alt=""></p>
<p>Note:</p>
<ol>
<li>不仅参数的数量随意！每个参数的 type 也随意！</li>
<li>注意有两处出现了 <code>...</code>, 一处位置在 <code>Types</code> 左边，一个的位置在 <code>Types</code> 的右边。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-2.png" alt=""><br>Note:</p>
<ol>
<li>这个例子讲得是 hash function 的设计，其中每个 hash_val 的调用关系都画出来了。</li>
<li>第二个同名函数在递归调用的最后，会调用到第三个同名函数。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-3.png" alt=""><br>Note:</p>
<ol>
<li>这个例子是类的递归继承！</li>
</ol>
<h3 id="alias-template-template-typedef-C-11"><a href="#alias-template-template-typedef-C-11" class="headerlink" title="alias template (template typedef) C++11"></a>alias template (template typedef) C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-1.png" alt=""></p>
<p>这里要注意的就是 “template + using” 的做法竟然不能用 define 来替代！</p>
<p>下面两个图：</p>
<ol>
<li>左边的是侯老师的一个想法，希望实现一个函数可以接收两个那样的东西，然后完成一系列的测试。</li>
<li>但是写出来原型代码后，侯老师意识到这个实现是天方夜谭，需要的功能是完全不被支持的！</li>
<li>右边的写法是，侯老师意识到了传递给函数的一定是一个东西，一个 object, 而不能是一个 type.<ol>
<li>因此调用函数的方式变成了 <code>test_moveable(list(), MyString())</code>。加上括号就变成了 object 嘛。</li>
</ol>
</li>
<li>注意右边在函数定义的上面有加上了一句话，显示得说明了 Container 和 T 都是模板，但这个时候函数里面的一句话有报错了。</li>
<li>侯老师接着把函数里面的 <code>Container&lt;T&gt; c</code> 改成 <code>typename Container&lt;T&gt; c</code> 试图强制让编译器认为 Container 是一个模板，但还是有错。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-3.png" alt=""></p>
<p>下图注解：</p>
<ol>
<li>上面的做法怎么样都搞不定了，侯老师只好改变了函数接收的参数。</li>
<li>这里有个厉害的操作是他获取 <code>value_type</code> 的方式！</li>
<li>图中的方式可行，是因为 container 一定有 iterator 一定有 value_type, 那如果没有呢？<ol>
<li>就需要 <a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#template-template-parameter" target="_blank" rel="noopener">template template parameter</a> 了。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-4.png" alt=""></p>
<h3 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization 模板特化"></a>specialization 模板特化</h3><p>有特化就有泛化，而泛化指的就是模板。</p>
<p>下面的代码就是一个模板，一个泛化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span></span><br><span class="line">    <span class="comment">// 此处省略了具体的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>为什么需要特化？</mark></p>
<ol>
<li>上面的模板呢可能对于大多数类型的 Key, 都可以用</li>
<li>但是呢，对于一些特殊的 Key 类型，我们有更好的实现，不需要那么复杂。</li>
<li>这个时候我们当然可以另外的去新建一个 (template) class，但是这样子程序员使用者就必须要知道这两个类的名字，还需要记住它们分别适用于哪些 Key</li>
<li>而模板特化呢，就允许我们使用相同的名字，但是里面的实现可以完全不一样！</li>
<li><mark>事实上，可以理解成编译器对于模板的特化是当做一个全新的 class 对待，因此里面的内容可以完全不同。</mark></li>
</ol>
<p>下面的代码介绍的就是特化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;               <span class="comment">// "Key" 已经被绑定了，所以这里尖括号里面是空白！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些语法的说明</p>
<ol>
<li>模板那一行写得是 template&lt;&gt;, 其中的 <code>template</code> 告诉编译器后面跟着得是模板类型，留空的 <code>&lt;&gt;</code> 表示没有模板参数。（因为我们把唯一的 class Key 换成了一个具体的类型）。</li>
<li>hash 后面紧跟的尖括号里面具体给出了我们要建立一个怎样的 hash 类。</li>
</ol>
<h3 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization 偏特化"></a>partial specialization 偏特化</h3><p>两种“偏”</p>
<ol>
<li>个数上</li>
<li>范围上</li>
</ol>
<h4 id="个数上的偏"><a href="#个数上的偏" class="headerlink" title="个数上的偏"></a>个数上的偏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处省略了实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 特殊的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="范围上"><a href="#范围上" class="headerlink" title="范围上"></a>范围上</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是特化版本，针对指针类型的特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 这里的 T 只是一个名称而已，别跟上面弄混淆了，T 也可以改成 U 什么的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client 代码</span></span><br><span class="line">C&lt;<span class="built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure>

<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using directive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二 using declaration</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法三：不展开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Can-constructor-be-private"><a href="#Can-constructor-be-private" class="headerlink" title="Can constructor be private?"></a>Can constructor be private?</h3><p>constructor 会在创建一个当前类的对象的时候自动被调用。</p>
<p>虽然默认情况下 constructors 被定义在 public 区间，但是它其实是可以被定义在 private 区间的，下面介绍一下在什么情况下我们这么用！</p>
<h4 id="Using-Friend-Class"><a href="#Using-Friend-Class" class="headerlink" title="Using Friend Class"></a>Using Friend Class</h4><p>If we want that class should not be instantiated by anyone else but only by a friend class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        A a1;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出是</p>
<pre><code>constructor of A
constructor of B</code></pre><h4 id="Singleton-design-pattern"><a href="#Singleton-design-pattern" class="headerlink" title="Singleton design pattern"></a>Singleton design pattern</h4><p>这一个例子可以参考博客文章 <a href="https://zheng-xing.github.io/2020/01/15/design-pattern/" target="_blank" rel="noopener">design pattern</a>.</p>
<h4 id="Named-Constructor-Idiom"><a href="#Named-Constructor-Idiom" class="headerlink" title="Named Constructor Idiom"></a>Named Constructor Idiom</h4><p>如果有多个 Constructor 的时候容易出错，万一某两个的参数列表都一样咋整？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// ambiguous nature of constructor </span></span><br><span class="line"><span class="comment">// with same no of parameters of same type </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Rectangular coordinates </span></span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Polar coordinates (radius and angle) </span></span><br><span class="line">    Point(<span class="keyword">float</span> r, <span class="keyword">float</span> a);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// error: ‘Point::Point(float, float)’ cannot </span></span><br><span class="line">    <span class="comment">// be overloaded </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Ambiguous: Which constructor to be called ? </span></span><br><span class="line">    Point p = Point(<span class="number">5.7</span>, <span class="number">1.2</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个问题可以用下面的方法解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// named constructor idiom </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">float</span> x1, y1; </span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">    &#123; </span><br><span class="line">        x1 = x; </span><br><span class="line">        y1 = y; </span><br><span class="line">    &#125;; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// polar(radius, angle) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Polar</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular(x, y) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Rectangular</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function for displaying of coordinates </span></span><br><span class="line"><span class="keyword">void</span> Point :: <span class="built_in">display</span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"y :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return polar coordinates </span></span><br><span class="line">Point Point :: Polar(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x*<span class="built_in">cos</span>(y), x*<span class="built_in">sin</span>(y)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return rectangular coordinates </span></span><br><span class="line">Point Point :: Rectangular(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x,y); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Polar coordinates </span></span><br><span class="line">    Point pp = Point::Polar(<span class="number">5.7</span>, <span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"polar coordinates \n"</span>; </span><br><span class="line">    pp.<span class="built_in">display</span>(); </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular coordinates </span></span><br><span class="line">    Point pr = Point::Rectangular(<span class="number">5.7</span>,<span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangular coordinates \n"</span>; </span><br><span class="line">    pr.<span class="built_in">display</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是调用了 public 的函数而已，而这些函数会去调用定义在 private 区域的 Constructor.</p>
<h3 id="Constructor-Delegation"><a href="#Constructor-Delegation" class="headerlink" title="Constructor Delegation"></a>Constructor Delegation</h3><p>没想到这个东西是 C++ 11 才出现的。就是为了让一个 Constructor 去启动另个 Constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    A() </span><br><span class="line">    &#123; </span><br><span class="line">        x = <span class="number">0</span>; </span><br><span class="line">        y = <span class="number">0</span>; </span><br><span class="line">        z = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Constructor delegation  </span></span><br><span class="line">    A(<span class="keyword">int</span> z) : A() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;z = z; <span class="comment">// Only update z </span></span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; y &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; z; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line">    obj.show(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用 <code>A()</code> 要放到 initialization list 那里，不可以放到 <code>{}</code> 里面。</p>
<h3 id="conversion-function-转换函数"><a href="#conversion-function-转换函数" class="headerlink" title="conversion function 转换函数"></a>conversion function 转换函数</h3><p>从一个例子开始</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>) : m_denominator(den), m_numerator(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) (m_numerator) / (m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">4</span> + f;    <span class="comment">// 调用 operator double()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是解释</p>
<ol>
<li>转换函数不止可以是 <code>double</code> 类型，只要是之前出现过的，编译器认识的类型都可以去转换；</li>
<li>编译器在看到 <code>double d = 4 + f</code> 的时候会去看很多东西以确定这个操作是合理的<ol>
<li>比如它会去看有没有一个全局的函数重载了 <code>+</code>，这个函数会接受一个 <code>int</code> 和一个 <code>Fraction</code> 类别</li>
<li>它当然还会去看 <code>f</code> 能不能变成 int, float, double 的类型，这样子就可以跟 4 进行相加的操作了。</li>
</ol>
</li>
<li>如果你同时再定一个 <code>operator int() const{}</code> 转换函数，那么编译器会报错 <code>error: ambiguous overload for &#39;operator+&#39; (operand types are &#39;int&#39; and &#39;Fraction&#39;)</code>.</li>
</ol>
<h4 id="标准库的一个例子"><a href="#标准库的一个例子" class="headerlink" title="标准库的一个例子"></a>标准库的一个例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool, Alloc&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __bit_reference reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    reference <span class="keyword">operator</span>[] (size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + difference_type(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明一下</p>
<ol>
<li>上面这个例子用到了 proxy 设计模式，因为 operator[] 重载的函数需要返回 bool 值啊，这里却用了另一个 reference 代替返回的类型；</li>
<li>可是为什么 reference 类型的可以用在这里呢？明明需要返回的是 bool 类型？那么，reference 类型的类定义里面一定包含了如何将 bool 转换成 bool 类型的定义！！！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> !(!(*p &amp; mask));&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h3><p>explicit 关键字用途很窄，基本上都是用来放在 constructor 前面。</p>
<h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>一个正确的用法！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// 编译器看到这里会发现确实有个 + 运算符</span></span><br><span class="line">                            <span class="comment">// 调用 non-explicit constructor 将 4 转为 Fraction 类型</span></span><br><span class="line">                            <span class="comment">// 然后调用 operator+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs non-explicit-one-argument constructor"></a>conversion function vs non-explicit-one-argument constructor</h4><p>注意，下面这个代码会让编译器有歧义，它不知道该怎么处理.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit 在这里的意思是如果我没有显示地用你去做转换，编译器你不要自作聪明！</span></span><br><span class="line">    <span class="comment">// 不要调用我去把其他的 int 类型转变成 Fraction 类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! conversion from 'double' to 'Fraction' requested.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-11-explicit-for-ctors-taking-more-than-one-argument"><a href="#C-11-explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="C++11 explicit for ctors taking more than one argument"></a>C++11 explicit for ctors taking more than one argument</h4><p>上面的例子只针对有一个实参的 ctor. C++11 里面引入了多个实参的支持！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-explicit-keyword.png" alt=""></p>
<h3 id="range-based-for-C-11"><a href="#range-based-for-C-11" class="headerlink" title="range-based for C++11"></a>range-based for C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-1.png" alt=""><br>这个图解释了一下编译器会把 range based for 语句翻译成什么样子！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-2.png" alt=""></p>
<p>这个例子主要是用来说明 for loop 里面可能会报错，这个错误报错位置跟来源可能会在代码上离得比较远。<br>不过如果错误信息足够详细的话问题也不大！</p>
<h3 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h3><h4 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h4><p>这个代码来自于早期版本的标准库代码，C++ 2.0 (C++ 11) 以后改动了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : px(p) &#123;&#125;    <span class="comment">// 接受一个天然的指针！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="keyword">long</span>* pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;    <span class="comment">// 把 new 出来的指针包装成一个智能指针！</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line">    sp-&gt;method();    <span class="comment">// 变成 px-&gt;method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ol>
<li>任何一个智能指针类一定含有一个真正的指针在类里面；</li>
<li>任何一个智能指针类别一定有两个重载函数 <code>operator *()</code> 和 <code>operator-&gt;()</code>，并且它们的写法就跟这个例子里面一样；</li>
<li><mark>操作符 <code>-&gt;</code> 有个特点，它返回的东西可以接着用 <code>-&gt;</code>。比如这里的 <code>sp-&gt;method()</code> 中的 <code>sp-&gt;</code> 应该变成 <code>px</code>，但是这样子 <code>px</code> 怎么样去指向 <code>method</code> 呢，它还可以用 <code>-&gt;</code>。</mark></li>
</ol>
<h4 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator 迭代器"></a>iterator 迭代器</h4><p>迭代器要比智能指针多支持一些操作符！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;    <span class="comment">// 改个名而已</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;                       <span class="comment">// 真正的那个指针！！！</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node != x.node;&#125;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*node).data;        <span class="comment">// *node 返回的是 struct 的 object</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* prev;</span><br><span class="line">    <span class="keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用端的代码</span></span><br><span class="line"><span class="built_in">list</span>&lt;Foo&gt;::iterator ite;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">*ite;    <span class="comment">// 获得一个 Foo object</span></span><br><span class="line">ite-&gt;method();</span><br><span class="line">  <span class="comment">// 意思是调用 Foo::method()</span></span><br><span class="line">  <span class="comment">// 相当于 (*ite).method()</span></span><br><span class="line">  <span class="comment">// 相当于 (&amp;(*ite))-&gt;method()</span></span><br></pre></td></tr></table></figure>

<h3 id="function-like-classes-仿函数-functor"><a href="#function-like-classes-仿函数-functor" class="headerlink" title="function-like classes 仿函数 functor"></a>function-like classes 仿函数 functor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::second_type&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>辅助代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="base-classes-for-functor"><a href="#base-classes-for-functor" class="headerlink" title="base classes for functor"></a>base classes for functor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x - y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x == y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这些奇怪的 <code>unary_function</code> 和 <code>binary_function</code> 到底是个啥玩意？？？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处没有细讲，请参考侯捷老师专门的STL课程。</p>
<p>另外注意的是，这些class 没有成员变量的哦！只有一些 <code>typedef</code> 而已。</p>
<h2 id="object-relationships-有关"><a href="#object-relationships-有关" class="headerlink" title="object relationships 有关"></a>object relationships 有关</h2><h3 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h3><ol>
<li>Background<ol>
<li>Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.</li>
</ol>
</li>
<li>relationships between object<ol>
<li>a circle “is a “ shape</li>
<li>a house “has a” bedroom</li>
<li>I “use a” mechanical keyboard</li>
<li>mail “depend on” mailman to be delievered</li>
<li>I am “member of” Pingpang club</li>
</ol>
</li>
</ol>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><ol>
<li>主要用来描述 “has a” 关系的。<ol>
<li>Your computer “has a” CPU.</li>
<li>C++ concepts like structs and classes are both composite types.</li>
</ol>
</li>
<li>有两种 composition 子类<ol>
<li>composition</li>
<li>aggregation</li>
</ol>
</li>
<li>composition 子类满足条件<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time</li>
<li>The part (member) has its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
</li>
<li>说人话<ol>
<li>object 建立的时候创建 the part，object 摧毁的时候 part 也被摧毁</li>
<li>object manages part’s lifetime</li>
<li>part 不知道 object 的存在</li>
</ol>
</li>
</ol>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><p>Many games and simulations have creatures or objects that move around a board, map, or screen. One thing that all of these creatures/objects have in common is that they all have a location. In this example, we are going to create a creature class that uses a point class to hold the creature’s location.</p>
<p>First, let’s design the point class. Our creature is going to live in a 2d world, so our point class will have 2 dimensions, X and Y. We will assume the world is made up of discrete squares, so these dimensions will always be integers.</p>
<p>Point2D.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT2D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT2D_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// A default constructor</span></span><br><span class="line">    Point2D()</span><br><span class="line">        : m_x(<span class="number">0</span>), m_y(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// A specific constructor</span></span><br><span class="line">    Point2D(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        : m_x(x), m_y(y)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// An overloaded output operator</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access functions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Note that because we’ve implemented all of our functions in the header file (for the sake of keeping the example concise), there is no Point2D.cpp.</p>
<p>This Point2d class is a composition of its parts: location values x and y are part-of Point2D, and their lifespan is tied to that of a given Point2D instance.</p>
<p>Now let’s design our Creature. Our Creature is going to have a few properties: a name, which will be a string, and a location, which will be our Point2D class.</p>
<p>Creature.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CREATURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATURE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point2D.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    Point2D m_location;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Creature(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Point2D &amp;location)</span><br><span class="line">        : m_name(name), m_location(location)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Creature &amp;creature)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; creature.m_name &lt;&lt; <span class="string">" is at "</span> &lt;&lt; creature.m_location;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_location.setPoint(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p><mark>注意这里可以这么改写Code</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="title">printToStream</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  out &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">printToStream(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">point</span>);</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>[Variants on the composition theme]</strong></p>
<p>Although most compositions directly create their parts when the composition is created and directly destroy their parts when the composition is destroyed, there are some variations of composition that bend these rules a bit.</p>
<p>For example:</p>
<ol>
<li>A composition may defer creation of some parts until they are needed. For example, a string class may not create a dynamic array of characters until the user assigns the string some data to hold.</li>
<li>A composition may opt to use a part that has been given to it as input rather than create the part itself.</li>
<li>A composition may delegate destruction of its parts to some other object (e.g. to a garbage collection routine).</li>
</ol>
<p>The key point here is that the composition should manage its parts without the user of the composition needing to manage anything.</p>
<p><strong>[Composition and subclasses]</strong></p>
<p>One question that new programmers often ask when it comes to object composition is, “When should I use a subclass instead of direct implementation of a feature?”. For example, instead of using the Point2D class to implement the Creature’s location, we could have instead just added 2 integers to the Creature class and written code in the Creature class to handle the positioning. However, making Point2D its own class has a number of benefits:</p>
<ol>
<li>Each individual class can be kept relatively simple and straightforward, focused on performing one task well. This makes those classes easier to write and much easier to understand, as they are more focused. For example, Point2D only worries about point-related stuff, which helps keep it simple. <mark>可以找人去负责 Point2D class, 另外的人去负责 Creature class.</mark></li>
<li>Each subclass can be self-contained, which makes them reusable. For example, we could reuse our Point2D class in a completely different application. Or if our creature ever needed another point (for example, a destination it was trying to get to), we can simply add another Point2D member variable.</li>
<li>The parent class can have the subclasses do most of the hard work, and instead focus on coordinating the data flow between the subclasses. This helps lower the overall complexity of the parent object, because it can delegate tasks to its children, who already know how to do those tasks. For example, when we move our Creature, it delegates that task to the Point class, which already understands how to set a point. Thus, the Creature class does not have to worry about how such things would be implemented.</li>
</ol>
<p>A good rule of thumb is that each class should be built to accomplish a single task. That task should either be the storage and manipulation of some kind of data (e.g. Point2D, std::string), OR the coordination of subclasses (e.g. Creature). Ideally not both.</p>
<p>In this case of our example, it makes sense that Creature shouldn’t have to worry about how Points are implemented, or how the name is being stored. Creature’s job isn’t to know those intimate details. Creature’s job is to worry about how to coordinate the data flow and ensure that each of the subclasses knows what it is supposed to do. It’s up to the individual subclasses to worry about how they will do it.</p>
<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p><strong>[满足条件]</strong></p>
<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can belong to more than one object (class) at a time</li>
<li>The part (member) does not have its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
<p><strong>[与 composition 异同]</strong></p>
<ol>
<li>共同点<ol>
<li>都是 part-whole 关系</li>
</ol>
</li>
<li>不同点<ol>
<li>parts 可以同时属于多个 object</li>
<li>object 不负责创建和摧毁 parts</li>
</ol>
</li>
</ol>
<p><strong>[具体例子]</strong></p>
<ol>
<li>每个人都有个家庭住址，但是家庭住址可以属于多个人。</li>
<li>人住进来之前家庭地址就存在了</li>
<li>人搬走后家庭地址依然存在</li>
<li>人知道他住在哪里，而一个家庭地址不知道住的是谁(假定是这样子的)</li>
</ol>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>Because aggregations are similar to compositions in that they are both part-whole relationships, they are implemented almost identically, and the difference between them is mostly semantic. In a composition, we typically add our parts to the composition using normal member variables (or pointers where the allocation and deallocation process is handled by the composition class).</p>
<p>In an aggregation, we also add parts as member variables. However, these member variables are typically either references or pointers that are used to point at objects that have been created outside the scope of the class. Consequently, an aggregation usually either takes the objects it is going to point to as constructor parameters, or it begins empty and the subobjects are added later via access functions or operators.</p>
<p>Because these parts exist outside of the scope of the class, when the class is destroyed, the pointer or reference member variable will be destroyed (but not deleted). Consequently, the parts themselves will still exist.</p>
<p>Let’s take a look at a Teacher and Department example in more detail. In this example, we’re going to make a couple of simplifications: First, the department will only hold one teacher. Second, the teacher will be unaware of what department they’re part of.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Teacher *m_teacher; <span class="comment">// This dept holds only one teacher for simplicity, but it could hold many teachers</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Department(Teacher *teacher = <span class="literal">nullptr</span>)</span><br><span class="line">        : m_teacher(teacher)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a teacher outside the scope of the Department</span></span><br><span class="line">    Teacher *teacher = <span class="keyword">new</span> Teacher(<span class="string">"Bob"</span>); <span class="comment">// create a teacher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a department and use the constructor parameter to pass</span></span><br><span class="line">        <span class="comment">// the teacher to it.</span></span><br><span class="line">        <span class="function">Department <span class="title">dept</span><span class="params">(teacher)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// dept goes out of scope here and is destroyed</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Teacher still exists here because dept did not delete m_teacher</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; teacher-&gt;getName() &lt;&lt; <span class="string">" still exists!"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> teacher;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里假定了 teacher 不知道工作的 department.</p>
<h4 id="总结-composition-和-aggregation"><a href="#总结-composition-和-aggregation" class="headerlink" title="总结 composition 和 aggregation"></a>总结 composition 和 aggregation</h4><ol>
<li>compositions<ol>
<li>Typically use normal member variables</li>
<li>Can use pointer members if the class handles object allocation/deallocation itself</li>
<li>Responsible for creation/destruction of parts</li>
</ol>
</li>
<li>Agreegations<ol>
<li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregate class</li>
<li>Not responsible for creating/destroying parts</li>
</ol>
</li>
</ol>
<p>It is worth noting that the concepts of composition and aggregation are not mutually exclusive, and can be mixed freely within the same class. It is entirely possible to write a class that is responsible for the creation/destruction of some parts but not others. For example, our Department class could have a name and a Teacher. The name would probably be added to the Department by composition, and would be created and destroyed with the Department. On the other hand, the Teacher would be added to the department by aggregation, and created/destroyed independently.</p>
<p>While aggregations can be extremely useful, they are also potentially more dangerous. Because aggregations do not handle deallocation of their parts, that is left up to an external party to do so. If the external party no longer has a pointer or reference to the abandoned parts, or if it simply forgets to do the cleanup (assuming the class will handle that), then memory will be leaked.</p>
<p>For this reason, compositions should be favored over aggregations.</p>
<h3 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h3><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h3 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation 委托"></a>Delegation 委托</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-relation-delegation.png" alt=""></p>
<p>图的注解：</p>
<ol>
<li>“pimpl”: pointer to implementation</li>
<li>这个概念跟 composition 其实只有一点微妙的区别，一个含有 object, 一个含有指针。</li>
<li>图中左下角介绍的东西有点类似 shared ptr 啊，三个指针指向同一个东西。如果有一个要改动东西，那么会发生 “copy on write”，即拷贝一个出来让它修改。</li>
</ol>
<h2 id="class-有关"><a href="#class-有关" class="headerlink" title="class 有关"></a>class 有关</h2><h3 id="概念题"><a href="#概念题" class="headerlink" title="概念题"></a>概念题</h3><p>[Differnce with struct]</p>
<ol>
<li>The only difference between “class” and “struct” is whether the beginning content in the class body (before first appearance of “private”/“public” keyword) is public or private. For class, that part is private. For struct, that part is public.</li>
</ol>
<p>[Method 定义的位置]</p>
<ol>
<li>定义在 class body 中的话，是要求这些 function become inline, thus avoid function call overhead.</li>
<li>定义在 class body 外的话，就会有 function call.</li>
</ol>
<p>[Compiler generated functions]</p>
<ol>
<li>Compilter silently write 4 functions if they are not explicitly declared:<ol>
<li>Copy constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Default Constructor (Only if there is no constructor declared)<ol>
<li>If there exists copy constructor, then compiler will not generate default constructor.</li>
<li>However, if there exists some constructor (not copy constructor), compiler will generate copy constructor if needed.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="不同关系下的构造与析构函数"><a href="#不同关系下的构造与析构函数" class="headerlink" title="不同关系下的构造与析构函数"></a>不同关系下的构造与析构函数</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-composition.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance-and-composition.png" alt=""></p>
<h3 id="虚指针和虚函数表"><a href="#虚指针和虚函数表" class="headerlink" title="虚指针和虚函数表"></a>虚指针和虚函数表</h3><p>多态背后的技术叫做动态绑定！底层的实现是使用虚函数表。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了实现C++的多态<mark>（关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>）</mark>，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h4 id="类的虚表"><a href="#类的虚表" class="headerlink" title="类的虚表"></a>类的虚表</h4><p>每个包含了虚函数的类都包含一个虚表。</p>
<p>我们知道，当一个类 A 继承另一个类 B 时，类 A 会继承类 B 的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可以调用这些虚函数。<br>换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>简单的例子，看一下下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，类 <code>A</code> 有虚函数，因此它有一个虚表。</p>
<p>类 <code>A</code> 的虚表如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png" alt=""></p>
<p><mark>虚表是一个指针数组，其元素是虚函数的指针。每个元素对应一个虚函数的函数指针。<br>需要指出的是，普通的函数，即非虚函数，其调用并不需要经过虚表。<br>因此虚表的元素并不包括普通函数的函数指针。</mark></p>
<h4 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h4><p><mark>虚表是属于类的，而不是属于某个具体的对象！一个类只需要一个虚表即可！同一个类的所有对象都使用同一个虚表。</mark></p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，<mark>编译器在类中添加了一个指针，<code>*__vptr</code>, 用来指向虚表。</mark><br>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png" alt=""></p>
<p>再重复一遍！一个继承类的基类如果包含虚函数，那么这个继承类也有自己的虚表，这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>下面讲一下 C++ 是如何利用虚表和虚表指针实现动态绑定的。先看一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 A 是基类，类 B 继承类 A，类 C 又继承类 B。<br>它们三个的对象模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png" alt=""></p>
<p>[关于上图的几点说明]</p>
<ol>
<li>由于<mark>这三个类都有虚函数，故编译器为每个类都创建了一个虚表</mark>，即类 A 有虚表 vtbl_A, 类 B 有虚表 vtbl_B, 类 C 有虚表 vtbl_C. 类A, B, C 的<code>对象</code>都拥有一个虚表指针， <code>*__vptr</code>, 用来指向自己所属类的虚表。</li>
<li>图中最左边一列给出了三个类的各自的一个对象。其中 B 类对象 b 中黑框圈中的部分是基类的内容。C 类对象 c 里面黑框圈中的部分是基类 B 的内容。</li>
<li>类 A 包括两个虚函数，故 vtbl_A 包含两个指针，分别指向 A::vfunc1() 和 A::vfunc2().</li>
<li>类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 vtbl_B 的两个指针分别指向 B::vfunc1() 和 A::vfunc2().</li>
<li>类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故 vtbl_C 的两个指针分别指向 B::vfunc1() (指向继承的最近的一个类的函数) 和 C::vfunc2().</li>
<li>因此一共有四个非虚函数，以及四个虚函数。</li>
<li>图三看起来有点复杂，但是核心还是：<mark>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</mark>。抓住这个核心思想，就可以快速将这几个类的对象模型在脑中想象出来！</li>
<li>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</li>
</ol>
<p>假设我们定义一个类 B 的对象如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>这里要注意了，虽然 <code>p</code> 是基类的指针，只能指向基类的部分，但是虚表指针也属于基类的部分，亦即 <code>b</code> 实例内存中的虚表指针也属于基类部分。所以 <code>p</code> 可以访问到对象 <code>bObject</code> 的虚表指针. <code>bObject</code> 的虚表指针指向类 <code>B</code> 的虚表，所以 <code>p</code> 可以访问到 <code>vtbl_B</code>. </mark></p>
<p>当我们使用 <code>p</code> 来调用 <code>vfunc1()</code> 函数时候，会发横什么现象?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在执行 <code>p-&gt;vfunc1()</code> 时会发现 <code>p</code> 是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤：</p>
<ol>
<li>首先，根据虚表指针 <code>p-&gt;__vptr</code> 来访问对象 <code>bObject</code> 对应的虚表。虽然指针 <code>p</code> 是基类 <code>A*</code> 类型，但是 <code>*__vptr</code> 也是基类的一部分，所以可以通过 <code>p-&gt;__vptr</code> 访问到对象对应的虚表。</li>
<li>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 <code>p-&gt;vfunc1()</code> 的调用，<code>vtbl_B</code> 的第一项即是 <code>vfunc1</code> 对应的条目。</li>
<li>最后，根据虚表中找到的函数指针，调用函数。从上图可以看出，<code>vtbl_B</code> 的第一项指向 <code>B::vfunc1()</code>，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>B::vfunc1()</code> 函数。</li>
</ol>
<p>而如果 <code>p</code> 指向类 <code>A</code> 的对象，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; aObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>aObject</code> 在创建时，它的虚表指针 <code>__vptr</code> 已设置为指向 <code>vtbl_A</code>，这样 <code>p-&gt;__vptr</code> 就指向 <code>vtbl_A</code>. <code>vfunc1</code> 在 <code>vtbl_A</code> 对应的条目指向了 <code>A::vfunc1()</code> 函数，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>A::vfunc1()</code> 函数。</p>
<p><mark>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。</mark></p>
<p>[动态绑定]</p>
<ol>
<li>先明确<code>静态绑定</code>。编译器对静态绑定的处理是会生成一个 <code>call some_address</code> 的汇编命令。这个 <code>some_address</code> 是固定了的。</li>
<li>而我们把<mark>经过虚表调用虚函数的过程称为动态绑定</mark>，其表现出来的现象称为<mark>运行时多态</mark>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</li>
</ol>
<p>那么，<mark>什么时候会执行函数的动态绑定？</mark>这需要符合以下三个条件。</p>
<ol>
<li>通过指针来调用函数</li>
<li>指针 upcast 向上转型（继承类向基类的转换称为 upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h4 id="基类指针调用子类非虚函数"><a href="#基类指针调用子类非虚函数" class="headerlink" title="基类指针调用子类非虚函数"></a>基类指针调用子类非虚函数</h4><p>使用基类的指针可以去调用子类的非虚函数吗？<br>回忆一下好像没有这么用过，一直都是拿基类指针调用了子类的虚函数。</p>
<p>事实上这个是可以的。但是要注意，<mark>此时被调用的函数实际上是基类的函数！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123;x=i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class show():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class virtual display():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> i,<span class="keyword">int</span> j):A(i) &#123; y=j;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class show(): y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="comment">//前面有无virtual都可以</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class virtual display():y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a(5),*pa;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    pa=&amp;b;</span><br><span class="line">    pa-&gt;show();</span><br><span class="line">    pa-&gt;<span class="built_in">display</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<ol>
<li>这个例子里面类 B 继承了类 A，而类 A 和类 B 都有一个 show() 函数。</li>
<li>类B的实例 <code>b</code> 里面含有基类部分，也含有自己的部分。注意了！<mark>基类部分里面含有一个虚表指针，也含有一个 A::show()；而子类的部分呢含有 B::show()。</li>
<li><code>pa</code> 是基类的指针，因此指向的是子类实例<code>b</code>中的基类部分那一块！所以调用的 <code>pa-&gt;show()</code> 是基类的 <code>A::show()</code>。</li>
<li>而 <code>pa-&gt;display()</code> 则通过基类部分的虚表指针指向了子类 <code>B</code> 的虚函数表，然后调用到了 <code>B::display()</code>。</li>
</ol>
<p>最终的输出是</p>
<pre><code>A class show():x=10
B class virtual display():y=20</code></pre><p>[总结]<br>基类的指针指向派生类的对象，当调用同名的成员函数时：</p>
<ol>
<li>如果在基类中成员函数为<font color='red'>虚函数</font>，那么基类指针调用的就是<font color='red'>派生类</font>的同名函数。<code>virtual void display()</code>;<ol>
<li>可以这么理解：因为该函数是虚的，所以会找真正实现的那个函数，所以调用派生类B中的 B class virtual display.</li>
</ol>
</li>
<li>如果基类中成员函数为<font color='red'>非虚函数</font>，则调用的是<font color='red'>基类</font>的成员函数。<code>void show()</code>;<ol>
<li>因为基类是非虚的，已经完全实现了，所以没有必要再调用派生类的了，就调用基类的A class show()</li>
</ol>
</li>
</ol>
<h4 id="底层解释-汇编语言"><a href="#底层解释-汇编语言" class="headerlink" title="底层解释-汇编语言"></a>底层解释-汇编语言</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-2.png" alt=""></p>
<h4 id="用-C-能实现吗"><a href="#用-C-能实现吗" class="headerlink" title="用 C 能实现吗?"></a>用 C 能实现吗?</h4><p>如果我们不使用这一套体系，用 C 一般怎么实现用一个指针的列表去访问各个子类的函数呢？</p>
<p>通常情况下我们必须针对每个指针，通过一系列的 if else 语句先去判断是哪一类对象的函数，然后再去调用相应的函数。</p>
<p>但是这样子不好的是，如果后来又新加了一个类别，那么我们就必须去重新改动 if else 那一部分的代码，多添加一个 else 语句去支持新增加的类别。</p>
<h4 id="虚函数另一用法-template-method"><a href="#虚函数另一用法-template-method" class="headerlink" title="虚函数另一用法: template method"></a>虚函数另一用法: template method</h4><p>这里的 template method 是一种设计模式，具体可以参考<a href="https://zheng-xing.github.io/2020/01/15/design-pattern/#Template-Method" target="_blank" rel="noopener">here</a>.</p>
<h3 id="构造函数可以是虚函数吗？"><a href="#构造函数可以是虚函数吗？" class="headerlink" title="构造函数可以是虚函数吗？"></a>构造函数可以是虚函数吗？</h3><h4 id="C-不可以"><a href="#C-不可以" class="headerlink" title="C++ 不可以"></a>C++ 不可以</h4><p>简答回答是不可以！C++ 的作者在他<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener">个人主页</a>已经回答了，原样复制过来</p>
<p>A virtual call is a mechanism to get work done given partial information. In particular, “virtual” allows us to call a function knowing only an interfaces and not the exact type of the object. <mark>To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a “call to a constructor” cannot be virtual.</mark></p>
<p>意思就是，虚拟函数调用只需要知道部分信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。<br>如果你调用一个虚拟构造函数，编译器怎么知道你想构建继承树上的哪种类型呢？所以这在逻辑上是一个悖论。</p>
<p>Techniques for using an indirection when you ask to create an object are often referred to as “Virtual constructors”. For example, see TC++PL3 15.6.2.</p>
<p>For example, here is a technique for generating an object of an appropriate type using an abstract class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span>  <span class="comment">// interface to object creation functions</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user</span><span class="params">(<span class="keyword">const</span> F&amp; fac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* p = fac.make_an_A(); <span class="comment">// make an A of the appropriate type</span></span><br><span class="line">    B* q = fac.make_a_B();  <span class="comment">// make a B of the appropriate type</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FX</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AX(); &#125; <span class="comment">// AX is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BX();  &#125; <span class="comment">// BX is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FY</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AY(); &#125; <span class="comment">// AY is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BY();  &#125; <span class="comment">// BY is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FX x;</span><br><span class="line">    FY y;</span><br><span class="line">    user(x);    <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(y);    <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line"></span><br><span class="line">    user(FX()); <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(FY()); <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a variant of what is often called “the factory pattern”. The point is that user() is completely isolated from knowledge of classes such as AX and AY.</p>
<h4 id="Delphi-却支持"><a href="#Delphi-却支持" class="headerlink" title="Delphi 却支持"></a>Delphi 却支持</h4><p>那么Delphi为什么能够支持虚拟构造函数呢？Delphi有一种类类型，储存着某个类的meta data。<br>TClass是所有自定义类类型（不是自定义类型）的祖先类。构建一个新对象的时候，事实上是调用TClass的某个子类（即自定义类类型）的虚拟Create方法，而这个子类储存了相关类的meta<br>data，因此避免了“虚拟构造函数不知道具体类型信息”的问题。这可以视为factory<br>pattern的一种通用实现，在语言级别非常优雅和完美地解决了这个问题。</p>
<p>资料来自<a href="https://www.zhihu.com/question/35632207/answer/63936329" target="_blank" rel="noopener">这里</a></p>
<h1 id="fundamental-concept-基本概念"><a href="#fundamental-concept-基本概念" class="headerlink" title="fundamental concept 基本概念"></a>fundamental concept 基本概念</h1><h2 id="heap-or-stack-memory"><a href="#heap-or-stack-memory" class="headerlink" title="heap or stack memory"></a>heap or stack memory</h2><p><mark>C语言里面不能把一个很长的 array 放到 stack 上。</mark></p>
<p>使用 C 语法时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一个语句会出现 stack overflow 错误</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式一</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="built_in">malloc</span>(<span class="number">1000000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式二</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式三</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">1000000</span>];  <span class="comment">// allocated in data segment</span></span><br></pre></td></tr></table></figure>

<p>使用 C++ STL 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// will allocate the vector, i.e. the header info, on the stack, but the elements on the free store "heap".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * vect = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// allocates everything on the free store.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>*&gt; vect;</span><br><span class="line"><span class="comment">// will allocate the vector on the stack and a bunch of pointers on the free store</span></span><br><span class="line"><span class="comment">// But where these pointer is determined by how you use them</span></span><br><span class="line"><span class="comment">// You could point element 0 to the free store and element 1 to the stack.</span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-and-std-nullptr-t-C-11"><a href="#nullptr-and-std-nullptr-t-C-11" class="headerlink" title="nullptr and std::nullptr_t (C++11)"></a>nullptr and std::nullptr_t (C++11)</h2><ol>
<li>C++11 允许使用 nullptr 来代替 0 或者 NULL，to specify that a pointer refers to no value (which differs from having an undefined value). This new feature especially helps to avoid mistakes that occurred when a null pointer was interpreted as an integral value. </li>
</ol>
<p>举例来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有如下两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方式会调用到哪个函数呢？</span></span><br><span class="line">f(<span class="number">0</span>);          <span class="comment">// calls f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>);       <span class="comment">// calls f(int) if NULL is 0, ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>);    <span class="comment">// calls f(void*)</span></span><br></pre></td></tr></table></figure>

<ol>
<li><font color='red'>nullptr</font> is a new keyword. It automatically converts into each pointer type but not to any integral type. It has type <font color='red'>std::nullptr_t</font>, defined in <code>&lt;</code><font color='red'>cstddef</font><code>&gt;</code>, so you can now even overload operations for the case that a null pointer is passed. Note that <font color='red'>std::nullptr_t</font> counts as a fundamental data type.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/stddef.h 文件包含有如下语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure>


<h2 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h2><p>Most of the times compilers will do optimization to the code to speed up the program. For example in the below code,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>( a == <span class="number">10</span>)&#123;</span><br><span class="line">     <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compiler may think that value of ‘a’ is not getting changed from the program and replace it with ‘while(true)’, which will result in an infinite loop. In actual scenario the value of ‘a’ may be getting updated from outside of the program.<br>Volatile keyword is used to tell compiler that the variable declared using volatile may be used from outside the current scope so that compiler wont apply any optimization. This matters only in case of multi-threaded applications.<br>In the above example if variable ‘a’ was declared using volatile, compiler will not optimize it. In shot, value of the volatile variables will be read from the memory location directly.</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>此处参考了《Effective C++》.</p>
<h3 id="什么是-const"><a href="#什么是-const" class="headerlink" title="什么是 const"></a>什么是 const</h3><p><code>const</code> objects 就是这个 object 不能被改变，<mark>编译器在编译的时候会检查程序有没有试图去修改 object 的内容</mark>。</p>
<p>如果你声明某个 variable 是 const，在声明的那个语句中你就必须给它初始化！因为后面你就没有机会再修改了！编译器会发现你试图对 <code>const</code> object 修改，就编译错误！</p>
<h3 id="几种用途"><a href="#几种用途" class="headerlink" title="几种用途"></a>几种用途</h3><p><code>const</code> 可以用在如下几个地方:</p>
<ol>
<li>Outside of classes, we can use it for constants at global or namespace scope.</li>
<li>For objects declared <code>static</code> at file, function, or block scope.</li>
<li>Inside classes, can be used for both static and non-static data members.</li>
</ol>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, non-const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// constant pointer, non-constant data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子就需要记住一点: <mark> 如果 <code>const</code> 出现在 <code>*</code> 的左边，那么数据是 <code>const</code> 的；如果 <code>const</code> 在 <code>*</code> 的右边，那么指针是 <code>const</code> 的。</mark></p>
<font color='red'>
    易混淆！当数据是 `const` 时候，`type` 和 `const` 这两个先后顺序可以改变的。谁在前面都一样。
</font>

<p>看这个例子，两种表示方式没有区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Widget <span class="keyword">const</span> *pw)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const iterator"></a>const iterator</h3><p><mark>注意 STL iterator 有专门的 <code>const_iterator</code> 语法，表示这个迭代器不会修改 container 里面的数据内容。直接在普通 iterator 的前面加上 <code>const</code> 的意思是另外一种，表示这个迭代器本身是 constant 的。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// iter acts like a T* const, 即指针是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 操作可以执行。因为数据不是 const</span></span><br><span class="line">++iter;                                            <span class="comment">// 报错！iter 是 const 类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">// cIter acts like a const T*, 即数据是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 报错！*cIter is const</span></span><br><span class="line">++iter;                                            <span class="comment">// 没毛病! 改变指针</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><mark>If the container itself is const, you can only use const iterator to access its elements.</mark></li>
<li>==begin()== returns const_iterator if the container is const, and returns non-const iterator if the container is not const. (But you can always use ==auto==)</li>
<li>cbegin(), cend() returns const_iterator.</li>
</ol>
<h3 id="类成员函数的-const"><a href="#类成员函数的-const" class="headerlink" title="类成员函数的 const"></a>类成员函数的 const</h3><p><mark>某些类里面的函数要不要加 const 并不是无所谓的！！！</mark>见这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class complex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    complex(double r &#x3D; 0, double i &#x3D; 0) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    complex&amp; operator +&#x3D; (const complex&amp;);</span><br><span class="line">    double real() const &#123;return m_r;&#125;</span><br><span class="line">    double imag() const &#123;return m_i;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_r, m_i;</span><br><span class="line">    friend complex&amp; __doapl (complex*, const complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    const complex c1(2, 1);</span><br><span class="line">    cout &lt;&lt; c1.real();</span><br><span class="line">    cout &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>因为这里 complex c1 被声明成了 const 类型，那么作用在这个 object 身上的所有函数也都必须声明成 const 类型，不管这个函数本身是否有修改 c1 内容！！！所以 real() 的定义必须加上 const, 这个例子里面是加了的。如果没加的话就会有错。</mark></p>
<p><font color='red'>这个例子告诉我们，在设计成员函数的时候，可以加 <code>const</code> 的时候一定要加上，以避免其他使用者犯错。他们会觉得这是类设计者的错误！</font></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-const-intro.png" alt="const"></p>
<h3 id="不加const为啥不行"><a href="#不加const为啥不行" class="headerlink" title="不加const为啥不行"></a>不加const为啥不行</h3><ol>
<li>上面也提到了，一旦某些时候你把一个 object 声明成了 const，那么这个 object 只能调用那些 const 成员函数。<ol>
<li>至于什么时候会把一个 <code>object</code> 声明成 <code>const</code>。比如函数调用时候，pass by reference to const.</li>
</ol>
</li>
</ol>
<p>第二个例子，重载乘法运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rational a, b, c;</span><br><span class="line">    <span class="keyword">if</span>(a * b = c)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子里面，由于程序员不小心把<code>==</code> 写成了 <code>=</code>。这个时候如果你按照上面把乘法运算符重载后，返回的是 <code>const</code> 类型，那么编译器在这里就会提醒你不能给 <code>a*b</code> 的结果赋值，方便你检查出这个 typo 了。</p>
<p>而如果你没有把返回值定义成 <code>const</code> 类型，就会</p>
<h3 id="physical-vs-logical-constness"><a href="#physical-vs-logical-constness" class="headerlink" title="physical vs logical constness"></a>physical vs logical constness</h3><p>编译器只会检查 physical constness 或者叫做 bitwise constness. 即检查是否对一个 const object 的直接内容作了修改。<br>如果没有，就可以编译通过。</p>
<p><mark>但是！如果类对象里含有指针，那么对指针指向的空间的内容进行修改，编译器是不会报错的！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pString[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 operator[] 的定义里面并没有修改内容啊，所以编译器不报错。</span></span><br><span class="line"><span class="comment">// 但是</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> MyString <span class="title">str</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;str[<span class="number">0</span>];</span><br><span class="line">    *pc = <span class="string">"J"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数里面事实上修改了 str 的内容，这与 str 是一个 const object 矛盾了！！！</span></span><br><span class="line"><span class="comment">// 可惜编译器发现不了这个问题！！！</span></span><br></pre></td></tr></table></figure>

<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>有时候你希望 const object 的意思是对 object 的某些数据内容不能修改，但是 object 可能也含有一些辅助数据，你希望 const 不作用在它们上面，那怎么办呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> strLength;        <span class="comment">// these data members may always be modified,</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;      <span class="comment">// even in const member functions</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">MyString::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;     <span class="comment">// 如果没有上面的 mutable 关键字，那么这个函数是 const 类型</span></span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;              <span class="comment">// 不可以对变量 strLength, lengthIsValid 进行修改！</span></span><br><span class="line">        strLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pString);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h2><ol>
<li>相同 class 的各个 objects 互为 friends（友元）。</li>
</ol>
<h2 id="三种-function-parameters"><a href="#三种-function-parameters" class="headerlink" title="三种 function parameters"></a>三种 function parameters</h2><ol>
<li>someFunction(vector<double> vec)</li>
<li>someFunction(const vector<double>&amp; vec)</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Local variables that are declared to be static </span></span><br><span class="line"><span class="comment">are preserved across invocations of the function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thus, we'll construct and initialize the string name</span></span><br><span class="line"><span class="comment">only on the first call to someFunction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">someFunction</span><span class="params">(balabala)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> name = <span class="string">"Zheng Xing"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-static-intro.png" alt=""></p>
<p>注意点：</p>
<ol>
<li>non-static data members 存在于每个 instances object 里面；而 static data members, member functions, static member functions 是 class 拥有的，所有的 instances 共享！</li>
<li>什么时候使用 static data members<ol>
<li>当你这一个 class 的所有 objects 都拥有并且一样的那些数据</li>
</ol>
</li>
<li>什么时候用 static member functions<ol>
<li><mark> static member function 与正常的 member functions 的区别在于静态的函数没有 this 指针，因此也就无法访问非静态的数据，它只能够处理 static data members.</li>
</ol>
</li>
<li>调用 static member functions的两种方法<ol>
<li>通过 class name 调用</li>
<li>通过 object 调用</li>
<li>参考下面的代码</li>
</ol>
</li>
<li>一个概念<ol>
<li>Static objects inside functions are known as local static objects (because they’re local to a function).</li>
<li>The other kinds of static objects are known as non-local static objects.</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Account::set_rate(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    Account a;</span><br><span class="line">    a.set_rate(<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个经典的应用是设计 Singleton 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">setup</span>() &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A();</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A::getInstance().setup();</span></span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li>reference data must be assigned at initialization</li>
<li>reference data cannot be reassigned</li>
</ol>
<p>注意两个概念</p>
<ol>
<li>return by value vs return by reference (to const)</li>
<li>pass by value vs pass by reference</li>
</ol>
<p>reference 有指针的速度，同时使用的时候很方便，在传递的时候不需要知道类型到底是 value 还是 reference。</p>
<p><mark> 函数是否返回 reference 要看你是不是在函数里面搞了一个临时变量，是的话，千万不能返回 reference.</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; a, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.real() + b.real(), a.imag() + b.imag());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>same signature</mark><br>下面两个函数不能同时存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span> </span>&#123;&#125;    <span class="comment">// Ambiguity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多提一句，可以通过添加 const 来区别两个函数。</span></span><br><span class="line"><span class="comment">// 比如下面两个函数是不同的，编译器不会报错。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="and-初始化方法"><a href="#and-初始化方法" class="headerlink" title="() and = 初始化方法"></a>() and = 初始化方法</h2><ol>
<li>container<T> c(c2)<ol>
<li>defines c as a container that is a copy of c2</li>
</ol>
</li>
<li>container<T> c = c2<ol>
<li>same</li>
</ol>
</li>
</ol>
<h2 id="default-value-initialization"><a href="#default-value-initialization" class="headerlink" title="default/value initialization"></a>default/value initialization</h2><ol>
<li>local variables of built-in type that are not explicitly initialized are undefined.</li>
<li>class type says what initializer to use if there is not one specified.</li>
<li>(Accerated C++, P125) When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is ==value-initialized==, which, for simple types such as int, is equivalent to setting the value to zero.</li>
</ol>
<h2 id="overloading-1"><a href="#overloading-1" class="headerlink" title="overloading"></a>overloading</h2><p>Several functions with the same name.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r, m_i;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doapl (<span class="built_in">complex</span>*, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; __doapl(<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;        <span class="comment">// 返回指针所指向的东西！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; complext::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>, r);    <span class="comment">// 任何一个成员函数都有一个隐藏的 this 指针！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"("</span> &lt;&lt; real(x) &lt;&lt; <span class="string">","</span> &lt;&lt; imag(x) &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.real();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里操作符 &lt;&lt; 的结果可以返回 ostream reference.</p>
<p><mark>注意，操作符 += 的重载的返回值不能是 void 类型哦！你要考虑到有人可能会连续加的情况！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 += c2 += c1;</span><br></pre></td></tr></table></figure>

<h3 id="重载-lt-lt-符号"><a href="#重载-lt-lt-符号" class="headerlink" title="重载 &lt;&lt; 符号"></a>重载 &lt;&lt; 符号</h3><p>此处的东西来自<a href="https://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">这里</a>.</p>
<p>最简单的思想：若想去打印 object 内容，我们可以定义一些 public 方法去获得私有变量内容，然后输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现支持我们这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; <span class="built_in">point</span>.getX() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getY() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getZ() &lt;&lt; <span class="string">")"</span>;</span><br></pre></td></tr></table></figure>

<p>进阶思路一：能不能定一个函数来重复使用呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">", "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>注意 print 虽然写到了 class 定义里面，但是它不是 member function。</mark></p>
<p>上面的思路确实比最初的思路好了，但是它的缺点在于我们不能在 cout 的中间使用，必须得这么用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span>;                <span class="comment">// 这里要分成三个命令来写，不能串起来了。。。</span></span><br><span class="line">    point.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶思路二：能不能这样子写？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span> &lt;&lt; <span class="built_in">point</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br></pre></td></tr></table></figure>

<p>答案是可以的，就是去重载 &lt;&lt; 操作符。</p>
<p><mark>[几个注意点]</mark></p>
<ol>
<li><font color="red">重载函数的定义最开始要注明 friend 关键字，因为这个函数要获得私有变量信息！</font></li>
<li><font color="red">这个重载函数不能定义成 member function, 即不能加上 “String::operator&lt;&lt;”, 因为 member function 自动得把当前 object 作为第一个参数传递给函数。<ol>
<li>这样子首先顺序就不对了，因为我们希望 cout 作为第一个参数，</li>
<li>其次呢，我们如果放两个参数进去 cout 和 Point&amp; ，但是调用这个函数的 object 本身也会传递一个 this，这样子就变成三个参数了。 </font></li>
</ol>
</li>
<li><font color="red">注意返回的类型是 reference 类型，不能是 void，否则无法使用多个操作符串起来用！！！也不能返回 value 类型，因为 cout 本身也不允许 being copied.</font></li>
<li><font color="red"></font></li>
</ol>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载 ="></a>重载 =</h3><p>以上面的 complex 类来考虑，如果要支持 c3 = c1 + c2 的操作，需要如何重载 = 操作符？</p>
<p><mark>因为 c1 + c2 会返回 temporary object, 所以我们不能传递一个 reference, 如果要使用 reference, 需要传递一个 const reference.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个实现是错误的！！！</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(other.real(), other.imag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误原因</span></span><br><span class="line"><span class="comment">// 1. 函数里面新建了一个 temporary object，它是没法返回给 complex&amp; 类型的</span></span><br><span class="line"><span class="comment">// 2. 这个东西其实是"拷贝赋值函数"，因此它是属于当前 class 的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的实现</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="built_in">complex</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = other.real();</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = other.imag();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><p>就是一个可以被赋值的东西。denote a nontemporary object.</p>
<ol>
<li>variable</li>
<li>reference</li>
<li>the result of calling a function that returns a reference.</li>
</ol>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>==( * iter).name== is the same as ==iter-&gt;name==</p>
<h2 id="initialization"><a href="#initialization" class="headerlink" title="initialization"></a>initialization</h2><h3 id="uniform-initialization-C-11"><a href="#uniform-initialization-C-11" class="headerlink" title="uniform initialization C++11"></a>uniform initialization C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-uniform-initialization.png" alt=""></p>
<h3 id="initializer-list-C-11"><a href="#initializer-list-C-11" class="headerlink" title="initializer list C++11"></a>initializer list C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-9.png" alt=""></p>
<h2 id="三种定义-Comparison-Function-的方法"><a href="#三种定义-Comparison-Function-的方法" class="headerlink" title="三种定义 Comparison Function 的方法"></a>三种定义 Comparison Function 的方法</h2><h3 id="一：Define-operator-lt"><a href="#一：Define-operator-lt" class="headerlink" title="一：Define operator&lt;()"></a>一：Define operator&lt;()</h3><p>在自定义的数据结构里面定义好 &lt; 运算符的意义.</p>
<p>注意：operator&lt;() 参数只有一个！！！并且 operator 是 const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort the edges in decreasing order</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你不喜欢这种语法，只有一个参数，</span></span><br><span class="line"><span class="comment">却比较两个objects，那么你可以用下面的方式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This way it is much clearer that you are </span></span><br><span class="line"><span class="comment">comparing a and b, not *this and other. </span></span><br><span class="line"><span class="comment">Note also that friend function is like static function; </span></span><br><span class="line"><span class="comment">it cannot access member variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二：定义-comparison-function"><a href="#二：定义-comparison-function" class="headerlink" title="二：定义 comparison function"></a>二：定义 comparison function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stringVec.<span class="built_in">begin</span>(), stringVec.<span class="built_in">end</span>(), comp);</span><br></pre></td></tr></table></figure>

<h3 id="三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><a href="#三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object" class="headerlink" title="三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object."></a>三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了上面的定义，你就可以这样用：</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, cmp&gt; myset;  <span class="comment">// cmp 是 type</span></span><br><span class="line"><span class="comment">// 或者这样（cmp 也是 type）</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个错误用法</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="comment">// cmp 是type，sort需要 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法-1</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp());</span><br><span class="line"><span class="comment">// 正确写法-2</span></span><br><span class="line">cmp cmpobject;</span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmpobject);</span><br></pre></td></tr></table></figure>
<p>注意，虽然 set, map 里面只能使用 functor/type</p>
<p>实际上他们也可以用 function 的方法，但是容易用错，</p>
<p>不过这里还是给出来看一下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can use comparison function for STL containers</span></span><br><span class="line"><span class="comment">by passing them as the first argument of the constructor, </span></span><br><span class="line"><span class="comment">and specifying the function type as the additional template argument. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;string, bool (*)(string, string)&gt; myset(comp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lambda function 也是一个 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>; &#125;;</span><br><span class="line">priority_queue&lt;string, vector&lt;int&gt;, decltype(comp)&gt; mypq(comp);</span><br></pre></td></tr></table></figure>

<h3 id="二-vs-三"><a href="#二-vs-三" class="headerlink" title="二 vs 三"></a>二 vs 三</h3><ol>
<li>方法三 compiler 很容易 inline，所以效率高！</li>
</ol>
<h3 id="STL-内置的函数对象"><a href="#STL-内置的函数对象" class="headerlink" title="STL 内置的函数对象"></a>STL 内置的函数对象</h3><p>STL提供的函数对象</p>
<ol>
<li>用于算术运算的函数对象：<ol>
<li>一元函数对象(一个参数) ：negate</li>
<li>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</li>
</ol>
</li>
<li>用于关系运算、逻辑运算的函数对象(要求返回值为bool)<ol>
<li>一元谓词(一个参数)：logical_not</li>
<li>二元谓词(两个参数)：equalto、notequalto、greater、less、greaterequal、lessequal、logicaland、logical_or</li>
</ol>
</li>
</ol>
<h1 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h1><h2 id="泛型设计的基本概念"><a href="#泛型设计的基本概念" class="headerlink" title="泛型设计的基本概念"></a>泛型设计的基本概念</h2><h3 id="目的：为啥需要泛型程序设计"><a href="#目的：为啥需要泛型程序设计" class="headerlink" title="目的：为啥需要泛型程序设计"></a>目的：为啥需要泛型程序设计</h3><ol>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从具体的数据结构中抽象出来，成为通用的</li>
<li>C++ 的模板为泛型程序设计奠定了关键的基础</li>
</ol>
<h3 id="术语一：概念"><a href="#术语一：概念" class="headerlink" title="术语一：概念"></a>术语一：概念</h3><p>概念是指：用来界定具备一定功能的数据类型。例如：</p>
<ol>
<li>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable</li>
<li>将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable</li>
<li>将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable</li>
</ol>
<p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：</p>
<ol>
<li>Sortable既是Comparable的子概念，也是Assignable的子概念</li>
</ol>
<h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><p>模型（model）：符合一个概念的数据类型称为该概念的模型，例如：</p>
<ol>
<li>int型是Comparable概念的模型。</li>
<li>静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）</li>
</ol>
<h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><p>很多STL的实现代码就是使用概念来命名模板参数的。</p>
<p>为概念赋予一个名称，并使用该名称作为模板参数名。例如</p>
<p>表示insertionSort这样一个函数模板的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Sortable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insertionSort</span>(<span class="title">Sortable</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>);</span></span><br></pre></td></tr></table></figure>

<h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><h3 id="STL的基本组件"><a href="#STL的基本组件" class="headerlink" title="STL的基本组件"></a>STL的基本组件</h3><ol>
<li>容器（container）</li>
<li>迭代器（iterator）</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ol>
<h3 id="STL的基本组件间的关系"><a href="#STL的基本组件间的关系" class="headerlink" title="STL的基本组件间的关系"></a>STL的基本组件间的关系</h3><ol>
<li>Iterators（迭代器）是算法和容器的桥梁。</li>
<li>将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。</li>
<li>将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png" alt=""></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>transform算法的一种实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryFunction</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">        *result = op(*first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transform算法顺序遍历first和last两个迭代器所指向的元素；</p>
<p>将每个元素的值作为函数对象op的参数；</p>
<p>将op的返回值通过迭代器result顺序输出；</p>
<p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回.</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是算法和容器的桥梁</p>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ol>
<p>算法和容器独立</p>
<ol>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也能适用</li>
</ol>
<h3 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h3><p>顺序容器包括：</p>
<ol>
<li>向量、双端队列、列表、单向链表、数组</li>
</ol>
<h4 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h4><p>特点</p>
<ol>
<li>一个可以扩展的动态数组</li>
<li>随机访问、在尾部插入或删除元素快</li>
<li>在中间或头部插入或删除元素慢</li>
</ol>
<p>向量的容量</p>
<ol>
<li>容量(capacity)：实际分配空间的大小</li>
<li>s.capacity() ：返回当前容量</li>
<li>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</li>
</ol>
<h4 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h4><p>特点</p>
<ol>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量容器慢</li>
</ol>
<p>例10-5 奇偶排序<br>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    istream_iterator&lt;int&gt; i1(cin), i2;  //建立一对输入流迭代器</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line">    sort(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>)    <span class="comment">//偶数放到s2尾部</span></span><br><span class="line">             s2.push_back(*iter);</span><br><span class="line">         <span class="keyword">else</span>       <span class="comment">//奇数放到s2首部</span></span><br><span class="line">             s2.push_front(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s2的结果输出</span></span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==心得一：输出 vector 到标准输出我一般都是用 for 循环一个一个喂给 cout，这里却用 iterator 和 copy 函数很简洁得做到了（上段代码倒数第三句）==</p>
<p>==心得二：这个方法思路很好啊！！==</p>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p>特点</p>
<ol>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ol>
<p>接合(splice)操作</p>
<ol>
<li>==s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到s1中p所指向元素之前==</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> names1[] = &#123; <span class="string">"Alice"</span>, <span class="string">"Helen"</span>, <span class="string">"Lucy"</span>, <span class="string">"Susan"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> names2[] = &#123; <span class="string">"Bob"</span>, <span class="string">"David"</span>, <span class="string">"Levin"</span>, <span class="string">"Mike"</span> &#125;;</span><br><span class="line">    <span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line">    s2.splice(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line">    advance(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter2 = s2.<span class="built_in">begin</span>();  <span class="comment">//iter2指向s2首</span></span><br><span class="line">    ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line">    advance(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line">    <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line">    s1.splice(iter1, s2, iter2, iter3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别将s1和s2输出</span></span><br><span class="line">    copy(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h4><ol>
<li>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</li>
<li>未定义insert、emplace和erase操作，而定义了insertafter、emplaceafter和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</li>
<li>不支持size操作。</li>
</ol>
<h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><ol>
<li>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</li>
<li>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小。</li>
<li>不能动态地改变容器大小</li>
</ol>
<h4 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h4><p>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容器所需要执行的操作来决定选择哪一种容器。</p>
<ol>
<li>如果需要执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector；</li>
<li>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应当选择双端队列容器deque；</li>
<li>如果不需要对容器进行随机访问，但是需要在中间位置插入或者删除元素，就应当选择列表容器list或forward_list；</li>
<li>如果需要数组，array相对于内置数组类型而言，是一种更安全、更容易使用的数组类型。</li>
</ol>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ol>
<li>容器适配器</li>
<li>函数适配器</li>
<li>迭代器适配器</li>
</ol>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>STL提供了三个==容器适配器==：</p>
<ol>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ol>
<p>这些适配器都是包装了vector、list、deque中某个顺序容器的包装器。<br>stack和queue是容器，但是他们==在本质上是适配器，他们本身并没有实现什么结构和算法，而是把deque拿过来，接口改造一下，实现了自己需要的功能==。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png" alt=""></p>
<p>注意：</p>
<ol>
<li>适配器没有提供迭代器，也不能同时插入或删除多个元素</li>
</ol>
<h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><h4 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cpp/" rel="tag"># cpp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/01/massive-data-analysis/" rel="next" title="massive-data-analysis">
                <i class="fa fa-chevron-left"></i> massive-data-analysis
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/04/python-good-code-examples/" rel="prev" title="python-good-code-examples">
                python-good-code-examples <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象高级编程"><span class="nav-number">1.</span> <span class="nav-text">面向对象高级编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一些基础的点"><span class="nav-number">1.1.</span> <span class="nav-text">一些基础的点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-initialization-list"><span class="nav-number">1.1.1.</span> <span class="nav-text">constructor initialization list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object-数据初始化顺序"><span class="nav-number">1.1.2.</span> <span class="nav-text">object 数据初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#overloading"><span class="nav-number">1.1.3.</span> <span class="nav-text">overloading</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#big-three-三个特殊函数"><span class="nav-number">1.1.4.</span> <span class="nav-text">big three 三个特殊函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default-delete"><span class="nav-number">1.1.5.</span> <span class="nav-text">&#x3D;default, &#x3D;delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-amp-delete"><span class="nav-number">1.1.6.</span> <span class="nav-text">new &amp; delete</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存管理"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载-new-amp-delete"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">重载 ::new &amp; ::delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载-operator-new-amp-operator-delete"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">重载 operator new &amp; operator delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载-new-amp-delete-1"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">重载 new() &amp; delete()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个示例"><span class="nav-number">1.1.6.4.1.</span> <span class="nav-text">一个示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的大小-sizeof"><span class="nav-number">1.1.7.</span> <span class="nav-text">类的大小 sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节对齐"><span class="nav-number">1.1.8.</span> <span class="nav-text">字节对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#template-模板"><span class="nav-number">1.1.9.</span> <span class="nav-text">template 模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-template"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">[class template]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-template"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">[function template]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#member-template"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">member template</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#template-template-parameter"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">template template parameter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variadic-templates-C-11"><span class="nav-number">1.1.10.</span> <span class="nav-text">variadic templates (C++11)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alias-template-template-typedef-C-11"><span class="nav-number">1.1.11.</span> <span class="nav-text">alias template (template typedef) C++11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#specialization-模板特化"><span class="nav-number">1.1.12.</span> <span class="nav-text">specialization 模板特化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-specialization-偏特化"><span class="nav-number">1.1.13.</span> <span class="nav-text">partial specialization 偏特化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#个数上的偏"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">个数上的偏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#范围上"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">范围上</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">1.1.14.</span> <span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Can-constructor-be-private"><span class="nav-number">1.1.15.</span> <span class="nav-text">Can constructor be private?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Friend-Class"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">Using Friend Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singleton-design-pattern"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">Singleton design pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Named-Constructor-Idiom"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">Named Constructor Idiom</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor-Delegation"><span class="nav-number">1.1.16.</span> <span class="nav-text">Constructor Delegation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#conversion-function-转换函数"><span class="nav-number">1.1.17.</span> <span class="nav-text">conversion function 转换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标准库的一个例子"><span class="nav-number">1.1.17.1.</span> <span class="nav-text">标准库的一个例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explicit-关键字"><span class="nav-number">1.1.18.</span> <span class="nav-text">explicit 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#non-explicit-one-argument-ctor"><span class="nav-number">1.1.18.1.</span> <span class="nav-text">non-explicit-one-argument ctor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#conversion-function-vs-non-explicit-one-argument-constructor"><span class="nav-number">1.1.18.2.</span> <span class="nav-text">conversion function vs non-explicit-one-argument constructor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit-one-argument-ctor"><span class="nav-number">1.1.18.3.</span> <span class="nav-text">explicit-one-argument ctor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11-explicit-for-ctors-taking-more-than-one-argument"><span class="nav-number">1.1.18.4.</span> <span class="nav-text">C++11 explicit for ctors taking more than one argument</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range-based-for-C-11"><span class="nav-number">1.1.19.</span> <span class="nav-text">range-based for C++11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pointer-like-classes"><span class="nav-number">1.1.20.</span> <span class="nav-text">pointer-like classes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于智能指针"><span class="nav-number">1.1.20.1.</span> <span class="nav-text">关于智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iterator-迭代器"><span class="nav-number">1.1.20.2.</span> <span class="nav-text">iterator 迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-like-classes-仿函数-functor"><span class="nav-number">1.1.21.</span> <span class="nav-text">function-like classes 仿函数 functor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#base-classes-for-functor"><span class="nav-number">1.1.21.1.</span> <span class="nav-text">base classes for functor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object-relationships-有关"><span class="nav-number">1.2.</span> <span class="nav-text">object relationships 有关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总论"><span class="nav-number">1.2.1.</span> <span class="nav-text">总论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition"><span class="nav-number">1.2.2.</span> <span class="nav-text">Composition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码例子"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">代码例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aggregation"><span class="nav-number">1.2.3.</span> <span class="nav-text">Aggregation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实例"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">代码实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-composition-和-aggregation"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">总结 composition 和 aggregation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Association"><span class="nav-number">1.2.4.</span> <span class="nav-text">Association</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dependencies"><span class="nav-number">1.2.5.</span> <span class="nav-text">Dependencies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delegation-委托"><span class="nav-number">1.2.6.</span> <span class="nav-text">Delegation 委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class-有关"><span class="nav-number">1.3.</span> <span class="nav-text">class 有关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念题"><span class="nav-number">1.3.1.</span> <span class="nav-text">概念题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同关系下的构造与析构函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">不同关系下的构造与析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚指针和虚函数表"><span class="nav-number">1.3.3.</span> <span class="nav-text">虚指针和虚函数表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的虚表"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">类的虚表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚表指针"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">虚表指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态绑定"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基类指针调用子类非虚函数"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">基类指针调用子类非虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#底层解释-汇编语言"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">底层解释-汇编语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用-C-能实现吗"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">用 C 能实现吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数另一用法-template-method"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">虚函数另一用法: template method</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数可以是虚函数吗？"><span class="nav-number">1.3.4.</span> <span class="nav-text">构造函数可以是虚函数吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-不可以"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">C++ 不可以</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Delphi-却支持"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Delphi 却支持</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fundamental-concept-基本概念"><span class="nav-number">2.</span> <span class="nav-text">fundamental concept 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-or-stack-memory"><span class="nav-number">2.1.</span> <span class="nav-text">heap or stack memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nullptr-and-std-nullptr-t-C-11"><span class="nav-number">2.2.</span> <span class="nav-text">nullptr and std::nullptr_t (C++11)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-keyword"><span class="nav-number">2.3.</span> <span class="nav-text">volatile keyword</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">2.4.</span> <span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-const"><span class="nav-number">2.4.1.</span> <span class="nav-text">什么是 const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几种用途"><span class="nav-number">2.4.2.</span> <span class="nav-text">几种用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-iterator"><span class="nav-number">2.4.3.</span> <span class="nav-text">const iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员函数的-const"><span class="nav-number">2.4.4.</span> <span class="nav-text">类成员函数的 const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不加const为啥不行"><span class="nav-number">2.4.5.</span> <span class="nav-text">不加const为啥不行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#physical-vs-logical-constness"><span class="nav-number">2.4.6.</span> <span class="nav-text">physical vs logical constness</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutable"><span class="nav-number">2.4.7.</span> <span class="nav-text">mutable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#friend"><span class="nav-number">2.5.</span> <span class="nav-text">friend</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种-function-parameters"><span class="nav-number">2.6.</span> <span class="nav-text">三种 function parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">2.7.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">2.8.</span> <span class="nav-text">reference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#and-初始化方法"><span class="nav-number">2.9.</span> <span class="nav-text">() and &#x3D; 初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-value-initialization"><span class="nav-number">2.10.</span> <span class="nav-text">default&#x2F;value initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overloading-1"><span class="nav-number">2.11.</span> <span class="nav-text">overloading</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重载-lt-lt-符号"><span class="nav-number">2.11.1.</span> <span class="nav-text">重载 &lt;&lt; 符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载"><span class="nav-number">2.11.2.</span> <span class="nav-text">重载 &#x3D;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lvalue"><span class="nav-number">2.12.</span> <span class="nav-text">lvalue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterator"><span class="nav-number">2.13.</span> <span class="nav-text">iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initialization"><span class="nav-number">2.14.</span> <span class="nav-text">initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#uniform-initialization-C-11"><span class="nav-number">2.14.1.</span> <span class="nav-text">uniform initialization C++11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initializer-list-C-11"><span class="nav-number">2.14.2.</span> <span class="nav-text">initializer list C++11</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种定义-Comparison-Function-的方法"><span class="nav-number">2.15.</span> <span class="nav-text">三种定义 Comparison Function 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一：Define-operator-lt"><span class="nav-number">2.15.1.</span> <span class="nav-text">一：Define operator&lt;()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二：定义-comparison-function"><span class="nav-number">2.15.2.</span> <span class="nav-text">二：定义 comparison function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><span class="nav-number">2.15.3.</span> <span class="nav-text">三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-vs-三"><span class="nav-number">2.15.4.</span> <span class="nav-text">二 vs 三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-内置的函数对象"><span class="nav-number">2.15.5.</span> <span class="nav-text">STL 内置的函数对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#泛型设计"><span class="nav-number">3.</span> <span class="nav-text">泛型设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型设计的基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">泛型设计的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目的：为啥需要泛型程序设计"><span class="nav-number">3.1.1.</span> <span class="nav-text">目的：为啥需要泛型程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#术语一：概念"><span class="nav-number">3.1.2.</span> <span class="nav-text">术语一：概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#术语：模型"><span class="nav-number">3.1.3.</span> <span class="nav-text">术语：模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用概念做模板参数名"><span class="nav-number">3.1.4.</span> <span class="nav-text">用概念做模板参数名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL-简介"><span class="nav-number">3.2.</span> <span class="nav-text">STL 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STL的基本组件"><span class="nav-number">3.2.1.</span> <span class="nav-text">STL的基本组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL的基本组件间的关系"><span class="nav-number">3.2.2.</span> <span class="nav-text">STL的基本组件间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个例子"><span class="nav-number">3.2.3.</span> <span class="nav-text">一个例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">3.2.4.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序容器的特性"><span class="nav-number">3.2.5.</span> <span class="nav-text">顺序容器的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向量（Vector）"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">向量（Vector）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双端队列（deque）"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">双端队列（deque）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表-list"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">列表(list)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单向链表（forward-list）"><span class="nav-number">3.2.5.4.</span> <span class="nav-text">单向链表（forward_list）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组（array）"><span class="nav-number">3.2.5.5.</span> <span class="nav-text">数组（array）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序容器的比较"><span class="nav-number">3.2.5.6.</span> <span class="nav-text">顺序容器的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配器"><span class="nav-number">3.2.6.</span> <span class="nav-text">适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器适配器"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数适配器"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">函数适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器适配器"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">迭代器适配器</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2020/01/04/cpp-summary/';
          this.page.identifier = '2020/01/04/cpp-summary/';
          this.page.title = 'cpp-summary';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://githubio-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
