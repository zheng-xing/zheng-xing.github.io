<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="cpp," />










<meta name="description" content="object relationships 有关总论 Background Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.   relationships between object a circle “is a “ shape a hous">
<meta name="keywords" content="cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-summary">
<meta property="og:url" content="http://yoursite.com/2020/01/04/cpp-summary/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="object relationships 有关总论 Background Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.   relationships between object a circle “is a “ shape a hous">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png">
<meta property="og:updated_time" content="2020-01-10T05:35:52.882Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cpp-summary">
<meta name="twitter:description" content="object relationships 有关总论 Background Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.   relationships between object a circle “is a “ shape a hous">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/04/cpp-summary/"/>





  <title>cpp-summary | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/cpp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">cpp-summary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T17:28:42-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/cpp-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/cpp-summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="object-relationships-有关"><a href="#object-relationships-有关" class="headerlink" title="object relationships 有关"></a>object relationships 有关</h2><h3 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h3><ol>
<li>Background<ol>
<li>Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.</li>
</ol>
</li>
<li>relationships between object<ol>
<li>a circle “is a “ shape</li>
<li>a house “has a” bedroom</li>
<li>I “use a” mechanical keyboard</li>
<li>mail “depend on” mailman to be delievered</li>
<li>I am “member of” Pingpang club</li>
</ol>
</li>
</ol>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><ol>
<li>主要用来描述 “has a” 关系的。<ol>
<li>Your computer “has a” CPU.</li>
<li>C++ concepts like structs and classes are both composite types.</li>
</ol>
</li>
<li>有两种 composition 子类<ol>
<li>composition</li>
<li>aggregation</li>
</ol>
</li>
<li>composition 子类满足条件<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time</li>
<li>The part (member) has its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
</li>
<li>说人话<ol>
<li>object 建立的时候创建 the part，object 摧毁的时候 part 也被摧毁</li>
<li>object manages part’s lifetime</li>
<li>part 不知道 object 的存在</li>
</ol>
</li>
</ol>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><p>Many games and simulations have creatures or objects that move around a board, map, or screen. One thing that all of these creatures/objects have in common is that they all have a location. In this example, we are going to create a creature class that uses a point class to hold the creature’s location.</p>
<p>First, let’s design the point class. Our creature is going to live in a 2d world, so our point class will have 2 dimensions, X and Y. We will assume the world is made up of discrete squares, so these dimensions will always be integers.</p>
<p>Point2D.h:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT2D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT2D_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// A default constructor</span></span><br><span class="line">    Point2D()</span><br><span class="line">        : m_x(<span class="number">0</span>), m_y(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// A specific constructor</span></span><br><span class="line">    Point2D(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        : m_x(x), m_y(y)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// An overloaded output operator</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;point)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; point.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access functions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>Note that because we’ve implemented all of our functions in the header file (for the sake of keeping the example concise), there is no Point2D.cpp.</p>
<p>This Point2d class is a composition of its parts: location values x and y are part-of Point2D, and their lifespan is tied to that of a given Point2D instance.</p>
<p>Now let’s design our Creature. Our Creature is going to have a few properties: a name, which will be a string, and a location, which will be our Point2D class.</p>
<p>Creature.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CREATURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATURE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point2D.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    Point2D m_location;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Creature(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Point2D &amp;location)</span><br><span class="line">        : m_name(name), m_location(location)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Creature &amp;creature)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; creature.m_name &lt;&lt; <span class="string">" is at "</span> &lt;&lt; creature.m_location;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_location.setPoint(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><mark>注意这里可以这么改写Code</mark><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;point)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; point.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">printToStream</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  out &lt;&lt; <span class="string">'('</span> &lt;&lt; point.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.m_y &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">printToStream(<span class="built_in">std</span>::<span class="built_in">cout</span>, point);</span><br></pre></td></tr></table></figure></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>[Variants on the composition theme]</strong></p>
<p>Although most compositions directly create their parts when the composition is created and directly destroy their parts when the composition is destroyed, there are some variations of composition that bend these rules a bit.</p>
<p>For example:</p>
<ol>
<li>A composition may defer creation of some parts until they are needed. For example, a string class may not create a dynamic array of characters until the user assigns the string some data to hold.</li>
<li>A composition may opt to use a part that has been given to it as input rather than create the part itself.</li>
<li>A composition may delegate destruction of its parts to some other object (e.g. to a garbage collection routine).</li>
</ol>
<p>The key point here is that the composition should manage its parts without the user of the composition needing to manage anything.</p>
<p><strong>[Composition and subclasses]</strong></p>
<p>One question that new programmers often ask when it comes to object composition is, “When should I use a subclass instead of direct implementation of a feature?”. For example, instead of using the Point2D class to implement the Creature’s location, we could have instead just added 2 integers to the Creature class and written code in the Creature class to handle the positioning. However, making Point2D its own class has a number of benefits:</p>
<ol>
<li>Each individual class can be kept relatively simple and straightforward, focused on performing one task well. This makes those classes easier to write and much easier to understand, as they are more focused. For example, Point2D only worries about point-related stuff, which helps keep it simple. <mark>可以找人去负责 Point2D class, 另外的人去负责 Creature class.</mark></li>
<li>Each subclass can be self-contained, which makes them reusable. For example, we could reuse our Point2D class in a completely different application. Or if our creature ever needed another point (for example, a destination it was trying to get to), we can simply add another Point2D member variable.</li>
<li>The parent class can have the subclasses do most of the hard work, and instead focus on coordinating the data flow between the subclasses. This helps lower the overall complexity of the parent object, because it can delegate tasks to its children, who already know how to do those tasks. For example, when we move our Creature, it delegates that task to the Point class, which already understands how to set a point. Thus, the Creature class does not have to worry about how such things would be implemented.</li>
</ol>
<p>A good rule of thumb is that each class should be built to accomplish a single task. That task should either be the storage and manipulation of some kind of data (e.g. Point2D, std::string), OR the coordination of subclasses (e.g. Creature). Ideally not both.</p>
<p>In this case of our example, it makes sense that Creature shouldn’t have to worry about how Points are implemented, or how the name is being stored. Creature’s job isn’t to know those intimate details. Creature’s job is to worry about how to coordinate the data flow and ensure that each of the subclasses knows what it is supposed to do. It’s up to the individual subclasses to worry about how they will do it.</p>
<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p><strong>[满足条件]</strong></p>
<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can belong to more than one object (class) at a time</li>
<li>The part (member) does not have its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
<p><strong>[与 composition 异同]</strong></p>
<ol>
<li>共同点<ol>
<li>都是 part-whole 关系</li>
</ol>
</li>
<li>不同点<ol>
<li>parts 可以同时属于多个 object</li>
<li>object 不负责创建和摧毁 parts</li>
</ol>
</li>
</ol>
<p><strong>[具体例子]</strong></p>
<ol>
<li>每个人都有个家庭住址，但是家庭住址可以属于多个人。</li>
<li>人住进来之前家庭地址就存在了</li>
<li>人搬走后家庭地址依然存在</li>
<li>人知道他住在哪里，而一个家庭地址不知道住的是谁(假定是这样子的)</li>
</ol>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>Because aggregations are similar to compositions in that they are both part-whole relationships, they are implemented almost identically, and the difference between them is mostly semantic. In a composition, we typically add our parts to the composition using normal member variables (or pointers where the allocation and deallocation process is handled by the composition class).</p>
<p>In an aggregation, we also add parts as member variables. However, these member variables are typically either references or pointers that are used to point at objects that have been created outside the scope of the class. Consequently, an aggregation usually either takes the objects it is going to point to as constructor parameters, or it begins empty and the subobjects are added later via access functions or operators.</p>
<p>Because these parts exist outside of the scope of the class, when the class is destroyed, the pointer or reference member variable will be destroyed (but not deleted). Consequently, the parts themselves will still exist.</p>
<p>Let’s take a look at a Teacher and Department example in more detail. In this example, we’re going to make a couple of simplifications: First, the department will only hold one teacher. Second, the teacher will be unaware of what department they’re part of.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Teacher *m_teacher; <span class="comment">// This dept holds only one teacher for simplicity, but it could hold many teachers</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Department(Teacher *teacher = <span class="literal">nullptr</span>)</span><br><span class="line">        : m_teacher(teacher)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a teacher outside the scope of the Department</span></span><br><span class="line">    Teacher *teacher = <span class="keyword">new</span> Teacher(<span class="string">"Bob"</span>); <span class="comment">// create a teacher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a department and use the constructor parameter to pass</span></span><br><span class="line">        <span class="comment">// the teacher to it.</span></span><br><span class="line">        <span class="function">Department <span class="title">dept</span><span class="params">(teacher)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// dept goes out of scope here and is destroyed</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Teacher still exists here because dept did not delete m_teacher</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; teacher-&gt;getName() &lt;&lt; <span class="string">" still exists!"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> teacher;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里假定了 teacher 不知道工作的 department.</p>
<h4 id="总结-composition-和-aggregation"><a href="#总结-composition-和-aggregation" class="headerlink" title="总结 composition 和 aggregation"></a>总结 composition 和 aggregation</h4><ol>
<li>compositions<ol>
<li>Typically use normal member variables</li>
<li>Can use pointer members if the class handles object allocation/deallocation itself</li>
<li>Responsible for creation/destruction of parts</li>
</ol>
</li>
<li>Agreegations<ol>
<li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregate class</li>
<li>Not responsible for creating/destroying parts</li>
</ol>
</li>
</ol>
<p>It is worth noting that the concepts of composition and aggregation are not mutually exclusive, and can be mixed freely within the same class. It is entirely possible to write a class that is responsible for the creation/destruction of some parts but not others. For example, our Department class could have a name and a Teacher. The name would probably be added to the Department by composition, and would be created and destroyed with the Department. On the other hand, the Teacher would be added to the department by aggregation, and created/destroyed independently.</p>
<p>While aggregations can be extremely useful, they are also potentially more dangerous. Because aggregations do not handle deallocation of their parts, that is left up to an external party to do so. If the external party no longer has a pointer or reference to the abandoned parts, or if it simply forgets to do the cleanup (assuming the class will handle that), then memory will be leaked.</p>
<p>For this reason, compositions should be favored over aggregations.</p>
<h3 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h3><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h2 id="class-有关"><a href="#class-有关" class="headerlink" title="class 有关"></a>class 有关</h2><h3 id="概念题"><a href="#概念题" class="headerlink" title="概念题"></a>概念题</h3><p>[Differnce with struct]</p>
<ol>
<li>The only difference between “class” and “struct” is whether the beginning content in the class body (before first appearance of “private”/“public” keyword) is public or private. For class, that part is private. For struct, that part is public.</li>
</ol>
<p>[Method 定义的位置]</p>
<ol>
<li>定义在 class body 中的话，是要求这些 function become inline, thus avoid function call overhead.</li>
<li>定义在 class body 外的话，就会有 function call.</li>
</ol>
<p>[Compiler generated functions]</p>
<ol>
<li>Compilter silently write 4 functions if they are not explicitly declared:<ol>
<li>Copy constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Default Constructor (Only if there is no constructor declared)<ol>
<li>If there exists copy constructor, then compiler will not generate default constructor.</li>
<li>However, if there exists some constructor (not copy constructor), compiler will generate copy constructor if needed.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>多态背后的技术叫做动态绑定！底层的实现是使用虚函数表。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了实现C++的多态<mark>（关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>）</mark>，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h4 id="类的虚表"><a href="#类的虚表" class="headerlink" title="类的虚表"></a>类的虚表</h4><p>每个包含了虚函数的类都包含一个虚表。</p>
<p>我们知道，当一个类 A 继承另一个类 B 时，类 A 会继承类 B 的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可以调用这些虚函数。<br>换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>简单的例子，看一下下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可知，类 A 有虚函数，因此它有一个虚表。</p>
<p>类 A 的虚表如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png" alt=""></p>
<p><mark>虚表是一个指针数组，其元素是虚函数的指针。每个元素对应一个虚函数的函数指针。<br>需要指出的是，普通的函数，即非虚函数，其调用并不需要经过虚表。<br>因此虚表的元素并不包括普通函数的函数指针。</mark></p>
<h4 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h4><p><mark>虚表是属于类的，而不是属于某个具体的对象！一个类只需要一个虚表即可！同一个类的所有对象都使用同一个虚表。</mark></p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，<mark>编译器在类中添加了一个指针，<code>*__vptr</code>, 用来指向虚表。</mark><br>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png" alt=""></p>
<p>再重复一遍！一个继承类的基类如果包含虚函数，那么这个继承类也有自己的虚表，这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>下面讲一下 C++ 是如何利用虚表和虚表指针实现动态绑定的。先看一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 A 是基类，类 B 继承类 A，类 C 又继承类 B。<br>它们三个的对象模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png" alt=""></p>
<p>[关于上图的几点说明]</p>
<ol>
<li>由于<mark>这三个类都有虚函数，故编译器为每个类都创建了一个虚表</mark>，即类 A 有虚表 vtbl_A, 类 B 有虚表 vtbl_B, 类 C 有虚表 vtbl_C. 类A, B, C 的<code>对象</code>都拥有一个虚表指针， <code>*__vptr</code>, 用来指向自己所属类的虚表。</li>
<li>类 A 包括两个虚函数，故 vtbl_A 包含两个指针，分别指向 A::vfunc1() 和 A::vfunc2().</li>
<li>类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 vtbl_B 的两个指针分别指向 B::vfunc1() 和 A::vfunc2().</li>
<li>类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故 vtbl_C 的两个指针分别指向 B::vfunc1() (指向继承的最近的一个类的函数) 和 C::vfunc2().</li>
<li>图三看起来有点复杂，但是核心还是：<mark>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</mark>。抓住这个核心思想，就可以快速将这几个类的对象模型在脑中想象出来！</li>
<li>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</li>
</ol>
<p>假设我们定义一个类 B 的对象如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>这里要注意了，虽然 <code>p</code> 是基类的指针，只能指向基类的部分，但是虚表指针也属于基类的部分，亦即 b 实例内存中的虚表指针也属于基类部分。所以 <code>p</code> 可以访问到对象 bObject 的虚表指针. bObject 的虚表指针指向类 B 的虚表，所以 <code>p</code> 可以访问到 vtbl_B. </mark></p>
<p>当我们使用 p 来调用 vfunc1() 函数时候，会发横什么现象?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; bObject;</span><br><span class="line">	p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在执行 <code>p-&gt;vfunc1()</code> 时会发现 p 是个指针，且调用的函数式虚函数，接下来便会进行以下的步骤</p>
<ol>
<li>首先，根据虚表指针 <code>p-&gt;__vptr</code> 来访问对象 bObject 对应的虚表。虽然指针 p 是基类 <code>A*</code> 类型，但是 <code>*__vptr</code> 也是基类的一部分，所以可以通过 <code>p-&gt;__vptr</code> 访问到对象对应的虚表。</li>
<li>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编一阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 <code>p-&gt;vfunc1()</code> 的调用，vtbl_B 的第一项即是 vfunc1 对应的条目。</li>
<li>最后，根据虚表中找到的函数指针，调用函数。从上图可以看出，vtbl_B 的第一项指向 B::vfunc1()，所以 <code>p-&gt;vfunc1()</code> 实质会调用 B::vfunc1() 函数。</li>
</ol>
<p>而如果 p 指向类 A 的对象，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A aObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; aObject;</span><br><span class="line">	p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 aObject 在创建时，它的虚表指针 <code>__vptr</code> 已设置为指向 vtbl_A，这样 <code>p-&gt;__vptr</code> 就指向 vtbl_A. vfunc1 在 vtbl_A 对应的条目指向了 A::vfunc1() 函数，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>A::vfunc1()</code> 函数。</p>
<p><mark>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。</mark></p>
<p>[动态绑定]<br>我们把<mark>经过虚表调用虚函数的过程称为动态绑定</mark>，其表现出来的现象称为<mark>运行时多态</mark>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，<mark>什么时候会执行函数的动态绑定？</mark>这需要符合以下三个条件。</p>
<ol>
<li>通过指针来调用函数</li>
<li>指针 upcast 向上转型（继承类向基类的转换称为 upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h2 id="fundamental-concept-基本概念"><a href="#fundamental-concept-基本概念" class="headerlink" title="fundamental concept 基本概念"></a>fundamental concept 基本概念</h2><h4 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h4><p>Most of the times compilers will do optimization to the code to speed up the program. For example in the below code,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>( a == <span class="number">10</span>)&#123;</span><br><span class="line">     <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compiler may think that value of ‘a’ is not getting changed from the program and replace it with ‘while(true)’, which will result in an infinite loop. In actual scenario the value of ‘a’ may be getting updated from outside of the program.<br>Volatile keyword is used to tell compiler that the variable declared using volatile may be used from outside the current scope so that compiler wont apply any optimization. This matters only in case of multi-threaded applications.<br>In the above example if variable ‘a’ was declared using volatile, compiler will not optimize it. In shot, value of the volatile variables will be read from the memory location directly.</p>
<h4 id="—————-const—————"><a href="#—————-const—————" class="headerlink" title="—————-const—————-"></a>—————-const—————-</h4><ol>
<li>如果你声明某个 variable 是 const，在声明的那个语句中你就必须给它初始化！因为后面你就没有机会再修改了！</li>
<li>non-const iterator can be used to access/modify the container.</li>
<li>const iterator can only be used for access, and cannot be used for modification.</li>
<li>If the container itself is const, you can only use const iterator to access its elements.</li>
<li>==begin()== returns const_iterator if the container is const, and returns non-const iterator if the container is not const. (But you can always use ==auto==)</li>
<li>cbegin(), cend() returns const_iterator.</li>
</ol>
<h4 id="—————-three-kinds-of-function-parameters———"><a href="#—————-three-kinds-of-function-parameters———" class="headerlink" title="—————-three kinds of function parameters———-"></a>—————-three kinds of function parameters———-</h4><ol>
<li>someFunction(vector<double> vec)</double></li>
<li>someFunction(const vector<double>&amp; vec)</double></li>
</ol>
<h4 id="—————-static—————"><a href="#—————-static—————" class="headerlink" title="—————-static—————-"></a>—————-static—————-</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Local variables that are declared to be static </span></span><br><span class="line"><span class="comment">are preserved across invocations of the function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thus, we'll construct and initialize the string name</span></span><br><span class="line"><span class="comment">only on the first call to someFunction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">someFunction</span><span class="params">(balabala)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> name = <span class="string">"Zheng Xing"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="—————-reference—————"><a href="#—————-reference—————" class="headerlink" title="—————-reference—————-"></a>—————-reference—————-</h4><ol>
<li>reference data must be assigned at initialization</li>
<li>reference data cannot be reassigned</li>
</ol>
<h4 id="—————-and-—————"><a href="#—————-and-—————" class="headerlink" title="—————-() and =  —————-"></a>—————-() and =  —————-</h4><ol>
<li>container<t> c(c2)<ol>
<li>defines c as a container that is a copy of c2</li>
</ol>
</t></li>
<li>container<t> c = c2<ol>
<li>same</li>
</ol>
</t></li>
</ol>
<h4 id="—————-default-value-initialization—————"><a href="#—————-default-value-initialization—————" class="headerlink" title="—————-default/value initialization—————-"></a>—————-default/value initialization—————-</h4><ol>
<li>local variables of built-in type that are not explicitly initialized are undefined.</li>
<li>class type says what initializer to use if there is not one specified.</li>
<li>(Accerated C++, P125) When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is ==value-initialized==, which, for simple types such as int, is equivalent to setting the value to zero.</li>
</ol>
<h4 id="—————-overloading—————"><a href="#—————-overloading—————" class="headerlink" title="—————-overloading—————-"></a>—————-overloading—————-</h4><p>Several functions with the same name.</p>
<h4 id="—————-lvalue—————"><a href="#—————-lvalue—————" class="headerlink" title="—————-lvalue—————-"></a>—————-lvalue—————-</h4><p>就是一个可以被赋值的东西。denote a nontemporary object.</p>
<ol>
<li>variable</li>
<li>reference</li>
<li>the result of calling a function that returns a reference.</li>
</ol>
<h4 id="—————-iterator—————"><a href="#—————-iterator—————" class="headerlink" title="—————-iterator—————-"></a>—————-iterator—————-</h4><p>==( * iter).name== is the same as ==iter-&gt;name==</p>
<h2 id="三种定义-Comparison-Function-的方法"><a href="#三种定义-Comparison-Function-的方法" class="headerlink" title="三种定义 Comparison Function 的方法"></a>三种定义 Comparison Function 的方法</h2><h4 id="方法一：Define-operator-lt"><a href="#方法一：Define-operator-lt" class="headerlink" title="方法一：Define operator&lt;()"></a>方法一：Define operator&lt;()</h4><p>在自定义的数据结构里面定义好 &lt; 运算符的意义.</p>
<p>注意：operator&lt;() 参数只有一个！！！并且 operator 是 const<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort the edges in decreasing order</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你不喜欢这种语法，只有一个参数，</span></span><br><span class="line"><span class="comment">却比较两个objects，那么你可以用下面的方式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This way it is much clearer that you are </span></span><br><span class="line"><span class="comment">comparing a and b, not *this and other. </span></span><br><span class="line"><span class="comment">Note also that friend function is like static function; </span></span><br><span class="line"><span class="comment">it cannot access member variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h4 id="方法二：定义-comparison-function"><a href="#方法二：定义-comparison-function" class="headerlink" title="方法二：定义 comparison function"></a>方法二：定义 comparison function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stringVec.begin(), stringVec.end(), comp);</span><br></pre></td></tr></table></figure>
<h4 id="方法三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><a href="#方法三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object" class="headerlink" title="方法三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object."></a>方法三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了上面的定义，你就可以这样用：</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, cmp&gt; myset;  <span class="comment">// cmp 是 type</span></span><br><span class="line"><span class="comment">// 或者这样（cmp 也是 type）</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个错误用法</span></span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmp);</span><br><span class="line"><span class="comment">// cmp 是type，sort需要 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法-1</span></span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmp());</span><br><span class="line"><span class="comment">// 正确写法-2</span></span><br><span class="line">cmp cmpobject;</span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmpobject);</span><br></pre></td></tr></table></figure>
<p>注意，虽然 set, map 里面只能使用 functor/type</p>
<p>实际上他们也可以用 function 的方法，但是容易用错，</p>
<p>不过这里还是给出来看一下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can use comparison function for STL containers</span></span><br><span class="line"><span class="comment">by passing them as the first argument of the constructor, </span></span><br><span class="line"><span class="comment">and specifying the function type as the additional template argument. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span> (*)(<span class="built_in">string</span>, <span class="built_in">string</span>)&gt; myset(comp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lambda function 也是一个 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123; <span class="keyword">return</span> a.size() &gt; b.size; &#125;;</span><br><span class="line">priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(comp)&gt; mypq(comp);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法二-vs-方法三"><a href="#方法二-vs-方法三" class="headerlink" title="方法二 vs 方法三"></a>方法二 vs 方法三</h4><ol>
<li>方法三 compiler 很容易 inline，所以效率高！</li>
</ol>
<h4 id="STL-内置的函数对象"><a href="#STL-内置的函数对象" class="headerlink" title="STL 内置的函数对象"></a>STL 内置的函数对象</h4><p>STL提供的函数对象</p>
<ol>
<li>用于算术运算的函数对象：<ol>
<li>一元函数对象(一个参数) ：negate</li>
<li>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</li>
</ol>
</li>
<li>用于关系运算、逻辑运算的函数对象(要求返回值为bool)<ol>
<li>一元谓词(一个参数)：logical_not</li>
<li>二元谓词(两个参数)：equalto、notequalto、greater、less、greaterequal、lessequal、logicaland、logical_or</li>
</ol>
</li>
</ol>
<h2 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h2><h3 id="泛型设计的基本概念"><a href="#泛型设计的基本概念" class="headerlink" title="泛型设计的基本概念"></a>泛型设计的基本概念</h3><h4 id="目的：为啥需要泛型程序设计"><a href="#目的：为啥需要泛型程序设计" class="headerlink" title="目的：为啥需要泛型程序设计"></a>目的：为啥需要泛型程序设计</h4><ol>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从具体的数据结构中抽象出来，成为通用的</li>
<li>C++ 的模板为泛型程序设计奠定了关键的基础</li>
</ol>
<h4 id="术语一：概念"><a href="#术语一：概念" class="headerlink" title="术语一：概念"></a>术语一：概念</h4><p>概念是指：用来界定具备一定功能的数据类型。例如：</p>
<ol>
<li>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable</li>
<li>将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable</li>
<li>将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable</li>
</ol>
<p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：</p>
<ol>
<li>Sortable既是Comparable的子概念，也是Assignable的子概念</li>
</ol>
<h4 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h4><p>模型（model）：符合一个概念的数据类型称为该概念的模型，例如：</p>
<ol>
<li>int型是Comparable概念的模型。</li>
<li>静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）</li>
</ol>
<h4 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h4><p>很多STL的实现代码就是使用概念来命名模板参数的。</p>
<p>为概念赋予一个名称，并使用该名称作为模板参数名。例如</p>
<p>表示insertionSort这样一个函数模板的原型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Sortable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insertionSort</span>(<span class="title">Sortable</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>);</span></span><br></pre></td></tr></table></figure></p>
<h3 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h3><h4 id="STL的基本组件"><a href="#STL的基本组件" class="headerlink" title="STL的基本组件"></a>STL的基本组件</h4><ol>
<li>容器（container）</li>
<li>迭代器（iterator）</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ol>
<h4 id="STL的基本组件间的关系"><a href="#STL的基本组件间的关系" class="headerlink" title="STL的基本组件间的关系"></a>STL的基本组件间的关系</h4><ol>
<li>Iterators（迭代器）是算法和容器的桥梁。</li>
<li>将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。</li>
<li>将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png" alt=""></p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>transform算法的一种实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryFunction</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">        *result = op(*first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform算法顺序遍历first和last两个迭代器所指向的元素；</p>
<p>将每个元素的值作为函数对象op的参数；</p>
<p>将op的返回值通过迭代器result顺序输出；</p>
<p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回.</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器是算法和容器的桥梁</p>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ol>
<p>算法和容器独立</p>
<ol>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也能适用</li>
</ol>
<h4 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h4><p>顺序容器包括：</p>
<ol>
<li>向量、双端队列、列表、单向链表、数组</li>
</ol>
<h5 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h5><p>特点</p>
<ol>
<li>一个可以扩展的动态数组</li>
<li>随机访问、在尾部插入或删除元素快</li>
<li>在中间或头部插入或删除元素慢</li>
</ol>
<p>向量的容量</p>
<ol>
<li>容量(capacity)：实际分配空间的大小</li>
<li>s.capacity() ：返回当前容量</li>
<li>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</li>
</ol>
<h5 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h5><p>特点</p>
<ol>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量容器慢</li>
</ol>
<p>例10-5 奇偶排序<br>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; i1(<span class="built_in">cin</span>), i2;  <span class="comment">//建立一对输入流迭代器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1(i1, i2); <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line">    sort(s1.begin(), s1.end()); <span class="comment">//将输入的整数排序</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.begin(); iter != s1.end(); ++iter) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>)    <span class="comment">//偶数放到s2尾部</span></span><br><span class="line">             s2.push_back(*iter);</span><br><span class="line">         <span class="keyword">else</span>       <span class="comment">//奇数放到s2首部</span></span><br><span class="line">             s2.push_front(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s2的结果输出</span></span><br><span class="line">    copy(s2.begin(), s2.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>==心得一：输出 vector 到标准输出我一般都是用 for 循环一个一个喂给 cout，这里却用 iterator 和 copy 函数很简洁得做到了（上段代码倒数第三句）==</p>
<p>==心得二：这个方法思路很好啊！！==</p>
<h5 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h5><p>特点</p>
<ol>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ol>
<p>接合(splice)操作</p>
<ol>
<li>==s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到s1中p所指向元素之前==</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> names1[] = &#123; <span class="string">"Alice"</span>, <span class="string">"Helen"</span>, <span class="string">"Lucy"</span>, <span class="string">"Susan"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> names2[] = &#123; <span class="string">"Bob"</span>, <span class="string">"David"</span>, <span class="string">"Levin"</span>, <span class="string">"Mike"</span> &#125;;</span><br><span class="line">    <span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; s1(names1, names1 + <span class="number">4</span>); </span><br><span class="line">    <span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; s2(names2, names2 + <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line">    s2.splice(s2.end(), s1, s1.begin());</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter1 = s1.begin(); <span class="comment">//iter1指向s1首</span></span><br><span class="line">    advance(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter2 = s2.begin();  <span class="comment">//iter2指向s2首</span></span><br><span class="line">    ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line">    advance(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line">    <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line">    s1.splice(iter1, s2, iter2, iter3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别将s1和s2输出</span></span><br><span class="line">    copy(s1.begin(), s1.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(s2.begin(), s2.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h5><ol>
<li>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</li>
<li>未定义insert、emplace和erase操作，而定义了insertafter、emplaceafter和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</li>
<li>不支持size操作。</li>
</ol>
<h5 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h5><ol>
<li>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</li>
<li>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小。</li>
<li>不能动态地改变容器大小</li>
</ol>
<h5 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h5><p>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容器所需要执行的操作来决定选择哪一种容器。</p>
<ol>
<li>如果需要执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector；</li>
<li>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应当选择双端队列容器deque；</li>
<li>如果不需要对容器进行随机访问，但是需要在中间位置插入或者删除元素，就应当选择列表容器list或forward_list；</li>
<li>如果需要数组，array相对于内置数组类型而言，是一种更安全、更容易使用的数组类型。</li>
</ol>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><ol>
<li>容器适配器</li>
<li>函数适配器</li>
<li>迭代器适配器</li>
</ol>
<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p>STL提供了三个==容器适配器==：</p>
<ol>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ol>
<p>这些适配器都是包装了vector、list、deque中某个顺序容器的包装器。<br>stack和queue是容器，但是他们==在本质上是适配器，他们本身并没有实现什么结构和算法，而是把deque拿过来，接口改造一下，实现了自己需要的功能==。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png" alt=""></p>
<p>注意：</p>
<ol>
<li>适配器没有提供迭代器，也不能同时插入或删除多个元素</li>
</ol>
<h5 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h5><h5 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h5>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/cpp/" rel="tag"># cpp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/01/massive-data-analysis/" rel="next" title="massive-data-analysis">
                <i class="fa fa-chevron-left"></i> massive-data-analysis
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/04/python-good-code-examples/" rel="prev" title="python-good-code-examples">
                python-good-code-examples <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#object-relationships-有关"><span class="nav-number">1.</span> <span class="nav-text">object relationships 有关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总论"><span class="nav-number">1.1.</span> <span class="nav-text">总论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Composition"><span class="nav-number">1.2.</span> <span class="nav-text">Composition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码例子"><span class="nav-number">1.2.1.</span> <span class="nav-text">代码例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">1.2.2.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aggregation"><span class="nav-number">1.3.</span> <span class="nav-text">Aggregation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实例"><span class="nav-number">1.3.1.</span> <span class="nav-text">代码实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-composition-和-aggregation"><span class="nav-number">1.3.2.</span> <span class="nav-text">总结 composition 和 aggregation</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Association"><span class="nav-number">1.4.</span> <span class="nav-text">Association</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dependencies"><span class="nav-number">1.5.</span> <span class="nav-text">Dependencies</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class-有关"><span class="nav-number">2.</span> <span class="nav-text">class 有关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念题"><span class="nav-number">2.1.</span> <span class="nav-text">概念题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数表"><span class="nav-number">2.2.</span> <span class="nav-text">虚函数表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">2.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的虚表"><span class="nav-number">2.2.2.</span> <span class="nav-text">类的虚表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚表指针"><span class="nav-number">2.2.3.</span> <span class="nav-text">虚表指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态绑定"><span class="nav-number">2.2.4.</span> <span class="nav-text">动态绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fundamental-concept-基本概念"><span class="nav-number">3.</span> <span class="nav-text">fundamental concept 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-keyword"><span class="nav-number">3.0.1.</span> <span class="nav-text">volatile keyword</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-const—————"><span class="nav-number">3.0.2.</span> <span class="nav-text">—————-const—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-three-kinds-of-function-parameters———"><span class="nav-number">3.0.3.</span> <span class="nav-text">—————-three kinds of function parameters———-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-static—————"><span class="nav-number">3.0.4.</span> <span class="nav-text">—————-static—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-reference—————"><span class="nav-number">3.0.5.</span> <span class="nav-text">—————-reference—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-and-—————"><span class="nav-number">3.0.6.</span> <span class="nav-text">—————-() and =  —————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-default-value-initialization—————"><span class="nav-number">3.0.7.</span> <span class="nav-text">—————-default/value initialization—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-overloading—————"><span class="nav-number">3.0.8.</span> <span class="nav-text">—————-overloading—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-lvalue—————"><span class="nav-number">3.0.9.</span> <span class="nav-text">—————-lvalue—————-</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#—————-iterator—————"><span class="nav-number">3.0.10.</span> <span class="nav-text">—————-iterator—————-</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种定义-Comparison-Function-的方法"><span class="nav-number">4.</span> <span class="nav-text">三种定义 Comparison Function 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一：Define-operator-lt"><span class="nav-number">4.0.1.</span> <span class="nav-text">方法一：Define operator<()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二：定义-comparison-function"><span class="nav-number">4.0.2.</span> <span class="nav-text">方法二：定义 comparison function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><span class="nav-number">4.0.3.</span> <span class="nav-text">方法三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二-vs-方法三"><span class="nav-number">4.0.4.</span> <span class="nav-text">方法二 vs 方法三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL-内置的函数对象"><span class="nav-number">4.0.5.</span> <span class="nav-text">STL 内置的函数对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型设计"><span class="nav-number">5.</span> <span class="nav-text">泛型设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型设计的基本概念"><span class="nav-number">5.1.</span> <span class="nav-text">泛型设计的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目的：为啥需要泛型程序设计"><span class="nav-number">5.1.1.</span> <span class="nav-text">目的：为啥需要泛型程序设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#术语一：概念"><span class="nav-number">5.1.2.</span> <span class="nav-text">术语一：概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#术语：模型"><span class="nav-number">5.1.3.</span> <span class="nav-text">术语：模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用概念做模板参数名"><span class="nav-number">5.1.4.</span> <span class="nav-text">用概念做模板参数名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-简介"><span class="nav-number">5.2.</span> <span class="nav-text">STL 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STL的基本组件"><span class="nav-number">5.2.1.</span> <span class="nav-text">STL的基本组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL的基本组件间的关系"><span class="nav-number">5.2.2.</span> <span class="nav-text">STL的基本组件间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个例子"><span class="nav-number">5.2.3.</span> <span class="nav-text">一个例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-number">5.2.4.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序容器的特性"><span class="nav-number">5.2.5.</span> <span class="nav-text">顺序容器的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#向量（Vector）"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">向量（Vector）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双端队列（deque）"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">双端队列（deque）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#列表-list"><span class="nav-number">5.2.5.3.</span> <span class="nav-text">列表(list)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单向链表（forward-list）"><span class="nav-number">5.2.5.4.</span> <span class="nav-text">单向链表（forward_list）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组（array）"><span class="nav-number">5.2.5.5.</span> <span class="nav-text">数组（array）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序容器的比较"><span class="nav-number">5.2.5.6.</span> <span class="nav-text">顺序容器的比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器"><span class="nav-number">5.2.6.</span> <span class="nav-text">适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#容器适配器"><span class="nav-number">5.2.6.1.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数适配器"><span class="nav-number">5.2.6.2.</span> <span class="nav-text">函数适配器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代器适配器"><span class="nav-number">5.2.6.3.</span> <span class="nav-text">迭代器适配器</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2020/01/04/cpp-summary/';
          this.page.identifier = '2020/01/04/cpp-summary/';
          this.page.title = 'cpp-summary';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://githubio-2.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
