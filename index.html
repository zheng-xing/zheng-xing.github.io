<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="//index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zheng Xing">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com///"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/11/leetcode-mics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/leetcode-mics/" itemprop="url">leetcode-mics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-11T00:12:45-07:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/11/leetcode-mics/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/03/11/leetcode-mics/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="求和-很多限制条件"><a href="#求和-很多限制条件" class="headerlink" title="求和(很多限制条件)"></a>求和(很多限制条件)</h2><p>[题目]</p>
<ol>
<li>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</li>
</ol>
<p>[分析]</p>
<ol>
<li>这道题目出自《贱指offer》</li>
<li>首先看到说不能使用公式直接计算（公式中包含乘除法），所以可以考虑使用递归进行求解。</li>
<li>但是递归中一般需要使用 if 来指定返回条件，而这里不允许使用 if，所以无法使用普通的递归思路。</li>
<li>直接看代码！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这里的思路就是利用 C++ 语言中在处理 <code>A &amp;&amp; B</code> 时候的规则.</li>
<li>只有 A 为 true，才会执行 B, 根据 B 的结果返回。</li>
<li>如果 A 为 false, 不会执行 B, 直接返回 false.</li>
<li>因此这里使用这么个技巧使得 n 在不为 0 的时候都会执行右边的赋值和递归运算，从而得到结果。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/design-pattern/" itemprop="url">design-pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-15T21:09:00-08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/Python/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/15/design-pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/15/design-pattern/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h1><h2 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h2><h2 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h2><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    static  A&amp; getInstance();</span><br><span class="line">    setup() &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp; rhs);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&amp; A::getInstance()&#123;</span><br><span class="line">    static A a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A::getInstance().setup();</span><br></pre></td></tr></table></figure>

<p>解释一下</p>
<ol>
<li>注意这里面的 Constructor 都是在 private 区域(参考<a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#Can-constructor-be-private" target="_blank" rel="noopener">private constructor</a>)，因此你不能使用 <code>A a1;</code> 这种方式去生成一个 object;</li>
<li>你只能用 <code>A a1 = A::getInstance()</code> 这种方式去获得一个 object.</li>
</ol>
<h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><h3 id="原型模式的作用"><a href="#原型模式的作用" class="headerlink" title="原型模式的作用"></a>原型模式的作用</h3><ol>
<li>基本就是你需要从A的实例得到一份与A内容相同，但是又互不干扰的实例的话，就需要使用原型模式。</li>
<li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这个其实和C++的拷贝构造函数的作用是相似的（但不相同），实际上就是动态抽取 当前对象 运行时 的 状态。</li>
<li>当然有的时候，如果我们并不需要基于现有的对象复制新的对象，或者我们需要的就是一个干净的空对象，那么我的首先还是工厂模式或者抽象工厂模式。</li>
</ol>
<h3 id="为什么需要原型模式？"><a href="#为什么需要原型模式？" class="headerlink" title="为什么需要原型模式？"></a>为什么需要原型模式？</h3><ol>
<li>为什么不用new直接新建对象，而要用原型模式？<ol>
<li>首先，用new新建对象不能获取当前对象运行时的状态，其次就算new了新对象，在将当前对象的值复制给新对象，效率也不如原型模式高。</li>
</ol>
</li>
<li>为什么不直接使用拷贝构造函数，而要使用原型模式？<ol>
<li>原型模式与拷贝构造函数是不同的概念，拷贝构造函数涉及的类是已知的，原型模式涉及的类可以是未知的（基类的拷贝构造函数只能复制得到基类的对象）。</li>
<li>原型模式生成的新对象可能是一个派生类。拷贝构造函数生成的新对象只能是类本身。原型模式是描述了一个通用方法(或概念)，它不管是如何实现的，而拷贝构造则是描述了一个具体实现方法。</li>
</ol>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>资源优化场景<ol>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
</ol>
</li>
<li>性能和安全要求的场景<ol>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
</ol>
</li>
<li>一个对象多个修改者的场景<ol>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ol>
</li>
<li>结合使用<ol>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为浑然一体，大家可以随手拿来使用。</li>
</ol>
</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>
<li>实现原型模式每个派生类都必须实现 Clone接口。</li>
<li>逃避构造函数的约束。</li>
</ol>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p> 在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。</p>
<p>在c++中，怎么实现原型模式呢？实际上就拷贝构造函数，而且有时候还涉及到深拷贝，这个自行研究c++深拷贝机制。下面给出最简单的一种实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Prototype()&#123;&#125;</span><br><span class="line">     ~Prototype()&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> :</span><span class="keyword">public</span> Prototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcretePrototypeA() :member(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~ConcretePrototypeA()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ConcretePrototypeA(<span class="keyword">const</span> ConcretePrototypeA &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        member = rhs.member;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConcretePrototypeA* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy of self"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototypeA(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成对像</span></span><br><span class="line">    ConcretePrototypeA *conPro = <span class="keyword">new</span> ConcretePrototypeA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制自身</span></span><br><span class="line">    ConcretePrototypeA * conPro1 = conPro-&gt;clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制自身</span></span><br><span class="line">    ConcretePrototypeA * conPro2 = conPro-&gt;clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro;</span><br><span class="line">    conPro = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro1;</span><br><span class="line">    conPro1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro2;</span><br><span class="line">    conPro2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实现了一个最简单的原型模式，但是已经将原型模式的基本实现原理展现出来了。而有的时候，当调用Clone获得了一个复制的对象以后，需要改变对象的状态，此时就可能需要在ConcretePrototype类中添加一个Initialize操作，专门用于初始化克隆对象。由于在clone的内部调用的是复制构造函数，而此处又涉及到深复制和浅复制的问题。所以，在实际操作的过程中，这些问题，都需要进行仔细的考虑。</p>
<p>来看一个稍微复杂点的例子：类含有指针成员，这里就涉及到了拷贝构造函数的深拷贝。其实这里例子还需要一个拷贝复制函数，很简单，就是要考虑到自赋值的情况就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resume()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Resume* <span class="title">clone</span><span class="params">()</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Resume()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span>*name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResumeA</span> :</span> <span class="keyword">public</span> Resume</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ResumeA()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ResumeA(<span class="keyword">const</span> <span class="keyword">char</span> *str)  <span class="comment">//构造函数  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResumeA(<span class="keyword">const</span> ResumeA &amp;rhs) <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name, rhs.name);</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">    ResumeA&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResumeA&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(rhs.name);</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name, rhs.name);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function">ResumeA* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ResumeA name : "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResumeA(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ~ResumeA()</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span>[] name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resume *r = <span class="keyword">new</span> ResumeA(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    Resume *r1 = r-&gt;clone();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">delete</span> r1;</span><br><span class="line">    r1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-prototype-1.png" alt=""></p>
<p>Discussion. Image base class provides the mechanism for storing, finding, and cloning the prototype for all derived classes. Each derived class specifies a private static data member whose initialization “registers” a prototype of itself with the base class. When the client asks for a “clone” of a certain type, the base class finds the prototype and calls clone() on the correct derived class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> imageType</span><br><span class="line">&#123;</span><br><span class="line">  LSAT, SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Image *<span class="title">findAndClone</span><span class="params">(imageType)</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// As each subclass of Image is declared, it registers its prototype</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPrototype</span><span class="params">(Image *<span class="built_in">image</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _prototypes[_nextSlot++] = <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// addPrototype() saves each registered prototype here</span></span><br><span class="line">    <span class="keyword">static</span> Image *_prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Image *Image::_prototypes[];</span><br><span class="line"><span class="keyword">int</span> Image::_nextSlot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Client calls this public static member function when it needs an instance</span></span><br><span class="line"><span class="comment">// of an Image subclass</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">    <span class="keyword">if</span> (_prototypes[i]-&gt;returnType() == type)</span><br><span class="line">      <span class="keyword">return</span> _prototypes[i]-&gt;clone();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandSatImage</span>:</span> <span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LSAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"LandSatImage::draw "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When clone() is called, call the one-argument ctor with a dummy arg</span></span><br><span class="line">    <span class="function">Image *<span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LandSatImage(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// This is only called from clone()</span></span><br><span class="line">    LandSatImage(<span class="keyword">int</span> dummy)</span><br><span class="line">    &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Mechanism for initializing an Image subclass - this causes the</span></span><br><span class="line">    <span class="comment">// default ctor to be called, which registers the subclass's prototype</span></span><br><span class="line">    <span class="keyword">static</span> LandSatImage _landSatImage;</span><br><span class="line">    <span class="comment">// This is only called when the private static data member is initiated</span></span><br><span class="line">    <span class="comment">// 也就是说这个构造函数只会被执行一次！！！</span></span><br><span class="line">    LandSatImage()</span><br><span class="line">    &#123;</span><br><span class="line">        addPrototype(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Nominal "state" per instance mechanism</span></span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the subclass's prototype</span></span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="comment">// Initialize the "state" per instance mechanism</span></span><br><span class="line"><span class="keyword">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpotImage</span>:</span> <span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"SpotImage::draw "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Image *<span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpotImage(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    SpotImage(<span class="keyword">int</span> dummy)</span><br><span class="line">    &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    SpotImage()</span><br><span class="line">    &#123;</span><br><span class="line">        addPrototype(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> SpotImage _spotImage;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpotImage SpotImage::_spotImage;</span><br><span class="line"><span class="keyword">int</span> SpotImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simulated stream of creation requests</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_IMAGES = <span class="number">8</span>;</span><br><span class="line">imageType input[NUM_IMAGES] =</span><br><span class="line">&#123;</span><br><span class="line">  LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Image *images[NUM_IMAGES];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Given an image type, find the right prototype, and return a clone</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    images[i] = Image::findAndClone(input[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Demonstrate that correct image objects have been cloned</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    images[i]-&gt;draw();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Free the dynamic memory</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    <span class="keyword">delete</span> images[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<pre><code>LandSatImage::draw 1
LandSatImage::draw 2
LandSatImage::draw 3
SpotImage::draw 1
LandSatImage::draw 4
SpotImage::draw 2
SpotImage::draw 3
LandSatImage::draw 5</code></pre><p>注意：</p>
<ol>
<li>我擦，这个例子看了我很久！！！</li>
<li>第一个要注意的地方是，两个子类都含有 static data members, 你必须在类的定义后面紧接着去定义它们（系统对它们的内存分配发生在这一步）！</li>
<li>第二个要注意的地方是，父类的 <code>Image *Image::_prototypes[];</code> 数组里面包含每一种子类！也就是说，有多少个子类，这个数组就有多少个元素！！！不会多，也不会少！<ol>
<li>因为看代码可以知道，这个数组的改变只有通过 <code>addPrototype</code> 函数！</li>
<li>而这个函数只有在子类的 static data member 初始化的时候才会被调用。而这个 static data member 只有一个。</li>
</ol>
</li>
<li>第三个要注意的是，不要搞混了主函数里的 images 数组和上面提到的 <code>_prototypes[]</code> 数组！</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工厂方法模式、抽象工厂模式、建造者模式和原型模式都是创建型模式。工厂方法模式适用于生产较复杂，一个工厂生产单一的一种产品的时候；抽象工厂模式适用于一个工厂生产多个相互依赖的产品；建造者模式着重于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；原型模式则更强调的是从自身复制自己，创建要给和自己一模一样的对象。</p>
<p>原型模式作为创建型模式中最特殊的一个模式，具体的创建过程，是由对象本身提供，这样我们在很多的场景下可以很方便的快速的构建新的对象。但是，原型模式的最大缺点是继承原型的子类都要实现Clone操作，这个是很困难的。例如，当所考虑的类已经存在时就难以新增Clone操作。当内部包括一些不支持拷贝或者有循环引用的对象时，实现克隆可能也会很困难。说以说，每一种设计模式都有它的优点和缺点，在设计的时候，我们需要进行权衡各方面的因素，扬长避短。</p>
<h1 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h1><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-composite.png" alt=""></p>
<h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><h2 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h2><h2 id="Flyweight"><a href="#Flyweight" class="headerlink" title="Flyweight"></a>Flyweight</h2><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h1 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h1><h2 id="Chain-of-responsibility"><a href="#Chain-of-responsibility" class="headerlink" title="Chain of responsibility"></a>Chain of responsibility</h2><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h2 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h2><h2 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h2><h2 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h2><p>在文章 <a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" target="_blank" rel="noopener">cpp-summary</a> 里面介绍虚函数，虚函数表，和虚表指针的时候，那里提到了虚函数的一个常见用法。</p>
<p>就是可以用基类的指针数组去统一管理所有的子类对象。</p>
<p>此处介绍虚函数的另一个常见用法。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-template-method-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-template-method-2.png" alt=""></p>
<p>图的注解</p>
<ol>
<li>这个模式的思路是：<ol>
<li>在你开发一个基类的时候，比如打开一个文件，有一些基本的操作可以在基类完成（比如输出要打开的文件的名字，以及其他状态的描述输出）</li>
<li>但是呢，如何打开一个具体的文件，这个操作需要由将来其他人实现的子类来实现。</li>
</ol>
</li>
</ol>
<h2 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h2><p>相关的 OOD 概念有： Delegation 委托 + Inheritance 继承</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-observer-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-observer-2.png" alt=""></p>
<p>图的注解：</p>
<ol>
<li>图一是背景介绍，包括两个例子<ol>
<li>例一，讲的是对于同一个文件，我现在打开了四个窗口，比如四个窗口分别看同一个 word 文档的不同页面。</li>
<li>例二，讲的是同一个数据，我们有几种不同的表现形式，eg. 原始数据的直接展示，统计直方图，etc.</li>
</ol>
</li>
<li>图二是如何使用 delegation 和 inheritance 来设计这个类<ol>
<li>Subject 类里面包括有 Observer 类的指针，这个是 delegation 关系。</li>
<li>同时 Observer 也是一个基类，它可以由很多不同的子类实现不同的功能，比如上面的例二。</li>
</ol>
</li>
</ol>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/python-good-code-examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/python-good-code-examples/" itemprop="url">python-good-code-examples</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T23:50:27-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/python-good-code-examples/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/python-good-code-examples/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="25-个有用代码段"><a href="#25-个有用代码段" class="headerlink" title="25 个有用代码段"></a>25 个有用代码段</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 交换变量的值</span></span><br><span class="line"><span class="comment">#    在 C++ 语言里面，不使用第三个变量的情况下去交换两个变量的值需要一定的技巧（使用运算符或者使用 XOR 操作）</span></span><br><span class="line"><span class="comment">#    而在 Python 里面很简单</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查是否是偶数</span></span><br><span class="line"><span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将多行数据变成行列表</span></span><br><span class="line"><span class="keyword">return</span> lines.split(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查找对象使用的内存</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getsizeof(<span class="number">5</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 翻转字符串</span></span><br><span class="line"><span class="comment">#    在 C++ 里面有 std::reverse 可以使用</span></span><br><span class="line">str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 字符串复制 n 次</span></span><br><span class="line">str = <span class="string">"Python"</span></span><br><span class="line">str * <span class="number">3</span>    <span class="comment"># PythonPythonPython</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 检查字符串是否回文</span></span><br><span class="line"><span class="keyword">return</span> str == str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 将字符串列表合并为单个字符串</span></span><br><span class="line">strings = [<span class="string">"abc"</span>, <span class="string">"dsf"</span>, <span class="string">"wer"</span>, <span class="string">"uiods"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">","</span>.join(strings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 查找列表的第一个元素</span></span><br><span class="line">list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. 找到两个列表的元素并集</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a + list_b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. 查找给定列表中所有元素, 重复的只算一次</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. 求列表元素的平均值</span></span><br><span class="line"><span class="keyword">return</span> sum(list_a, <span class="number">0.0</span>) / len(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13. 判断列表中元素是不是没有重复的</span></span><br><span class="line"><span class="keyword">return</span> len(list_a) == len(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14. 求列表元素的 frequency</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">count = Counter(list_a)</span><br><span class="line">print(count)    <span class="comment"># &#123;2: 3, 3: 3, 1: 1, 4: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 15. 找到列表中出现次数最多的那个</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">return</span> max(set(numbers), key = numbers.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 16. 角度转换成弧度</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">deg = <span class="number">90</span></span><br><span class="line"><span class="keyword">return</span> (deg * math.pi) / <span class="number">180.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 17. 计算一段代码的耗时</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">a,b = <span class="number">5</span>,<span class="number">10</span></span><br><span class="line">c = a+b</span><br><span class="line">end_time = time.time()</span><br><span class="line">time_taken = (end_time- start_time)*(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">print(<span class="string">"Time taken in micro_seconds:"</span>, time_taken) <span class="comment"># Time taken in micro_seconds: 39.577484130859375</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 18. 找到一组数字的最大公约数 gcd</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">numbers = [<span class="number">24</span>, <span class="number">108</span>, <span class="number">90</span>]</span><br><span class="line"><span class="keyword">return</span> reduce(math.gcd, numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 19. 找到字符串所有出现过的字符（多次出现的只考虑一次）</span></span><br><span class="line">str = <span class="string">"abcbcabdb"</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(set(str))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 20. 使用 lambda 函数</span></span><br><span class="line">x = <span class="keyword">lambda</span> a, b, c : a + b + c</span><br><span class="line">print(x(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>))    <span class="comment"># 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map(multiply, list_a)</span><br><span class="line">print(list(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map</span><br><span class="line"></span><br><span class="line"><span class="comment">## 22. 使用 filter 函数</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, arr))</span><br><span class="line">print(arr)    <span class="comment"># [2, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 23. 使用 list comprehensions</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">squares = [number**<span class="number">2</span> <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 24. 使用 slicing operation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(arr, d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arr[d:] + arr[:d]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    arr = rotate(arr, <span class="number">2</span>)</span><br><span class="line">    print(arr)    <span class="comment"># [3, 4, 5, 1, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 25. 使用 chained 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line">print((subtract <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b))    <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p>25 题还是挺有意思的，看出来可以把函数当成一个 first clas object 来玩儿了。</p>
<h1 id="一百题"><a href="#一百题" class="headerlink" title="一百题"></a>一百题</h1><h1 id="一些数据结构用-Python-里面如何操作"><a href="#一些数据结构用-Python-里面如何操作" class="headerlink" title="一些数据结构用 Python 里面如何操作"></a>一些数据结构用 Python 里面如何操作</h1><h2 id="stack-and-heap"><a href="#stack-and-heap" class="headerlink" title="stack and heap"></a>stack and heap</h2><p>比如判断括号组成的字符串是否合法这道题目，C++ 实现的话需要用到 STL 的 stack 和 heap.<br>在 Python 里面如何做呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#### remove first item from a list  ###</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-1: list.pop()</span></span><br><span class="line"><span class="comment"># list.pop(i) will remove the item at index "i"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-2: list.remove()</span></span><br><span class="line"><span class="comment"># list.remove(x) will remove the first element that equal to "x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(l[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-3: slicing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = l[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-4: del</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#### remove lat item from a list  ###</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># Method-1: l.pop()</span></span><br><span class="line"><span class="comment"># Method-2: l = l[:-1]</span></span><br><span class="line"><span class="comment"># Method-3: del l[-1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/cpp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/cpp-summary/" itemprop="url">cpp-summary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T17:28:42-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/cpp-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/cpp-summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="一些基础的点"><a href="#一些基础的点" class="headerlink" title="一些基础的点"></a>一些基础的点</h2><h3 id="constructor-initialization-list"><a href="#constructor-initialization-list" class="headerlink" title="constructor initialization list"></a>constructor initialization list</h3><ol>
<li>initialization list 要注意，是证明你是 C++ 老手的一个点。</li>
<li>它的执行顺序是按照你在 class 里面定义的顺序来得；</li>
<li>它跟在函数体里面实现的区别在于<ol>
<li>函数体里的实现是赋值操作，编译器还是需要先进行初始化操作，然后进入函数体执行赋值操作。</li>
<li>initialization list 里面是初始化操作，避免了多余的赋值操作。</li>
</ol>
</li>
<li>对于 primitive types，写在函数体里面进行赋值也不会有太大损失；不过最好也是统一写到 initialization list 那里吧！</li>
<li>有时候不仅仅是时间上的考虑，对于 const member data 来说，你必须放在 initialization list 那里，函数体里面不能进行赋值！</li>
</ol>
<h3 id="object-数据初始化顺序"><a href="#object-数据初始化顺序" class="headerlink" title="object 数据初始化顺序"></a>object 数据初始化顺序</h3><ol>
<li>对于类的数据来说，永远是先初始化基类的数据，然后对于当前子类来说，按照定义的顺序来初始化！</li>
<li>The relative order of initialization of non-local static objects defined in different translation units is underfined.<ol>
<li>A <code>translation unit</code> is the source code giving rise to a single object file. It’s basically a single source file, plus all of its <code>#include</code> files.</li>
<li>设想你需要初始化 static object B 和 A, 但是呢，B 的初始化需要先让 A 去初始化才行。这个时候你完全没有办法保证编译器会先初始化 A。怎么办？</li>
<li><mark>解决办法就是类似于 Singleton 设计得思想，把 B 的初始化放到一个函数里面，然后在函数体里面先去调用另一个函数去获得 static A object 的 reference，这样子就可以保证 A 会在 B 之前初始化了。</mark></li>
</ol>
</li>
</ol>
<h3 id="overloading"><a href="#overloading" class="headerlink" title="overloading"></a>overloading</h3><p>编译器是如何处理 overloading 的。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overloading-function-different-names.png" alt=""></p>
<p>此处注意如果你的参数列表都有默认值，有可能看起来跟其他同名函数不同，实际上却可能一样。</p>
<h3 id="big-three-三个特殊函数"><a href="#big-three-三个特殊函数" class="headerlink" title="big three 三个特殊函数"></a>big three 三个特殊函数</h3><p><mark>如果类里有指针，必须有(1) copy constructor (2) copy op= 拷贝赋值函数 (3) destructor. 三大函数</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.h 文件 ///////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    ~<span class="keyword">String</span>();</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_data&#125;;    <span class="comment">// 这里还需要提一句！这个函数须是 const 类型的！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.cpp 文件</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];    <span class="comment">// strlen 不会考虑字符串末尾的 '\n' 字符</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定初值时候</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];    <span class="comment">// 注意这里直接取另一个 instance 的私有数据！！因为同一类的不同 instance 互为 friend.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;    <span class="comment">// 检测自我赋值(self assignment)，这个能写出来就是高手！！！</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;    <span class="comment">// 不止是效率问题，是会出错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    os &lt;&lt; str.get_c_str();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="default-delete"><a href="#default-delete" class="headerlink" title="=default, =delete"></a>=default, =delete</h3><p>我们知道，对于 big three 这些函数，如果你没有定义，那么编译器会帮你生成一个！</p>
<p>而如果你自行定义了一个 ctor, 那么编译器就不会再给你一个 default ctor.<br>如果你强制加上 <code>=default</code>, 就可以重新获得并使用编译器给你的 default ctor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Zoo(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2): d1(i1), d2(i2) &#123;&#125;;</span><br><span class="line">    Zoo(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;    <span class="comment">// copy constructor</span></span><br><span class="line">    Zoo(Zoo&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// move constructor</span></span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Zoo() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++标准库里面使用 <code>=delete</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-1.png" alt=""></p>
<p>C++标准库里面使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-2.png" alt=""></p>
<p>C++标准库里面 destructor 使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-3.png" alt=""></p>
<p>具体的实例！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-5.png" alt=""></p>
<p><mark>非常棒的用法！！！</mark><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-7.png" alt=""></p>
<h3 id="override-amp-final"><a href="#override-amp-final" class="headerlink" title="override &amp; final"></a>override &amp; final</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-override-keyword.png" alt=""></p>
<p>下面介绍 final 关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种情况作用在 class 上面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> <span class="title">final</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base1 &#123;&#125;;</span><br><span class="line"> <span class="comment">// [Error] cannot derive from 'final' base 'Base1' in derived type 'Derived1'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况作用在函数上面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// [Error] overriding final function 'virtual void Base2::f()'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 编译器如何对待 new</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化为</span></span><br><span class="line"><span class="keyword">String</span>* ps;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="keyword">String</span>));  <span class="comment">// 分配内存, 内部会调用 malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;<span class="keyword">String</span>*&gt;(mem);    <span class="comment">// 转型</span></span><br><span class="line">ps-&gt;<span class="keyword">String</span>::<span class="keyword">String</span>(<span class="string">"Hello"</span>);    <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 编译器如何对待 delete</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化成</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>(ps);    <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;    <span class="comment">// 释放内存，内部调用 free(ps);</span></span><br></pre></td></tr></table></figure>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-2.png" alt=""></p>
<p>注一</p>
<ol>
<li>那一大块 32 byte 灰色区域是 debug mode 才会有的，Release mode 不存在这一块。图中左一左三对应 debug mode 下的空间；</li>
<li>绿色部分是实际的数据；</li>
<li>VC 里面实际分配的区间长度一定是 16 的倍数，所以这里要加上 padding 使得长度由 52 变成 64;</li>
<li>00000041 代表这一块区间有多长，这个数字是16进制的，因此是 64 byte</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-3.png" alt=""></p>
<p>注二：</p>
<ol>
<li>这里主要强调 array 情况下的内存分配</li>
<li>注意清楚 array 的空间一定要使用 delete[] ps 而不是 delete ps<ol>
<li>使用 delete ps 会造成内存泄漏，但是这个内存泄漏跟想得不太一样，不是 ps 直接指向的那一块空间泄露了，而是 ps 指向的空间里面的保存的指针二次指向的内存出现了泄露。</li>
<li><font color="red">如果这里不是 String 类，而是 Complex class，那么因为 Complex 的私有数据没有指针，所以就不会出现上面的情况。也就是说，即使你没有使用 deletep[] pc，其实也不会造成内存泄漏问题！</font></li>
</ol>
</li>
</ol>
<h4 id="重载-new-amp-delete"><a href="#重载-new-amp-delete" class="headerlink" title="重载 ::new &amp; ::delete"></a>重载 ::new &amp; ::delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-0.png" alt=""></p>
<h4 id="重载-operator-new-amp-operator-delete"><a href="#重载-operator-new-amp-operator-delete" class="headerlink" title="重载 operator new &amp; operator delete"></a>重载 operator new &amp; operator delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-5.png" alt=""></p>
<h4 id="重载-new-amp-delete-1"><a href="#重载-new-amp-delete-1" class="headerlink" title="重载 new() &amp; delete()"></a>重载 new() &amp; delete()</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-8.png" alt=""></p>
<h5 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h5><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-9.png" alt=""></p>
<h3 id="类的大小-sizeof"><a href="#类的大小-sizeof" class="headerlink" title="类的大小 sizeof"></a>类的大小 sizeof</h3><ol>
<li>[易错易忽略] 一定要注意，不要说类的大小，而要说类的对象的大小。<ol>
<li>类的大小是什么？确切地说，类只是一个类型定义，它没有大小可言。</li>
<li>用 sizeof 对一个类型名操作，得到的是具有该类型实体的大小。</li>
<li>如果 <code>Class A; A obj</code>，那么 <code>sizeof(A) == sizeof(obj)</code></li>
</ol>
</li>
<li>一个对象的大小 <mark>大于等于</mark> 所有 非静态成员 大小的总和。为什么是大于等于而不是正好想等呢？超出的部分有如下两方面：<ol>
<li>C++对象模型本身 对于具有虚函数的类型来说，需要有一个方法为它的实体提供类型信息(RTTI)和虚函数入口，常见的方法是建立一个虚函数入口表，这个表可为相同类型的对象共享，因此对象中需要有一个指向虚函数表的指针，此外，为了支持RTTI，许多编译器都把该类型信息放在虚函数表中。但是，是否必须采用这种实现方法，C++标准没有规定，但是这几户是主流编译器均采用的一种方案。</li>
<li>编译器优化 因为对于大多数CPU来说，CPU字长的整数倍操作起来更快，因此对于这些成员加起来如果不够这个整数倍，有可能编译器会插入多余的内容凑足这个整数倍，此外，有时候相邻的成员之间也有可能因为这个目的被插入空白，这个叫做“补齐”(padding)。所以，C++ 标准紧紧规定成员的排列按照类定义的顺序, 但是不要求在存储器中是紧密排列的。</li>
</ol>
</li>
<li>基于上述两点，可以说用sizeof对类名操作，得到的结果是该类的对象在存储器中所占据的字节大小，由于静态成员变量不在对象中存储，因此这个结果等于各非静态数据成员（不包括成员函数）的总和加上编译器额外增加的字节。后者依赖于不同的编译器实现，C++标准对此不做任何保证。</li>
<li>C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch1; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="keyword">char</span> ch2; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> in;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象c扩充为2个字，但是对象b为什么没扩充为1个字呢（空类的对象一个字节，含一个char的类类对象也为一个字节。）？</span></span><br><span class="line">    <span class="comment">// 因为B类只有一个成员变量，普通成员函数不占用内存。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">    <span class="comment">//对象c实际上只有6字节有用数据，但是按照上面第二点编译器优化，编译器将此扩展为两个字（add charles 字节对齐），即8字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<ol>
<li>一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。</li>
<li>对象大小= vptr(可能不止一个，这个很难确定，不过试过，类中定义了一个virtual函数，仍然为占用4个字节) + 所有非静态数据成员大小 + </li>
<li>类a，b明明是空类，它的大小应该为为０，为什么编译器输出的结果为１呢？这就是我们刚才所说的实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址．所以a，b的大小为１．</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></span><br><span class="line">pivate: </span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span>&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">int</span> b::data1=<span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(a)="</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么类b多了一个数据成员，却大小和类a的大小相同呢？因为：类b的静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员．但是它不影响类的大小，不管这个类实际产生　了多少实例，还是派生了多少新的类，静态成员数据在类中永远只有一个实体存在，而类的非静态数据成员只有被实例化的时候，他们才存在．但是类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在．可以这么说，类的静态数据成员是一种特殊的全局变量．<br>所以a，b的大小相同．</p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>这里讨论 <code>sizeof</code> 一个 <code>struct</code> 时候的结果。</p>
<p>[三大规则]</p>
<ol>
<li>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节,则要从４的整数倍地址开始存储。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</li>
</ol>
<p>[举例]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;             <span class="comment">//[0]...[3]</span></span><br><span class="line">    <span class="keyword">double</span> weight;      <span class="comment">//[8]...[15]　　　　　　原则１</span></span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">height</span>;       <span class="comment">//[16]..[19], 总长要为８的整数倍,补齐[20]...[23]　　　　　原则３</span></span><br><span class="line">&#125;BB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aa</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">2</span>];     <span class="comment">//[0],[1]</span></span><br><span class="line">    <span class="keyword">int</span>  id;          <span class="comment">//[4]...[7]　　　　　　　　　　原则１</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> score;     <span class="comment">//[8]....[15]　　　　</span></span><br><span class="line">    short grade;      <span class="comment">//[16],[17]　　　　　　　　</span></span><br><span class="line">    BB b;             <span class="comment">//[24]......[47]　　　　　　　　　　原则２</span></span><br><span class="line">&#125;AA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AA a;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="keyword">sizeof</span>(BB)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是: 48 24</span></span><br></pre></td></tr></table></figure>

<p>[#pragma pack()]<br>在代码前加一句#pragma pack(1),你会很高兴的发现,上面的代码输出为</p>
<p>32 16<br>bb是4+8+4=16,aa是2+4+8+2+16=32;</p>
<p>这不是理想中的没有内存对齐的世界吗.没错,#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.</p>
<p>明白了不? </p>
<p>那 <code>#pragma pack(2)</code> 的结果又是多少呢?对不起,５分钟到了,自己去测试吧.</p>
<p>ps:Vc,Vs等编译器默认是#pragma pack(8)，所以测试我们的规则会正常；注意gcc默认是#pragma pack(4)，并且gcc只支持1,2,4对齐。套用三原则里计算的对齐值是不能大于#pragma pack指定的n值。</p>
<h3 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h3><p>C++ 里面模板的使用一共有四种情况：</p>
<ol>
<li>函数模板</li>
<li>类模板</li>
<li>成员模板</li>
<li>模板参数</li>
</ol>
<h4 id="class-template"><a href="#class-template" class="headerlink" title="[class template]"></a>[class template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-template.png" alt=""></p>
<h4 id="function-template"><a href="#function-template" class="headerlink" title="[function template]"></a>[function template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-function-template.png" alt=""></p>
<p>注意：</p>
<ol>
<li>class template 里面 template 后面方括号里面的关键字是 Typename</li>
<li>function template 里面 template 后面方括号里面的关键字是 class T</li>
<li>对于 class template, 在实际生成具体数据的时候，需要指明数据的类型, 比如 vector<int> 指明了这是一个 int 类型的 vector</li>
<li>而对于 function template，在实际调用执行这个函数的时候，并没有显式地说明输入数据的类型, 比如 min(a, b)<ol>
<li>此时如上图所示，编译器会自动推导该调用哪个（argument deduction）.</li>
</ol>
</li>
<li>最后想说明的是，STL 里面一大块就是 algorithm 算法，它们都是用 template 来实现的！！！<ol>
<li>这样子保证了解耦，比如上面的 min(a, b) algorithm 里面会使用”&lt;” 运算符，而这个运算符会由各个 class 的设计者去实现 &lt; operator 的重载！！</li>
</ol>
</li>
</ol>
<h4 id="member-template"><a href="#member-template" class="headerlink" title="member template"></a>member template</h4><p>成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;U1, U2&gt;) :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个具体例子，假设我们有两个父类，每个父类都一个子类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们打算这么用</span></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p);   // 这个操作可以吗？？？</span><br></pre></td></tr></table></figure>

<p>上面的操作是可以的！</p>
<p>在看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>:</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span> : __shared_ptr&lt;_Tp&gt;<span class="params">(__p)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体用的时候是这样子</span></span><br><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;    <span class="comment">// 这个叫做指针的 up-cast</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Base1&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>;    <span class="comment">// 模拟 up-cast</span></span><br></pre></td></tr></table></figure>

<h4 id="template-template-parameter"><a href="#template-template-parameter" class="headerlink" title="template template parameter"></a>template template parameter</h4><p>模板模板参数是指：模板的参数又是一个模板。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&gt;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        elems.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::pop empty!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> elem = elems.back();</span><br><span class="line">        elems.pop_back();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这段代码几个要注意的地方：</p>
<ol>
<li>模板的第一个参数是T类型，第二个参数的类型是一个模板，而这个模板具有一个类型参数。此处因为这个形参名字没有被使用，所以省略了。</li>
<li>第二个参数那里按照规定只能用 <code>class Container</code> 不能是 <code>typename Container</code></li>
<li>第二个参数有默认值，是 <code>std::vector</code></li>
</ol>
<p>那么如何使用它呢？有两种方法</p>
<ol>
<li>第一个是只提供一个参数，第二个参数使用默认的。<code>Stack&lt;int&gt; mys</code></li>
<li>如果要提供两种参数的话，第二个参数要提供一个模板类。  <code>Stack&lt;int, some_user_defined_template&gt;</code></li>
</ol>
<p><font color = 'red'>Warning!!!</font><br>有了上面的定义，我们期望可以这样使用 Stack：<code>Stack&lt;int, std::deque&gt; intStack</code>，但编译器却给了我们一个教训。</p>
<p>std::deque类模板在stl库中的定义有两个类型参数，第一个参数是元素类型，第二个参数是分配器allocator的类型。虽然std::deque的第二个类型参数有默认值，但是当编译器使用std::deque替换Container时却会严格匹配参数，默认值被忽略了。</p>
<p>需要将代码修改成如下的样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;Elem&gt;&gt; class Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&gt;</span><br><span class="line"><span class="comment">// class Stack 的内容如上，没有变化</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>Stack&lt;int, std::deque&gt; intStack</code> 就可以编译通过了。</p>
<p>下面再考虑一个问题？如下的定义还算是模板模板参数吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = <span class="built_in">list</span>&lt;T&gt;&gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从使用方法上考虑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用方法有两种：</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure>

<p>第一种，只指定了第一个模板参数，使用第二个默认的模板参数。</p>
<p>第二种，指定了两个模板参数。</p>
<p>但是！这不是模板模板参数。因为，一旦指定了第一个模板参数，那么第二个参数的类型就会确定，而真正的模板模板参数，第二个模板参数和第一个模板参数的类型是没有关系的，可以指定为第一个模板参数的类型，也可以指定为其他类型。因此，这不是模板模板参数!!!</p>
<h3 id="variadic-templates-C-11"><a href="#variadic-templates-C-11" class="headerlink" title="variadic templates (C++11)"></a>variadic templates (C++11)</h3><p>侯捷老师说，这个东西是 C++11 里面类似于核弹级别的东西，需要好好体会！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates.png" alt=""></p>
<p>Note:</p>
<ol>
<li>不仅参数的数量随意！每个参数的 type 也随意！</li>
<li>注意有两处出现了 <code>...</code>, 一处位置在 <code>Types</code> 左边，一个的位置在 <code>Types</code> 的右边。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-2.png" alt=""><br>Note:</p>
<ol>
<li>这个例子讲得是 hash function 的设计，其中每个 hash_val 的调用关系都画出来了。</li>
<li>第二个同名函数在递归调用的最后，会调用到第三个同名函数。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-3.png" alt=""><br>Note:</p>
<ol>
<li>这个例子是类的递归继承！</li>
</ol>
<h3 id="alias-template-template-typedef-C-11"><a href="#alias-template-template-typedef-C-11" class="headerlink" title="alias template (template typedef) C++11"></a>alias template (template typedef) C++11</h3><p>下图注解：</p>
<ol>
<li>这里要注意的就是 “template + using” 的做法竟然不能用 define 来替代！</li>
<li>注意这里是给 template 起化名，我在用 ITK 库的时候虽然也用了 using 关键字，但是并不是对 template 起化名，而是对一个确定的东西起别名！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-1.png" alt=""></li>
</ol>
<p>下面两个图：</p>
<ol>
<li>左边的是侯老师的一个想法，希望实现一个函数可以接收两个那样的东西，然后完成一系列的测试。</li>
<li>但是写出来原型代码后，侯老师意识到这个实现是天方夜谭，需要的功能是完全不被支持的！</li>
<li>右边的写法是，侯老师意识到了传递给函数的一定是一个东西，一个 object, 而不能是一个 type.<ol>
<li>因此调用函数的方式变成了 <code>test_moveable(list(), MyString())</code>。加上括号就变成了 object 嘛。</li>
</ol>
</li>
<li>注意右边在函数定义的上面有加上了一句话，显示得说明了 Container 和 T 都是模板，但这个时候函数里面的一句话有报错了。</li>
<li>侯老师接着把函数里面的 <code>Container&lt;T&gt; c</code> 改成 <code>typename Container&lt;T&gt; c</code> 试图强制让编译器认为 Container 是一个模板，但还是有错。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-3.png" alt=""></p>
<p>下面三个图注解：</p>
<ol>
<li>上面的做法怎么样都搞不定了，侯老师只好改变了函数接收的参数。</li>
<li>这里有个厉害的操作是他获取 <code>value_type</code> 的方式！</li>
<li>图中的方式可行，是因为 container 一定有 iterator 一定有 value_type, 那如果没有呢？<ol>
<li>就需要 <a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#template-template-parameter" target="_blank" rel="noopener">template template parameter</a> 了。</li>
</ol>
</li>
<li>但是只用 template template parameter 好像不行</li>
<li>最后是用了 template template parameter 和 alias template 一起才完美解决了问题。<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-4.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-5.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-6.png" alt=""></li>
</ol>
<h3 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization 模板特化"></a>specialization 模板特化</h3><p>有特化就有泛化，而泛化指的就是模板。</p>
<p>下面的代码就是一个模板，一个泛化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span></span><br><span class="line">    <span class="comment">// 此处省略了具体的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>为什么需要特化？</mark></p>
<ol>
<li>上面的模板呢可能对于大多数类型的 Key, 都可以用</li>
<li>但是呢，对于一些特殊的 Key 类型，我们有更好的实现，不需要那么复杂。</li>
<li>这个时候我们当然可以另外的去新建一个 (template) class，但是这样子程序员使用者就必须要知道这两个类的名字，还需要记住它们分别适用于哪些 Key</li>
<li>而模板特化呢，就允许我们使用相同的名字，但是里面的实现可以完全不一样！</li>
<li><mark>事实上，可以理解成编译器对于模板的特化是当做一个全新的 class 对待，因此里面的内容可以完全不同。</mark></li>
</ol>
<p>下面的代码介绍的就是特化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;               <span class="comment">// "Key" 已经被绑定了，所以这里尖括号里面是空白！</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些语法的说明</p>
<ol>
<li>模板那一行写得是 template&lt;&gt;, 其中的 <code>template</code> 告诉编译器后面跟着得是模板类型，留空的 <code>&lt;&gt;</code> 表示没有模板参数。（因为我们把唯一的 class Key 换成了一个具体的类型）。</li>
<li>hash 后面紧跟的尖括号里面具体给出了我们要建立一个怎样的 hash 类。</li>
</ol>
<h3 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization 偏特化"></a>partial specialization 偏特化</h3><p>两种“偏”</p>
<ol>
<li>个数上</li>
<li>范围上</li>
</ol>
<h4 id="个数上的偏"><a href="#个数上的偏" class="headerlink" title="个数上的偏"></a>个数上的偏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处省略了实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 特殊的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="范围上"><a href="#范围上" class="headerlink" title="范围上"></a>范围上</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是特化版本，针对指针类型的特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 这里的 T 只是一个名称而已，别跟上面弄混淆了，T 也可以改成 U 什么的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client 代码</span></span><br><span class="line">C&lt;<span class="built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure>

<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using directive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二 using declaration</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法三：不展开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Can-constructor-be-private"><a href="#Can-constructor-be-private" class="headerlink" title="Can constructor be private?"></a>Can constructor be private?</h3><p>constructor 会在创建一个当前类的对象的时候自动被调用。</p>
<p>虽然默认情况下 constructors 被定义在 public 区间，但是它其实是可以被定义在 private 区间的，下面介绍一下在什么情况下我们这么用！</p>
<h4 id="Using-Friend-Class"><a href="#Using-Friend-Class" class="headerlink" title="Using Friend Class"></a>Using Friend Class</h4><p>If we want that class should not be instantiated by anyone else but only by a friend class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        A a1;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出是</p>
<pre><code>constructor of A
constructor of B</code></pre><h4 id="Singleton-design-pattern"><a href="#Singleton-design-pattern" class="headerlink" title="Singleton design pattern"></a>Singleton design pattern</h4><p>这一个例子可以参考博客文章 <a href="https://zheng-xing.github.io/2020/01/15/design-pattern/" target="_blank" rel="noopener">design pattern</a>.</p>
<h4 id="Named-Constructor-Idiom"><a href="#Named-Constructor-Idiom" class="headerlink" title="Named Constructor Idiom"></a>Named Constructor Idiom</h4><p>如果有多个 Constructor 的时候容易出错，万一某两个的参数列表都一样咋整？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// ambiguous nature of constructor </span></span><br><span class="line"><span class="comment">// with same no of parameters of same type </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Rectangular coordinates </span></span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Polar coordinates (radius and angle) </span></span><br><span class="line">    Point(<span class="keyword">float</span> r, <span class="keyword">float</span> a);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// error: ‘Point::Point(float, float)’ cannot </span></span><br><span class="line">    <span class="comment">// be overloaded </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Ambiguous: Which constructor to be called ? </span></span><br><span class="line">    Point p = Point(<span class="number">5.7</span>, <span class="number">1.2</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个问题可以用下面的方法解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// named constructor idiom </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">float</span> x1, y1; </span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">    &#123; </span><br><span class="line">        x1 = x; </span><br><span class="line">        y1 = y; </span><br><span class="line">    &#125;; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// polar(radius, angle) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Polar</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular(x, y) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Rectangular</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function for displaying of coordinates </span></span><br><span class="line"><span class="keyword">void</span> Point :: <span class="built_in">display</span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"y :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return polar coordinates </span></span><br><span class="line">Point Point :: Polar(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x*<span class="built_in">cos</span>(y), x*<span class="built_in">sin</span>(y)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return rectangular coordinates </span></span><br><span class="line">Point Point :: Rectangular(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x,y); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Polar coordinates </span></span><br><span class="line">    Point pp = Point::Polar(<span class="number">5.7</span>, <span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"polar coordinates \n"</span>; </span><br><span class="line">    pp.<span class="built_in">display</span>(); </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular coordinates </span></span><br><span class="line">    Point pr = Point::Rectangular(<span class="number">5.7</span>,<span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangular coordinates \n"</span>; </span><br><span class="line">    pr.<span class="built_in">display</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是调用了 public 的函数而已，而这些函数会去调用定义在 private 区域的 Constructor.</p>
<h3 id="Constructor-Delegation"><a href="#Constructor-Delegation" class="headerlink" title="Constructor Delegation"></a>Constructor Delegation</h3><p>没想到这个东西是 C++ 11 才出现的。就是为了让一个 Constructor 去启动另个 Constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    A() </span><br><span class="line">    &#123; </span><br><span class="line">        x = <span class="number">0</span>; </span><br><span class="line">        y = <span class="number">0</span>; </span><br><span class="line">        z = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Constructor delegation  </span></span><br><span class="line">    A(<span class="keyword">int</span> z) : A() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;z = z; <span class="comment">// Only update z </span></span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; y &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; z; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line">    obj.show(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用 <code>A()</code> 要放到 initialization list 那里，不可以放到 <code>{}</code> 里面。</p>
<h3 id="conversion-function-转换函数"><a href="#conversion-function-转换函数" class="headerlink" title="conversion function 转换函数"></a>conversion function 转换函数</h3><p>从一个例子开始</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>) : m_denominator(den), m_numerator(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) (m_numerator) / (m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">4</span> + f;    <span class="comment">// 调用 operator double()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是解释</p>
<ol>
<li>转换函数不止可以是 <code>double</code> 类型，只要是之前出现过的，编译器认识的类型都可以去转换；</li>
<li>编译器在看到 <code>double d = 4 + f</code> 的时候会去看很多东西以确定这个操作是合理的<ol>
<li>比如它会去看有没有一个全局的函数重载了 <code>+</code>，这个函数会接受一个 <code>int</code> 和一个 <code>Fraction</code> 类别</li>
<li>它当然还会去看 <code>f</code> 能不能变成 int, float, double 的类型，这样子就可以跟 4 进行相加的操作了。</li>
</ol>
</li>
<li>如果你同时再定一个 <code>operator int() const{}</code> 转换函数，那么编译器会报错 <code>error: ambiguous overload for &#39;operator+&#39; (operand types are &#39;int&#39; and &#39;Fraction&#39;)</code>.</li>
</ol>
<h4 id="标准库的一个例子"><a href="#标准库的一个例子" class="headerlink" title="标准库的一个例子"></a>标准库的一个例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool, Alloc&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __bit_reference reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    reference <span class="keyword">operator</span>[] (size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + difference_type(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明一下</p>
<ol>
<li>上面这个例子用到了 proxy 设计模式，因为 operator[] 重载的函数需要返回 bool 值啊，这里却用了另一个 reference 代替返回的类型；</li>
<li>可是为什么 reference 类型的可以用在这里呢？明明需要返回的是 bool 类型？那么，reference 类型的类定义里面一定包含了如何将 bool 转换成 bool 类型的定义！！！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> !(!(*p &amp; mask));&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h3><p>explicit 关键字用途很窄，基本上都是用来放在 constructor 前面。</p>
<h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>一个正确的用法！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// 编译器看到这里会发现确实有个 + 运算符</span></span><br><span class="line">                            <span class="comment">// 调用 non-explicit constructor 将 4 转为 Fraction 类型</span></span><br><span class="line">                            <span class="comment">// 然后调用 operator+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs non-explicit-one-argument constructor"></a>conversion function vs non-explicit-one-argument constructor</h4><p>注意，下面这个代码会让编译器有歧义，它不知道该怎么处理.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit 在这里的意思是如果我没有显示地用你去做转换，编译器你不要自作聪明！</span></span><br><span class="line">    <span class="comment">// 不要调用我去把其他的 int 类型转变成 Fraction 类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! conversion from 'double' to 'Fraction' requested.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-11-explicit-for-ctors-taking-more-than-one-argument"><a href="#C-11-explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="C++11 explicit for ctors taking more than one argument"></a>C++11 explicit for ctors taking more than one argument</h4><p>上面的例子只针对有一个实参的 ctor. C++11 里面引入了多个实参的支持！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-explicit-keyword.png" alt=""></p>
<h3 id="range-based-for-C-11"><a href="#range-based-for-C-11" class="headerlink" title="range-based for C++11"></a>range-based for C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-1.png" alt=""><br>这个图解释了一下编译器会把 range based for 语句翻译成什么样子！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-2.png" alt=""></p>
<p>这个例子主要是用来说明 for loop 里面可能会报错，这个错误报错位置跟来源可能会在代码上离得比较远。<br>不过如果错误信息足够详细的话问题也不大！</p>
<h3 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h3><h4 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h4><p>这个代码来自于早期版本的标准库代码，C++ 2.0 (C++ 11) 以后改动了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : px(p) &#123;&#125;    <span class="comment">// 接受一个天然的指针！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="keyword">long</span>* pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;    <span class="comment">// 把 new 出来的指针包装成一个智能指针！</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line">    sp-&gt;method();    <span class="comment">// 变成 px-&gt;method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ol>
<li>任何一个智能指针类一定含有一个真正的指针在类里面；</li>
<li>任何一个智能指针类别一定有两个重载函数 <code>operator *()</code> 和 <code>operator-&gt;()</code>，并且它们的写法就跟这个例子里面一样；</li>
<li><mark>操作符 <code>-&gt;</code> 有个特点，它返回的东西可以接着用 <code>-&gt;</code>。比如这里的 <code>sp-&gt;method()</code> 中的 <code>sp-&gt;</code> 应该变成 <code>px</code>，但是这样子 <code>px</code> 怎么样去指向 <code>method</code> 呢，它还可以用 <code>-&gt;</code>。</mark></li>
</ol>
<h4 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator 迭代器"></a>iterator 迭代器</h4><p>迭代器要比智能指针多支持一些操作符！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;    <span class="comment">// 改个名而已</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;                       <span class="comment">// 真正的那个指针！！！</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node != x.node;&#125;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*node).data;        <span class="comment">// *node 返回的是 struct 的 object</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* prev;</span><br><span class="line">    <span class="keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用端的代码</span></span><br><span class="line"><span class="built_in">list</span>&lt;Foo&gt;::iterator ite;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">*ite;    <span class="comment">// 获得一个 Foo object</span></span><br><span class="line">ite-&gt;method();</span><br><span class="line">  <span class="comment">// 意思是调用 Foo::method()</span></span><br><span class="line">  <span class="comment">// 相当于 (*ite).method()</span></span><br><span class="line">  <span class="comment">// 相当于 (&amp;(*ite))-&gt;method()</span></span><br></pre></td></tr></table></figure>

<h3 id="function-like-classes-仿函数-functor"><a href="#function-like-classes-仿函数-functor" class="headerlink" title="function-like classes 仿函数 functor"></a>function-like classes 仿函数 functor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::second_type&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>辅助代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="base-classes-for-functor"><a href="#base-classes-for-functor" class="headerlink" title="base classes for functor"></a>base classes for functor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x - y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x == y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这些奇怪的 <code>unary_function</code> 和 <code>binary_function</code> 到底是个啥玩意？？？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处没有细讲，请参考侯捷老师专门的STL课程。</p>
<p>另外注意的是，这些class 没有成员变量的哦！只有一些 <code>typedef</code> 而已。</p>
<h2 id="object-relationships-有关"><a href="#object-relationships-有关" class="headerlink" title="object relationships 有关"></a>object relationships 有关</h2><h3 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h3><ol>
<li>Background<ol>
<li>Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.</li>
</ol>
</li>
<li>relationships between object<ol>
<li>a circle “is a “ shape</li>
<li>a house “has a” bedroom</li>
<li>I “use a” mechanical keyboard</li>
<li>mail “depend on” mailman to be delievered</li>
<li>I am “member of” Pingpang club</li>
</ol>
</li>
</ol>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><ol>
<li>主要用来描述 “has a” 关系的。<ol>
<li>Your computer “has a” CPU.</li>
<li>C++ concepts like structs and classes are both composite types.</li>
</ol>
</li>
<li>有两种 composition 子类<ol>
<li>composition</li>
<li>aggregation</li>
</ol>
</li>
<li>composition 子类满足条件<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time</li>
<li>The part (member) has its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
</li>
<li>说人话<ol>
<li>object 建立的时候创建 the part，object 摧毁的时候 part 也被摧毁</li>
<li>object manages part’s lifetime</li>
<li>part 不知道 object 的存在</li>
</ol>
</li>
</ol>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><p>Many games and simulations have creatures or objects that move around a board, map, or screen. One thing that all of these creatures/objects have in common is that they all have a location. In this example, we are going to create a creature class that uses a point class to hold the creature’s location.</p>
<p>First, let’s design the point class. Our creature is going to live in a 2d world, so our point class will have 2 dimensions, X and Y. We will assume the world is made up of discrete squares, so these dimensions will always be integers.</p>
<p>Point2D.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT2D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT2D_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// A default constructor</span></span><br><span class="line">    Point2D()</span><br><span class="line">        : m_x(<span class="number">0</span>), m_y(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// A specific constructor</span></span><br><span class="line">    Point2D(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        : m_x(x), m_y(y)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// An overloaded output operator</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access functions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Note that because we’ve implemented all of our functions in the header file (for the sake of keeping the example concise), there is no Point2D.cpp.</p>
<p>This Point2d class is a composition of its parts: location values x and y are part-of Point2D, and their lifespan is tied to that of a given Point2D instance.</p>
<p>Now let’s design our Creature. Our Creature is going to have a few properties: a name, which will be a string, and a location, which will be our Point2D class.</p>
<p>Creature.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CREATURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATURE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point2D.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    Point2D m_location;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Creature(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Point2D &amp;location)</span><br><span class="line">        : m_name(name), m_location(location)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Creature &amp;creature)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; creature.m_name &lt;&lt; <span class="string">" is at "</span> &lt;&lt; creature.m_location;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_location.setPoint(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p><mark>注意这里可以这么改写Code</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="title">printToStream</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  out &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">printToStream(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">point</span>);</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>[Variants on the composition theme]</strong></p>
<p>Although most compositions directly create their parts when the composition is created and directly destroy their parts when the composition is destroyed, there are some variations of composition that bend these rules a bit.</p>
<p>For example:</p>
<ol>
<li>A composition may defer creation of some parts until they are needed. For example, a string class may not create a dynamic array of characters until the user assigns the string some data to hold.</li>
<li>A composition may opt to use a part that has been given to it as input rather than create the part itself.</li>
<li>A composition may delegate destruction of its parts to some other object (e.g. to a garbage collection routine).</li>
</ol>
<p>The key point here is that the composition should manage its parts without the user of the composition needing to manage anything.</p>
<p><strong>[Composition and subclasses]</strong></p>
<p>One question that new programmers often ask when it comes to object composition is, “When should I use a subclass instead of direct implementation of a feature?”. For example, instead of using the Point2D class to implement the Creature’s location, we could have instead just added 2 integers to the Creature class and written code in the Creature class to handle the positioning. However, making Point2D its own class has a number of benefits:</p>
<ol>
<li>Each individual class can be kept relatively simple and straightforward, focused on performing one task well. This makes those classes easier to write and much easier to understand, as they are more focused. For example, Point2D only worries about point-related stuff, which helps keep it simple. <mark>可以找人去负责 Point2D class, 另外的人去负责 Creature class.</mark></li>
<li>Each subclass can be self-contained, which makes them reusable. For example, we could reuse our Point2D class in a completely different application. Or if our creature ever needed another point (for example, a destination it was trying to get to), we can simply add another Point2D member variable.</li>
<li>The parent class can have the subclasses do most of the hard work, and instead focus on coordinating the data flow between the subclasses. This helps lower the overall complexity of the parent object, because it can delegate tasks to its children, who already know how to do those tasks. For example, when we move our Creature, it delegates that task to the Point class, which already understands how to set a point. Thus, the Creature class does not have to worry about how such things would be implemented.</li>
</ol>
<p>A good rule of thumb is that each class should be built to accomplish a single task. That task should either be the storage and manipulation of some kind of data (e.g. Point2D, std::string), OR the coordination of subclasses (e.g. Creature). Ideally not both.</p>
<p>In this case of our example, it makes sense that Creature shouldn’t have to worry about how Points are implemented, or how the name is being stored. Creature’s job isn’t to know those intimate details. Creature’s job is to worry about how to coordinate the data flow and ensure that each of the subclasses knows what it is supposed to do. It’s up to the individual subclasses to worry about how they will do it.</p>
<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p><strong>[满足条件]</strong></p>
<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can belong to more than one object (class) at a time</li>
<li>The part (member) does not have its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
<p><strong>[与 composition 异同]</strong></p>
<ol>
<li>共同点<ol>
<li>都是 part-whole 关系</li>
</ol>
</li>
<li>不同点<ol>
<li>parts 可以同时属于多个 object</li>
<li>object 不负责创建和摧毁 parts</li>
</ol>
</li>
</ol>
<p><strong>[具体例子]</strong></p>
<ol>
<li>每个人都有个家庭住址，但是家庭住址可以属于多个人。</li>
<li>人住进来之前家庭地址就存在了</li>
<li>人搬走后家庭地址依然存在</li>
<li>人知道他住在哪里，而一个家庭地址不知道住的是谁(假定是这样子的)</li>
</ol>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>Because aggregations are similar to compositions in that they are both part-whole relationships, they are implemented almost identically, and the difference between them is mostly semantic. In a composition, we typically add our parts to the composition using normal member variables (or pointers where the allocation and deallocation process is handled by the composition class).</p>
<p>In an aggregation, we also add parts as member variables. However, these member variables are typically either references or pointers that are used to point at objects that have been created outside the scope of the class. Consequently, an aggregation usually either takes the objects it is going to point to as constructor parameters, or it begins empty and the subobjects are added later via access functions or operators.</p>
<p>Because these parts exist outside of the scope of the class, when the class is destroyed, the pointer or reference member variable will be destroyed (but not deleted). Consequently, the parts themselves will still exist.</p>
<p>Let’s take a look at a Teacher and Department example in more detail. In this example, we’re going to make a couple of simplifications: First, the department will only hold one teacher. Second, the teacher will be unaware of what department they’re part of.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Teacher *m_teacher; <span class="comment">// This dept holds only one teacher for simplicity, but it could hold many teachers</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Department(Teacher *teacher = <span class="literal">nullptr</span>)</span><br><span class="line">        : m_teacher(teacher)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a teacher outside the scope of the Department</span></span><br><span class="line">    Teacher *teacher = <span class="keyword">new</span> Teacher(<span class="string">"Bob"</span>); <span class="comment">// create a teacher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a department and use the constructor parameter to pass</span></span><br><span class="line">        <span class="comment">// the teacher to it.</span></span><br><span class="line">        <span class="function">Department <span class="title">dept</span><span class="params">(teacher)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// dept goes out of scope here and is destroyed</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Teacher still exists here because dept did not delete m_teacher</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; teacher-&gt;getName() &lt;&lt; <span class="string">" still exists!"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> teacher;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里假定了 teacher 不知道工作的 department.</p>
<h4 id="总结-composition-和-aggregation"><a href="#总结-composition-和-aggregation" class="headerlink" title="总结 composition 和 aggregation"></a>总结 composition 和 aggregation</h4><ol>
<li>compositions<ol>
<li>Typically use normal member variables</li>
<li>Can use pointer members if the class handles object allocation/deallocation itself</li>
<li>Responsible for creation/destruction of parts</li>
</ol>
</li>
<li>Agreegations<ol>
<li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregate class</li>
<li>Not responsible for creating/destroying parts</li>
</ol>
</li>
</ol>
<p>It is worth noting that the concepts of composition and aggregation are not mutually exclusive, and can be mixed freely within the same class. It is entirely possible to write a class that is responsible for the creation/destruction of some parts but not others. For example, our Department class could have a name and a Teacher. The name would probably be added to the Department by composition, and would be created and destroyed with the Department. On the other hand, the Teacher would be added to the department by aggregation, and created/destroyed independently.</p>
<p>While aggregations can be extremely useful, they are also potentially more dangerous. Because aggregations do not handle deallocation of their parts, that is left up to an external party to do so. If the external party no longer has a pointer or reference to the abandoned parts, or if it simply forgets to do the cleanup (assuming the class will handle that), then memory will be leaked.</p>
<p>For this reason, compositions should be favored over aggregations.</p>
<h3 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h3><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h3 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation 委托"></a>Delegation 委托</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-relation-delegation.png" alt=""></p>
<p>图的注解：</p>
<ol>
<li>“pimpl”: pointer to implementation</li>
<li>这个概念跟 composition 其实只有一点微妙的区别，一个含有 object, 一个含有指针。</li>
<li>图中左下角介绍的东西有点类似 shared ptr 啊，三个指针指向同一个东西。如果有一个要改动东西，那么会发生 “copy on write”，即拷贝一个出来让它修改。</li>
</ol>
<h2 id="class-有关"><a href="#class-有关" class="headerlink" title="class 有关"></a>class 有关</h2><h3 id="概念题"><a href="#概念题" class="headerlink" title="概念题"></a>概念题</h3><p>[Differnce with struct]</p>
<ol>
<li>The only difference between “class” and “struct” is whether the beginning content in the class body (before first appearance of “private”/“public” keyword) is public or private. For class, that part is private. For struct, that part is public.</li>
</ol>
<p>[Method 定义的位置]</p>
<ol>
<li>定义在 class body 中的话，是要求这些 function become inline, thus avoid function call overhead.</li>
<li>定义在 class body 外的话，就会有 function call.</li>
</ol>
<p>[Compiler generated functions]</p>
<ol>
<li>Compilter silently write 4 functions if they are not explicitly declared:<ol>
<li>Copy constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Default Constructor (Only if there is no constructor declared)<ol>
<li>If there exists copy constructor, then compiler will not generate default constructor.</li>
<li>However, if there exists some constructor (not copy constructor), compiler will generate copy constructor if needed.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="不同关系下的构造与析构函数"><a href="#不同关系下的构造与析构函数" class="headerlink" title="不同关系下的构造与析构函数"></a>不同关系下的构造与析构函数</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-composition.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance-and-composition.png" alt=""></p>
<h3 id="虚指针和虚函数表"><a href="#虚指针和虚函数表" class="headerlink" title="虚指针和虚函数表"></a>虚指针和虚函数表</h3><p>多态背后的技术叫做动态绑定！底层的实现是使用虚函数表。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了实现C++的多态<mark>（关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>）</mark>，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h4 id="类的虚表"><a href="#类的虚表" class="headerlink" title="类的虚表"></a>类的虚表</h4><p>每个包含了虚函数的类都包含一个虚表。</p>
<p>我们知道，当一个类 A 继承另一个类 B 时，类 A 会继承类 B 的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可以调用这些虚函数。<br>换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>简单的例子，看一下下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，类 <code>A</code> 有虚函数，因此它有一个虚表。</p>
<p>类 <code>A</code> 的虚表如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png" alt=""></p>
<p><mark>虚表是一个指针数组，其元素是虚函数的指针。每个元素对应一个虚函数的函数指针。<br>需要指出的是，普通的函数，即非虚函数，其调用并不需要经过虚表。<br>因此虚表的元素并不包括普通函数的函数指针。</mark></p>
<h4 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h4><p><mark>虚表是属于类的，而不是属于某个具体的对象！一个类只需要一个虚表即可！同一个类的所有对象都使用同一个虚表。</mark></p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，<mark>编译器在类中添加了一个指针，<code>*__vptr</code>, 用来指向虚表。</mark><br>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png" alt=""></p>
<p>再重复一遍！一个继承类的基类如果包含虚函数，那么这个继承类也有自己的虚表，这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>下面讲一下 C++ 是如何利用虚表和虚表指针实现动态绑定的。先看一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 A 是基类，类 B 继承类 A，类 C 又继承类 B。<br>它们三个的对象模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png" alt=""></p>
<p>[关于上图的几点说明]</p>
<ol>
<li>由于<mark>这三个类都有虚函数，故编译器为每个类都创建了一个虚表</mark>，即类 A 有虚表 vtbl_A, 类 B 有虚表 vtbl_B, 类 C 有虚表 vtbl_C. 类A, B, C 的<code>对象</code>都拥有一个虚表指针， <code>*__vptr</code>, 用来指向自己所属类的虚表。</li>
<li>图中最左边一列给出了三个类的各自的一个对象。其中 B 类对象 b 中黑框圈中的部分是基类的内容。C 类对象 c 里面黑框圈中的部分是基类 B 的内容。</li>
<li>类 A 包括两个虚函数，故 vtbl_A 包含两个指针，分别指向 A::vfunc1() 和 A::vfunc2().</li>
<li>类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 vtbl_B 的两个指针分别指向 B::vfunc1() 和 A::vfunc2().</li>
<li>类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故 vtbl_C 的两个指针分别指向 B::vfunc1() (指向继承的最近的一个类的函数) 和 C::vfunc2().</li>
<li>因此一共有四个非虚函数，以及四个虚函数。</li>
<li>图三看起来有点复杂，但是核心还是：<mark>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</mark>。抓住这个核心思想，就可以快速将这几个类的对象模型在脑中想象出来！</li>
<li>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</li>
</ol>
<p>假设我们定义一个类 B 的对象如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>这里要注意了，虽然 <code>p</code> 是基类的指针，只能指向基类的部分，但是虚表指针也属于基类的部分，亦即 <code>b</code> 实例内存中的虚表指针也属于基类部分。所以 <code>p</code> 可以访问到对象 <code>bObject</code> 的虚表指针. <code>bObject</code> 的虚表指针指向类 <code>B</code> 的虚表，所以 <code>p</code> 可以访问到 <code>vtbl_B</code>. </mark></p>
<p>当我们使用 <code>p</code> 来调用 <code>vfunc1()</code> 函数时候，会发横什么现象?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在执行 <code>p-&gt;vfunc1()</code> 时会发现 <code>p</code> 是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤：</p>
<ol>
<li>首先，根据虚表指针 <code>p-&gt;__vptr</code> 来访问对象 <code>bObject</code> 对应的虚表。虽然指针 <code>p</code> 是基类 <code>A*</code> 类型，但是 <code>*__vptr</code> 也是基类的一部分，所以可以通过 <code>p-&gt;__vptr</code> 访问到对象对应的虚表。</li>
<li>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 <code>p-&gt;vfunc1()</code> 的调用，<code>vtbl_B</code> 的第一项即是 <code>vfunc1</code> 对应的条目。</li>
<li>最后，根据虚表中找到的函数指针，调用函数。从上图可以看出，<code>vtbl_B</code> 的第一项指向 <code>B::vfunc1()</code>，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>B::vfunc1()</code> 函数。</li>
</ol>
<p>而如果 <code>p</code> 指向类 <code>A</code> 的对象，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; aObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>aObject</code> 在创建时，它的虚表指针 <code>__vptr</code> 已设置为指向 <code>vtbl_A</code>，这样 <code>p-&gt;__vptr</code> 就指向 <code>vtbl_A</code>. <code>vfunc1</code> 在 <code>vtbl_A</code> 对应的条目指向了 <code>A::vfunc1()</code> 函数，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>A::vfunc1()</code> 函数。</p>
<p><mark>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。</mark></p>
<p>[动态绑定]</p>
<ol>
<li>先明确<code>静态绑定</code>。编译器对静态绑定的处理是会生成一个 <code>call some_address</code> 的汇编命令。这个 <code>some_address</code> 是固定了的。</li>
<li>而我们把<mark>经过虚表调用虚函数的过程称为动态绑定</mark>，其表现出来的现象称为<mark>运行时多态</mark>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</li>
</ol>
<p>那么，<mark>什么时候会执行函数的动态绑定？</mark>这需要符合以下三个条件。</p>
<ol>
<li>通过指针来调用函数</li>
<li>指针 upcast 向上转型（继承类向基类的转换称为 upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h4 id="基类指针调用子类非虚函数"><a href="#基类指针调用子类非虚函数" class="headerlink" title="基类指针调用子类非虚函数"></a>基类指针调用子类非虚函数</h4><p>使用基类的指针可以去调用子类的非虚函数吗？<br>回忆一下好像没有这么用过，一直都是拿基类指针调用了子类的虚函数。</p>
<p>事实上这个是可以的。但是要注意，<mark>此时被调用的函数实际上是基类的函数！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123;x=i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class show():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class virtual display():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> i,<span class="keyword">int</span> j):A(i) &#123; y=j;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class show(): y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="comment">//前面有无virtual都可以</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class virtual display():y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a(5),*pa;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    pa=&amp;b;</span><br><span class="line">    pa-&gt;show();</span><br><span class="line">    pa-&gt;<span class="built_in">display</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<ol>
<li>这个例子里面类 B 继承了类 A，而类 A 和类 B 都有一个 show() 函数。</li>
<li>类B的实例 <code>b</code> 里面含有基类部分，也含有自己的部分。注意了！<mark>基类部分里面含有一个虚表指针，也含有一个 A::show()；而子类的部分呢含有 B::show()。</li>
<li><code>pa</code> 是基类的指针，因此指向的是子类实例<code>b</code>中的基类部分那一块！所以调用的 <code>pa-&gt;show()</code> 是基类的 <code>A::show()</code>。</li>
<li>而 <code>pa-&gt;display()</code> 则通过基类部分的虚表指针指向了子类 <code>B</code> 的虚函数表，然后调用到了 <code>B::display()</code>。</li>
</ol>
<p>最终的输出是</p>
<pre><code>A class show():x=10
B class virtual display():y=20</code></pre><p>[总结]<br>基类的指针指向派生类的对象，当调用同名的成员函数时：</p>
<ol>
<li>如果在基类中成员函数为<font color='red'>虚函数</font>，那么基类指针调用的就是<font color='red'>派生类</font>的同名函数。<code>virtual void display()</code>;<ol>
<li>可以这么理解：因为该函数是虚的，所以会找真正实现的那个函数，所以调用派生类B中的 B class virtual display.</li>
</ol>
</li>
<li>如果基类中成员函数为<font color='red'>非虚函数</font>，则调用的是<font color='red'>基类</font>的成员函数。<code>void show()</code>;<ol>
<li>因为基类是非虚的，已经完全实现了，所以没有必要再调用派生类的了，就调用基类的A class show()</li>
</ol>
</li>
</ol>
<h4 id="底层解释-汇编语言"><a href="#底层解释-汇编语言" class="headerlink" title="底层解释-汇编语言"></a>底层解释-汇编语言</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-2.png" alt=""></p>
<h4 id="用-C-能实现吗"><a href="#用-C-能实现吗" class="headerlink" title="用 C 能实现吗?"></a>用 C 能实现吗?</h4><p>如果我们不使用这一套体系，用 C 一般怎么实现用一个指针的列表去访问各个子类的函数呢？</p>
<p>通常情况下我们必须针对每个指针，通过一系列的 if else 语句先去判断是哪一类对象的函数，然后再去调用相应的函数。</p>
<p>但是这样子不好的是，如果后来又新加了一个类别，那么我们就必须去重新改动 if else 那一部分的代码，多添加一个 else 语句去支持新增加的类别。</p>
<h4 id="虚函数另一用法-template-method"><a href="#虚函数另一用法-template-method" class="headerlink" title="虚函数另一用法: template method"></a>虚函数另一用法: template method</h4><p>这里的 template method 是一种设计模式，具体可以参考<a href="https://zheng-xing.github.io/2020/01/15/design-pattern/#Template-Method" target="_blank" rel="noopener">here</a>.</p>
<h3 id="构造函数可以是虚函数吗？"><a href="#构造函数可以是虚函数吗？" class="headerlink" title="构造函数可以是虚函数吗？"></a>构造函数可以是虚函数吗？</h3><h4 id="C-不可以"><a href="#C-不可以" class="headerlink" title="C++ 不可以"></a>C++ 不可以</h4><p>简答回答是不可以！C++ 的作者在他<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener">个人主页</a>已经回答了，原样复制过来</p>
<p>A virtual call is a mechanism to get work done given partial information. In particular, “virtual” allows us to call a function knowing only an interfaces and not the exact type of the object. <mark>To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a “call to a constructor” cannot be virtual.</mark></p>
<p>意思就是，虚拟函数调用只需要知道部分信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。<br>如果你调用一个虚拟构造函数，编译器怎么知道你想构建继承树上的哪种类型呢？所以这在逻辑上是一个悖论。</p>
<p>Techniques for using an indirection when you ask to create an object are often referred to as “Virtual constructors”. For example, see TC++PL3 15.6.2.</p>
<p>For example, here is a technique for generating an object of an appropriate type using an abstract class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span>  <span class="comment">// interface to object creation functions</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user</span><span class="params">(<span class="keyword">const</span> F&amp; fac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* p = fac.make_an_A(); <span class="comment">// make an A of the appropriate type</span></span><br><span class="line">    B* q = fac.make_a_B();  <span class="comment">// make a B of the appropriate type</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FX</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AX(); &#125; <span class="comment">// AX is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BX();  &#125; <span class="comment">// BX is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FY</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AY(); &#125; <span class="comment">// AY is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BY();  &#125; <span class="comment">// BY is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FX x;</span><br><span class="line">    FY y;</span><br><span class="line">    user(x);    <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(y);    <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line"></span><br><span class="line">    user(FX()); <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(FY()); <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a variant of what is often called “the factory pattern”. The point is that user() is completely isolated from knowledge of classes such as AX and AY.</p>
<h4 id="Delphi-却支持"><a href="#Delphi-却支持" class="headerlink" title="Delphi 却支持"></a>Delphi 却支持</h4><p>那么Delphi为什么能够支持虚拟构造函数呢？Delphi有一种类类型，储存着某个类的meta data。<br>TClass是所有自定义类类型（不是自定义类型）的祖先类。构建一个新对象的时候，事实上是调用TClass的某个子类（即自定义类类型）的虚拟Create方法，而这个子类储存了相关类的meta<br>data，因此避免了“虚拟构造函数不知道具体类型信息”的问题。这可以视为factory<br>pattern的一种通用实现，在语言级别非常优雅和完美地解决了这个问题。</p>
<p>资料来自<a href="https://www.zhihu.com/question/35632207/answer/63936329" target="_blank" rel="noopener">这里</a></p>
<h1 id="fundamental-concept-基本概念"><a href="#fundamental-concept-基本概念" class="headerlink" title="fundamental concept 基本概念"></a>fundamental concept 基本概念</h1><h2 id="heap-or-stack-memory"><a href="#heap-or-stack-memory" class="headerlink" title="heap or stack memory"></a>heap or stack memory</h2><p><mark>C语言里面不能把一个很长的 array 放到 stack 上。</mark></p>
<p>使用 C 语法时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一个语句会出现 stack overflow 错误</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式一</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="built_in">malloc</span>(<span class="number">1000000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式二</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式三</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">1000000</span>];  <span class="comment">// allocated in data segment</span></span><br></pre></td></tr></table></figure>

<p>使用 C++ STL 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// will allocate the vector, i.e. the header info, on the stack, but the elements on the free store "heap".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * vect = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// allocates everything on the free store.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>*&gt; vect;</span><br><span class="line"><span class="comment">// will allocate the vector on the stack and a bunch of pointers on the free store</span></span><br><span class="line"><span class="comment">// But where these pointer is determined by how you use them</span></span><br><span class="line"><span class="comment">// You could point element 0 to the free store and element 1 to the stack.</span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-and-std-nullptr-t-C-11"><a href="#nullptr-and-std-nullptr-t-C-11" class="headerlink" title="nullptr and std::nullptr_t (C++11)"></a>nullptr and std::nullptr_t (C++11)</h2><ol>
<li>C++11 允许使用 nullptr 来代替 0 或者 NULL，to specify that a pointer refers to no value (which differs from having an undefined value). This new feature especially helps to avoid mistakes that occurred when a null pointer was interpreted as an integral value. </li>
</ol>
<p>举例来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有如下两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方式会调用到哪个函数呢？</span></span><br><span class="line">f(<span class="number">0</span>);          <span class="comment">// calls f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>);       <span class="comment">// calls f(int) if NULL is 0, ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>);    <span class="comment">// calls f(void*)</span></span><br></pre></td></tr></table></figure>

<ol>
<li><font color='red'>nullptr</font> is a new keyword. It automatically converts into each pointer type but not to any integral type. It has type <font color='red'>std::nullptr_t</font>, defined in <code>&lt;</code><font color='red'>cstddef</font><code>&gt;</code>, so you can now even overload operations for the case that a null pointer is passed. Note that <font color='red'>std::nullptr_t</font> counts as a fundamental data type.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/stddef.h 文件包含有如下语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure>


<h2 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h2><p>Most of the times compilers will do optimization to the code to speed up the program. For example in the below code,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>( a == <span class="number">10</span>)&#123;</span><br><span class="line">     <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compiler may think that value of ‘a’ is not getting changed from the program and replace it with ‘while(true)’, which will result in an infinite loop. In actual scenario the value of ‘a’ may be getting updated from outside of the program.<br>Volatile keyword is used to tell compiler that the variable declared using volatile may be used from outside the current scope so that compiler wont apply any optimization. This matters only in case of multi-threaded applications.<br>In the above example if variable ‘a’ was declared using volatile, compiler will not optimize it. In shot, value of the volatile variables will be read from the memory location directly.</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>此处参考了《Effective C++》.</p>
<h3 id="什么是-const"><a href="#什么是-const" class="headerlink" title="什么是 const"></a>什么是 const</h3><p><code>const</code> objects 就是这个 object 不能被改变，<mark>编译器在编译的时候会检查程序有没有试图去修改 object 的内容</mark>。</p>
<p>如果你声明某个 variable 是 const，在声明的那个语句中你就必须给它初始化！因为后面你就没有机会再修改了！编译器会发现你试图对 <code>const</code> object 修改，就编译错误！</p>
<h3 id="几种用途"><a href="#几种用途" class="headerlink" title="几种用途"></a>几种用途</h3><p><code>const</code> 可以用在如下几个地方:</p>
<ol>
<li>Outside of classes, we can use it for constants at global or namespace scope.</li>
<li>For objects declared <code>static</code> at file, function, or block scope.</li>
<li>Inside classes, can be used for both static and non-static data members.</li>
</ol>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, non-const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// constant pointer, non-constant data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子就需要记住一点: <mark> 如果 <code>const</code> 出现在 <code>*</code> 的左边，那么数据是 <code>const</code> 的；如果 <code>const</code> 在 <code>*</code> 的右边，那么指针是 <code>const</code> 的。</mark></p>
<font color='red'>
    易混淆！当数据是 `const` 时候，`type` 和 `const` 这两个先后顺序可以改变的。谁在前面都一样。
</font>

<p>看这个例子，两种表示方式没有区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Widget <span class="keyword">const</span> *pw)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const iterator"></a>const iterator</h3><p><mark>注意 STL iterator 有专门的 <code>const_iterator</code> 语法，表示这个迭代器不会修改 container 里面的数据内容。直接在普通 iterator 的前面加上 <code>const</code> 的意思是另外一种，表示这个迭代器本身是 constant 的。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// iter acts like a T* const, 即指针是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 操作可以执行。因为数据不是 const</span></span><br><span class="line">++iter;                                            <span class="comment">// 报错！iter 是 const 类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">// cIter acts like a const T*, 即数据是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 报错！*cIter is const</span></span><br><span class="line">++iter;                                            <span class="comment">// 没毛病! 改变指针</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><mark>If the container itself is const, you can only use const iterator to access its elements.</mark></li>
<li>==begin()== returns const_iterator if the container is const, and returns non-const iterator if the container is not const. (But you can always use ==auto==)</li>
<li>cbegin(), cend() returns const_iterator.</li>
</ol>
<h3 id="类成员函数的-const"><a href="#类成员函数的-const" class="headerlink" title="类成员函数的 const"></a>类成员函数的 const</h3><p><mark>某些类里面的函数要不要加 const 并不是无所谓的！！！</mark>见这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class complex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    complex(double r &#x3D; 0, double i &#x3D; 0) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    complex&amp; operator +&#x3D; (const complex&amp;);</span><br><span class="line">    double real() const &#123;return m_r;&#125;</span><br><span class="line">    double imag() const &#123;return m_i;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_r, m_i;</span><br><span class="line">    friend complex&amp; __doapl (complex*, const complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    const complex c1(2, 1);</span><br><span class="line">    cout &lt;&lt; c1.real();</span><br><span class="line">    cout &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>因为这里 complex c1 被声明成了 const 类型，那么作用在这个 object 身上的所有函数也都必须声明成 const 类型，不管这个函数本身是否有修改 c1 内容！！！所以 real() 的定义必须加上 const, 这个例子里面是加了的。如果没加的话就会有错。</mark></p>
<p><font color='red'>这个例子告诉我们，在设计成员函数的时候，可以加 <code>const</code> 的时候一定要加上，以避免其他使用者犯错。他们会觉得这是类设计者的错误！</font></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-const-intro.png" alt="const"></p>
<h3 id="不加const为啥不行"><a href="#不加const为啥不行" class="headerlink" title="不加const为啥不行"></a>不加const为啥不行</h3><ol>
<li>上面也提到了，一旦某些时候你把一个 object 声明成了 const，那么这个 object 只能调用那些 const 成员函数。<ol>
<li>至于什么时候会把一个 <code>object</code> 声明成 <code>const</code>。比如函数调用时候，pass by reference to const.</li>
</ol>
</li>
</ol>
<p>第二个例子，重载乘法运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rational a, b, c;</span><br><span class="line">    <span class="keyword">if</span>(a * b = c)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子里面，由于程序员不小心把<code>==</code> 写成了 <code>=</code>。这个时候如果你按照上面把乘法运算符重载后，返回的是 <code>const</code> 类型，那么编译器在这里就会提醒你不能给 <code>a*b</code> 的结果赋值，方便你检查出这个 typo 了。</p>
<p>而如果你没有把返回值定义成 <code>const</code> 类型，就会</p>
<h3 id="physical-vs-logical-constness"><a href="#physical-vs-logical-constness" class="headerlink" title="physical vs logical constness"></a>physical vs logical constness</h3><p>编译器只会检查 physical constness 或者叫做 bitwise constness. 即检查是否对一个 const object 的直接内容作了修改。<br>如果没有，就可以编译通过。</p>
<p><mark>但是！如果类对象里含有指针，那么对指针指向的空间的内容进行修改，编译器是不会报错的！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pString[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 operator[] 的定义里面并没有修改内容啊，所以编译器不报错。</span></span><br><span class="line"><span class="comment">// 但是</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> MyString <span class="title">str</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;str[<span class="number">0</span>];</span><br><span class="line">    *pc = <span class="string">"J"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数里面事实上修改了 str 的内容，这与 str 是一个 const object 矛盾了！！！</span></span><br><span class="line"><span class="comment">// 可惜编译器发现不了这个问题！！！</span></span><br></pre></td></tr></table></figure>

<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>有时候你希望 const object 的意思是对 object 的某些数据内容不能修改，但是 object 可能也含有一些辅助数据，你希望 const 不作用在它们上面，那怎么办呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> strLength;        <span class="comment">// these data members may always be modified,</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;      <span class="comment">// even in const member functions</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">MyString::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;     <span class="comment">// 如果没有上面的 mutable 关键字，那么这个函数是 const 类型</span></span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;              <span class="comment">// 不可以对变量 strLength, lengthIsValid 进行修改！</span></span><br><span class="line">        strLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pString);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="noexcept-c-11"><a href="#noexcept-c-11" class="headerlink" title="noexcept c++11"></a>noexcept c++11</h2><p>注：</p>
<ol>
<li>第一个图中这个例子好二啊！就想说：当我不暴怒的时候我是不会暴怒的。。。</li>
<li>第二个图里之所以定义了两个 move constructor 是因为作者肯定发现了某种比 copy constructor 更高效的实现方法（这里并没有给出细节）。<ol>
<li>这个时候为了让编译器去调用这个 move constructor 就需要加上 noexcept 关键字。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-noexcept.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-noexcept-2.png" alt=""></p>
<h2 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h2><ol>
<li>相同 class 的各个 objects 互为 friends（友元）。</li>
</ol>
<h2 id="三种-function-parameters"><a href="#三种-function-parameters" class="headerlink" title="三种 function parameters"></a>三种 function parameters</h2><ol>
<li>someFunction(vector<double> vec)</li>
<li>someFunction(const vector<double>&amp; vec)</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Local variables that are declared to be static </span></span><br><span class="line"><span class="comment">are preserved across invocations of the function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thus, we'll construct and initialize the string name</span></span><br><span class="line"><span class="comment">only on the first call to someFunction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">someFunction</span><span class="params">(balabala)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> name = <span class="string">"Zheng Xing"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-static-intro.png" alt=""></p>
<p>注意点：</p>
<ol>
<li>non-static data members 存在于每个 instances object 里面；而 static data members, member functions, static member functions 是 class 拥有的，所有的 instances 共享！</li>
<li>什么时候使用 static data members<ol>
<li>当你这一个 class 的所有 objects 都拥有并且一样的那些数据</li>
</ol>
</li>
<li>什么时候用 static member functions<ol>
<li><mark> static member function 与正常的 member functions 的区别在于静态的函数没有 this 指针，因此也就无法访问非静态的数据，它只能够处理 static data members.</li>
</ol>
</li>
<li>调用 static member functions的两种方法<ol>
<li>通过 class name 调用</li>
<li>通过 object 调用</li>
<li>参考下面的代码</li>
</ol>
</li>
<li>一个概念<ol>
<li>Static objects inside functions are known as local static objects (because they’re local to a function).</li>
<li>The other kinds of static objects are known as non-local static objects.</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Account::set_rate(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    Account a;</span><br><span class="line">    a.set_rate(<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个经典的应用是设计 Singleton 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">setup</span>() &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A();</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A::getInstance().setup();</span></span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li>reference data must be assigned at initialization</li>
<li>reference data cannot be reassigned</li>
</ol>
<p>注意两个概念</p>
<ol>
<li>return by value vs return by reference (to const)</li>
<li>pass by value vs pass by reference</li>
</ol>
<p>reference 有指针的速度，同时使用的时候很方便，在传递的时候不需要知道类型到底是 value 还是 reference。</p>
<p><mark> 函数是否返回 reference 要看你是不是在函数里面搞了一个临时变量，是的话，千万不能返回 reference.</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; a, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.real() + b.real(), a.imag() + b.imag());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>same signature</mark><br>下面两个函数不能同时存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span> </span>&#123;&#125;    <span class="comment">// Ambiguity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多提一句，可以通过添加 const 来区别两个函数。</span></span><br><span class="line"><span class="comment">// 比如下面两个函数是不同的，编译器不会报错。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="and-初始化方法"><a href="#and-初始化方法" class="headerlink" title="() and = 初始化方法"></a>() and = 初始化方法</h2><ol>
<li>container<T> c(c2)<ol>
<li>defines c as a container that is a copy of c2</li>
</ol>
</li>
<li>container<T> c = c2<ol>
<li>same</li>
</ol>
</li>
</ol>
<h2 id="default-value-initialization"><a href="#default-value-initialization" class="headerlink" title="default/value initialization"></a>default/value initialization</h2><ol>
<li>local variables of built-in type that are not explicitly initialized are undefined.</li>
<li>class type says what initializer to use if there is not one specified.</li>
<li>(Accerated C++, P125) When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is ==value-initialized==, which, for simple types such as int, is equivalent to setting the value to zero.</li>
</ol>
<h2 id="overloading-1"><a href="#overloading-1" class="headerlink" title="overloading"></a>overloading</h2><p>Several functions with the same name.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r, m_i;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doapl (<span class="built_in">complex</span>*, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; __doapl(<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;        <span class="comment">// 返回指针所指向的东西！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; complext::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>, r);    <span class="comment">// 任何一个成员函数都有一个隐藏的 this 指针！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"("</span> &lt;&lt; real(x) &lt;&lt; <span class="string">","</span> &lt;&lt; imag(x) &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.real();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里操作符 &lt;&lt; 的结果可以返回 ostream reference.</p>
<p><mark>注意，操作符 += 的重载的返回值不能是 void 类型哦！你要考虑到有人可能会连续加的情况！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 += c2 += c1;</span><br></pre></td></tr></table></figure>

<h3 id="重载-lt-lt-符号"><a href="#重载-lt-lt-符号" class="headerlink" title="重载 &lt;&lt; 符号"></a>重载 &lt;&lt; 符号</h3><p>此处的东西来自<a href="https://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">这里</a>.</p>
<p>最简单的思想：若想去打印 object 内容，我们可以定义一些 public 方法去获得私有变量内容，然后输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现支持我们这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; <span class="built_in">point</span>.getX() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getY() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getZ() &lt;&lt; <span class="string">")"</span>;</span><br></pre></td></tr></table></figure>

<p>进阶思路一：能不能定一个函数来重复使用呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">", "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>注意 print 虽然写到了 class 定义里面，但是它不是 member function。</mark></p>
<p>上面的思路确实比最初的思路好了，但是它的缺点在于我们不能在 cout 的中间使用，必须得这么用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span>;                <span class="comment">// 这里要分成三个命令来写，不能串起来了。。。</span></span><br><span class="line">    point.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶思路二：能不能这样子写？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span> &lt;&lt; <span class="built_in">point</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br></pre></td></tr></table></figure>

<p>答案是可以的，就是去重载 &lt;&lt; 操作符。</p>
<p><mark>[几个注意点]</mark></p>
<ol>
<li><font color="red">重载函数的定义最开始要注明 friend 关键字，因为这个函数要获得私有变量信息！</font></li>
<li><font color="red">这个重载函数不能定义成 member function, 即不能加上 “String::operator&lt;&lt;”, 因为 member function 自动得把当前 object 作为第一个参数传递给函数。<ol>
<li>这样子首先顺序就不对了，因为我们希望 cout 作为第一个参数，</li>
<li>其次呢，我们如果放两个参数进去 cout 和 Point&amp; ，但是调用这个函数的 object 本身也会传递一个 this，这样子就变成三个参数了。 </font></li>
</ol>
</li>
<li><font color="red">注意返回的类型是 reference 类型，不能是 void，否则无法使用多个操作符串起来用！！！也不能返回 value 类型，因为 cout 本身也不允许 being copied.</font></li>
<li><font color="red"></font></li>
</ol>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载 ="></a>重载 =</h3><p>以上面的 complex 类来考虑，如果要支持 c3 = c1 + c2 的操作，需要如何重载 = 操作符？</p>
<p><mark>因为 c1 + c2 会返回 temporary object, 所以我们不能传递一个 reference, 如果要使用 reference, 需要传递一个 const reference.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个实现是错误的！！！</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(other.real(), other.imag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误原因</span></span><br><span class="line"><span class="comment">// 1. 函数里面新建了一个 temporary object，它是没法返回给 complex&amp; 类型的</span></span><br><span class="line"><span class="comment">// 2. 这个东西其实是"拷贝赋值函数"，因此它是属于当前 class 的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的实现</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="built_in">complex</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = other.real();</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = other.imag();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><p>就是一个可以被赋值的东西。denote a nontemporary object.</p>
<ol>
<li>variable</li>
<li>reference</li>
<li>the result of calling a function that returns a reference.</li>
</ol>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>==( * iter).name== is the same as ==iter-&gt;name==</p>
<h2 id="initialization"><a href="#initialization" class="headerlink" title="initialization"></a>initialization</h2><h3 id="uniform-initialization-C-11"><a href="#uniform-initialization-C-11" class="headerlink" title="uniform initialization C++11"></a>uniform initialization C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-uniform-initialization.png" alt=""></p>
<h3 id="initializer-list-C-11"><a href="#initializer-list-C-11" class="headerlink" title="initializer list C++11"></a>initializer list C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-9.png" alt=""></p>
<h2 id="三种定义-Comparison-Function-的方法"><a href="#三种定义-Comparison-Function-的方法" class="headerlink" title="三种定义 Comparison Function 的方法"></a>三种定义 Comparison Function 的方法</h2><h3 id="一：Define-operator-lt"><a href="#一：Define-operator-lt" class="headerlink" title="一：Define operator&lt;()"></a>一：Define operator&lt;()</h3><p>在自定义的数据结构里面定义好 &lt; 运算符的意义.</p>
<p>注意：operator&lt;() 参数只有一个！！！并且 operator 是 const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort the edges in decreasing order</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你不喜欢这种语法，只有一个参数，</span></span><br><span class="line"><span class="comment">却比较两个objects，那么你可以用下面的方式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This way it is much clearer that you are </span></span><br><span class="line"><span class="comment">comparing a and b, not *this and other. </span></span><br><span class="line"><span class="comment">Note also that friend function is like static function; </span></span><br><span class="line"><span class="comment">it cannot access member variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二：定义-comparison-function"><a href="#二：定义-comparison-function" class="headerlink" title="二：定义 comparison function"></a>二：定义 comparison function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stringVec.<span class="built_in">begin</span>(), stringVec.<span class="built_in">end</span>(), comp);</span><br></pre></td></tr></table></figure>

<h3 id="三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><a href="#三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object" class="headerlink" title="三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object."></a>三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了上面的定义，你就可以这样用：</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, cmp&gt; myset;  <span class="comment">// cmp 是 type</span></span><br><span class="line"><span class="comment">// 或者这样（cmp 也是 type）</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个错误用法</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="comment">// cmp 是type，sort需要 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法-1</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp());</span><br><span class="line"><span class="comment">// 正确写法-2</span></span><br><span class="line">cmp cmpobject;</span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmpobject);</span><br></pre></td></tr></table></figure>
<p>注意，虽然 set, map 里面只能使用 functor/type</p>
<p>实际上他们也可以用 function 的方法，但是容易用错，</p>
<p>不过这里还是给出来看一下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can use comparison function for STL containers</span></span><br><span class="line"><span class="comment">by passing them as the first argument of the constructor, </span></span><br><span class="line"><span class="comment">and specifying the function type as the additional template argument. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;string, bool (*)(string, string)&gt; myset(comp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lambda function 也是一个 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>; &#125;;</span><br><span class="line">priority_queue&lt;string, vector&lt;int&gt;, decltype(comp)&gt; mypq(comp);</span><br></pre></td></tr></table></figure>

<h3 id="二-vs-三"><a href="#二-vs-三" class="headerlink" title="二 vs 三"></a>二 vs 三</h3><ol>
<li>方法三 compiler 很容易 inline，所以效率高！</li>
</ol>
<h3 id="STL-内置的函数对象"><a href="#STL-内置的函数对象" class="headerlink" title="STL 内置的函数对象"></a>STL 内置的函数对象</h3><p>STL提供的函数对象</p>
<ol>
<li>用于算术运算的函数对象：<ol>
<li>一元函数对象(一个参数) ：negate</li>
<li>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</li>
</ol>
</li>
<li>用于关系运算、逻辑运算的函数对象(要求返回值为bool)<ol>
<li>一元谓词(一个参数)：logical_not</li>
<li>二元谓词(两个参数)：equalto、notequalto、greater、less、greaterequal、lessequal、logicaland、logical_or</li>
</ol>
</li>
</ol>
<h1 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h1><h2 id="泛型设计的基本概念"><a href="#泛型设计的基本概念" class="headerlink" title="泛型设计的基本概念"></a>泛型设计的基本概念</h2><h3 id="目的：为啥需要泛型程序设计"><a href="#目的：为啥需要泛型程序设计" class="headerlink" title="目的：为啥需要泛型程序设计"></a>目的：为啥需要泛型程序设计</h3><ol>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从具体的数据结构中抽象出来，成为通用的</li>
<li>C++ 的模板为泛型程序设计奠定了关键的基础</li>
</ol>
<h3 id="术语一：概念"><a href="#术语一：概念" class="headerlink" title="术语一：概念"></a>术语一：概念</h3><p>概念是指：用来界定具备一定功能的数据类型。例如：</p>
<ol>
<li>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable</li>
<li>将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable</li>
<li>将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable</li>
</ol>
<p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：</p>
<ol>
<li>Sortable既是Comparable的子概念，也是Assignable的子概念</li>
</ol>
<h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><p>模型（model）：符合一个概念的数据类型称为该概念的模型，例如：</p>
<ol>
<li>int型是Comparable概念的模型。</li>
<li>静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）</li>
</ol>
<h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><p>很多STL的实现代码就是使用概念来命名模板参数的。</p>
<p>为概念赋予一个名称，并使用该名称作为模板参数名。例如</p>
<p>表示insertionSort这样一个函数模板的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Sortable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insertionSort</span>(<span class="title">Sortable</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>);</span></span><br></pre></td></tr></table></figure>

<h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><h3 id="STL的基本组件"><a href="#STL的基本组件" class="headerlink" title="STL的基本组件"></a>STL的基本组件</h3><ol>
<li>容器（container）</li>
<li>迭代器（iterator）</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ol>
<h3 id="STL的基本组件间的关系"><a href="#STL的基本组件间的关系" class="headerlink" title="STL的基本组件间的关系"></a>STL的基本组件间的关系</h3><ol>
<li>Iterators（迭代器）是算法和容器的桥梁。</li>
<li>将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。</li>
<li>将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png" alt=""></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>transform算法的一种实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryFunction</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">        *result = op(*first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transform算法顺序遍历first和last两个迭代器所指向的元素；</p>
<p>将每个元素的值作为函数对象op的参数；</p>
<p>将op的返回值通过迭代器result顺序输出；</p>
<p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回.</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是算法和容器的桥梁</p>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ol>
<p>算法和容器独立</p>
<ol>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也能适用</li>
</ol>
<h3 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h3><p>顺序容器包括：</p>
<ol>
<li>向量、双端队列、列表、单向链表、数组</li>
</ol>
<h4 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h4><p>特点</p>
<ol>
<li>一个可以扩展的动态数组</li>
<li>随机访问、在尾部插入或删除元素快</li>
<li>在中间或头部插入或删除元素慢</li>
</ol>
<p>向量的容量</p>
<ol>
<li>容量(capacity)：实际分配空间的大小</li>
<li>s.capacity() ：返回当前容量</li>
<li>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</li>
</ol>
<h4 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h4><p>特点</p>
<ol>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量容器慢</li>
</ol>
<p>例10-5 奇偶排序<br>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    istream_iterator&lt;int&gt; i1(cin), i2;  //建立一对输入流迭代器</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line">    sort(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>)    <span class="comment">//偶数放到s2尾部</span></span><br><span class="line">             s2.push_back(*iter);</span><br><span class="line">         <span class="keyword">else</span>       <span class="comment">//奇数放到s2首部</span></span><br><span class="line">             s2.push_front(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s2的结果输出</span></span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==心得一：输出 vector 到标准输出我一般都是用 for 循环一个一个喂给 cout，这里却用 iterator 和 copy 函数很简洁得做到了（上段代码倒数第三句）==</p>
<p>==心得二：这个方法思路很好啊！！==</p>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p>特点</p>
<ol>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ol>
<p>接合(splice)操作</p>
<ol>
<li>==s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到s1中p所指向元素之前==</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> names1[] = &#123; <span class="string">"Alice"</span>, <span class="string">"Helen"</span>, <span class="string">"Lucy"</span>, <span class="string">"Susan"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> names2[] = &#123; <span class="string">"Bob"</span>, <span class="string">"David"</span>, <span class="string">"Levin"</span>, <span class="string">"Mike"</span> &#125;;</span><br><span class="line">    <span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line">    s2.splice(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line">    advance(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter2 = s2.<span class="built_in">begin</span>();  <span class="comment">//iter2指向s2首</span></span><br><span class="line">    ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line">    advance(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line">    <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line">    s1.splice(iter1, s2, iter2, iter3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别将s1和s2输出</span></span><br><span class="line">    copy(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h4><ol>
<li>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</li>
<li>未定义insert、emplace和erase操作，而定义了insertafter、emplaceafter和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</li>
<li>不支持size操作。</li>
</ol>
<h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><ol>
<li>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</li>
<li>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小。</li>
<li>不能动态地改变容器大小</li>
</ol>
<h4 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h4><p>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容器所需要执行的操作来决定选择哪一种容器。</p>
<ol>
<li>如果需要执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector；</li>
<li>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应当选择双端队列容器deque；</li>
<li>如果不需要对容器进行随机访问，但是需要在中间位置插入或者删除元素，就应当选择列表容器list或forward_list；</li>
<li>如果需要数组，array相对于内置数组类型而言，是一种更安全、更容易使用的数组类型。</li>
</ol>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ol>
<li>容器适配器</li>
<li>函数适配器</li>
<li>迭代器适配器</li>
</ol>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>STL提供了三个==容器适配器==：</p>
<ol>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ol>
<p>这些适配器都是包装了vector、list、deque中某个顺序容器的包装器。<br>stack和queue是容器，但是他们==在本质上是适配器，他们本身并没有实现什么结构和算法，而是把deque拿过来，接口改造一下，实现了自己需要的功能==。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png" alt=""></p>
<p>注意：</p>
<ol>
<li>适配器没有提供迭代器，也不能同时插入或删除多个元素</li>
</ol>
<h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><h4 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/massive-data-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/massive-data-analysis/" itemprop="url">massive-data-analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T19:22:40-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/massive-data-analysis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/massive-data-analysis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>倒排索引的索引表中的每一项都包括一个属性值和具有该属性值得各记录的地址。</li>
<li>因为不是由记录来确定属性值，而是由属性来确定记录，因而成为倒排索引（inverted index）。</li>
<li>带有倒排索引的文件称为倒排索引文件，简称倒排文件（inverted file）。</li>
</ol>
<h3 id="倒排列表"><a href="#倒排列表" class="headerlink" title="倒排列表"></a>倒排列表</h3><ol>
<li>倒排列表记录了某个单词位于哪些文档中。在给定的文档语料中，一般会有多个文档包含某单词，每个文档有唯一的编号(DocID)，单词在这个文档中出现的次数(TF)及单词在文档中哪些位置出现等信息，与一个文档相关的信息被称作倒排索引项（posting），包含这个单词的一系列倒排索引项形成了列表结构，这就是某个单词对应的倒排列表。</li>
</ol>
<h3 id="在实践中的另外一个应用"><a href="#在实践中的另外一个应用" class="headerlink" title="在实践中的另外一个应用"></a>在实践中的另外一个应用</h3><ol>
<li>跳跃链表、跳跃表、跳表</li>
<li>GIS 中的 POI(point of Interest 查询)<ol>
<li>部分匹配：戴尔外星人电脑，外星人电脑</li>
<li>跳跃匹配：中国科技大学，中科大</li>
</ol>
</li>
</ol>
<p>POI 信息点 搜索总框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFileObject::Search</span><span class="params">(LPCTSTR lpszContent, <span class="keyword">int</span> nIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lpszContent || !lpszContent[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateSearchTree(nIndex);</span><br><span class="line"></span><br><span class="line">    SearchFuzzy(lpszContent, nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai417992qj20li0d8tg3.jpg" alt="Screen Shot 2020-01-01 at 20.35.19.png"></p>
<h2 id="simHash-算法"><a href="#simHash-算法" class="headerlink" title="simHash 算法"></a>simHash 算法</h2><h3 id="算法起源和步骤"><a href="#算法起源和步骤" class="headerlink" title="算法起源和步骤"></a>算法起源和步骤</h3><ol>
<li>问题的起源：设计比较两篇文章相似度的算法。</li>
<li>simHash 算法分为 5 个步骤：<ol>
<li>分词</li>
<li>Hash</li>
<li>加权</li>
<li>合并</li>
<li>降维</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai2j6ly1hj211c0oi1fv.jpg" alt="Screen Shot 2020-01-01 at 19.43.21.png"></p>
<p>注意！！！</p>
<ol>
<li>上面”加权“那一项中是吧 W(CSDN)=100101 看成 6 个位置（6个数字，分别是 1, 0, 0, 1, 0, 1），然后再把 0 当成 -1 来计算乘积。</li>
<li>上面的”合并“那一项最后得到的是”9, -9, 1, -1, 1, 9“，图中漏写了最后的”9“。</li>
<li>权重的计算可以使用 TF-IDF 方法！</li>
</ol>
<h3 id="simHash-的应用"><a href="#simHash-的应用" class="headerlink" title="simHash 的应用"></a>simHash 的应用</h3><ol>
<li>每篇文档得到 simHash 签名值后，接着计算两个签名的海明距离即可。根据经验值，对 64 位的 SimHash 值，海明距离在 3 以内的可以认为相似度较高。</li>
<li>海明距离的求法：两个二进制数去异或操作，结果中 1 的个数就是海明距离。</li>
</ol>
<p>[对simHash的分块处理]</p>
<ol>
<li>如何将其扩展到海量数据呢？比如如何在海量的样本库中查询与其海明距离在 3 以内的记录呢？</li>
<li>一种方案是查找待查询文本的 64 为 simHash code 所有 3 位以内变化的组合</li>
<li>大约 43744 个。</li>
</ol>
<h3 id="进一步的思考"><a href="#进一步的思考" class="headerlink" title="进一步的思考"></a>进一步的思考</h3><ol>
<li>完全丢掉了位置信息和语义信息<ol>
<li>考虑使用 WordNet 影响 Hash 值？</li>
<li>考虑使用主题模型、标签传递算法等机器学习方法来分析语义</li>
</ol>
</li>
<li>允许交换，算一次变换：如 meter 和 metre<ol>
<li>能否写出递推关系式</li>
<li>还能设计出 O(n^2)的算法吗？</li>
</ol>
</li>
<li>如果计算字符串的语义距离，怎么考虑？<ol>
<li>WordNet 是由 Princeton 大学的心理学家，语言学家和计算机工程师联合设计得一种基于认知语言学的英语词典。它不光是把单词以字母顺序排列，而且按照单次的意义组成一个”单次的网络“。</li>
</ol>
</li>
</ol>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><ol>
<li>布隆过滤器(Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出的，他是一种空间高效的概率性数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单，爬虫(Crawler)的网址判重等问题中经常被用到。</li>
<li>哈希表也能用于判断元素是否在集合中，但是 Bloom Filter 只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。Bloom Filter 可以插入元素，但不可以删除已有元素。集合中的元素越多，误报率(false positive rate)越大，但是不会漏报 (false negative).</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rg9avlj20nu0gitit.jpg" alt="Screen Shot 2020-01-01 at 20.40.37.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rqrt0aj20mg0cgafh.jpg" alt="Screen Shot 2020-01-01 at 21.00.25.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai50f2nggj20lq0doq8u.jpg" alt="Screen Shot 2020-01-01 at 21.09.10.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai521tg4fj20o80e0wmi.jpg" alt="Screen Shot 2020-01-01 at 21.10.46.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5bt06y8j20me0eawkm.jpg" alt="Screen Shot 2020-01-01 at 21.20.12.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5ck8aqjj20oc0g8dqk.jpg" alt="Screen Shot 2020-01-01 at 21.20.57.png"></p>
<h3 id="Bloom-Filter-特点"><a href="#Bloom-Filter-特点" class="headerlink" title="Bloom Filter 特点"></a>Bloom Filter 特点</h3><ol>
<li>优点：相比于其他的数据结构，Bloom Filter 在空间和时间方面有巨大的优势。Bloom Filter 存储空间是线性的，插入和查询时间都是常数。另外，Hash 函数相互之间没有关系，方便由硬件并行实现。Bloom Filter 不存储元素本身，在某些对保密要求非常严格的场合有优势。</li>
<li>很容易想到把位向量变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素是将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在 Bloom Filter 里面。这一点单凭这个过滤器是无法保证的。另外计数器下溢出也会造成问题（槽的值已经是 0 了，仍然执行删除操作）。</li>
</ol>
<h3 id="Bloom-Filter-用例"><a href="#Bloom-Filter-用例" class="headerlink" title="Bloom Filter 用例"></a>Bloom Filter 用例</h3><ol>
<li>Google 著名分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的 IO 次数。</li>
<li>Squid 网页代理缓存服务器在 cachedigests 中使用了 BloomFilter</li>
<li>Venti 文档存储系统采用 BloomFilter 来检测先前存储的数据；</li>
<li>SPIN 模型检测器使用 BloomFilter 在大规模验证问题时跟踪可达状态空间</li>
<li>Google Chrome 浏览器使用 BloomFilter 加速安全浏览服务</li>
<li>在很多 Key-Value 系统中也是用 BloomFilter 来加快查询过程，如 HBase, Accumulo, Leveldb<ol>
<li>一般而言，value 保存在磁盘中，访问磁盘需要花费大量时间，然而使用 BloomFilter 可以快速判断某个 Key 是否存在，因此可以避免很多不必要的磁盘 IO 操作；另外，引入布隆过滤器会带来一定的内存消耗。</li>
<li>如果你真的非常在意 false positive 的话，那么可以在 Bloom Filter 给出“存在”的结论时候，再去磁盘真的查询一次看看到底在不在。</li>
</ol>
</li>
</ol>
<h2 id="跳跃链表（skip-list）"><a href="#跳跃链表（skip-list）" class="headerlink" title="跳跃链表（skip list）"></a>跳跃链表（skip list）</h2><ol>
<li>Treaps/RB-Tree/BTree</li>
<li>跳跃链表是一种随机化数据结构，基于并联的链表，其效率与 RBTree 相当。具有简单、高效、动态（Simple, Effective, Dynamic）的特点。</li>
<li>跳跃链表对有序的链表副驾辅助结构，在链表中的查找可以快速的跳过部分节点（由此得名）。<ol>
<li>查找、增加、删除的期望时间都是 O(logN)</li>
<li>with high probability (W.H.P. ~ 1 - 1/(n^alpha))</li>
</ol>
</li>
<li>跳跃链表在并行计算中非常有用，数据插入可以再跳表的不同部分并行进行，而不用全局的数据结构重新平衡。</li>
<li>跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速跑道“，这里在层 i 中的元素按某个固定的概率 p 出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现。<ol>
<li>为什么是 1/(1-p)?</li>
</ol>
</li>
<li>优势<ol>
<li>编程方便</li>
<li>尤其方便将增删改查操作扩展成并行算法！</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8c6p5coj20na0eqtg7.jpg" alt="Screen Shot 2020-01-02 at 19.29.50.png"></p>
<p>由上图可以看出来，要找一个元素，先在最上层找，找不到再往下走一层找。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8grgkdvj20ns0gcti8.jpg" alt="Screen Shot 2020-01-02 at 19.54.17.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8ip6lijj20lu0caqa8.jpg" alt="Screen Shot 2020-01-02 at 19.56.13.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8kf7iagj20nk0fqdsc.jpg" alt="Screen Shot 2020-01-02 at 19.57.54.png"></p>
<mark>
    注意上面这个计算有错！
    k = ln(N) 这个结果没什么毛病。但是 T(N) 的表达有问题 T(N) = ln(N) * N^(1 / ln(N))
    而乘法号后面的 N^(1 / ln(N)) 等于数学常量 e
    因此 T(N) = e * ln(N)
</mark>


<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol>
<li>随着底层链表的插入，某一段上的数据将不满足理想链表的要求，需要做些调整。<ol>
<li>将底层链表这一段上元素的中位数在拷贝到上层链表中；</li>
<li>重新计算上层链表，使得上层链表仍然是底层链表的 1/e;</li>
<li>如果上述操作过程中，上层链表不满足要求，继续上上层链表的操作。</li>
</ol>
</li>
<li>新的数据应该在上层甚至上上层链表中吗？因为要找 1/e 的数据放在上层链表，因此：<mark>抛硬币！</mark></li>
<li>插入元素后的跳表维护<ol>
<li>考察待需要提升的某段节点</li>
<li>若抛硬币得到的随机数 p &lt; 1/e, 则提升到上层，继续抛硬币，直到 p &gt; 1/e<ol>
<li>或者到了顶层仍然 p &lt; 1/e, 建立一个新的顶层</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol>
<li>在某层链表上找到了该元素，则删除；如果该层链表不是底层链表，就跳转到下一层，继续本操作</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj9wczbs7j20os0coahp.jpg" alt="Screen Shot 2020-01-02 at 20.43.55.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSSkipNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    tagSSkipNode* pNext;</span><br><span class="line">    tagSSkipNode* pNextLayer;</span><br><span class="line"></span><br><span class="line">    tagSSkipNode(<span class="keyword">int</span> v) : value(v), pNext(<span class="literal">nullptr</span>), pNextLayer(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; SSkipNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSkipList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SSkipNode* m_pHead;</span><br><span class="line">    <span class="keyword">int</span> m_nSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CSkipList()&#123;</span><br><span class="line">        m_pHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);</span><br><span class="line">        m_nSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SSkipNode* <span class="title">Find</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">SSkipNode* <span class="title">FindIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize &lt;= <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintLayer</span><span class="params">(<span class="keyword">const</span> SSkipNode* pNode)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsSuccess</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand() &gt; RAND_MAX * <span class="number">0.36787944117</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find</span></span><br><span class="line"><span class="function">SSkipNode* <span class="title">CSkipList::Find</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; (cur-&gt;value &lt; value))    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while 结束后 cur-&gt;value 不小于 value, 而 pre-&gt;value 小于 value</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSkipList::Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead-&gt;pNext)&#123;</span><br><span class="line">        m_pHead-&gt;pNext = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">        m_nSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SSkipNode*&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;    <span class="comment">// 已经存在，这里的思想是是不允许插入。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 当然也可以修改数据结构，记录一下次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.push(pre);    <span class="comment">// 记录插入点</span></span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到 pre 的后面，cur 的前面</span></span><br><span class="line">    SSkipNode* now = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">    now-&gt;pNext = cur;</span><br><span class="line">    pre-&gt;pNext = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机上升</span></span><br><span class="line">    SSkipNode* nowInLayer;</span><br><span class="line">    SSkipNode* pLayerHead;</span><br><span class="line">    <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!IsSuccess())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop();    <span class="comment">// 第一次到这里的时候，这个是最下层的，没有用的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到层的插入位置</span></span><br><span class="line">        <span class="keyword">if</span>(path.empty())&#123;</span><br><span class="line">            pre = m_pHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = path.top();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成节点</span></span><br><span class="line">        nowInLayer = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">        nowInLayer-&gt;pNextLayer = now;</span><br><span class="line">        <span class="keyword">if</span>(path.empty())&#123;    <span class="comment">// 说明顶层后仍然成功，则新建层</span></span><br><span class="line">            pLayerHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);    <span class="comment">// 生成层的新头指针</span></span><br><span class="line">            pLayerHead-&gt;pNext = m_pHead-&gt;pNext;</span><br><span class="line">            pLayerHead-&gt;pNextLayer = m_pHead-&gt;pNextLayer;</span><br><span class="line">            m_pHead-&gt;pNextLayer = pLayerHead;    <span class="comment">// 退化到下一层</span></span><br><span class="line">            m_pHead-&gt;pNext = nowInLayer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nowInLayer-&gt;pNext = pre-&gt;pNext;</span><br><span class="line">            pre-&gt;pNext = nowInLayer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为下次上升作准备</span></span><br><span class="line">        now = nowInLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSkipList::Delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">    SSkipNode* pHeadPre = <span class="literal">nullptr</span>;</span><br><span class="line">    SSkipNode* pHead = m_pHead;</span><br><span class="line">    <span class="keyword">bool</span> bDelete = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;   <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">            bDelete = <span class="literal">true</span>;</span><br><span class="line">            pre-&gt;pNext = cur-&gt;pNext;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            <span class="keyword">if</span>(!pHead-&gt;pNext)&#123;    <span class="comment">// 该层没有元素，则删除该层</span></span><br><span class="line">                <span class="keyword">if</span>（pHead == m_pHead)&#123;    <span class="comment">// 顶层</span></span><br><span class="line">                    SSkipNode* pNL = m_pHead-&gt;pNextLayer;</span><br><span class="line">                    m_pHead-&gt;pNextLayer = pNL ? pNL-&gt;pNextLayer : <span class="literal">nullptr</span>;</span><br><span class="line">                    m_pHead-&gt;pNext = pNL ? pNL-&gt;pNext : <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pHeadPre-&gt;pNextLayer = pHead-&gt;pNextLayer;</span><br><span class="line">                    <span class="keyword">delete</span> pHead;</span><br><span class="line">                    pHead = pHeadPre</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pHead;</span><br><span class="line">                cur = pre-&gt;pNext;</span><br><span class="line">                <span class="keyword">continue</span>;    <span class="comment">// 删除该层后，pre/cur 已经向下移动了一层</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer) <span class="keyword">break</span>;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line"></span><br><span class="line">        pHeadPre = pHead;</span><br><span class="line">        pHead = pHead-&gt;pNextLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nSize--;</span><br><span class="line">    <span class="keyword">return</span> bDelete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)&#123;</span><br><span class="line">    CSkipList sl;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;    <span class="comment">// 随机插入数据</span></span><br><span class="line">        sl.Insert(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sl.Print();</span><br><span class="line">    <span class="keyword">while</span>(!sl.IsEmpty())&#123;</span><br><span class="line">        SSkipNode* p = sl.FindIndex(rand() % sl.GetSize());</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = p-&gt;value;</span><br><span class="line">            <span class="keyword">if</span>(sl.Delete(num))&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sl.Print();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"==================\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><ol>
<li>MD5 (Message Digest Algorithm)，消息摘要算法，用以提供消息的完整性保护。</li>
</ol>
<h3 id="框架理解"><a href="#框架理解" class="headerlink" title="框架理解"></a>框架理解</h3><ol>
<li>对于长度为 512bit 的信息，可以通过处理，得到长度为 128bit 的摘要</li>
<li>初始化摘要 0x0123456789ABCDEFFEDCBA9876543210<ol>
<li>A = 0x01234567</li>
<li>B = 0x89ABCDEF</li>
<li>C = 0xFEDCBA98</li>
<li>D = 0x76543210</li>
</ol>
</li>
<li>现在的工作，是要用长度为512 位的信息，变换初始摘要</li>
<li>定义变量 a，b，c，d，分别记录 A，B，C，D</li>
<li>将 512 bit 的信息按照 32 bit 一组，分成 16 组；分别记为 Mj (0 &lt;= j &lt;= 15)</li>
<li>取某正数 s, t_k, 定义函数 FF(a,b,c,d,Mj,s,t_k) = (a+F(b,c,d)+Mj+t_k) &lt;&lt; s</li>
<li>利用 Mj 分别进行信息提取，将结果保存到 a<ol>
<li>其中，F(X,Y,Z) = (X &amp; Y) | (~X &amp; Z)</li>
</ol>
</li>
<li>经过以上 16 次变换，a，b，c，d 带有了 Mj 的信息</li>
<li>事实上经过四轮这样的变换（4轮 * 16次 = 64 次）</li>
<li>经过 64 次变换后，将 a，b，c，d 累加给 A，B，C，D</li>
<li>此时，完成了 512 bit 信息的提取；进行下一个 512 bit 信息的相同操作。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbqj9ymdj20m80giwjo.jpg" alt="Screen Shot 2020-01-02 at 21.47.31.png"></p>
<h3 id="细致算法"><a href="#细致算法" class="headerlink" title="细致算法"></a>细致算法</h3><ol>
<li>在算法中，首先要对信息进行填充，使其长度对 512 求余的结果是 448</li>
<li>填充的方法如下，在信息的后面填充一个 1 和若干个 0，知道满足上面的条件。然后在这个结果后面附加一个以 64 位二进制表示的原始信息长度 length</li>
<li>经过这两步的处理，数据总长度为 N * 512 + 448 + 64 = (N+1) * 512.</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbs4sb7nj20lk0ds14h.jpg" alt="Screen Shot 2020-01-02 at 21.49.07.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbv3nfevj20m40goh3v.jpg" alt="Screen Shot 2020-01-02 at 21.51.56.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/leetcode-math/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/leetcode-math/" itemprop="url">leetcode-math</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T10:44:36-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/leetcode-math/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/leetcode-math/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h1><h2 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h2><p>本福特定律（本福特法则，Frank Benford），又称第一数字定律，是指在实际生活得出的一组数据中，以 1 为首位数字出现的概率约为总数的三成；是直观想象 1/9 的三倍。</p>
<ul>
<li>阶乘，素数数列，斐波那契数列</li>
<li>住宅地址号码</li>
<li>经济数据反欺诈（检验是否符合本定律）</li>
<li>选举投票发欺诈</li>
</ul>
<table>
<thead>
<tr>
<th>数字</th>
<th>出现概率</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.1%</td>
</tr>
<tr>
<td>2</td>
<td>17.6%</td>
</tr>
<tr>
<td>3</td>
<td>12.5%</td>
</tr>
<tr>
<td>4</td>
<td>9.7%</td>
</tr>
<tr>
<td>5</td>
<td>7.9%</td>
</tr>
<tr>
<td>6</td>
<td>6.7%</td>
</tr>
<tr>
<td>7</td>
<td>5.8%</td>
</tr>
<tr>
<td>8</td>
<td>5.1%</td>
</tr>
<tr>
<td>9</td>
<td>4.6%</td>
</tr>
</tbody></table>
<h2 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h2><p>[题目]<br>给定 N 个数，设计算法，输出随机排列的一个结果。</p>
<p>[思路]</p>
<ol>
<li>直接一个数字一个数字的选择就可以了</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % (b - a + <span class="number">1</span>) + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomShuffle2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;    <span class="comment">// i 是待生成的第几个数</span></span><br><span class="line">        j = Random2(i, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思考]</p>
<ol>
<li>其实 STL 里面有 std::random_shuffle 可以直接得到结果。</li>
</ol>
<h2 id="0650-2-Keys-keyboard"><a href="#0650-2-Keys-keyboard" class="headerlink" title="0650 2 Keys keyboard"></a>0650 2 Keys keyboard</h2><p>[题目]</p>
<ul>
<li>屏幕上开始有一个 A, 你的键盘只有 <code>copy all</code> 和 <code>paste</code> 两个功能键</li>
<li>给定 N, 问你需要操作多少次键盘才可以获得 N 个 A.</li>
<li>Example<ul>
<li>N = 3, copy all + paste + paste 需要三次</li>
<li>N = 4, c + p + p + p 或者 c + p + c + p 需要四次</li>
</ul>
</li>
</ul>
<p>[思路一：我的思路]</p>
<ul>
<li>使用 DP，如果已知 ans[i] 了，那么可以对它进行 copy all + K 个 paste 获得后面的值</li>
<li>时间复杂度为 O( (1 + 1/2 + 1/3 + … + 1/N) * N ) 复杂度 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans[n + <span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j = j + i)&#123;</span><br><span class="line">            ans[j] = ans[i] + j / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路二：数学观察]</p>
<ul>
<li>如果 n 为质数，那么 n 是多少，就需要多少次。</li>
<li><mark>如果 n 为合数，那么其需要的次数等于将其分解质因数的操作次数的和！</mark><ul>
<li>比如，30 = 1 * 3 * 2 * 5。那么我们首先复制 1，进行两次粘贴得到 3. 然后复制 3，进行一次粘贴得到 6；然后复制 6，进行 4 次粘贴得到 30. 总共需要 3 + 2 + 5 = 10 次<ul>
<li>1 * 3 就代表需要 3 个 1，怎么办呢？复制一次，粘贴两次</li>
<li>1 * 3 的结果再 * 2, 也就是需要 2 个 3，怎么办？复制一次 3个星，粘贴就好了啊！</li>
</ul>
</li>
<li>注意，由于分解的质因数顺序可以改变，也就意味着我们操作顺序可以不同。比如我们同样可以: 30 = 5 * 2 * 3. 即先复制 1, 进行四次粘贴得到 5; 然后复制 5, 进行一次粘贴得到 10; 然后复制 10，进行两次粘贴得到 30.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p>[题目]<br>编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。</p>
<p>[分析]</p>
<ol>
<li>经典的思路是使用环形链表，模拟这个步骤来找到最终结果。但是这个并非最优的解决办法。</li>
<li>我们可以使用递归的思想去做！<ol>
<li>定义递归函数 f(n, m)，很显然 f(1, m) = 1</li>
<li>我们需要找到 f(n, m) 和 f(n-1, m) 之间的关系。</li>
<li>刚开始的编号为: 1, …, m-2, m-1, m, m+1, m+2, …, n, …</li>
<li>考虑删除前和删除后的编号转换关系<ol>
<li>删除前 —- 删除后</li>
<li>… —— …</li>
<li>m-2  —-  n-2</li>
<li>m-1  —-  n-1</li>
<li>m  ——  无（因为编号被删除了）</li>
<li>m+1  —-  1 (因为下次就从这里报数了)</li>
<li>m+2  —-  2</li>
<li>…  —-  …</li>
</ol>
</li>
<li>新的环中只有 n-1 个节点。且删除前编号为 m+1, m+2, m+3 的节点成了删除后编号为 1, 2, 3 的节点</li>
<li>假设 old 为删除之前的节点编号，new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为:<ol>
<li>old = (new + m - 1) % n + 1</li>
<li>注意！有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? n : (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0172-n的阶乘后边有多少0"><a href="#0172-n的阶乘后边有多少0" class="headerlink" title="0172 n的阶乘后边有多少0"></a>0172 n的阶乘后边有多少0</h2><p>[题目]<br>给定数字 n, 求 n! 后缀有多少个 0.</p>
<p>[分析]</p>
<ol>
<li>只需要看有多少个 5</li>
<li>有些数字里面有 2 个，3个，多个 5</li>
<li>总共有 sum = N / 5 + N / 25 + N / 125 + … 个 5 存在</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + f(n/<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0319-开关灯泡"><a href="#0319-开关灯泡" class="headerlink" title="0319 开关灯泡"></a>0319 开关灯泡</h2><p>[题目]</p>
<ol>
<li>初始时有 n 个灯泡关闭。</li>
<li>第 1 轮，你打开所有的灯泡。</li>
<li>第 2 轮，每两个灯泡关闭一次。</li>
<li>第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。</li>
<li>第 i 轮，每 i 个灯泡切换一次开关。对于第 n 轮，你只切换最后一个灯泡的开关。</li>
<li>找出 n 轮后有多少个亮着的灯泡。</li>
</ol>
<p>[例子]</p>
<ol>
<li>示例:</li>
<li>输入: 3</li>
<li>输出: 1 </li>
<li>解释: <ol>
<li>初始时, 灯泡状态 [关闭, 关闭, 关闭].</li>
<li>第一轮后, 灯泡状态 [开启, 开启, 开启].</li>
<li>第二轮后, 灯泡状态 [开启, 关闭, 开启].</li>
<li>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ol>
<li>这个题目评级为 hard, 但是这道题实际上是一道数学题目</li>
<li>想象一下位置为 k 的灯泡会被改变多少次呢？<ol>
<li>第一步的时候肯定是变亮了</li>
<li>第二步的时候取决于 k 是不是奇数，也就是 k 除以 2 能否整除，或者说 2 是不是 k 的约数</li>
<li>第三部的时候取决于 3 是不是 k 的约数</li>
</ol>
</li>
<li><mark>以此类推。第 k 个灯泡变化的次数，等于 k 的约数的个数</mark><ol>
<li>如果有奇数个约数，那么最后灯泡是亮的</li>
<li>如果有偶数个约数，那么最后灯泡是暗的</li>
</ol>
</li>
<li>所以问题可以转变成，<mark>1 到 n 这 n 个数字里面有多少个数字拥有奇数个约数？</mark></li>
<li>有一个数学知识就是：只有完全平方数才有奇数个约数！<ol>
<li>为什么？</li>
<li>因为如果 m 是 k 的约数，那么 <code>k/m</code> 也是 k 的约数</li>
<li>m 和 k/m 一定是成对出现的</li>
<li>因此，一个数字的约数个数是偶数个，除非最中间的两个约数相等了，也就是 <code>m = k/m</code>，也就意味着 <code>k = m^2</code></li>
<li>因此, 完全平方数才有奇数个约数</li>
</ol>
</li>
<li>1 到 n 里面有多少个完全平方数可以直接计算如下<ol>
<li><code>int(sqrt(n))</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h2><p>[题目]</p>
<ol>
<li>给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：<ol>
<li>令 x 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size()</code> 的任意下标 i ，并让 A[i] = x 。</li>
<li>你可以重复该过程任意次</li>
</ol>
</li>
<li>如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。</li>
</ol>
<p>[例子一]</p>
<ol>
<li>输入: target = [9, 3, 5]</li>
<li>输出: true</li>
<li>解释<ol>
<li>从 [1, 1, 1] 开始</li>
<li>和为 3， A[1] = 3, 数组变成 [1, 3, 1]</li>
<li>和为 5， a[2] = 5, 数组变成 [1, 3, 5]</li>
<li>和为 9， a[0] = 9, 数组变成 [9, 3, 5]</li>
</ol>
</li>
</ol>
<p>[例子二]</p>
<ol>
<li>输入: target = [1, 1, 1, 2]</li>
<li>输出: false</li>
</ol>
<p>[思路]</p>
<ol>
<li>正着考虑很麻烦，因为要遍历各种可能的位置去放数组的和，BFS, DFS 这种复杂度都很高</li>
<li>DP 的话看起来很难找到状态转移方程</li>
<li>正着考虑不行就反向考虑！<ol>
<li>注意到数组里最大的那个数字一定是最后一步得到的，因此它是倒数第二步的数组里所有元素的和。</li>
<li>因此只需要把这个数字减去其他所有的数字，就得到了它倒数第二步的数字！</li>
<li>以此类推，可以逐渐得到前面所有步骤的数组。</li>
</ol>
</li>
<li>那么这里又存在一个问题，如何动态找出所有元素中的最大值？<ol>
<li>这个简单，我们可以借助 最大堆 这个数据结构，它可以帮助我们在 logn 的时间维护一个排序好的序列。</li>
</ol>
</li>
<li>有了这些，这道题基本上就可以解决了。以上就是最为基本的解题思路.</li>
<li>不过！！这道题目会存在一些比较极端的 case，比如 [1, 100000000] ，因此我们要对之前的解法进行优化。我们之前说过，我们需要考虑 sum 还有就是 max，但是当 max 相对于其他元素过于大的时候，我们需要对这一个元素反复做同样的事情很多次，这个过程能否简化呢？这里我们可以用一个取余的方法做到：<ol>
<li>[2, 100]</li>
<li>sum = 102, max = 100, other = 2  </li>
<li>sum = 100, max = 98, other = 2</li>
<li>sum = 98, max = 96, other = 2</li>
<li>…</li>
<li>// 如果 max 与 other 差距过大，每次迭代我们其实都在更新 max</li>
<li>// 因为 other 没有变，每次 max 减去的都是相同的值</li>
<li>// 这里，我们可以利用取余的方式来使得 max 一次性更新到刚好比 other 小的值</li>
<li>// end_max = max % other</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : target) &#123;</span><br><span class="line">        pq.offer(i);</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.peek() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = pq.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 other</span></span><br><span class="line">        sum -= max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other = 1，不管 max 是多少，都可以通过 1 不断迭代而成</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是反向推，只减不加</span></span><br><span class="line">        <span class="comment">// other 小于 1，说明无法构建</span></span><br><span class="line">        <span class="comment">// other 必须小于 max 来保证 max 的正常迭代递减，不然 max 无法递减到 1</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= <span class="number">0</span> || max &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过取余操作将 max 迭代到比 other 小的地方</span></span><br><span class="line">        max %= sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other + prev_max = prev_sum</span></span><br><span class="line">        sum += max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prev_max 放入队列，继续迭代</span></span><br><span class="line">        pq.offer(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url">leetcode-dp-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-31T21:35:23-08:00">
                2019-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/31/leetcode-dp-动态规划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h2><p>[题目]<br>给定不超过 100 万元的现金总额，兑换成数量不限的 100, 50, 20, 10, 5, 2, 1 的组合，共有多少种组合呢？</p>
<p>[思路一]<br>这个是视频里讲得思路</p>
<ul>
<li>定义 dp[i][j]: 使用面额小于等于 i 的钱币，凑成 j 元钱，宫有多少种组合方法</li>
<li>dp[100][500] = dp[50][500] + dp[100][400]</li>
<li>dp[i][j] = dp[i_small][j] + dp[i][j-1]<ul>
<li>不考虑下界溢出的情况</li>
</ul>
</li>
</ul>
<p>[思路二]<br>我觉得把，用个一维的数组来做 dp 就可以了。</p>
<p>DP[target] 表示用给定的钱币凑出来 target 的组合数量，那么<br>DP[target] 显然等于 DP[target-1] + DP[target-2] + DP[target-5] + … + DP[target-100]</p>
<p>就跟走楼梯的方法一模一样啊！！！</p>
<h2 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h2><p>[题目]<br>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p>[分析]<br>直接使用 DP 的话因为要考虑删除字符，有点不好理解，这里先转化成一个对齐的问题！</p>
<table>
<thead>
<tr>
<th>S</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>D</td>
<td>B</td>
<td>-</td>
<td>F</td>
<td>G</td>
</tr>
</tbody></table>
<ol>
<li>S = “ABCF”, T = “DBFG”</li>
<li>对应位置相同时候不扣分，不同则扣一分（修改了）</li>
<li>两个特殊字符”-“ 不会对应</li>
<li>S 位置 “-“ 代表增加字符</li>
<li>T 位置 “-“ 代表删掉字符</li>
<li>目标是使得扣分最少</li>
</ol>
<p>这个问题的 DP 思路就很好想到了</p>
<ol>
<li>假定 DP[i][j] 表示 S[0…i-1] 和 T[0…j-1] 对齐了</li>
<li>现在需要看 S[i] == T[j] ?<ol>
<li>如果相等, 说明 DP[i+1][j+1] = DP[i][j]</li>
<li>如果不相等，则有三种操作方式<ol>
<li>S[i] 替换成 T[j], DP[i+1][j+1] = DP[i][j] + 1</li>
<li>删掉 S[i], DP[i+1][j+1] = DP[i][j+1] + 1</li>
<li>删掉 T[j], DP[i+1][j+1] = DP[i+1][j] + 1</li>
</ol>
</li>
</ol>
</li>
<li>初值<ol>
<li>DP[0][j] = j, DP[i][0] = i</li>
</ol>
</li>
<li>同样，空间可以优化一下，稍微需要点技巧。</li>
</ol>
<h2 id="两次走棋盘"><a href="#两次走棋盘" class="headerlink" title="两次走棋盘"></a>两次走棋盘</h2><p>[题目]</p>
<ul>
<li>Maximum points from top left of matrix to bottom right and return back</li>
<li>给定 MxN 的矩阵，每个位置是一个非负的权值，从左上角开始，每次只能朝右和下走，走到右下角；然后，从右下角开始，每次只能超左和上走，走到左上角。求权值总和最大的路径。若相同格子走过两次，则该位置的权值只算一次。</li>
</ul>
<p>[思路]</p>
<ol>
<li>错误的思路一：贪心，先从左上到右下，再从右下到左上！这样子做选的路径两条路将会一模一样，因为重复的结点权值只算一次，这样子肯定不行。</li>
<li>错误的思路二：接错误一，如果你第一次走的时候把走过的结点权值改成 0，然后第二次走再选最大的路径。这样子也是不对的！</li>
<li>正确的思路：这题的一个技巧是把第二个图翻转过来，跟第一条路放到一起，二者同时走，即从左上角同时出发有两条路，终点都是右下角！</li>
<li>有了这个转换之后，显然，就可以用 row1, col1, row2, row4 来表示状态了！注意在任何时刻都满足条件： row1 + col1 = row2 + col2. 因此可以只用三个变量 row1, col1, row2 来表示状态。</li>
<li>在任意时刻，如果两条路汇合到同一个位置，那么这个位置的权值只计算一次，如果在两个不同的位置，那么两个权值都计算上！</li>
</ol>
<p>[代码]<br>这里的代码是自上而下的一个 DP.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; goldMatrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col2 = row1 + col1 - row2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>(), n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if they reach bottom right location</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == m<span class="number">-1</span> &amp;&amp; row1 == row2 &amp;&amp; col1 == n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> goldMatrix[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(row1 == m || row2 == m || col1 == n || col2 == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The same state has been calculated previously</span></span><br><span class="line">    <span class="keyword">if</span>(dp[row1][col1][row2] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row1][col1][row2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// They are at the same spot</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == row2)&#123; </span><br><span class="line">        res += goldMatrix[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += (goldMatrix[row1][col1] + goldMatrix[row2][col2]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move right</span></span><br><span class="line">    dp1 = helper(row1, col1+<span class="number">1</span>, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move down</span></span><br><span class="line">    dp2 = helper(row1, col1+<span class="number">1</span>, row2+<span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move right</span></span><br><span class="line">    dp3 = helper(row1+<span class="number">1</span>, col, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move down</span></span><br><span class="line">    dp4 = helper(row1 + <span class="number">1</span>, col, row2 + <span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    res += <span class="built_in">max</span>(dp1, <span class="built_in">max</span>(dp2, <span class="built_in">max</span>(dp3, dp4)));</span><br><span class="line"></span><br><span class="line">    dp[row1][col1][row2] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collectGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; goldMatrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, goldMatrix, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 错位排列</span><br><span class="line">[问题]</span><br><span class="line"><span class="number">1.</span> 把数字 <span class="number">1</span> 到 n 做个排列，要求数字 i 不能位于第 i 个位置。问：这样的排列一共有多少种?</span><br><span class="line"><span class="number">2.</span> 这个问题最早是由 Danial Bernoulli （著名的伯努利家族成员）提出的。</span><br><span class="line"></span><br><span class="line">[思路]</span><br><span class="line"><span class="number">1.</span> (n<span class="number">-1</span>)! 这个结果是不对的，不能排除掉重复的结果！</span><br><span class="line"><span class="number">2.</span> 先考虑 n</span><br><span class="line">    <span class="number">1.</span> n 可以放置在 <span class="number">1</span> 到 n<span class="number">-1</span> 一共 n<span class="number">-1</span> 种可能。假设放在了 k 位置</span><br><span class="line"><span class="number">3.</span> 现在考虑数字 k，有两种情况</span><br><span class="line">    <span class="number">1.</span> 第一种情况，数字 k 放到了 位置 n，那么剩下的可能就是 DP(n<span class="number">-2</span>) 了。</span><br><span class="line">    <span class="number">2.</span> 第二种情况下，数字 k 不能放到位置 n，这时候把数字 k 想象成数字 n（数字 n 本来已经用掉了，可以用 k 替代它继续做问题），而剩下的 n<span class="number">-2</span> 个数字也各有一个位置不能放！其实这就是 DP(n<span class="number">-1</span>) 啊！</span><br><span class="line"><span class="number">4.</span> 所以 DP 的转移公式是</span><br><span class="line">    <span class="number">1.</span> DP[n] = (n<span class="number">-1</span>)(DP[n<span class="number">-1</span>] + DP[n<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">![Screen Shot <span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> at <span class="number">17.16</span><span class="number">.10</span>.png](https:<span class="comment">//ws1.sinaimg.cn/large/6a607485gy1gahya0ozdgj20l20c043w.jpg)</span></span><br></pre></td></tr></table></figure>

<h2 id="三字符字符串组合"><a href="#三字符字符串组合" class="headerlink" title="三字符字符串组合"></a>三字符字符串组合</h2><p>[题目]<br>仅由三个字符 A, B, C 构成字符串，且字符串任意三个相邻元素不能完全相同。如 “ACCCAB” 不合法，”ABBCBCA” 合法。求满足条件的长度为 n 的字符串个数。note: 假定不考虑整数溢出，并且要求时间和空间复杂度不高于 O(N)。</p>
<p>[分析]</p>
<ol>
<li>若当前已经有了所有长度为 n-1 的合法字符串，如何在末端增加一个字符，形成长度为 n 的字符串呢？</li>
<li>将长度为 n-1 字符串分成”末尾两个字符不相等“和”末尾两个字符相等“两种情况，各自数目记做 dp[n-1][0], dp[n-1][1]:<ol>
<li>dp[n][0] = 2 * dp[n-1][0] + 2 * dp[n-1][1]</li>
<li>dp[n][1] = dp[n-1][0]</li>
<li>初始条件是 dp[1][0] = 3, dp[1][1] = 0</li>
</ol>
</li>
</ol>
<h3 id="改进空间复杂度"><a href="#改进空间复杂度" class="headerlink" title="改进空间复杂度"></a>改进空间复杂度</h3><ol start="3">
<li><mark>状态转移方程总结与改进</mark><ol>
<li>滚动数组法</li>
<li>dp[0] = 2 * dp[0] + 2 * dp[1]</li>
<li>dp[1] = dp[0]</li>
<li>此法将空间复杂度由 O(N) 降到 O(1)</li>
</ol>
</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t = nNonRepeat;</span><br><span class="line">        nNonRepeat = <span class="number">2</span> * (nNonRepeat + nRepeat);</span><br><span class="line">        nRepeat = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nNonRepeat + nRepeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进时间复杂度"><a href="#改进时间复杂度" class="headerlink" title="改进时间复杂度"></a>改进时间复杂度</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/2020-01-04-at-15-36-26.png" alt=""></p>
<p>而一个矩阵的 n 次幂可以用递归方法来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix2x2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    Matrix2x2(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd) : a(aa), b(bb), c(cc), d(dd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd)</span></span>&#123;</span><br><span class="line">        a = aa;</span><br><span class="line">        b = bb;</span><br><span class="line">        c = cc;</span><br><span class="line">        d = dd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMultiply</span><span class="params">(Matrix2x2 &amp; m, Matrix2x2 &amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = m.a * n.a + m.b * n.c;</span><br><span class="line">    <span class="keyword">int</span> b = m.a * n.b + m.b * n.d;</span><br><span class="line">    <span class="keyword">int</span> c = m.c * n.a + m.d * n.c;</span><br><span class="line">    <span class="keyword">int</span> d = m.c * n.b + m.d * n.d;</span><br><span class="line">    m.Set(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixN</span><span class="params">(Matrix2x2 &amp; m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        m.Set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 单位阵</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 偶数</span></span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           <span class="comment">// 奇数</span></span><br><span class="line">        Matrix2x2 x = m;</span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">        MatrixMultiply(m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Matrix2x2 <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    MatrixN(m, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * (m.a + m.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打气球-leetcode-312"><a href="#打气球-leetcode-312" class="headerlink" title="打气球 leetcode 312"></a>打气球 leetcode 312</h2><p>[题目]<br>给定一串气球，要全部打坏。每个气球上有一个整数，打坏它的得分等于它和左右邻居上的一共三个整数的乘积。<br>如果没有左右邻居，那么视为 1，求最大总得分。</p>
<p>[分析]</p>
<ol>
<li>这个题目拿到手一看就是用 DP</li>
<li>可以先假定用 <code>DP[i][j]</code> 表示气球 i 到气球 j 这一串气球都打完的得分是多少。</li>
<li>问题的难点在于？<ol>
<li>DP 的递推式该怎么样写？</li>
<li>打完一个气球后，本来不相邻的邻居现在变成邻居了，怎么办？</li>
</ol>
</li>
<li>关键思路在于: <mark>总有最后一个消灭的气球</mark></li>
<li>假定 <code>DP[i][j]</code> 里面气球 k 最后一个打破<ol>
<li>那么 <code>DP[i][k-1]</code> 是一个子问题，要最大得分</li>
<li><code>DP[k+1][j]</code> 也是一个子问题，要最大得分</li>
<li>两个字问题被气球 k 隔离，“边界”的气球不会变</li>
</ol>
</li>
<li>因此递推关系式如下<ol>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[k-1] * nums[k] * nums[k+1])\)</li>
<li><mark>上面的式子是错误的！</mark></li>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[i-1] * nums[k] * nums[j+1])\)</li>
<li>要注意如果 k-1 &lt; i, 那么 <code>DP[i][k-1]</code> 要理解成 0</li>
</ol>
</li>
<li>最终结果是 <code>DP[0][n-1]</code></li>
<li>更新顺序是: (j-i) 从小到大</li>
<li>时间复杂度 O(N^3)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">DP</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i+len) &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                DP[i][j] = <span class="built_in">max</span>(dp[i][j], ((i &lt;= k<span class="number">-1</span>) ? DP[i][k<span class="number">-1</span>] : <span class="number">0</span>) + ((k + <span class="number">1</span> &lt;= j) ? DP[k+<span class="number">1</span>][j] : <span class="number">0</span>)</span><br><span class="line">                + ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? nums[i<span class="number">-1</span>] : <span class="number">1</span>) * nums[k] * ((j + <span class="number">1</span> &lt; n) ? nums[j + <span class="number">1</span>] : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/leetcode-greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/31/leetcode-greedy/" itemprop="url">leetcode-greedy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-31T21:10:37-08:00">
                2019-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/31/leetcode-greedy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/31/leetcode-greedy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="稳定匹配问题"><a href="#稳定匹配问题" class="headerlink" title="稳定匹配问题"></a>稳定匹配问题</h2><p>[题目]<br>假如你是一个媒人，有若干个单身男子登门求助，还有同样多的单身女子也前来征婚。如果你已经知道这些女孩在每个男人心目中的排名，以及男孩们在每个女孩心中的排名(1)，你应该怎样为他们牵线配对呢？</p>
<p>这个匹配要稳定：<br>如果男 1 号和女 1 号各自有各自的对象，但男 1 号觉得，比起自己现在的对象，女 1 号更好一些；女 1 号也发现，在自己心目中，男 1 号的排名比现男友更靠前一些。这样一来，这两人就可能会发生外遇，最后扔下各自现在的对象，一起私奔了——因为这个结果对他们两人都更好一些。在一种男女配对的方案中，如果出现了这种情况，我们就说婚姻搭配是不稳定的。</p>
<p>[思路]</p>
<ol>
<li>1962 年，美国数学家 David Gale 和 Lloyd Shapley 发明了一种寻找稳定婚姻的策略。不管男女各有多少人，不管他们各自的偏好如何，应用这种策略后总能得到一个稳定的婚姻搭配。换句话说，他们证明了稳定的婚姻搭配总是存在的。有趣的是，这种策略反映了现实生活中的很多真实情况。</li>
<li>在这种策略中，男人将一轮一轮地去追求他中意的女子，女子可以选择接受或者拒绝她的追求者。第一轮，每个男人都选择自己名单上排在首位的女人，并向她表白。此时，一个女孩儿可能面对的情况有三种：没有人跟她表白，只有一个人跟她表白，有不止一个人跟她表白。在第一种情况下，这个女孩儿什么都不用做，只需要继续等待；在第二种情况下，接受那个人的表白，答应暂时和他做男女朋友；在第三种情况下，从所有追求者中选择自己最中意的那一位，答应和他暂时做男女朋友，并拒绝其他所有的追求者。</li>
<li>第一轮结束后，有些男人已经有女朋友了，有些男人仍然是单身。在第二轮追女行动中，每个单身男都从所有还没拒绝过他的女孩中选出自己最中意的那一个，并向她表白，不管她现在是否是单身。和第一轮一样，女孩儿们需要从表白者中选择最中意的一位，拒绝其他追求者。注意，如果这个女孩儿已经有男朋友了，当她遇到了更好的追求者时，她必须拒绝掉现在的男友，投向新的追求者的怀抱。这样，一些单身男人将会得到女友，那些已经有了女友的人也可能会被甩掉，重新变成光棍。在以后的每一轮中，单身的男人继续追求列表中的下一个女孩儿，女孩儿则从包括现男友在内的所有追求者中选择最好的一个，并对其他人说不。这样一轮一轮地进行下去，直到某个时候所有人都不再单身，下一轮将不会有任何新的表白发生，整个过程自动结束。此时的婚姻搭配就一定是稳定的了。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gahqf5s50kj207w071wei.jpg" alt="StableMatching"></p>
<p>[思考和应用]</p>
<ol>
<li>[历史应用] 历史上，这样的“配对游戏”还真有过实际应用，并且更有意思的是，这个算法的应用居然比算法本身的提出还早 10 年。早在 1952 年，美国就开始用这种办法给医学院的学生安排工作，这被称之为“全国住院医师配对项目”。配对的基本流程就是，各医院从尚未拒绝这一职位的医学院学生中选出最佳人选并发送聘用通知，当学生收到来自各医院的聘用通知后，系统会根据他所填写的意愿表自动将其分配到意愿最高的职位，并拒绝掉其它的职位。如此反复，直到每个学生都分配到了工作。当然，那时人们并不知道这样的流程可以保证工作分配的稳定性，只是凭直觉认为这是很合理的。直到 10 年之后， Gale 和 Shapley 才系统地研究了这个流程，提出了稳定婚姻问题，并证明了这个算法的正确性。</li>
<li>[男女公平吗]<ol>
<li>对男生是 optimal 的，对女生是 pesimal 的。</li>
<li>如果换一下顺序，让女生去追男的，那么结果对女生就是 optimal，对男生就是 pesimal 的。</li>
<li>注意！！！有一些简单的例子你换个顺序做会发现结果一样，这并不名说明上面的 optimal-pesimal 结论有错误，而是因为这个简单的例子只有一种可能的 stable matching. 所以两种方法都会得到这唯一的结果。</li>
<li>只有当有多个 stable solution 存在的时候（每一个solution 里面男 A 都有一个配偶），你会发现，如果是男追女，那么男A 最后的配偶一定是这些 solution 里面的配偶中男A 最喜欢的那个！而女人的配偶一定是这些solution 里面最差的那个。</li>
</ol>
</li>
<li><mark>[现实联系]</mark><ol>
<li><mark>想想生活中，一般都是男追女</mark></li>
<li><mark>那么男生先从自己最喜欢的女生追起来是很符合逻辑的</mark></li>
<li><mark>然后女生呢，只要有男生追自己，那么就先答应着！如果后面碰到更好的，就把男友踹了跟新来者谈恋爱</mark></li>
</ol>
</li>
</ol>
<p>[算法分析]</p>
<ol>
<li>贪心法<ol>
<li>我们希望第 k 个任务的计算占用空间加上前面 k-1 个任务的存储空间占用量之和，越小越好。</li>
<li>O_1 + O_2 + … + O_j + … + O_{k-1} + R_k &lt;=  O_1 + O_2 + … + O_k + … + O_{k-1} + R_j</li>
<li>上面公式的右边是假定从左边拿了任务 j 与 最后的任务 k 交换了</li>
<li>化简上面不等式，得到 O_j + R_k &lt;= O_k + R_j，得到 R_k - O_k &lt;= R_j - O_j</li>
<li>也就是说，只需要把 {R_i - O_i} 降序排列就可以了！</li>
</ol>
</li>
</ol>
<h2 id="Interval-Scheduling-区间调度问题"><a href="#Interval-Scheduling-区间调度问题" class="headerlink" title="Interval Scheduling 区间调度问题"></a>Interval Scheduling 区间调度问题</h2><p>[题目]</p>
<ul>
<li>给你很多形如 [starg, end] 的闭区间，</li>
<li>请设计一个算法，算出这些区间中最多有几个互不相交的区间。</li>
</ul>
<p>[例子]</p>
<ul>
<li>输入 [[1,3], [2,4], [3,6]]</li>
<li>分析 [[1,3], [3,6]]</li>
<li>输出 2</li>
<li>注意！[1,3] 和 [3,6] 边界相同，但是不算相交。</li>
</ul>
<p>[分析]</p>
<ul>
<li>正确的思路其实很简单，可以分为以下三步：<ul>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ul>
</li>
</ul>
<p>[代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435 无重叠区间"></a>leetcode 435 无重叠区间</h3><p>[题目]</p>
<ul>
<li>给定一个区间的集合，找到需要移除区间的最小数量，使得剩余区间互不重叠。</li>
<li>注意<ul>
<li>可以认为区间的终点总是大于它的起点</li>
<li>两个区间的边界相互接触不算重叠。</li>
</ul>
</li>
</ul>
<p>[分析]</p>
<ul>
<li>我们已经会求最多有几个区间不会重叠 了，那么剩下的不就是需要去除的区间吗？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">return</span> n - intervalSchedule(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-452-最少的箭射爆气球"><a href="#leetcode-452-最少的箭射爆气球" class="headerlink" title="leetcode 452 最少的箭射爆气球"></a>leetcode 452 最少的箭射爆气球</h3><p>[题目]</p>
<ul>
<li>在二维空间里有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。</li>
<li>由于它是水平的，所以 y 坐标并不重要。只需要知道开始和结束的 x 坐标就足够了。</li>
<li>开始坐标总是小于结束坐标。</li>
<li>平面内最多存在 10^4 个气球。</li>
<li>一支箭可以沿着 x 轴从不同点完全垂直地射出。</li>
<li>在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x_start, x_end, 且满足 x_start &lt;= x &lt;= x_end, 则该气球会被引爆</li>
<li>弓箭可以无限前进</li>
<li>我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</li>
</ul>
<p>[分析]</p>
<ul>
<li>这个问题和区间调度算法一模一样！如果最多有n个不重叠的区间，那么就至少需要n个箭头穿透所有区间：</li>
<li>只是有一点不一样，在intervalSchedule算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</li>
<li>所以只要将之前的算法稍作修改，就是这道题目的答案</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 把 &gt;= 改成 &gt; 就行了</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/leetcode-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/leetcode-graph/" itemprop="url">leetcode-graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-28T17:44:02-08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/leetcode-graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/28/leetcode-graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><ul>
<li>图的遍历和搜索</li>
<li>（隐式）图的搜索（连通性）<ul>
<li>重点</li>
<li>8皇后</li>
</ul>
</li>
<li>最短路径<ul>
<li>单源图 (Dijkstra)</li>
<li>任意两点 (floyd)</li>
<li>有负边</li>
</ul>
</li>
<li>最小生成树 (MST)<ul>
<li>Prim</li>
<li>Krusal</li>
</ul>
</li>
<li>拓扑排序 (Topological Sort)</li>
</ul>
<h2 id="图的表示和搜索"><a href="#图的表示和搜索" class="headerlink" title="图的表示和搜索"></a>图的表示和搜索</h2><ul>
<li>图的表示<ul>
<li>邻接矩阵<ul>
<li>NxN 的矩阵，有边是 1，无边是 0</li>
</ul>
</li>
<li>邻接表<ul>
<li>为每个点建立一个链表（数组）存放与之连接的点</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="所有括号匹配的字符串-leetcode-0022"><a href="#所有括号匹配的字符串-leetcode-0022" class="headerlink" title="所有括号匹配的字符串  leetcode 0022"></a>所有括号匹配的字符串  leetcode 0022</h2><p>[题目]<br>N 对括号能够得到的有效括号序列有哪些？</p>
<p>[例子]<br>N = 3, 有效括号串共 5 个，分别为：</p>
<ol>
<li>()()()</li>
<li>()(())</li>
<li>(())()</li>
<li>(()())</li>
<li>((()))</li>
</ol>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>[分析]</p>
<ul>
<li>关键的思路是：当前位置左括号不少于右括号</li>
<li>图是什么？<ul>
<li>节点：目前位置左括号和右括号数 (x, y) (x &gt;= y)</li>
<li>边: 从 (x,y) 到 (x+1, y) 和 (x, y+1)</li>
<li>当 x == y 时，没有到 (x, y+1) 这条边</li>
</ul>
</li>
<li>解是什么？<ul>
<li>从 (0,0) 出发到 (n,n) 的全部路径</li>
</ul>
</li>
<li>DFS 方法<ul>
<li>记录什么？<ul>
<li>左右括号的个数</li>
<li>当前的部分解</li>
</ul>
</li>
</ul>
</li>
<li>BFS 方法<ul>
<li>记录什么？<ul>
<li>方法一 当前的“部分解” —- 浪费空间</li>
<li>方法二 每个节点记录能到达它之前的节点集合 —- 麻烦，最后要还原路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>先看一下 DFS 如何实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param x: number of left parenthesis</span></span><br><span class="line"><span class="comment">@param y: number of right parenthesis</span></span><br><span class="line"><span class="comment">@param now: current solution</span></span><br><span class="line"><span class="comment">@param answer: return object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> now, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; answer)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意在递归调用时，我们始终保证 x &gt;= y 并且 x &lt;= n</span></span><br><span class="line">    <span class="keyword">if</span> (y == n) &#123;    <span class="comment">// 此时 x 一定也等于 n</span></span><br><span class="line">        answer.push_back(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; n) &#123;    <span class="comment">// 从 (x, y) 到 (x + 1, y) 的路径</span></span><br><span class="line">        dfs(n, x + <span class="number">1</span>, y, now + <span class="string">"("</span>, answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;    <span class="comment">// 从 (x, y) 到 (x, y + 1) 的路径</span></span><br><span class="line">        dfs(n, x, y + <span class="number">1</span>, now + <span class="string">")"</span>, answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">    dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看 BFS 的第一种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param x: number of left parenthesis</span></span><br><span class="line"><span class="comment">@param y: number of right parenthesis</span></span><br><span class="line"><span class="comment">@param now: current solution</span></span><br><span class="line"><span class="comment">@param answer: return object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">string</span> now;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; answer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        answer.push_back(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.x = temp.y = <span class="number">0</span>;</span><br><span class="line">    temp.now = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(q.push(temp); !q.empty(); q.pop())&#123;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        node other;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.x &lt; n)&#123;    <span class="comment">// 从 (x, y) 到 (x + 1, y) 的路径</span></span><br><span class="line">            other.x = temp.x + <span class="number">1</span>;</span><br><span class="line">            other.y = temp.y;</span><br><span class="line">            other.now = temp.now + <span class="string">"("</span>;</span><br><span class="line">            q.push(other);       <span class="comment">// 这里因为是加的左括号，因此一定不可能是最后的一个解，可以直接放到 q</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.x &gt; temp.y) &#123;    <span class="comment">// 从 (x, y) 到 (x, y+1) 的路径</span></span><br><span class="line">            other.x = temp.x;</span><br><span class="line">            other.y = temp.y + <span class="number">1</span>;</span><br><span class="line">            other.now = temp.now + <span class="string">")"</span>;</span><br><span class="line">            <span class="keyword">if</span> (other.y == n)&#123;</span><br><span class="line">                answer.push_back(other.now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.push(other);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">    bfs(n, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>[问题分析]</p>
<ul>
<li>任何一个括号序列，都可以写成形式 (A)B<ul>
<li>A 和 B 都是若干括号对形成的合法串（可以是空串）</li>
<li>若 N=0, 括号序列为空</li>
<li>若 N=1, 括号序列只能是 () 这一种。</li>
</ul>
</li>
<li>算法描述: i 属于 [0, N-1]<ul>
<li>计算 i 对括号的可行序列 A</li>
<li>计算 N-i-1 对括号的可行序列 B</li>
<li>组合得到 (A)B</li>
<li>注：加上额外一对括号 (), 总括号数量是 N 对</li>
</ul>
</li>
</ul>
<p><mark>注意下面算法有直接修改数组最后一个元素! 使用了返回引用的方法！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">AllParentheses</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; prefix, suffix, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        prefix = AllParentheses(i);</span><br><span class="line">        suffix = AllParentheses(n-i<span class="number">-1</span>);</span><br><span class="line">        Unit(result, prefix, suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prefix, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; suffix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip = prefix.<span class="built_in">begin</span>(); ip != prefix.<span class="built_in">end</span>(); ip++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> is = suffix.<span class="built_in">begin</span>(); is != suffix.<span class="built_in">end</span>(); is++)&#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">            <span class="built_in">string</span>&amp; r = result.back();    <span class="comment">// 这里返回的是引用！技巧啊！！</span></span><br><span class="line">            r += <span class="string">"("</span>;</span><br><span class="line">            r += *ip;</span><br><span class="line">            r += <span class="string">")"</span>;</span><br><span class="line">            r += *is;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思考]</p>
<ul>
<li>可以通过增加缓存的方式，对已经计算得到的字串直接获取，以空间换时间，降低时间复杂度。</li>
<li>如果只是计算可行括号串的数目，如何计算？<ul>
<li>事实上，数组 A[i] 表示长度为 i 的括号串的可行数目，即著名的 Catalan 数！</li>
</ul>
</li>
<li>Calalan 数（从 0 开始数）<ul>
<li>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, …</li>
</ul>
</li>
</ul>
<h2 id="最小平方划分"><a href="#最小平方划分" class="headerlink" title="最小平方划分"></a>最小平方划分</h2><p>[题目]<br>一个正整数可以由若干个正整数的平方和表示，求整数 201314 最小的平方划分数目。</p>
<p>[我的本来思路]<br>用DP的方法！</p>
<p>假设已知 1, …, n-1 的最小划分保存在数组 split[i] 中。求数 n 最小划分。</p>
<p>只需要遍历 1, …, n/2，然后看哪一个 split[i] + split[n-i] 最小，即是 n 的最小划分。</p>
<p>[优化的思路]<br>我的思路时间复杂度是 O(n^2), 因为对于每一个 n, 我都要考虑到 n/2 种情况。</p>
<p>事实上，这个题目可以优化到 O(n sqrt(n)) 的时间复杂度。具体做法就是考虑 n = a + K^2。<br>也就是说，只需要考虑 1 … K 这么多数字，其中 K = sqrt(n).<br>若 split[n - k^2] + 1 &lt; x (x 是当前的 n 的最小划分数目), 则将 x 更新为 split[n - k^2] + 1</p>
<p><mark>[如何求平方根]</mark><br>可以使用牛顿法。<br>牛顿法就是求一个方程的解的方法。</p>
<p>[题外话]<br>四平方和定理</p>
<ul>
<li>每个正整数均可表示为最多4个整数的平方和。</li>
<li>证明<ul>
<li>首先欧拉发现：如果正整数 m 和 n 能表示成 4 个整数的平方和，则其乘积 mn 也能表示成 4 个整数的平方和。</li>
<li>而由于每个正整数要么是质数，要么是合数，而合数都可以表达成质数的乘积形式。</li>
<li>因此只需要证明每个质数可以表示成四个整数的平方和即可！</li>
<li>拉格朗日和欧拉分别在 1770 和 1773 年做出证明。</li>
</ul>
</li>
</ul>
<h2 id="Palindrome-Partitioning-所有划分"><a href="#Palindrome-Partitioning-所有划分" class="headerlink" title="Palindrome Partitioning 所有划分"></a>Palindrome Partitioning 所有划分</h2><p>[题目]<br>给定一个字符串 str, 将 str 划分成若干子串，使得每一个子串都是回文串。计算 str 的所有可能的划分。</p>
<p>note: 因为单个字符一定是回文串，所以一定有解！</p>
<p>[思路一]</p>
<ul>
<li>若当前计算得到了 str[0 … i-1] 的所有划分，可否添加 str[i … j], 得到更大的划分呢？<ul>
<li>显然，若 str[i…j] 是回文串，则可以添加。</li>
</ul>
</li>
<li>剪枝: 在每一步都可以判断中间结果是否为合法结果<ul>
<li>回溯 + 剪枝：如果某一次发现划分不合法，立刻对该分支限界</li>
</ul>
</li>
</ul>
<p>[思路一的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSolution</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; oneSolution, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome[start][i])&#123;</span><br><span class="line">            oneSolution.push_back(str.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">            FindSolution(str, n, res, i + <span class="number">1</span>, oneSolution, isPalindrome);</span><br><span class="line">            oneSolution.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二维 DP 来构建 isPalindrome 矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        p[i][i] = True;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                isPalindrome[i][j] = True;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">PalindromePartitioning</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPalindrome</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;str&gt; oneSolution;    <span class="comment">// 记录一个解！！！</span></span><br><span class="line">    FindSolution(str, n, res, start, oneSolution, isPalindrome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>[思路二：动态规划]</p>
<ul>
<li>如果已知 str[0 … i-1] 的所有回文划分结果 res(i)</li>
<li>如何求 str[0 … i] 的所有划分呢？<ul>
<li>如果子串 str[j … i] 是回文串，则将该字串和 res(j) 共同添加到 res(i+1) 中。</li>
</ul>
</li>
<li>算法<ul>
<li>将集合 res 置空</li>
<li>遍历 j(0 &lt;= j &lt; i), 若 str[j … i] 是回文串，则将 {str[j…i], res(j)} 添加到 res(i+1) 中</li>
<li>i 从 0 到 n，一次调用上面两步骤，最终返回 res(n) 即为所求。</li>
</ul>
</li>
</ul>
<p>[思路二的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">res = &#123;</span></span><br><span class="line"><span class="comment">    &#123;&#123;&#125;&#125;,</span></span><br><span class="line"><span class="comment">    &#123;&#123;"a"&#125;&#125;,</span></span><br><span class="line"><span class="comment">    &#123;&#123;"a","a"&#125;, &#123;"aa"&#125;&#125;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        p[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                isPalindrome[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">PalindromePartitioning</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPalindrome</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line">    </span><br><span class="line">    res.push_back(&#123;&#123;&#125;&#125;);</span><br><span class="line">    res.push_back(&#123;&#123;str.substr(<span class="number">0</span>,<span class="number">1</span>)&#125;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it: res[j])&#123;    <span class="comment">// "it" is a vector of strings</span></span><br><span class="line">                    it.push_back(str.substr(j, i-j));</span><br><span class="line">                &#125;</span><br><span class="line">                temp.push_back(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS-与-DP-的思考"><a href="#DFS-与-DP-的思考" class="headerlink" title="DFS 与 DP 的思考"></a>DFS 与 DP 的思考</h3><ol>
<li>DFS 的过程，是计算完成了 str[0…i] 的切分，然后递归调用，继续计算 str[i+1, i+2, … n-1] 的过程；</li>
<li>而 DP 中，假定得到了 str[0 … i-1] 的所有可能切分方案，如何扩展得到 str[0…i] 的切分</li>
<li>从本质上说，二者是等价的：最终都是搜索一颗隐式树<ol>
<li>DFS 显然是深度优先搜索，DP 有点类似于层序遍历的思想。</li>
</ol>
</li>
</ol>
<h3 id="归纳推理的理解"><a href="#归纳推理的理解" class="headerlink" title="归纳推理的理解"></a>归纳推理的理解</h3><ol>
<li>第一数学归纳法，类似于马尔科夫模型，有状态 i 推理得到状态 i+1</li>
<li>第二数学归纳法，则是有状态 0 到 i 一起推理得到状态 i+1.</li>
</ol>
<h2 id="Word-break-leetcode-0139"><a href="#Word-break-leetcode-0139" class="headerlink" title="Word break leetcode 0139"></a>Word break leetcode 0139</h2><p>[题目]<br>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ol>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ol>
<p>[我的思路]</p>
<ol>
<li>用 DP 来记录各个长度的从头开始的子串是否满足条件。</li>
<li>如果 DP[i] 为 true, 则遍历字典中所有字符串 temp<ol>
<li>如果目标字符串 <code>s.substr(i, temp.size()) == temp</code> </li>
<li>那么可以更新 DP[i + temp.size()] 也为真</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(s.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(res[i])&#123;                    <span class="comment">// 截止到前i个字符，都是可以的</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> ss: wordDict)&#123;</span><br><span class="line">                    <span class="comment">// 注意这里的技巧，如果 res[i + ss.size()] 已经为真就不必要取子串判断了</span></span><br><span class="line">                    <span class="keyword">if</span>(i + ss.<span class="built_in">size</span>() &lt;= s.<span class="built_in">size</span>() &amp;&amp; (res[i + ss.<span class="built_in">size</span>()] || (ss.compare(s.substr(i, ss.<span class="built_in">size</span>())) == <span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; ss &lt;&lt; " " &lt;&lt; s.substr(i, ss.size()) &lt;&lt; endl;</span></span><br><span class="line">                        res[i + ss.<span class="built_in">size</span>()] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i+ss.<span class="built_in">size</span>() == s.<span class="built_in">size</span>())</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.<span class="built_in">size</span>()];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Word-break-2-leetcode-0140"><a href="#Word-break-2-leetcode-0140" class="headerlink" title="Word break 2 leetcode 0140"></a>Word break 2 leetcode 0140</h2><h2 id="几个-backtracking-题目"><a href="#几个-backtracking-题目" class="headerlink" title="几个 backtracking 题目"></a>几个 backtracking 题目</h2><h3 id="Combination-Sum-leetcode-0039"><a href="#Combination-Sum-leetcode-0039" class="headerlink" title="Combination Sum leetcode 0039"></a>Combination Sum leetcode 0039</h3><p>[题目]</p>
<ol>
<li>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</li>
<li>The same repeated number may be chosen from candidates unlimited number of times.</li>
<li>Note:<ol>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ol>
</li>
<li>Example 1:<ol>
<li>Input: candidates = [2,3,6,7], target = 7,</li>
<li>A solution set is: [ [7], [2,2,3] ]</li>
</ol>
</li>
<li>Example 2:<ol>
<li>Input: candidates = [2,3,5], target = 8,</li>
<li>A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ]</li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ul>
<li>先排序<ul>
<li>可以降低搜索次数，因为是从小到大搜，一旦有一个元素已经超过剩下的数值了，后面的元素也就不用看了</li>
</ul>
</li>
<li>如何才能使得数字重复利用<ul>
<li>当前从 i 位置开始搜索的，</li>
<li>把 candidates[i] 放到 combination 里面后</li>
<li>递归调用时候还是传递 begin = i，这样子还可以把 candidates[i] 接着放进去</li>
</ul>
</li>
<li>如何避免产生重复的 combinations<ul>
<li>从第 begin 个位置往下递归的调用不能进入小于 begin 的位置</li>
<li>即加入当前加入 3 了，那么剩下的结果你不要又从头开始看加个 1， 加个2， 加个 3；你只能看加个 3，加个 4，etc</li>
<li>否则你有一个递归是先加入 2，再加入的 3；而另外可能有一个递归是先加入了 3，再加入的 2.</li>
</ul>
</li>
</ul>
<p><mark>这个代码非常简洁优美！</mark> 来自<a href="https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c%2B%2B-solution-use-backtracking-easy-understand." target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        combinationSum(candidates, target, res, combination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != candidates.<span class="built_in">size</span>() &amp;&amp; target &gt;= candidates[i]; ++i) &#123;   <span class="comment">// target &gt;= candidates[i] 相当于剪枝了！</span></span><br><span class="line">            combination.push_back(candidates[i]);</span><br><span class="line">            combinationSum(candidates, target - candidates[i], res, combination, i);    <span class="comment">// 把 i 当做 begin, 既保证元素可以重复，</span></span><br><span class="line">            combination.pop_back();                                                     <span class="comment">// 又保证结果中不会出现重复的 combination</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Combination-Sum-II-leetcode-0040"><a href="#Combination-Sum-II-leetcode-0040" class="headerlink" title="Combination Sum II leetcode 0040"></a>Combination Sum II leetcode 0040</h3><p>[题目]</p>
<ul>
<li>参考上面 Combination Sum 的题目</li>
<li>这里的区别在于<font color="red">candidates元素只能用一次</font></li>
</ul>
<p>[思路]</p>
<ul>
<li>代码跟上面的 leetcode 0039 很类似</li>
<li>要注意的是如何保证 candidates 元素只能用一次</li>
<li>不能简单地这么做：递归调用时候传递 <code>begin</code> 为 <code>i+1</code> (上一题是 <code>begin = i</code>)<ul>
<li>这么做会导致重复</li>
<li>假设搜到某个步骤时候 target 变成 5 了</li>
<li>而此时 candidates 里面有 4 个 5</li>
<li>那么上面的做法会使得结果里面有 4 个一样的 combinations</li>
</ul>
</li>
<li>正确的方法是：<ul>
<li>加一个判断语句, 参见代码，真是优美！</li>
<li><code>if(i == begin || candidates[i] != candidates[i-1]) {...}</code></li>
<li><code>i == begin</code> 保证了只会连续得看，不会跳着看</li>
<li>即如果有 k 个 5，那么递归的时候只会考虑第一个 5 ，剩下的 5 就都跳过了</li>
<li>注意这里并没有说相同的 5 只考虑一个</li>
<li>因为 k 个 5 的时候考虑了第一个 5，此时递归下去后，下一次函数调用看到了 k-1 个连续的 5，它只会考虑第一个 5</li>
<li><mark>这样子就保证了如果某个 combination 里面有 m 个 5，那么它一定来自于 candidates 中连续的 k 个 5 中最左边 m 个！！！</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        combinationSum2(candidates, target, res, combination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != candidates.<span class="built_in">size</span>() &amp;&amp; target &gt;= candidates[i]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">begin</span> || candidates[i] != candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                combination.push_back(candidates[i]);</span><br><span class="line">                combinationSum2(candidates, target - candidates[i], res, combination, i + <span class="number">1</span>);</span><br><span class="line">                combination.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Combination-Sum-III-leetcode-0216"><a href="#Combination-Sum-III-leetcode-0216" class="headerlink" title="Combination Sum III leetcode 0216"></a>Combination Sum III leetcode 0216</h3><p>[题目]</p>
<ul>
<li>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</li>
<li>Note:<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
</li>
<li>Example 1:<ul>
<li>Input: k = 3, n = 7</li>
<li>Output: [[1,2,4]]</li>
</ul>
</li>
<li>Example 2:<ul>
<li>Input: k = 3, n = 9</li>
<li>Output: [[1,2,6], [1,3,5], [2,3,4]]</li>
</ul>
</li>
</ul>
<p>[思路]</p>
<ul>
<li>这一题比前两题都简单我觉得，因为你搜索的数字是 1-9，它们没有重复元素啊！！！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(combination);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt;= <span class="number">9</span> &amp;&amp; i &lt;= target; i++)&#123;</span><br><span class="line">            combination.push_back(i);</span><br><span class="line">            helper(k<span class="number">-1</span>, target - i, ans, combination, i+<span class="number">1</span>);</span><br><span class="line">            combination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        helper(k, n, ans, combination, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="subsets-leetcode-0078"><a href="#subsets-leetcode-0078" class="headerlink" title="subsets leetcode 0078"></a>subsets leetcode 0078</h3><p>[题目]</p>
<ul>
<li>Given a set of distinct integers, nums, return all possible subsets (the power set).</li>
<li>Note: The solution set must not contain duplicate subsets.</li>
<li>Example:<ul>
<li>Input: nums = [1,2,3]</li>
<li>Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]</li>
</ul>
</li>
</ul>
<p>[解法一：DFS 代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, ans, temp, <span class="built_in">begin</span>+<span class="number">1</span>);    <span class="comment">// 不放当前字母，递归看下一个位置</span></span><br><span class="line">            </span><br><span class="line">        temp.push_back(nums[<span class="built_in">begin</span>]);</span><br><span class="line">        dfs(nums, ans, temp, <span class="built_in">begin</span>+<span class="number">1</span>);    <span class="comment">// 放当前字母，然后递归看下一个位置。</span></span><br><span class="line">        temp.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        dfs(nums, ans, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种 dfs 实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;    <span class="comment">// 在这里声明也可以，不过不太好我觉得</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        dfs(<span class="number">0</span>, ans, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        res.push_back(ans);                            <span class="comment">// 开头第一句这个 很精髓！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">            dfs(i + <span class="number">1</span>, ans, nums);</span><br><span class="line">            ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[解法二: BFS]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：</span></span><br><span class="line"><span class="comment">组合|非递归实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 最外层循环逐一从 nums 数组中取出每个元素 num</span></span><br><span class="line"><span class="comment">2. 内层循环从原来的结果集中取出每个中间结果集，并向每个中间结果集中添加该 num 元素</span></span><br><span class="line"><span class="comment">3. 往每个中间结果集中加入 num</span></span><br><span class="line"><span class="comment">4. 将新的中间结果集加入结果集中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">邢政：这个非递归的我没有想出来最开始，主要还是我是从排列组合的角度去思考，先考虑空集合，</span></span><br><span class="line"><span class="comment">接着考虑只有一个元素的集合，再下来只有两个元素的subsets，这样子很不好弄。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而如下的算法非常巧妙，外层 for 循环一共执行 n 次 (n 是有多少个数字)，</span></span><br><span class="line"><span class="comment">内层for 循环是每次去看 result 里面已经有多少个集合了，然后每个集合取出来添加一个相同的当前数字，</span></span><br><span class="line"><span class="comment">形成的新集合放到 result 里面！！</span></span><br><span class="line"><span class="comment">非常巧妙！ 以 1，2，3 为例：</span></span><br><span class="line"><span class="comment">循环之前：res = &#123;&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">第一次循环，取出空集合，加入数字“1”并放回result中，res = &#123;&#123;&#125; &#123;1&#125;&#125;</span></span><br><span class="line"><span class="comment">第二次循环，取出集合 &#123;&#125; 和 &#123;1&#125;，分别加入数字“2”，新的两个集合放到 result中， res = &#123;&#123;&#125; &#123;1&#125; &#123;2&#125; &#123;1,2&#125;&#125;</span></span><br><span class="line"><span class="comment">第三次循环，取出result中的四个集合，加入数字“3”，新的4个集合放回result中，res= &#123;&#123;&#125; &#123;1&#125; &#123;2&#125; &#123;1,2&#125; &#123;3&#125; &#123;1,3&#125; &#123;2,3&#125; &#123;1,2,3&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss = res.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ss; j++)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = res[j];</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[解法三: 集合论]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">解法三：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">利用我们的集合论的知识，我们知道对于一个集合来说，若其元素个数为 n ，则其子集的个数为 2^n 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于其中元素来说，就是在当前子集和不在当前子集两种状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于任意一个子集，我们用一个长度为 n 的01串来表示在不在的状态。其中1表示在，0表示不在。比如：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">| 6 | 5 | 4 | 3 | 2 | 1 |    第i个元素</span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">| 1 | 0 | 0 | 1 | 0 | 1 |    是否在集合</span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">该01串也可以表示成二进制数(100101)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于一个集合来说，其子集若都采用这样的01串来表示，恰好覆盖了从 0 ~ 2^n-1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因此我们同样可以利用这个性质，枚举从0到2^n-1，然后依次还原这个子集。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现请参考下面的代码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">        <span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>()) - <span class="number">1</span>; <span class="comment">// 2^n-1</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());     <span class="comment">// 排序，保证子集的是由小到大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= limit; ++i) &#123;  <span class="comment">// 枚举 0 ~ 2^n-1</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp;</span><br><span class="line">            <span class="keyword">int</span> p = i, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                <span class="comment">// 若该位为1，则表示该位需要存入子集</span></span><br><span class="line">                <span class="keyword">if</span> (p &amp; <span class="number">1</span> == <span class="number">1</span>) tp.push_back( nums[now] );</span><br><span class="line">                p &gt;&gt;= <span class="number">1</span>, ++now;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="subsets-II-leetcode"><a href="#subsets-II-leetcode" class="headerlink" title="subsets II leetcode"></a>subsets II leetcode</h3><p>[题目]</p>
<p>[解法 DFS 代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="built_in">begin</span> || nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                dfs(nums, ans, temp, i+<span class="number">1</span>);    <span class="comment">// 放当前字母</span></span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        dfs(nums, ans, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树要求从一个带权无相连通图中选择 n-1 条边并使这个图仍然联通（即得到了一棵生成树），同时还要求树的权重最小。<br>解决这个问题有两个很著名的算法：Prim 和 Kruskal。它们都是<mark>贪心算法</mark>。</p>
<ol>
<li>Prim 算法<ol>
<li>从某个（任意一个）结点出发，选择与该结点邻接的权重最小的边；随着结点的不断加入，每次都选择这些结点发出的边中<mark>权值最小</mark>的：重复 n-1 次。</li>
</ol>
</li>
<li>Kruskal 算法<ol>
<li>将边按照权值递增排序，每次选择权值最小并且不构成环的边，重复 n-1 次。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/leecode-O-n-time-complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/leecode-O-n-time-complexity/" itemprop="url">leecode O(n) time complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-11T19:36:14-08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/11/leecode-O-n-time-complexity/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/11/leecode-O-n-time-complexity/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>O(n) 是什么<ul>
<li>注意 n 是什么？图的节点？边？</li>
<li>扫一遍</li>
<li>两头扫</li>
<li>双重循环，但是内循环变量不减</li>
<li>单调性<ul>
<li>队列</li>
<li>堆栈</li>
</ul>
</li>
<li>组合数学<ul>
<li>下一个排列（上一个排列）</li>
<li>巧妙地证明</li>
<li>计数 != 枚举</li>
</ul>
</li>
<li>动态规划</li>
</ul>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-名人问题"><a href="#1-名人问题" class="headerlink" title="1. 名人问题"></a>1. 名人问题</h2><p>[题目]<br>有 n 个人他们之间认识与否用邻接矩阵表示（1 表示认识，0 表示不认识），并且A认识 B 并不意味着 B 认识 A。<br>名人定义为他不认识任何人且所有人都认识他的人。请求出所有名人。</p>
<p>[分析]<br>最多有几个名人？1 个！</p>
<p>O(n) 的方法：<br>对于两个人 i 和 j，如果 i 认识 j，则 i 显然不是名人，排除掉；<br>如果 i 不认识 j，则 j 显然不是名人，排除掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一：一头扫</span></span><br><span class="line"><span class="comment">// i &lt; j, [0...i-1]没有名人，[i...j-1] 没有名人</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现二：两头扫</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;  <span class="comment">// i认识j或者j不认识i</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>


<h2 id="Trapping-in-Rain-Water-leetcode-0042"><a href="#Trapping-in-Rain-Water-leetcode-0042" class="headerlink" title="Trapping in Rain Water leetcode 0042"></a>Trapping in Rain Water leetcode 0042</h2><h2 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h2><p>[题目]<br>a[i] 表示横坐标为 i 出有一个高度为 a[i] 的竖线。把两个竖线当做一个容器左右边的高度，<br>横轴当做底，问哪两条线段组成的容器容量最大？</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            best = <span class="built_in">max</span>(best, <span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大间隔问题"><a href="#最大间隔问题" class="headerlink" title="最大间隔问题"></a><strong>最大间隔问题</strong></h2><p>[题目]<br>给定数组 a，求下标对 i，j 满足 a[i]&lt;=a[j]，并且 j-i 最大。</p>
<p>[分析]</p>
<ul>
<li>假设目前最优解是 d，对于 j，至少要检查 i = j - d - 1 才可能更优。</li>
<li>记录前缀最小值 p[x] = min{p[0…x]}</li>
<li>倒着循环 j，对于每个 j 看一下 p[j-d-1] 是否 &lt;= a[j]，用 p 引导。</li>
<li>如果前面都比 a[j] 大，则这个 j 得不到更优的解。</li>
</ul>
<p><mark>这一题我实在没有想到这个巧妙地思路，我始终局限在两个 pointer 指到元素上面。<br>但是它其实是有一个 “pointer” 是 d！参考下面的代码。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        p[i] = ((i ==<span class="number">0</span>) || (a[i] &lt; p[i<span class="number">-1</span>])) ? a[i] : p[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; best; --j)&#123;</span><br><span class="line">        <span class="keyword">while</span>((j &gt; best) &amp;&amp; (a[j] &gt;= p[j - best <span class="number">-1</span>]))&#123;</span><br><span class="line">            ++best;</span><br><span class="line">        &#125;  <span class="comment">// 对于每一个 j, 内层循环都试图找到这个 j 所能允许的最大的 gap.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01-相等的串"><a href="#01-相等的串" class="headerlink" title="01 相等的串"></a>01 相等的串</h2><p>[题目]<br>给定一个 01 串，求它的一个最长的子串满足 0 和 1 的个数相等。</p>
<p>[分析]</p>
<ul>
<li><mark>把 0 看成 -1，1 当做 +1</mark>，还是使用“前缀和”的技巧<ul>
<li><font color="orange">这个把 0 看成 -1 的操作绝了！本来这一段区间内即使 0 1 的数量相等，区间和也有很多种数值可能，现在把 0 当成 -1 以后，这么多的可能都塌缩到一种可能: 0!!</font></li>
</ul>
</li>
<li>如果有两个前缀和相等，则这两个前缀和之间的子串满足 0，1 的个数相等。</li>
<li>需要对前缀和排序吗？那就是 O(nlogn) 的时间复杂度了</li>
<li>优化！不需要排序<ul>
<li>前缀和的范围是[-n…n]，我们加上 n 之后就是 [0…2n]，只要记录<mark>第一次出现</mark>的位置。</li>
<li>本质！用 hash 代替排序。当 hash 值是比较小的非负整数时，可以用做数组下标。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">have</span><span class="params">((n &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">// 擦，括号里面就是 2n+1 的意思。</span></span><br><span class="line">    have[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        sum += (s[i] == <span class="string">'0'</span>) ? (<span class="number">-1</span>) : (+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(have[sum] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            best = <span class="built_in">max</span>(best, i - have[sum] + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            have[sum] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制矩阵中-1-的个数"><a href="#二进制矩阵中-1-的个数" class="headerlink" title="二进制矩阵中 1 的个数"></a>二进制矩阵中 1 的个数</h2><p>[题目]<br>给定 n * n 的 01 方阵，每一行都是降序的（即先连续的一段 1，再连续的一段 0），求 1 最多的那行中 1 的个数？</p>
<p>[分析]</p>
<ul>
<li>思路一：数出每一行的 1 … 复杂度O(n^2)</li>
<li>思路二：二分法找到每一行 0 和 1 的分界线，复杂度 O(nlogn)</li>
<li>思路三：从左上角开始，如果某个位置是 1，就向右走，如果是 0 则向下走！（我们只需要找到比本行更多的 1 才有意义！）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (best &lt; n) &amp;&amp; (i &lt; n); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>((best &lt; n) &amp;&amp; (a[i][best] == <span class="string">'1'</span>))&#123;</span><br><span class="line">            ++best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><ul>
<li>最大子数组和</li>
<li>KMP</li>
<li>Manacher</li>
<li>最大直方图（单调堆栈）</li>
<li>滑动窗口最大值（单调队列）</li>
<li>快排 partition 过程</li>
<li>杨氏矩阵查找<ul>
<li>荷兰国旗问题</li>
<li>First Missing Positive</li>
</ul>
</li>
<li>排列组合相关<ul>
<li>Next/Previous permutation</li>
</ul>
</li>
<li>树相关<ul>
<li>二叉树遍历，（最大、最小）深度，同构，镜像判断，平衡判断</li>
</ul>
</li>
</ul>
<h2 id="下一个排列-leetcode-0031-STL亦如此实现"><a href="#下一个排列-leetcode-0031-STL亦如此实现" class="headerlink" title="下一个排列 leetcode 0031 (STL亦如此实现)"></a>下一个排列 leetcode 0031 (STL亦如此实现)</h2><p>[题目]<br>Next Permutation 找到字典序里的下一个排列。12345 的下一个是 12354，而54321 的下一个是 12345.</p>
<p>[分析]</p>
<ul>
<li>a[0], a[1], …, a[n-1], 下一个排列是字典序比它大，最小的</li>
<li>找到尽可能大的 m, b[0] = a[0], b[1] = a[1], …, b[m-1] = a[m-1], 而 b[m] &gt; a[m], b[m+1 … n-1] 是按照升序排列的。</li>
</ul>
<p>[形象点的分析]</p>
<ul>
<li>目前的排列是: (A)a<a href="B">x</a></li>
<li>下一个排列是: (A)a<a href="B'">y</a><ul>
<li>A 是相同的，A 尽可能长</li>
<li>a[y] &gt; a[x]</li>
<li>B’ 几乎是 B 里面的数排好顺序的结果</li>
</ul>
</li>
<li>如何确定 x？<ul>
<li>一个位置只要右边有数比它大就是候选的 x</li>
<li>a[x] 是最后一个这样的数（最右边）<ul>
<li>a[x] 右边的数，没个数的右边没有比它大的</li>
<li>所以 a[x] 右边的数是按照降序（不升序）排列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[算法 (二找、一交换、一翻转)]</p>
<ul>
<li>找到最后一个严格升序的首位 (a[i] &lt; a[i+1])，定义为 x<ul>
<li>(A) = a[0…x-1], (B) = a[x+1…n-1]</li>
</ul>
</li>
<li>找到 y&gt;x, a[y] &gt; a[x], 且 a[y] 最小<ul>
<li>一定存在，因为 x+1 就是一个候选</li>
<li>a[x] 后面的数都是降序，所以从后往前找到第一个大于 a[x] 的位置就是 y 了</li>
<li>可以二分找到 y，但不影响总体时间复杂度</li>
</ul>
</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转<ul>
<li>交换后 a[x+1…n-1] 仍然是降序（不升）</li>
<li>逆转等于排序</li>
</ul>
</li>
</ul>
<p><mark>这个解法要熟记！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(x = n<span class="number">-2</span>; (x&gt;=<span class="number">0</span>) &amp;&amp; (nums[x] &gt;= nums[x+<span class="number">1</span>]); --x)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        reverse(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">for</span>(y = n - <span class="number">1</span>; nums[y] &lt;= nums[x]; --y)</span><br><span class="line">    ;</span><br><span class="line">    swap(nums[x], nums[y]);</span><br><span class="line">    reverse(nums.<span class="built_in">begin</span>() + x + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考题：上一个排列？"><a href="#思考题：上一个排列？" class="headerlink" title="思考题：上一个排列？"></a>思考题：上一个排列？</h3><p>类似的思路</p>
<ul>
<li>找到最后一个严格降序的首位(a[i] &gt; a[i+1])，定义为 x</li>
<li>找到 y&gt;x, a[y] &lt; a[x], 且 a[y] 最大</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转</li>
</ul>
<h2 id="均分01"><a href="#均分01" class="headerlink" title="均分01"></a>均分01</h2><p>[题目]<br>给定一个01串，签好包含 2n 个 0 和 2n 个 1，你可以把它切成若干段，再把它们任意拼接，要求拼接出两部分，每部分恰好包含 n 个 0，n 个 1，如何使得切得段数最少？</p>
<p>[示例]<br>举例一：0101，从中间切一刀形成(01)(01)，分别作为两部分<br>举例二：0011，切成 3 段 (0)(01)(1), 把中间 (01) 单独作为一部分，生育的 (0)(1) 作为另外一部分。</p>
<p>[思路]<br>这一题其实都不算是算法题我觉得。<br>先考虑前面 2n 个数字，如果里面 1 的个数超过 0，那么把这个长度为 2n 的窗口向右挪，中间肯定在某个位置使得 1 和 0 的个数相等？为啥呢？因为不可能在所有的位置都有 2n 窗口内 1 的个数大于 0 的个数，这与题目的条件 4n 窗口内有 2n 个 1 和 2n 个 0 相冲突！</p>
<p>[答案]<br>如果最前面 2n 个数满足 1 和 0 个数相等，那么就分成两段就可以了；<br>如果不是，那么就分成三部分。</p>
<h2 id="X-的个数"><a href="#X-的个数" class="headerlink" title="X 的个数"></a>X 的个数</h2><p>[题目]<br>给定一个长度为 n 的整数数组 a，下标从 0 开始，再给定一个元素 X，求一个位置 m，满足 0&lt;=m&lt;=n，且 a[0…m-1] 中 X 的个数（如果m=0表示空数组）和 a[m…n-1] 中非 X 的个数（如果 m==n，表示空数组）相等。</p>
<p>[分析]</p>
<ul>
<li>假设 a 中一共有 x 个 X，给定 m，假设 a[0…m-1] 中有 y 个 X，则 a[m…n-1] 中非 X 的个数是 (n-m)-(x-y) = n-m-x+y == y</li>
<li>化简可得 m = n - x</li>
<li>解存在且唯一！</li>
</ul>
<p>[解法]</p>
<ul>
<li>直接统计下有多少个 X 就可以了</li>
<li>O(n) 时间，O(1) 空间</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>[题目]<br>10个硬币，有四个是正面的，在不开灯的情况下，把他们分成两组，如果做可以使得正面的个数相等？（可以手动改变某些硬币的正反面）</p>
<p>[答案]<br>分成两组，一组 6 个，一组 4 个，然后把 4 个的那组所有硬币都翻个面。</p>
<h2 id="PAT-的个数"><a href="#PAT-的个数" class="headerlink" title="PAT 的个数"></a>PAT 的个数</h2><p>[题目]<br>给定一个只包含 P, A, T 的串，求一共出现多少个 “PAT” 子序列？</p>
<p>[分析：计数和枚举不同]</p>
<ul>
<li>p, pa, pat 表示之前出现的 “P”, “PA”, “PAT” 的个数</li>
<li>s[i] == “P”, ++p</li>
<li>s[i] == “A”, pa += p</li>
<li>s[i] == ‘T’, pat += pa</li>
<li>时间复杂度 O(n)，空间复杂度 O(1)</li>
</ul>
<h3 id="思考题-distinct-subsequences-leetcode-115"><a href="#思考题-distinct-subsequences-leetcode-115" class="headerlink" title="思考题 distinct subsequences leetcode 115"></a>思考题 distinct subsequences leetcode 115</h3><p>[题目]<br>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意内层的 for 循环是倒着来算的，这样子可以排除掉出现相同字母的情形。</span></span><br><span class="line"><span class="comment">比如 S = "rabbbit", T = "rabbit"</span></span><br><span class="line"><span class="comment">T 的第三第四个位置都是 'b'</span></span><br><span class="line"><span class="comment">如果你从左往右看 T, 第三个 'b' 那里你把 dp[2]更新了，</span></span><br><span class="line"><span class="comment">这会导致第四个 'b' 那里你用 dp[2] 来计算 dp[3] 出现错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(t.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = t.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                    dp[j] += j ? dp[j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小平均值子数组-codility"><a href="#最小平均值子数组-codility" class="headerlink" title="最小平均值子数组 codility"></a>最小平均值子数组 codility</h2><p>[题目]<br>给定一个数组，求一个至少包含两个元素的子数组，满足平均值最小。<br>输出子数组的起点，多个的时候输出最小的。</p>
<p>[分析]</p>
<ul>
<li>如果最优解长度为偶数，把它拆成长度为 2 的若干段</li>
<li>如果最优解长度为奇数 (&gt;2), 我们把它柴承长度为 2 的若干段，和一段长度为 3 的段</li>
<li>最优解中每一段的平均值都相等<ul>
<li>如果某一段平均值比最优解小，至少有一段平均值比最优解大，矛盾。</li>
</ul>
</li>
<li>！！！ 一次，只需要考虑长度为 2 和 3 的段计算就可以了。</li>
</ul>
<h2 id="环形最大子数组和-from-itint5-com-Q9"><a href="#环形最大子数组和-from-itint5-com-Q9" class="headerlink" title="环形最大子数组和 from itint5.com Q9"></a>环形最大子数组和 from itint5.com Q9</h2><p>[题目]<br>给定一个数组，是环形的，最后一个元素和第一个元素相接，求最大子数组和。</p>
<p>[分析]</p>
<ul>
<li>环形最大子数组和<ul>
<li>普通最大子数组和，例如 1 2 -4 <mark> 5 6 -9 </mark></li>
<li>开头和结尾的一部分，例如 <mark>1 2 </mark> -4 -5 -6 <mark> 9 </mark></li>
</ul>
</li>
<li>算法<ul>
<li>求普通最大子数组的和</li>
<li>总和减去普通的最小子数组和<ul>
<li>可以考虑对原始数组取相反数，调用最大子数组和模块。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="允许交换一次的最大子数组和"><a href="#允许交换一次的最大子数组和" class="headerlink" title="允许交换一次的最大子数组和"></a>允许交换一次的最大子数组和</h2><p><mark> 这一题非常难！要好好琢磨其 DP 思路 </mark></p>
<p>[题目]<br>给定一个数组，在允许交换两个数的前提下（只允许交换一次，可以不换），求最大子数组的和。</p>
<p>[分析]</p>
<ul>
<li>定义 f[i] 为两部分之和<ul>
<li>以 a[i] 结尾的最大子数组的和（可以为空）</li>
<li>与任意 a[0…i] 里面单独一个元素</li>
<li>以上两部分没有交集</li>
<li>递推式 f[i] = max(f[i-1] + a[i], max(a[0…i]))</li>
</ul>
</li>
<li>定义 g[i]<ul>
<li>以 a[i] 开头的最大子数组和（非空）</li>
<li>递推式 g[i] = max(g[i+1], 0) + a[i]</li>
</ul>
</li>
<li>如果 a[i] 和 a[j] 交换 (j &lt; i), 原来包含 a[i] 的最大子数组和变为<ul>
<li>g[i] - a[i] + f[i-1]</li>
<li>（即要换掉的元素在 f[i-1] 里, <mark>单独存在的那一个</mark>）</li>
</ul>
</li>
<li>如果不交换，答案就是 max{g[i]}</li>
<li>我们只考虑 j &lt; i 的情况，对于 j &gt; i, 把 a 翻转再做一次就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f, g;</span><br><span class="line">    f.resize(n);</span><br><span class="line">    f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> now = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        now = <span class="built_in">max</span>(now, a[i]);</span><br><span class="line">        f[i] = <span class="built_in">max</span>(a[i] + f[i<span class="number">-1</span>], now);</span><br><span class="line">    &#125;</span><br><span class="line">    g.resize(n);</span><br><span class="line">    g[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        g[i] = <span class="built_in">max</span>(g[i+<span class="number">1</span>], <span class="number">0</span>) + a[i];</span><br><span class="line">        answer = <span class="built_in">max</span>(answer, g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        answer = <span class="built_in">max</span>(answer, g[i] - a[i] + f[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = help(A);</span><br><span class="line">    reverse(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    answer = <span class="built_in">max</span>(answer, help(A));</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>计数 != 枚举</li>
<li>没有讲到的问题<ul>
<li>O(n^3) 优化到 O(n^2)</li>
<li>序列相关的问题<ul>
<li>给定一个 1-n 的排列，每次只能把一个数放到序列开头，至少几次能排好循序？</li>
<li>给定一个 1-n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序？</li>
</ul>
</li>
<li>更多前缀、后缀的利用</li>
</ul>
</li>
</ul>
<h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><h3 id="leetcode-53-最大连续子数组和"><a href="#leetcode-53-最大连续子数组和" class="headerlink" title="leetcode 53 最大连续子数组和"></a>leetcode 53 最大连续子数组和</h3><p>[题目]<br>给定一个数组，求最大的连续子数组和。</p>
<p>[分析]</p>
<ul>
<li>方法一 记录最小前缀和（两个前缀和的差就是一段连续的子数组）</li>
<li>方法二 动态规划，记录以每个位置结束的最大子数组的和。</li>
</ul>
<h3 id="leetcode-152-求最大的连续子数组乘积"><a href="#leetcode-152-求最大的连续子数组乘积" class="headerlink" title="leetcode 152 求最大的连续子数组乘积"></a>leetcode 152 求最大的连续子数组乘积</h3><p>[分析]</p>
<ul>
<li>首先要考虑一下是否会溢出</li>
<li>到当前项乘积最大要考虑之前乘积的绝对值，因此要记录<ul>
<li>之前最小乘积</li>
<li>之前最大乘积</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mini = nums[<span class="number">0</span>], maxi = nums[<span class="number">0</span>], ansmin = nums[<span class="number">0</span>], ansmax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempmin = <span class="built_in">min</span>(nums[i], <span class="built_in">min</span>(mini * nums[i], maxi * nums[i]));</span><br><span class="line">            <span class="keyword">int</span> tempmax = <span class="built_in">max</span>(nums[i], <span class="built_in">max</span>(mini * nums[i], maxi * nums[i]));</span><br><span class="line">            mini = tempmin;</span><br><span class="line">            maxi = tempmax;</span><br><span class="line">            ansmin = <span class="built_in">min</span>(mini, ansmin);</span><br><span class="line">            ansmax = <span class="built_in">max</span>(maxi, ansmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>[题目]<br>一个数组，比如 {1,2,3,4,5} 循环移动一位就是 {2,3,4,5,1}，再移动一位就是 {3,4,5,1,2}.</p>
<p>[分析]</p>
<ul>
<li>长度为 n，把它移动 m 位，和移动 m % n 位是一样的。</li>
<li>翻转前 m 位</li>
<li>翻转后 (n-m) 位</li>
<li>总体再翻转</li>
<li>翻转可以O(n)做到：<ul>
<li>for(int i = from, j = to; i &lt; j; swap(a[i++], a[j–]));</li>
</ul>
</li>
</ul>
<h3 id="单词翻转"><a href="#单词翻转" class="headerlink" title="单词翻转"></a>单词翻转</h3><h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><h2 id="快排-partition"><a href="#快排-partition" class="headerlink" title="快排 partition"></a>快排 partition</h2><ul>
<li>荷兰国旗问题 leetcode 75</li>
<li>奇偶数分开，正负数分开</li>
<li>01 交换排序</li>
<li>交换星号</li>
<li>第一个缺失的整数 leetcode 41</li>
<li>中位数、第k大（小）的书、最大（小）的k个数<ul>
<li>找第 k 大的数关键<ul>
<li>5 数取中做 pivot (3 数取中会退化)</li>
<li>Partition 过程分三段（分两段有相同数会退化）<ul>
<li>算法导论“偷懒”了（它假设了没有相同的数做了分析）</li>
</ul>
</li>
</ul>
</li>
<li>找到最小的 k 个数<ul>
<li>基于 partition 的方法找到的数是无序的</li>
<li>如果要有序建议用堆 O(nlogk)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>[思路一]</p>
<ul>
<li>直接两次快排</li>
<li>第一次把 0 和非 0 分开</li>
<li>第二次把 1 和 2 分开</li>
</ul>
<p>[思路2]<br>循环不变式的应用</p>
<ul>
<li>三个变量 begin, cur, end 把数组分成四个区域<ul>
<li>[0, begin): 所有数据都是 0</li>
<li>[begin, current): 所有数据都是 1</li>
<li>(end, size-1]: 所有数据都是 2</li>
<li>[current, end): 未知</li>
</ul>
</li>
<li>循环不变式<ul>
<li>初值 begin=current=0, end=size-1, 前三个区间都为空集，满足以上四个条件</li>
<li>遍历 current, 根据arr[current] 的值作相应处理，直到区间 [current, end) 为空，即 current==end 时退出。</li>
<li>代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Holland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = <span class="keyword">int</span>(arr.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[current] == <span class="number">2</span>)&#123;</span><br><span class="line">            swap(arr[<span class="built_in">end</span>], arr[current]);</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[current] == <span class="number">1</span>)&#123;</span><br><span class="line">            current++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// if(a[current] == 0)</span></span><br><span class="line">            <span class="keyword">if</span>(current != <span class="built_in">begin</span>)&#123;</span><br><span class="line">                swap(arr[current], arr[<span class="built_in">begin</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>[荷兰国旗与快排的优化]</mark></p>
<p>传统的快排每次选取 pivot，然后把元素分成 &lt;=pivot 和 &gt;pivot 两部分。<br>在有相同元素的时候，每次分割递归的时候还是把 pivot 左边的，pivot 右边的递归。</p>
<p>而使用荷兰国旗思想，则可以优化有大量重复数字的情况。</p>
<p>假设选取的 pivot 呢，有很多相同元素，荷兰国旗的思想就是把元素分成三段！<br>第一段小于 pivot, 第二段等于 pivot, 第三段大于 pivot.</p>
<p>然后递归的时候，中间等于 pivot 的那一段就不需要在处理了！！！<br>因此有很多优化。</p>
<p><mark>快排的最坏情况</mark></p>
<ol>
<li>本来已经是顺序排好了</li>
<li>本来已经是逆序排好了</li>
<li>所有元素都一样！(这个可以用荷兰国旗思想来优化！)</li>
</ol>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><ul>
<li>找出出现次数超过一半的数</li>
<li>推广：找出出现次数大于 1/k 的数，用 (k-1) 个 map，复杂度 O(n * k)，注意 k 是常数的时候就是 O(n).</li>
</ul>
<h2 id="单调堆栈"><a href="#单调堆栈" class="headerlink" title="单调堆栈"></a>单调堆栈</h2><p>[题目]<br>最大直方图</p>
<p>[思路]</p>
<ul>
<li>入栈时左边界确定</li>
<li>出栈时右边界确定</li>
<li>每块只出入栈一次<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="滑动窗口最值-栈和队列-例6"><a href="#滑动窗口最值-栈和队列-例6" class="headerlink" title="滑动窗口最值 (栈和队列 例6)"></a>滑动窗口最值 (栈和队列 例6)</h3><h3 id="codility-题目"><a href="#codility-题目" class="headerlink" title="codility 题目"></a>codility 题目</h3><p>[题目]<br>给定一个数组 A 和整数 K，问有多少对下标 i&lt;=j 满足 max(A[i…j]) - min(A[i…j]) &lt;= K</p>
<p>[分析]</p>
<ul>
<li>如果(i,j)满足条件，则(i+1,j), (i+2,j)…都满足条件。</li>
<li>对每个 i, 找到第一个不满足条件的 j</li>
<li>如何求 [i…j] 的最大最小值<ul>
<li>单调队列</li>
<li>滑动窗口（两个边界都只增大不减）<ul>
<li>滑动出去的不会进来</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qmin, qmax;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; A.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>((!qmin.empty()) &amp;&amp; (A[qmin.back()] &gt;= A[j]))&#123;</span><br><span class="line">                qmin.pop_back();</span><br><span class="line">            &#125; <span class="comment">// qmin 里面的元素是单调递增的！</span></span><br><span class="line">            qmin.push_back(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((!qmax.empty()) &amp;&amp; (A[qmax.back()] &lt;= A[j]))&#123;</span><br><span class="line">                qmax.pop_back();</span><br><span class="line">            &#125; <span class="comment">// qmax 里面的元素是单调递减的！</span></span><br><span class="line">            qmax.push_back(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(A[qmax.front()] - A[qmin.front()] &lt;= K)&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// 这个 while 循环找到最远的 j。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(qmin.front() == i)&#123;</span><br><span class="line">            qmin.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qmax.front() == i)&#123;</span><br><span class="line">            qmax.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer += j - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><ul>
<li>树的高度</li>
<li>二叉树对称判断</li>
<li>二叉树平衡判断</li>
<li>二叉树的最小深度</li>
<li>指定和的路径</li>
<li>二叉树双向链表转换</li>
<li>前中后序遍历</li>
</ul>
<h3 id="距离最远的点"><a href="#距离最远的点" class="headerlink" title="距离最远的点"></a>距离最远的点</h3><p>[题目]<br>给定一个无根的树（无向<mark>无环图</mark>），求距离最远的两个点（树的直径）。</p>
<p>[易忽略]</p>
<ul>
<li>对于一个自由树的直径，《算法导论》上的说明是“树中所有最短路径的最大值即为树的直径。”</li>
<li>记住，“无环图”这个概念很重要。</li>
<li>最笨的方法<ul>
<li>就是对每一个节点进行 BFS, 找到最远的点。这个方法时间复杂度是 O(n^2).</li>
</ul>
</li>
<li>简单巧妙的贪心<ul>
<li>以任意一点为根、找到距离它最远的节点 x</li>
<li>以 x 为根找到距离 x 最远的点 y</li>
<li>(x, y) 就是一条直径</li>
</ul>
</li>
<li>如何找最远的点？dfs 求深度</li>
<li>思考：算法证明？</li>
</ul>
<p>[证明]<br>但是在证明定义之前，先证明一个引理：</p>
<p>引理：在一个连通无向无环图中，x、y 和 z 是三个不同的结点。当 x 到 y 的最短路与 y 到 z 的最短路不重合时，x 到 z 的最短路就是这两条最短路的拼接。</p>
<p>证明：假设 x 到 z 有一条不经过 y 的更短路δ(x,z)，则该路与δ(x,y)、δ(y,z)形成一个环，与前提矛盾。</p>
<p>定理：在一个连通无向无环图中，以任意结点出发所能到达的最远结点，一定是该图直径的端点之一。</p>
<p>证明：假设这条直径是δ(s,t)。分两种情况：</p>
<ul>
<li>当出发结点 y 在δ(s,t)时，假设到达的最远结点 z 不是 s,t 中的任一个。这时将δ(y,z)与不与之重合的δ(y,s)拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的直径，与前提矛盾。</li>
<li>当出发结点 y 不在δ(s,t)上时，分两种情况：<ul>
<li>1). 当 y 到达的最远结点 z 横穿δ(s,t)时，记与之相交的结点为 x。此时有δ(y,z)=δ(y,x)+δ(x,z)。而此时δ(y,z)&gt;δ(y,t)，故可得δ(x,z)&gt;δ(x,t)。由1的结论可知该假设不成立。<br>2). 当 y 到达的最远结点 z 与δ(s,t)不相交时，记 y 到 t 的最短路首先与δ(s,t)相交的结点是 x。由假设δ(y,z)&gt;δ(y,x)+δ(x,t)。而δ(y,z)+δ(y,x)+δ(x,s)又可以形成δ(z,s)，而δ(z,s)&gt;δ(x,s)+δ(x,t)+2δ(y,x)=δ(s,t)+2δ(y,x)，显然与题意矛盾。</li>
</ul>
</li>
</ul>
<p>因此定理成立。</p>
<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><p>[题目]<br>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two end nodes</p>
<p>[分析]<br>The diameter of a tree T is the largest of the following quantities:</p>
<ul>
<li>the diameter of T’s left subtree</li>
<li>the diameter of T’s right subtree</li>
<li>the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xz注：这个代码是用 C 实现的，函数的调用需要记录两个变量，</span></span><br><span class="line"><span class="comment">tree height &amp; tree diameter，它这里采用的是通过传递</span></span><br><span class="line"><span class="comment">指针过去来计算得到 height, 然后函数返回的是 tree diameter.</span></span><br><span class="line"><span class="comment">如果使用 C++ 的话，可以让函数返回 vector&lt;int&gt; = &#123;tree_height, tree_diameter&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The second parameter is to store the height of tree. </span></span><br><span class="line"><span class="comment">   Initially, we need to pass a pointer to a location with value </span></span><br><span class="line"><span class="comment">   as 0. So, function should be used as follows: </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   int height = 0; </span></span><br><span class="line"><span class="comment">   struct node *root = SomeFunctionToMakeTree(); </span></span><br><span class="line"><span class="comment">   int diameter = diameterOpt(root, &amp;height); */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOpt</span><span class="params">(struct node *root, <span class="keyword">int</span>* <span class="built_in">height</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* lh --&gt; Height of left subtree </span></span><br><span class="line"><span class="comment">     rh --&gt; Height of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* ldiameter  --&gt; diameter of left subtree </span></span><br><span class="line"><span class="comment">     rdiameter  --&gt; Diameter of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> ldiameter = <span class="number">0</span>, rdiameter = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    *<span class="built_in">height</span> = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* diameter is also 0 */</span></span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Get the heights of left and right subtrees in lh and rh </span></span><br><span class="line"><span class="comment">    And store the returned values in ldiameter and ldiameter */</span></span><br><span class="line">  ldiameter = diameterOpt(root-&gt;left, &amp;lh); </span><br><span class="line">  rdiameter = diameterOpt(root-&gt;right, &amp;rh); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Height of current node is max of heights of left and </span></span><br><span class="line"><span class="comment">     right subtrees plus 1*/</span></span><br><span class="line">  *<span class="built_in">height</span> = <span class="built_in">max</span>(lh, rh) + <span class="number">1</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(lh + rh + <span class="number">1</span>, <span class="built_in">max</span>(ldiameter, rdiameter)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口相关"><a href="#滑动窗口相关" class="headerlink" title="滑动窗口相关"></a>滑动窗口相关</h2><h3 id="leetcode-209"><a href="#leetcode-209" class="headerlink" title="leetcode 209"></a>leetcode 209</h3><p>[题目]<br>给定一个数组，里面全是正整数，再给一个正整数 s, 求数组里面最少多少个连续的数，满足总和不小于 s.</p>
<p>[分析]</p>
<ul>
<li>核心：大窗口不满足条件，它的任意子窗口也不满足条件。</li>
<li>窗口 [i…j]<ul>
<li>过小，++j</li>
<li>过大, ++i</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> answer = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>; j &lt; n; )&#123;</span><br><span class="line">            <span class="keyword">while</span>((sum &lt; s) &amp;&amp; (j &lt; n))&#123;</span><br><span class="line">                sum += nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                <span class="keyword">for</span>(; sum &gt;= s; sum -= nums[i++])</span><br><span class="line">                ;</span><br><span class="line">                answer = <span class="built_in">min</span>(answer, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (answer &gt;= n) ? <span class="number">0</span> : answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子串变位词"><a href="#子串变位词" class="headerlink" title="子串变位词"></a>子串变位词</h3><p>easy TODO</p>
<h3 id="leetcode-76-最短子串包含全部子母"><a href="#leetcode-76-最短子串包含全部子母" class="headerlink" title="leetcode 76 最短子串包含全部子母"></a>leetcode 76 最短子串包含全部子母</h3><p>easy TODO</p>
<h3 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3 无重复字符的最长子串"></a>leetcode 3 无重复字符的最长子串</h3><p>easy TODO</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>长度</li>
<li>（K 个一组）翻转 leetcode 206, 92, 25</li>
<li>插入 leetcode 147</li>
<li>删除 leetcode 203, 82, 83</li>
<li>复制 leetcode 138</li>
<li>求交 leetcode 160</li>
<li>找环 leetcode 141, 142</li>
<li>（倒数）第 k 个元素 leetcode 19</li>
<li>链表判断是否回文</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2-SUM"></a>2-SUM</h3><p>使用hash easy</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>[题目]<br>给定一个 1-n 的排列，每次只能把一个数放到序列末尾，至少几次能排好顺序。</p>
<p>[分析]</p>
<ul>
<li>需要移动 1 吗？不，其他都排好了，1 自然就好了。</li>
<li>如果要移动 x，则我们必须把 (x+1), (x+2), …, n 都移动了</li>
<li>从 1 到 (x-1) 是有序的<ul>
<li>x 有多大？</li>
</ul>
</li>
</ul>
<p><font color="red">注意这一题跟下面两个题目不一样的地方是：这一题只能把数字移动到末尾。因此我们必须找从数字 1 开始的子序列，看看能达到多大。</p>
<p>假设可以达到 x，那么说明 x+1, x+2, …, n 都在 x 的前面出现了，那么为了让数组有序，需要依次把 x+1, x+2, …, n 放到数组最后。<br></font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), want = <span class="number">1</span>;  <span class="comment">// 从 1 开始的子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == want)&#123;  <span class="comment">// 每次找到 want 以后，就加 1.</span></span><br><span class="line">            ++want;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 这个找的实际上是有多少个数字出现在了比它小的数字的前面。。。</span></span><br><span class="line">    <span class="comment">// want ... n must be moved</span></span><br><span class="line">    <span class="keyword">return</span> n - want + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序2"><a href="#数组排序2" class="headerlink" title="数组排序2"></a>数组排序2</h3><p>题目<br>给定一个 1 到 n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序。</p>
<p>分析</p>
<ul>
<li><font color="red">这一题跟上一题不一样，数字可以移动到开头，所以不需要限制从 1 开始找，只需要找到 y 到 x 最长的就可以。</font></li>
<li>把数字 1 到数字 y 移动到开头，把数字 x 到 数字 n 移动到末尾</li>
<li>[y+1…x-1] 必须按顺序出现</li>
<li>所以目的就是要找到最小的 y 和 最大的 x，这样子 移动的数字才最少。</li>
<li>dp[x] 表示从 x 开始在原数组中往后按顺序出现的最长长度<ul>
<li>即 x, x+1, …, x+dp[x]-1 按顺序出现</li>
<li>倒着循环 i, dp[a[i]] = dp[a[i]+1] + 1</li>
</ul>
</li>
</ul>
<p><font color="orange">我其实觉得很奇怪，这个 dp 序列在更新的时候，不是按照一定的顺序来逐个得到的。而是来回跳。。。（取决于数组 a 里面的数字从右往左出现的顺序）。</font></p>
<p><font color="red">想了一个多小时，从上一题的思路到这一题，终于想明白。<br>首先要清楚，之所以 for 循环里面 i 从大到小，意味着数组是从右往左扫。<br>这样子如果扫到了比如 a[5] = 8, 那么 dp[8] 就可以计算出来了。<br>往左走如果 a[4]=7，那么 dp[7] 就可以用 dp[8] 的结果加上 1 得到。<br>为啥呢？因为是从右往左扫的，后遇见 dp[7] 说明 7 比 8 晚遇见，7 在 8 的左边嘛！满足排序的顺序。</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), m = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 使用 1...n+1 注意下标范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m, dp[a[i]] = dp[a[i]+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序3-NOIP，很难"><a href="#数组排序3-NOIP，很难" class="headerlink" title="数组排序3 NOIP，很难"></a>数组排序3 NOIP，很难</h3><p>[题目描述]<br>给定一个长度为N的数列Ai。<br>你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。<br>求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。</p>
<p>[输入格式]<br>第一行是一个正整数N。<br>第二行是N个正整数Ai。</p>
<p>[输出格式]<br>输出一个整数，表示最少需要的操作次数。</p>
<p>[样例输入]<br>5<br>6 3 7 8 6</p>
<p>[样例输出]<br>2</p>
<p>[题解]<br><font color="red">这一题跟上一题不一样的地方在于这一题的数字不一定是 1 到 n，并且数字还可以允许出现重复数字。</font></p>
<p>经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：</p>
<ul>
<li>子序列单调递增；</li>
<li>若子序列中最小数是L，最大数是R，则子序列必须包含[L+1,R−1]中的数列中的所有数。</li>
</ul>
<p>用单调队列求出满足这两个条件的子序列的最大长度，用n减去就是答案。<br>即这个子序列保持不动，其余数向前或后移动一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE], q[SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"change.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"change.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[a[i]].push_back(i);</span><br><span class="line">        m = <span class="built_in">max</span>(m, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        reverse(b[i].<span class="built_in">begin</span>(), b[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = b[i][j];</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">2</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            q[++r] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/%5C/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/%5C/page/4/">4</a><a class="extend next" rel="next" href="/%5C/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
