<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/python-good-code-examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/python-good-code-examples/" itemprop="url">python-good-code-examples</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T23:50:27-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/python-good-code-examples/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/python-good-code-examples/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="25-个有用代码段"><a href="#25-个有用代码段" class="headerlink" title="25 个有用代码段"></a>25 个有用代码段</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 交换变量的值</span></span><br><span class="line"><span class="comment">#    在 C++ 语言里面，不使用第三个变量的情况下去交换两个变量的值需要一定的技巧（使用运算符或者使用 XOR 操作）</span></span><br><span class="line"><span class="comment">#    而在 Python 里面很简单</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查是否是偶数</span></span><br><span class="line"><span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将多行数据变成行列表</span></span><br><span class="line"><span class="keyword">return</span> lines.split(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查找对象使用的内存</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getsizeof(<span class="number">5</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 翻转字符串</span></span><br><span class="line"><span class="comment">#    在 C++ 里面有 std::reverse 可以使用</span></span><br><span class="line">str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 字符串复制 n 次</span></span><br><span class="line">str = <span class="string">"Python"</span></span><br><span class="line">str * <span class="number">3</span>    <span class="comment"># PythonPythonPython</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 检查字符串是否回文</span></span><br><span class="line"><span class="keyword">return</span> str == str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 将字符串列表合并为单个字符串</span></span><br><span class="line">strings = [<span class="string">"abc"</span>, <span class="string">"dsf"</span>, <span class="string">"wer"</span>, <span class="string">"uiods"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">","</span>.join(strings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 查找列表的第一个元素</span></span><br><span class="line">list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. 找到两个列表的元素并集</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a + list_b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. 查找给定列表中所有元素, 重复的只算一次</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. 求列表元素的平均值</span></span><br><span class="line"><span class="keyword">return</span> sum(list_a, <span class="number">0.0</span>) / len(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13. 判断列表中元素是不是没有重复的</span></span><br><span class="line"><span class="keyword">return</span> len(list_a) == len(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14. 求列表元素的 frequency</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">count = Counter(list_a)</span><br><span class="line">print(count)    <span class="comment"># &#123;2: 3, 3: 3, 1: 1, 4: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 15. 找到列表中出现次数最多的那个</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">return</span> max(set(numbers), key = numbers.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 16. 角度转换成弧度</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">deg = <span class="number">90</span></span><br><span class="line"><span class="keyword">return</span> (deg * math.pi) / <span class="number">180.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 17. 计算一段代码的耗时</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">a,b = <span class="number">5</span>,<span class="number">10</span></span><br><span class="line">c = a+b</span><br><span class="line">end_time = time.time()</span><br><span class="line">time_taken = (end_time- start_time)*(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">print(<span class="string">"Time taken in micro_seconds:"</span>, time_taken) <span class="comment"># Time taken in micro_seconds: 39.577484130859375</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 18. 找到一组数字的最大公约数 gcd</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">numbers = [<span class="number">24</span>, <span class="number">108</span>, <span class="number">90</span>]</span><br><span class="line"><span class="keyword">return</span> reduce(math.gcd, numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 19. 找到字符串所有出现过的字符（多次出现的只考虑一次）</span></span><br><span class="line">str = <span class="string">"abcbcabdb"</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(set(str))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 20. 使用 lambda 函数</span></span><br><span class="line">x = <span class="keyword">lambda</span> a, b, c : a + b + c</span><br><span class="line">print(x(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>))    <span class="comment"># 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map(multiply, list_a)</span><br><span class="line">print(list(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map</span><br><span class="line"></span><br><span class="line"><span class="comment">## 22. 使用 filter 函数</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, arr))</span><br><span class="line">print(arr)    <span class="comment"># [2, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 23. 使用 list comprehensions</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">squares = [number**<span class="number">2</span> <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 24. 使用 slicing operation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(arr, d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arr[d:] + arr[:d]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    arr = rotate(arr, <span class="number">2</span>)</span><br><span class="line">    print(arr)    <span class="comment"># [3, 4, 5, 1, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 25. 使用 chained 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line">print((subtract <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b))    <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<p>25 题还是挺有意思的，看出来可以把函数当成一个 first clas object 来玩儿了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/cpp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/cpp-summary/" itemprop="url">cpp-summary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T17:28:42-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/cpp-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/cpp-summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="class-有关"><a href="#class-有关" class="headerlink" title="class 有关"></a>class 有关</h2><h3 id="概念题"><a href="#概念题" class="headerlink" title="概念题"></a>概念题</h3><p>[Differnce with struct]</p>
<ol>
<li>The only difference between “class” and “struct” is whether the beginning content in the class body (before first appearance of “private”/“public” keyword) is public or private. For class, that part is private. For struct, that part is public.</li>
</ol>
<p>[Method 定义的位置]</p>
<ol>
<li>定义在 class body 中的话，是要求这些 function become inline, thus avoid function call overhead.</li>
<li>定义在 class body 外的话，就会有 function call.</li>
</ol>
<p>[Compiler generated functions]</p>
<ol>
<li>Compilter silently write 4 functions if they are not explicitly declared:<ol>
<li>Copy constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Default Constructor (Only if there is no constructor declared)<ol>
<li>If there exists copy constructor, then compiler will not generate default constructor.</li>
<li>However, if there exists some constructor (not copy constructor), compiler will generate copy constructor if needed.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>多态背后的技术叫做动态绑定！底层的实现是使用虚函数表。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了实现C++的多态<mark>（关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>）</mark>，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h4 id="类的虚表"><a href="#类的虚表" class="headerlink" title="类的虚表"></a>类的虚表</h4><p>每个包含了虚函数的类都包含一个虚表。</p>
<p>我们知道，当一个类 A 继承另一个类 B 时，类 A 会继承类 B 的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可以调用这些虚函数。<br>换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>简单的例子，看一下下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由上面的代码可知，类 A 有虚函数，因此它有一个虚表。</p>
<p>类 A 的虚表如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png" alt=""></p>
<p><mark>虚表是一个指针数组，其元素是虚函数的指针。每个元素对应一个虚函数的函数指针。<br>需要指出的是，普通的函数，即非虚函数，其调用并不需要经过虚表。<br>因此虚表的元素并不包括普通函数的函数指针。</mark></p>
<h4 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h4><p><mark>虚表是属于类的，而不是属于某个具体的对象！一个类只需要一个虚表即可！同一个类的所有对象都使用同一个虚表。</mark></p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，<mark>编译器在类中添加了一个指针，<code>*__vptr</code>, 用来指向虚表。</mark><br>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png" alt=""></p>
<p>再重复一遍！一个继承类的基类如果包含虚函数，那么这个继承类也有自己的虚表，这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>下面讲一下 C++ 是如何利用虚表和虚表指针实现动态绑定的。先看一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 A 是基类，类 B 继承类 A，类 C 又继承类 B。<br>它们三个的对象模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png" alt=""></p>
<p>[关于上图的几点说明]</p>
<ol>
<li>由于<mark>这三个类都有虚函数，故编译器为每个类都创建了一个虚表</mark>，即类 A 有虚表 vtbl_A, 类 B 有虚表 vtbl_B, 类 C 有虚表 vtbl_C. 类A, B, C 的<code>对象</code>都拥有一个虚表指针， <code>*__vptr</code>, 用来指向自己所属类的虚表。</li>
<li>类 A 包括两个虚函数，故 vtbl_A 包含两个指针，分别指向 A::vfunc1() 和 A::vfunc2().</li>
<li>类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 vtbl_B 的两个指针分别指向 B::vfunc1() 和 A::vfunc2().</li>
<li>类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故 vtbl_C 的两个指针分别指向 B::vfunc1() (指向继承的最近的一个类的函数) 和 C::vfunc2().</li>
<li>图三看起来有点复杂，但是核心还是：<mark>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</mark>。抓住这个核心思想，就可以快速将这几个类的对象模型在脑中想象出来！</li>
<li>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</li>
</ol>
<p>假设我们定义一个类 B 的对象如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>这里要注意了，虽然 <code>p</code> 是基类的指针，只能指向基类的部分，但是虚表指针也属于基类的部分，亦即 b 实例内存中的虚表指针也属于基类部分。所以 <code>p</code> 可以访问到对象 bObject 的虚表指针. bObject 的虚表指针指向类 B 的虚表，所以 <code>p</code> 可以访问到 vtbl_B. </mark></p>
<p>当我们使用 p 来调用 vfunc1() 函数时候，会发横什么现象?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; bObject;</span><br><span class="line">	p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在执行 <code>p-&gt;vfunc1()</code> 时会发现 p 是个指针，且调用的函数式虚函数，接下来便会进行以下的步骤</p>
<ol>
<li>首先，根据虚表指针 <code>p-&gt;__vptr</code> 来访问对象 bObject 对应的虚表。虽然指针 p 是基类 <code>A*</code> 类型，但是 <code>*__vptr</code> 也是基类的一部分，所以可以通过 <code>p-&gt;__vptr</code> 访问到对象对应的虚表。</li>
<li>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编一阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 <code>p-&gt;vfunc1()</code> 的调用，vtbl_B 的第一项即是 vfunc1 对应的条目。</li>
<li>最后，根据虚表中找到的函数指针，调用函数。从上图可以看出，vtbl_B 的第一项指向 B::vfunc1()，所以 <code>p-&gt;vfunc1()</code> 实质会调用 B::vfunc1() 函数。</li>
</ol>
<p>而如果 p 指向类 A 的对象，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A aObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">	A *p = &amp; aObject;</span><br><span class="line">	p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 aObject 在创建时，它的虚表指针 <code>__vptr</code> 已设置为指向 vtbl_A，这样 <code>p-&gt;__vptr</code> 就指向 vtbl_A. vfunc1 在 vtbl_A 对应的条目指向了 A::vfunc1() 函数，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>A::vfunc1()</code> 函数。</p>
<p><mark>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。</mark></p>
<p>[动态绑定]<br>我们把<mark>经过虚表调用虚函数的过程称为动态绑定</mark>，其表现出来的现象称为<mark>运行时多态</mark>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，<mark>什么时候会执行函数的动态绑定？</mark>这需要符合以下三个条件。</p>
<ol>
<li>通过指针来调用函数</li>
<li>指针 upcast 向上转型（继承类向基类的转换称为 upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h2 id="fundamental-concept-基本概念"><a href="#fundamental-concept-基本概念" class="headerlink" title="fundamental concept 基本概念"></a>fundamental concept 基本概念</h2><h4 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h4><p>Most of the times compilers will do optimization to the code to speed up the program. For example in the below code,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>( a == <span class="number">10</span>)&#123;</span><br><span class="line">     <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compiler may think that value of ‘a’ is not getting changed from the program and replace it with ‘while(true)’, which will result in an infinite loop. In actual scenario the value of ‘a’ may be getting updated from outside of the program.<br>Volatile keyword is used to tell compiler that the variable declared using volatile may be used from outside the current scope so that compiler wont apply any optimization. This matters only in case of multi-threaded applications.<br>In the above example if variable ‘a’ was declared using volatile, compiler will not optimize it. In shot, value of the volatile variables will be read from the memory location directly.</p>
<h4 id="—————-const—————"><a href="#—————-const—————" class="headerlink" title="—————-const—————-"></a>—————-const—————-</h4><ol>
<li>如果你声明某个 variable 是 const，在声明的那个语句中你就必须给它初始化！因为后面你就没有机会再修改了！</li>
<li>non-const iterator can be used to access/modify the container.</li>
<li>const iterator can only be used for access, and cannot be used for modification.</li>
<li>If the container itself is const, you can only use const iterator to access its elements.</li>
<li>==begin()== returns const_iterator if the container is const, and returns non-const iterator if the container is not const. (But you can always use ==auto==)</li>
<li>cbegin(), cend() returns const_iterator.</li>
</ol>
<h4 id="—————-three-kinds-of-function-parameters———"><a href="#—————-three-kinds-of-function-parameters———" class="headerlink" title="—————-three kinds of function parameters———-"></a>—————-three kinds of function parameters———-</h4><ol>
<li>someFunction(vector<double> vec)</double></li>
<li>someFunction(const vector<double>&amp; vec)</double></li>
</ol>
<h4 id="—————-static—————"><a href="#—————-static—————" class="headerlink" title="—————-static—————-"></a>—————-static—————-</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Local variables that are declared to be static </span></span><br><span class="line"><span class="comment">are preserved across invocations of the function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thus, we'll construct and initialize the string name</span></span><br><span class="line"><span class="comment">only on the first call to someFunction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">someFunction</span><span class="params">(balabala)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> name = <span class="string">"Zheng Xing"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="—————-reference—————"><a href="#—————-reference—————" class="headerlink" title="—————-reference—————-"></a>—————-reference—————-</h4><ol>
<li>reference data must be assigned at initialization</li>
<li>reference data cannot be reassigned</li>
</ol>
<h4 id="—————-and-—————"><a href="#—————-and-—————" class="headerlink" title="—————-() and =  —————-"></a>—————-() and =  —————-</h4><ol>
<li>container<t> c(c2)<ol>
<li>defines c as a container that is a copy of c2</li>
</ol>
</t></li>
<li>container<t> c = c2<ol>
<li>same</li>
</ol>
</t></li>
</ol>
<h4 id="—————-default-value-initialization—————"><a href="#—————-default-value-initialization—————" class="headerlink" title="—————-default/value initialization—————-"></a>—————-default/value initialization—————-</h4><ol>
<li>local variables of built-in type that are not explicitly initialized are undefined.</li>
<li>class type says what initializer to use if there is not one specified.</li>
<li>(Accerated C++, P125) When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is ==value-initialized==, which, for simple types such as int, is equivalent to setting the value to zero.</li>
</ol>
<h4 id="—————-overloading—————"><a href="#—————-overloading—————" class="headerlink" title="—————-overloading—————-"></a>—————-overloading—————-</h4><p>Several functions with the same name.</p>
<h4 id="—————-lvalue—————"><a href="#—————-lvalue—————" class="headerlink" title="—————-lvalue—————-"></a>—————-lvalue—————-</h4><p>就是一个可以被赋值的东西。denote a nontemporary object.</p>
<ol>
<li>variable</li>
<li>reference</li>
<li>the result of calling a function that returns a reference.</li>
</ol>
<h4 id="—————-iterator—————"><a href="#—————-iterator—————" class="headerlink" title="—————-iterator—————-"></a>—————-iterator—————-</h4><p>==( * iter).name== is the same as ==iter-&gt;name==</p>
<h2 id="三种定义-Comparison-Function-的方法"><a href="#三种定义-Comparison-Function-的方法" class="headerlink" title="三种定义 Comparison Function 的方法"></a>三种定义 Comparison Function 的方法</h2><h4 id="方法一：Define-operator-lt"><a href="#方法一：Define-operator-lt" class="headerlink" title="方法一：Define operator&lt;()"></a>方法一：Define operator&lt;()</h4><p>在自定义的数据结构里面定义好 &lt; 运算符的意义.</p>
<p>注意：operator&lt;() 参数只有一个！！！并且 operator 是 const<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort the edges in decreasing order</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你不喜欢这种语法，只有一个参数，</span></span><br><span class="line"><span class="comment">却比较两个objects，那么你可以用下面的方式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This way it is much clearer that you are </span></span><br><span class="line"><span class="comment">comparing a and b, not *this and other. </span></span><br><span class="line"><span class="comment">Note also that friend function is like static function; </span></span><br><span class="line"><span class="comment">it cannot access member variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h4 id="方法二：定义-comparison-function"><a href="#方法二：定义-comparison-function" class="headerlink" title="方法二：定义 comparison function"></a>方法二：定义 comparison function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stringVec.begin(), stringVec.end(), comp);</span><br></pre></td></tr></table></figure>
<h4 id="方法三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><a href="#方法三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object" class="headerlink" title="方法三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object."></a>方法三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了上面的定义，你就可以这样用：</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, cmp&gt; myset;  <span class="comment">// cmp 是 type</span></span><br><span class="line"><span class="comment">// 或者这样（cmp 也是 type）</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个错误用法</span></span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmp);</span><br><span class="line"><span class="comment">// cmp 是type，sort需要 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法-1</span></span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmp());</span><br><span class="line"><span class="comment">// 正确写法-2</span></span><br><span class="line">cmp cmpobject;</span><br><span class="line">sort(stringArray.begin(), stringArray.end(), cmpobject);</span><br></pre></td></tr></table></figure>
<p>注意，虽然 set, map 里面只能使用 functor/type</p>
<p>实际上他们也可以用 function 的方法，但是容易用错，</p>
<p>不过这里还是给出来看一下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can use comparison function for STL containers</span></span><br><span class="line"><span class="comment">by passing them as the first argument of the constructor, </span></span><br><span class="line"><span class="comment">and specifying the function type as the additional template argument. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.size() &lt; str2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span> (*)(<span class="built_in">string</span>, <span class="built_in">string</span>)&gt; myset(comp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lambda function 也是一个 object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123; <span class="keyword">return</span> a.size() &gt; b.size; &#125;;</span><br><span class="line">priority_queue&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(comp)&gt; mypq(comp);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法二-vs-方法三"><a href="#方法二-vs-方法三" class="headerlink" title="方法二 vs 方法三"></a>方法二 vs 方法三</h4><ol>
<li>方法三 compiler 很容易 inline，所以效率高！</li>
</ol>
<h4 id="STL-内置的函数对象"><a href="#STL-内置的函数对象" class="headerlink" title="STL 内置的函数对象"></a>STL 内置的函数对象</h4><p>STL提供的函数对象</p>
<ol>
<li>用于算术运算的函数对象：<ol>
<li>一元函数对象(一个参数) ：negate</li>
<li>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</li>
</ol>
</li>
<li>用于关系运算、逻辑运算的函数对象(要求返回值为bool)<ol>
<li>一元谓词(一个参数)：logical_not</li>
<li>二元谓词(两个参数)：equalto、notequalto、greater、less、greaterequal、lessequal、logicaland、logical_or</li>
</ol>
</li>
</ol>
<h2 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h2><h3 id="泛型设计的基本概念"><a href="#泛型设计的基本概念" class="headerlink" title="泛型设计的基本概念"></a>泛型设计的基本概念</h3><h4 id="目的：为啥需要泛型程序设计"><a href="#目的：为啥需要泛型程序设计" class="headerlink" title="目的：为啥需要泛型程序设计"></a>目的：为啥需要泛型程序设计</h4><ol>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从具体的数据结构中抽象出来，成为通用的</li>
<li>C++ 的模板为泛型程序设计奠定了关键的基础</li>
</ol>
<h4 id="术语一：概念"><a href="#术语一：概念" class="headerlink" title="术语一：概念"></a>术语一：概念</h4><p>概念是指：用来界定具备一定功能的数据类型。例如：</p>
<ol>
<li>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable</li>
<li>将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable</li>
<li>将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable</li>
</ol>
<p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：</p>
<ol>
<li>Sortable既是Comparable的子概念，也是Assignable的子概念</li>
</ol>
<h4 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h4><p>模型（model）：符合一个概念的数据类型称为该概念的模型，例如：</p>
<ol>
<li>int型是Comparable概念的模型。</li>
<li>静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）</li>
</ol>
<h4 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h4><p>很多STL的实现代码就是使用概念来命名模板参数的。</p>
<p>为概念赋予一个名称，并使用该名称作为模板参数名。例如</p>
<p>表示insertionSort这样一个函数模板的原型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Sortable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insertionSort</span>(<span class="title">Sortable</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>);</span></span><br></pre></td></tr></table></figure></p>
<h3 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h3><h4 id="STL的基本组件"><a href="#STL的基本组件" class="headerlink" title="STL的基本组件"></a>STL的基本组件</h4><ol>
<li>容器（container）</li>
<li>迭代器（iterator）</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ol>
<h4 id="STL的基本组件间的关系"><a href="#STL的基本组件间的关系" class="headerlink" title="STL的基本组件间的关系"></a>STL的基本组件间的关系</h4><ol>
<li>Iterators（迭代器）是算法和容器的桥梁。</li>
<li>将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。</li>
<li>将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png" alt=""></p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>transform算法的一种实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryFunction</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">        *result = op(*first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform算法顺序遍历first和last两个迭代器所指向的元素；</p>
<p>将每个元素的值作为函数对象op的参数；</p>
<p>将op的返回值通过迭代器result顺序输出；</p>
<p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回.</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器是算法和容器的桥梁</p>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ol>
<p>算法和容器独立</p>
<ol>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也能适用</li>
</ol>
<h4 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h4><p>顺序容器包括：</p>
<ol>
<li>向量、双端队列、列表、单向链表、数组</li>
</ol>
<h5 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h5><p>特点</p>
<ol>
<li>一个可以扩展的动态数组</li>
<li>随机访问、在尾部插入或删除元素快</li>
<li>在中间或头部插入或删除元素慢</li>
</ol>
<p>向量的容量</p>
<ol>
<li>容量(capacity)：实际分配空间的大小</li>
<li>s.capacity() ：返回当前容量</li>
<li>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</li>
</ol>
<h5 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h5><p>特点</p>
<ol>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量容器慢</li>
</ol>
<p>例10-5 奇偶排序<br>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    istream_iterator&lt;<span class="keyword">int</span>&gt; i1(<span class="built_in">cin</span>), i2;  <span class="comment">//建立一对输入流迭代器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1(i1, i2); <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line">    sort(s1.begin(), s1.end()); <span class="comment">//将输入的整数排序</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.begin(); iter != s1.end(); ++iter) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>)    <span class="comment">//偶数放到s2尾部</span></span><br><span class="line">             s2.push_back(*iter);</span><br><span class="line">         <span class="keyword">else</span>       <span class="comment">//奇数放到s2首部</span></span><br><span class="line">             s2.push_front(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s2的结果输出</span></span><br><span class="line">    copy(s2.begin(), s2.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>==心得一：输出 vector 到标准输出我一般都是用 for 循环一个一个喂给 cout，这里却用 iterator 和 copy 函数很简洁得做到了（上段代码倒数第三句）==</p>
<p>==心得二：这个方法思路很好啊！！==</p>
<h5 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h5><p>特点</p>
<ol>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ol>
<p>接合(splice)操作</p>
<ol>
<li>==s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到s1中p所指向元素之前==</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> names1[] = &#123; <span class="string">"Alice"</span>, <span class="string">"Helen"</span>, <span class="string">"Lucy"</span>, <span class="string">"Susan"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> names2[] = &#123; <span class="string">"Bob"</span>, <span class="string">"David"</span>, <span class="string">"Levin"</span>, <span class="string">"Mike"</span> &#125;;</span><br><span class="line">    <span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; s1(names1, names1 + <span class="number">4</span>); </span><br><span class="line">    <span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; s2(names2, names2 + <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line">    s2.splice(s2.end(), s1, s1.begin());</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter1 = s1.begin(); <span class="comment">//iter1指向s1首</span></span><br><span class="line">    advance(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter2 = s2.begin();  <span class="comment">//iter2指向s2首</span></span><br><span class="line">    ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line">    advance(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line">    <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line">    s1.splice(iter1, s2, iter2, iter3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别将s1和s2输出</span></span><br><span class="line">    copy(s1.begin(), s1.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(s2.begin(), s2.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h5><ol>
<li>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</li>
<li>未定义insert、emplace和erase操作，而定义了insertafter、emplaceafter和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</li>
<li>不支持size操作。</li>
</ol>
<h5 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h5><ol>
<li>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</li>
<li>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小。</li>
<li>不能动态地改变容器大小</li>
</ol>
<h5 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h5><p>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容器所需要执行的操作来决定选择哪一种容器。</p>
<ol>
<li>如果需要执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector；</li>
<li>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应当选择双端队列容器deque；</li>
<li>如果不需要对容器进行随机访问，但是需要在中间位置插入或者删除元素，就应当选择列表容器list或forward_list；</li>
<li>如果需要数组，array相对于内置数组类型而言，是一种更安全、更容易使用的数组类型。</li>
</ol>
<h4 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h4><ol>
<li>容器适配器</li>
<li>函数适配器</li>
<li>迭代器适配器</li>
</ol>
<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p>STL提供了三个==容器适配器==：</p>
<ol>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ol>
<p>这些适配器都是包装了vector、list、deque中某个顺序容器的包装器。<br>stack和queue是容器，但是他们==在本质上是适配器，他们本身并没有实现什么结构和算法，而是把deque拿过来，接口改造一下，实现了自己需要的功能==。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png" alt=""></p>
<p>注意：</p>
<ol>
<li>适配器没有提供迭代器，也不能同时插入或删除多个元素</li>
</ol>
<h5 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h5><h5 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/massive-data-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/massive-data-analysis/" itemprop="url">massive-data-analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T19:22:40-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/massive-data-analysis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/massive-data-analysis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>倒排索引的索引表中的每一项都包括一个属性值和具有该属性值得各记录的地址。</li>
<li>因为不是由记录来确定属性值，而是由属性来确定记录，因而成为倒排索引（inverted index）。</li>
<li>带有倒排索引的文件称为倒排索引文件，简称倒排文件（inverted file）。</li>
</ol>
<h3 id="倒排列表"><a href="#倒排列表" class="headerlink" title="倒排列表"></a>倒排列表</h3><ol>
<li>倒排列表记录了某个单词位于哪些文档中。在给定的文档语料中，一般会有多个文档包含某单词，每个文档有唯一的编号(DocID)，单词在这个文档中出现的次数(TF)及单词在文档中哪些位置出现等信息，与一个文档相关的信息被称作倒排索引项（posting），包含这个单词的一系列倒排索引项形成了列表结构，这就是某个单词对应的倒排列表。</li>
</ol>
<h3 id="在实践中的另外一个应用"><a href="#在实践中的另外一个应用" class="headerlink" title="在实践中的另外一个应用"></a>在实践中的另外一个应用</h3><ol>
<li>跳跃链表、跳跃表、跳表</li>
<li>GIS 中的 POI(point of Interest 查询)<ol>
<li>部分匹配：戴尔外星人电脑，外星人电脑</li>
<li>跳跃匹配：中国科技大学，中科大</li>
</ol>
</li>
</ol>
<p>POI 信息点 搜索总框架<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CFileObject::Search(LPCTSTR lpszContent, <span class="keyword">int</span> nIndex)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!lpszContent || !lpszContent[<span class="number">0</span>])&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CreateSearchTree(nIndex);</span><br><span class="line"></span><br><span class="line">	SearchFuzzy(lpszContent, nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai417992qj20li0d8tg3.jpg" alt="Screen Shot 2020-01-01 at 20.35.19.png"></p>
<h2 id="simHash-算法"><a href="#simHash-算法" class="headerlink" title="simHash 算法"></a>simHash 算法</h2><h3 id="算法起源和步骤"><a href="#算法起源和步骤" class="headerlink" title="算法起源和步骤"></a>算法起源和步骤</h3><ol>
<li>问题的起源：设计比较两篇文章相似度的算法。</li>
<li>simHash 算法分为 5 个步骤：<ol>
<li>分词</li>
<li>Hash</li>
<li>加权</li>
<li>合并</li>
<li>降维</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai2j6ly1hj211c0oi1fv.jpg" alt="Screen Shot 2020-01-01 at 19.43.21.png"></p>
<p>注意！！！</p>
<ol>
<li>上面”加权“那一项中是吧 W(CSDN)=100101 看成 6 个位置（6个数字，分别是 1, 0, 0, 1, 0, 1），然后再把 0 当成 -1 来计算乘积。</li>
<li>上面的”合并“那一项最后得到的是”9, -9, 1, -1, 1, 9“，图中漏写了最后的”9“。</li>
<li>权重的计算可以使用 TF-IDF 方法！</li>
</ol>
<h3 id="simHash-的应用"><a href="#simHash-的应用" class="headerlink" title="simHash 的应用"></a>simHash 的应用</h3><ol>
<li>每篇文档得到 simHash 签名值后，接着计算两个签名的海明距离即可。根据经验值，对 64 位的 SimHash 值，海明距离在 3 以内的可以认为相似度较高。</li>
<li>海明距离的求法：两个二进制数去异或操作，结果中 1 的个数就是海明距离。</li>
</ol>
<p>[对simHash的分块处理]</p>
<ol>
<li>如何将其扩展到海量数据呢？比如如何在海量的样本库中查询与其海明距离在 3 以内的记录呢？</li>
<li>一种方案是查找待查询文本的 64 为 simHash code 所有 3 位以内变化的组合</li>
<li>大约 43744 个。</li>
</ol>
<h3 id="进一步的思考"><a href="#进一步的思考" class="headerlink" title="进一步的思考"></a>进一步的思考</h3><ol>
<li>完全丢掉了位置信息和语义信息<ol>
<li>考虑使用 WordNet 影响 Hash 值？</li>
<li>考虑使用主题模型、标签传递算法等机器学习方法来分析语义</li>
</ol>
</li>
<li>允许交换，算一次变换：如 meter 和 metre<ol>
<li>能否写出递推关系式</li>
<li>还能设计出 O(n^2)的算法吗？</li>
</ol>
</li>
<li>如果计算字符串的语义距离，怎么考虑？<ol>
<li>WordNet 是由 Princeton 大学的心理学家，语言学家和计算机工程师联合设计得一种基于认知语言学的英语词典。它不光是把单词以字母顺序排列，而且按照单次的意义组成一个”单次的网络“。</li>
</ol>
</li>
</ol>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><ol>
<li>布隆过滤器(Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出的，他是一种空间高效的概率性数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单，爬虫(Crawler)的网址判重等问题中经常被用到。</li>
<li>哈希表也能用于判断元素是否在集合中，但是 Bloom Filter 只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。Bloom Filter 可以插入元素，但不可以删除已有元素。集合中的元素越多，误报率(false positive rate)越大，但是不会漏报 (false negative).</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rg9avlj20nu0gitit.jpg" alt="Screen Shot 2020-01-01 at 20.40.37.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rqrt0aj20mg0cgafh.jpg" alt="Screen Shot 2020-01-01 at 21.00.25.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai50f2nggj20lq0doq8u.jpg" alt="Screen Shot 2020-01-01 at 21.09.10.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai521tg4fj20o80e0wmi.jpg" alt="Screen Shot 2020-01-01 at 21.10.46.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5bt06y8j20me0eawkm.jpg" alt="Screen Shot 2020-01-01 at 21.20.12.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5ck8aqjj20oc0g8dqk.jpg" alt="Screen Shot 2020-01-01 at 21.20.57.png"></p>
<h3 id="Bloom-Filter-特点"><a href="#Bloom-Filter-特点" class="headerlink" title="Bloom Filter 特点"></a>Bloom Filter 特点</h3><ol>
<li>优点：相比于其他的数据结构，Bloom Filter 在空间和时间方面有巨大的优势。Bloom Filter 存储空间是线性的，插入和查询时间都是常数。另外，Hash 函数相互之间没有关系，方便由硬件并行实现。Bloom Filter 不存储元素本身，在某些对保密要求非常严格的场合有优势。</li>
<li>很容易想到把位向量变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素是将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在 Bloom Filter 里面。这一点单凭这个过滤器是无法保证的。另外计数器下溢出也会造成问题（槽的值已经是 0 了，仍然执行删除操作）。</li>
</ol>
<h3 id="Bloom-Filter-用例"><a href="#Bloom-Filter-用例" class="headerlink" title="Bloom Filter 用例"></a>Bloom Filter 用例</h3><ol>
<li>Google 著名分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的 IO 次数。</li>
<li>Squid 网页代理缓存服务器在 cachedigests 中使用了 BloomFilter</li>
<li>Venti 文档存储系统采用 BloomFilter 来检测先前存储的数据；</li>
<li>SPIN 模型检测器使用 BloomFilter 在大规模验证问题时跟踪可达状态空间</li>
<li>Google Chrome 浏览器使用 BloomFilter 加速安全浏览服务</li>
<li>在很多 Key-Value 系统中也是用 BloomFilter 来加快查询过程，如 HBase, Accumulo, Leveldb<ol>
<li>一般而言，value 保存在磁盘中，访问磁盘需要花费大量时间，然而使用 BloomFilter 可以快速判断某个 Key 是否存在，因此可以避免很多不必要的磁盘 IO 操作；另外，引入布隆过滤器会带来一定的内存消耗。</li>
<li>如果你真的非常在意 false positive 的话，那么可以在 Bloom Filter 给出“存在”的结论时候，再去磁盘真的查询一次看看到底在不在。</li>
</ol>
</li>
</ol>
<h2 id="跳跃链表（skip-list）"><a href="#跳跃链表（skip-list）" class="headerlink" title="跳跃链表（skip list）"></a>跳跃链表（skip list）</h2><ol>
<li>Treaps/RB-Tree/BTree</li>
<li>跳跃链表是一种随机化数据结构，基于并联的链表，其效率与 RBTree 相当。具有简单、高效、动态（Simple, Effective, Dynamic）的特点。</li>
<li>跳跃链表对有序的链表副驾辅助结构，在链表中的查找可以快速的跳过部分节点（由此得名）。<ol>
<li>查找、增加、删除的期望时间都是 O(logN)</li>
<li>with high probability (W.H.P. ~ 1 - 1/(n^alpha))</li>
</ol>
</li>
<li>跳跃链表在并行计算中非常有用，数据插入可以再跳表的不同部分并行进行，而不用全局的数据结构重新平衡。</li>
<li>跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速跑道“，这里在层 i 中的元素按某个固定的概率 p 出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现。<ol>
<li>为什么是 1/(1-p)?</li>
</ol>
</li>
<li>优势<ol>
<li>编程方便</li>
<li>尤其方便将增删改查操作扩展成并行算法！</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8c6p5coj20na0eqtg7.jpg" alt="Screen Shot 2020-01-02 at 19.29.50.png"></p>
<p>由上图可以看出来，要找一个元素，先在最上层找，找不到再往下走一层找。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8grgkdvj20ns0gcti8.jpg" alt="Screen Shot 2020-01-02 at 19.54.17.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8ip6lijj20lu0caqa8.jpg" alt="Screen Shot 2020-01-02 at 19.56.13.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8kf7iagj20nk0fqdsc.jpg" alt="Screen Shot 2020-01-02 at 19.57.54.png"></p>
<p><mark><br>    注意上面这个计算有错！<br>    k = ln(N) 这个结果没什么毛病。但是 T(N) 的表达有问题 T(N) = ln(N) <em> N^(1 / ln(N))<br>    而乘法号后面的 N^(1 / ln(N)) 等于数学常量 e<br>    因此 T(N) = e </em> ln(N)<br></mark></p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol>
<li>随着底层链表的插入，某一段上的数据将不满足理想链表的要求，需要做些调整。<ol>
<li>将底层链表这一段上元素的中位数在拷贝到上层链表中；</li>
<li>重新计算上层链表，使得上层链表仍然是底层链表的 1/e;</li>
<li>如果上述操作过程中，上层链表不满足要求，继续上上层链表的操作。</li>
</ol>
</li>
<li>新的数据应该在上层甚至上上层链表中吗？因为要找 1/e 的数据放在上层链表，因此：<mark>抛硬币！</mark></li>
<li>插入元素后的跳表维护<ol>
<li>考察待需要提升的某段节点</li>
<li>若抛硬币得到的随机数 p &lt; 1/e, 则提升到上层，继续抛硬币，直到 p &gt; 1/e<ol>
<li>或者到了顶层仍然 p &lt; 1/e, 建立一个新的顶层</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol>
<li>在某层链表上找到了该元素，则删除；如果该层链表不是底层链表，就跳转到下一层，继续本操作</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj9wczbs7j20os0coahp.jpg" alt="Screen Shot 2020-01-02 at 20.43.55.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSSkipNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	tagSSkipNode* pNext;</span><br><span class="line">	tagSSkipNode* pNextLayer;</span><br><span class="line"></span><br><span class="line">    tagSSkipNode(<span class="keyword">int</span> v) : value(v), pNext(<span class="literal">nullptr</span>), pNextLayer(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; SSkipNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSkipList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SSkipNode* m_pHead;</span><br><span class="line">    <span class="keyword">int</span> m_nSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CSkipList()&#123;</span><br><span class="line">    	m_pHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);</span><br><span class="line">    	m_nSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SSkipNode* <span class="title">Find</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">SSkipNode* <span class="title">FindIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize &lt;= <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintLayer</span><span class="params">(<span class="keyword">const</span> SSkipNode* pNode)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsSuccess</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> rand() &gt; RAND_MAX * <span class="number">0.36787944117</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find</span></span><br><span class="line">SSkipNode* CSkipList::Find(<span class="keyword">int</span> value) <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	SSkipNode* pre = m_pHead;</span><br><span class="line">	SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(cur &amp;&amp; (cur-&gt;value &lt; value))    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre = cur;</span><br><span class="line">			cur = cur-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// while 结束后 cur-&gt;value 不小于 value, 而 pre-&gt;value 小于 value</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = pre-&gt;pNextLayer;</span><br><span class="line">		cur = pre-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert</span></span><br><span class="line"><span class="keyword">bool</span> CSkipList::Insert(<span class="keyword">int</span> value)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_pHead-&gt;pNext)&#123;</span><br><span class="line">		m_pHead-&gt;pNext = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">		m_nSize = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SSkipNode* pre = m_pHead;</span><br><span class="line">	SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">	<span class="built_in">stack</span>&lt;SSkipNode*&gt; path;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;    <span class="comment">// 已经存在，这里的思想是是不允许插入。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 当然也可以修改数据结构，记录一下次数</span></span><br><span class="line">		&#125;</span><br><span class="line">		path.push(pre);    <span class="comment">// 记录插入点</span></span><br><span class="line">		<span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = pre-&gt;pNextLayer;</span><br><span class="line">		cur = pre-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入到 pre 的后面，cur 的前面</span></span><br><span class="line">	SSkipNode* now = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">	now-&gt;pNext = cur;</span><br><span class="line">	pre-&gt;pNext = now;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随机上升</span></span><br><span class="line">	SSkipNode* nowInLayer;</span><br><span class="line">	SSkipNode* pLayerHead;</span><br><span class="line">	<span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">		<span class="keyword">if</span>(!IsSuccess())&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		path.pop();    <span class="comment">// 第一次到这里的时候，这个是最下层的，没有用的。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到层的插入位置</span></span><br><span class="line">		<span class="keyword">if</span>(path.empty())&#123;</span><br><span class="line">			pre = m_pHead;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre = path.top();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 生成节点</span></span><br><span class="line">		nowInLayer = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">		nowInLayer-&gt;pNextLayer = now;</span><br><span class="line">		<span class="keyword">if</span>(path.empty())&#123;    <span class="comment">// 说明顶层后仍然成功，则新建层</span></span><br><span class="line">            pLayerHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);    <span class="comment">// 生成层的新头指针</span></span><br><span class="line">            pLayerHead-&gt;pNext = m_pHead-&gt;pNext;</span><br><span class="line">            pLayerHead-&gt;pNextLayer = m_pHead-&gt;pNextLayer;</span><br><span class="line">            m_pHead-&gt;pNextLayer = pLayerHead;    <span class="comment">// 退化到下一层</span></span><br><span class="line">            m_pHead-&gt;pNext = nowInLayer;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nowInLayer-&gt;pNext = pre-&gt;pNext;</span><br><span class="line">			pre-&gt;pNext = nowInLayer;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为下次上升作准备</span></span><br><span class="line">		now = nowInLayer;</span><br><span class="line">	&#125;</span><br><span class="line">	m_nSize++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="keyword">bool</span> CSkipList::Delete(<span class="keyword">int</span> value)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	SSkipNode* pre = m_pHead;</span><br><span class="line">	SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">	SSkipNode* pHeadPre = <span class="literal">nullptr</span>;</span><br><span class="line">	SSkipNode* pHead = m_pHead;</span><br><span class="line">	<span class="keyword">bool</span> bDelete = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;   <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">    		pre = cur;</span><br><span class="line">    		cur = cur-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">			bDelete = <span class="literal">true</span>;</span><br><span class="line">			pre-&gt;pNext = cur-&gt;pNext;</span><br><span class="line">			<span class="keyword">delete</span> cur;</span><br><span class="line">			<span class="keyword">if</span>(!pHead-&gt;pNext)&#123;    <span class="comment">// 该层没有元素，则删除该层</span></span><br><span class="line">				<span class="keyword">if</span>（pHead == m_pHead)&#123;    <span class="comment">// 顶层</span></span><br><span class="line">					SSkipNode* pNL = m_pHead-&gt;pNextLayer;</span><br><span class="line">					m_pHead-&gt;pNextLayer = pNL ? pNL-&gt;pNextLayer : <span class="literal">nullptr</span>;</span><br><span class="line">					m_pHead-&gt;pNext = pNL ? pNL-&gt;pNext : <span class="literal">nullptr</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pHeadPre-&gt;pNextLayer = pHead-&gt;pNextLayer;</span><br><span class="line">					<span class="keyword">delete</span> pHead;</span><br><span class="line">					pHead = pHeadPre</span><br><span class="line">				&#125;</span><br><span class="line">				pre = pHead;</span><br><span class="line">				cur = pre-&gt;pNext;</span><br><span class="line">				<span class="keyword">continue</span>;    <span class="comment">// 删除该层后，pre/cur 已经向下移动了一层</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!pre-&gt;pNextLayer) <span class="keyword">break</span>;</span><br><span class="line">		pre = pre-&gt;pNextLayer;</span><br><span class="line">		cur = pre-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		pHeadPre = pHead;</span><br><span class="line">		pHead = pHead-&gt;pNextLayer;</span><br><span class="line">	&#125;</span><br><span class="line">	m_nSize--;</span><br><span class="line">	<span class="keyword">return</span> bDelete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)&#123;</span><br><span class="line">	CSkipList sl;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;    <span class="comment">// 随机插入数据</span></span><br><span class="line">		sl.Insert(rand() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sl.Print();</span><br><span class="line">	<span class="keyword">while</span>(!sl.IsEmpty())&#123;</span><br><span class="line">		SSkipNode* p = sl.FindIndex(rand() % sl.GetSize());</span><br><span class="line">		<span class="keyword">if</span>(p)&#123;</span><br><span class="line">			<span class="keyword">int</span> num = p-&gt;value;</span><br><span class="line">			<span class="keyword">if</span>(sl.Delete(num))&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"No Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			sl.Print();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"==================\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><ol>
<li>MD5 (Message Digest Algorithm)，消息摘要算法，用以提供消息的完整性保护。</li>
</ol>
<h3 id="框架理解"><a href="#框架理解" class="headerlink" title="框架理解"></a>框架理解</h3><ol>
<li>对于长度为 512bit 的信息，可以通过处理，得到长度为 128bit 的摘要</li>
<li>初始化摘要 0x0123456789ABCDEFFEDCBA9876543210<ol>
<li>A = 0x01234567</li>
<li>B = 0x89ABCDEF</li>
<li>C = 0xFEDCBA98</li>
<li>D = 0x76543210</li>
</ol>
</li>
<li>现在的工作，是要用长度为512 位的信息，变换初始摘要</li>
<li>定义变量 a，b，c，d，分别记录 A，B，C，D</li>
<li>将 512 bit 的信息按照 32 bit 一组，分成 16 组；分别记为 Mj (0 &lt;= j &lt;= 15)</li>
<li>取某正数 s, t_k, 定义函数 FF(a,b,c,d,Mj,s,t_k) = (a+F(b,c,d)+Mj+t_k) &lt;&lt; s</li>
<li>利用 Mj 分别进行信息提取，将结果保存到 a<ol>
<li>其中，F(X,Y,Z) = (X &amp; Y) | (~X &amp; Z)</li>
</ol>
</li>
<li>经过以上 16 次变换，a，b，c，d 带有了 Mj 的信息</li>
<li>事实上经过四轮这样的变换（4轮 * 16次 = 64 次）</li>
<li>经过 64 次变换后，将 a，b，c，d 累加给 A，B，C，D</li>
<li>此时，完成了 512 bit 信息的提取；进行下一个 512 bit 信息的相同操作。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbqj9ymdj20m80giwjo.jpg" alt="Screen Shot 2020-01-02 at 21.47.31.png"></p>
<h3 id="细致算法"><a href="#细致算法" class="headerlink" title="细致算法"></a>细致算法</h3><ol>
<li>在算法中，首先要对信息进行填充，使其长度对 512 求余的结果是 448</li>
<li>填充的方法如下，在信息的后面填充一个 1 和若干个 0，知道满足上面的条件。然后在这个结果后面附加一个以 64 位二进制表示的原始信息长度 length</li>
<li>经过这两步的处理，数据总长度为 N <em> 512 + 448 + 64 = (N+1) </em> 512.</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbs4sb7nj20lk0ds14h.jpg" alt="Screen Shot 2020-01-02 at 21.49.07.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbv3nfevj20m40goh3v.jpg" alt="Screen Shot 2020-01-02 at 21.51.56.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/leetcode-math/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/leetcode-math/" itemprop="url">leetcode-math</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T10:44:36-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/leetcode-math/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/leetcode-math/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h1><h2 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h2><p>本福特定律（本福特法则，Frank Benford），又称第一数字定律，是指在实际生活得出的一组数据中，以 1 为首位数字出现的概率约为总数的三成；是直观想象 1/9 的三倍。</p>
<ul>
<li>阶乘，素数数列，斐波那契数列</li>
<li>住宅地址号码</li>
<li>经济数据反欺诈（检验是否符合本定律）</li>
<li>选举投票发欺诈</li>
</ul>
<table>
<thead>
<tr>
<th>数字</th>
<th>出现概率</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>30.1%</td>
</tr>
<tr>
<td>2</td>
<td>17.6%</td>
</tr>
<tr>
<td>3</td>
<td>12.5%</td>
</tr>
<tr>
<td>4</td>
<td>9.7%</td>
</tr>
<tr>
<td>5</td>
<td>7.9%</td>
</tr>
<tr>
<td>6</td>
<td>6.7%</td>
</tr>
<tr>
<td>7</td>
<td>5.8%</td>
</tr>
<tr>
<td>8</td>
<td>5.1%</td>
</tr>
<tr>
<td>9</td>
<td>4.6%</td>
</tr>
</tbody>
</table>
<h2 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h2><p>[题目]<br>给定 N 个数，设计算法，输出随机排列的一个结果。</p>
<p>[思路]</p>
<ol>
<li>直接一个数字一个数字的选择就可以了</li>
</ol>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rand() % (b - a + <span class="number">1</span>) + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomShuffle2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size() - <span class="number">1</span>; i++)&#123;    <span class="comment">// i 是待生成的第几个数</span></span><br><span class="line">        j = Random2(i, a.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思考]</p>
<ol>
<li>其实 STL 里面有 std::random_shuffle 可以直接得到结果。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/leetcode-dp-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/31/leetcode-dp-动态规划/" itemprop="url">leetcode-dp-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-31T21:35:23-08:00">
                2019-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/31/leetcode-dp-动态规划/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/31/leetcode-dp-动态规划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h2><p>[题目]<br>给定不超过 100 万元的现金总额，兑换成数量不限的 100, 50, 20, 10, 5, 2, 1 的组合，共有多少种组合呢？</p>
<p>[思路一]<br>这个是视频里讲得思路</p>
<ul>
<li>定义 dp[i][j]: 使用面额小于等于 i 的钱币，凑成 j 元钱，宫有多少种组合方法</li>
<li>dp[100][500] = dp[50][500] + dp[100][400]</li>
<li>dp[i][j] = dp[i_small][j] + dp[i][j-1]<ul>
<li>不考虑下界溢出的情况</li>
</ul>
</li>
</ul>
<p>[思路二]<br>我觉得把，用个一维的数组来做 dp 就可以了。</p>
<p>DP[target] 表示用给定的钱币凑出来 target 的组合数量，那么<br>DP[target] 显然等于 DP[target-1] + DP[target-2] + DP[target-5] + … + DP[target-100]</p>
<p>就跟走楼梯的方法一模一样啊！！！</p>
<h2 id="两次走棋盘"><a href="#两次走棋盘" class="headerlink" title="两次走棋盘"></a>两次走棋盘</h2><p>[题目]</p>
<ul>
<li>Maximum points from top left of matrix to bottom right and return back</li>
<li>给定 MxN 的矩阵，每个位置是一个非负的权值，从左上角开始，每次只能朝右和下走，走到右下角；然后，从右下角开始，每次只能超左和上走，走到左上角。求权值总和最大的路径。若相同格子走过两次，则该位置的权值只算一次。</li>
</ul>
<p>[思路]</p>
<ol>
<li>错误的思路一：贪心，先从左上到右下，再从右下到左上！这样子做选的路径两条路将会一模一样，因为重复的结点权值只算一次，这样子肯定不行。</li>
<li>错误的思路二：接错误一，如果你第一次走的时候把走过的结点权值改成 0，然后第二次走再选最大的路径。这样子也是不对的！</li>
<li>正确的思路：这题的一个技巧是把第二个图翻转过来，跟第一条路放到一起，二者同时走，即从左上角同时出发有两条路，终点都是右下角！</li>
<li>有了这个转换之后，显然，就可以用 row1, col1, row2, row4 来表示状态了！注意在任何时刻都满足条件： row1 + col1 = row2 + col2. 因此可以只用三个变量 row1, col1, row2 来表示状态。</li>
<li>在任意时刻，如果两条路汇合到同一个位置，那么这个位置的权值只计算一次，如果在两个不同的位置，那么两个权值都计算上！</li>
</ol>
<p>[代码]<br>这里的代码是自上而下的一个 DP.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; goldMatrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> col2 = row1 + col1 - row2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.size(), n = goldMatrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if they reach bottom right location</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == m<span class="number">-1</span> &amp;&amp; row1 == row2 &amp;&amp; col1 == n<span class="number">-1</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> goldMatrix[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(row1 == m || row2 == m || col1 == n || col2 == n)&#123;</span><br><span class="line">		<span class="keyword">return</span> INT_MIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The same state has been calculated previously</span></span><br><span class="line">	<span class="keyword">if</span>(dp[row1][col1][row2] != <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> dp[row1][col1][row2];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// They are at the same spot</span></span><br><span class="line">	<span class="keyword">if</span>(row1 == row2)&#123; </span><br><span class="line">        res += goldMatrix[row1][col1];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res += (goldMatrix[row1][col1] + goldMatrix[row2][col2]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first move right, second move right</span></span><br><span class="line">	dp1 = helper(row1, col1+<span class="number">1</span>, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first move right, second move down</span></span><br><span class="line">	dp2 = helper(row1, col1+<span class="number">1</span>, row2+<span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first move down, second move right</span></span><br><span class="line">	dp3 = helper(row1+<span class="number">1</span>, col, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first move down, second move down</span></span><br><span class="line">	dp4 = helper(row1 + <span class="number">1</span>, col, row2 + <span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">	res += max(dp1, max(dp2, max(dp3, dp4)));</span><br><span class="line"></span><br><span class="line">	dp[row1][col1][row2] = res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collectGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; goldMatrix)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = goldMatrix.size();</span><br><span class="line">	<span class="keyword">int</span> n = goldMatrix[<span class="number">0</span>].size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, goldMatrix, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 错位排列</span><br><span class="line">[问题]</span><br><span class="line"><span class="number">1.</span> 把数字 <span class="number">1</span> 到 n 做个排列，要求数字 i 不能位于第 i 个位置。问：这样的排列一共有多少种?</span><br><span class="line"><span class="number">2.</span> 这个问题最早是由 Danial Bernoulli （著名的伯努利家族成员）提出的。</span><br><span class="line"></span><br><span class="line">[思路]</span><br><span class="line"><span class="number">1.</span> (n<span class="number">-1</span>)! 这个结果是不对的，不能排除掉重复的结果！</span><br><span class="line"><span class="number">2.</span> 先考虑 n</span><br><span class="line">	<span class="number">1.</span> n 可以放置在 <span class="number">1</span> 到 n<span class="number">-1</span> 一共 n<span class="number">-1</span> 种可能。假设放在了 k 位置</span><br><span class="line"><span class="number">3.</span> 现在考虑数字 k，有两种情况</span><br><span class="line">	<span class="number">1.</span> 第一种情况，数字 k 放到了 位置 n，那么剩下的可能就是 DP(n<span class="number">-2</span>) 了。</span><br><span class="line">	<span class="number">2.</span> 第二种情况下，数字 k 不能放到位置 n，这时候把数字 k 想象成数字 n（数字 n 本来已经用掉了，可以用 k 替代它继续做问题），而剩下的 n<span class="number">-2</span> 个数字也各有一个位置不能放！其实这就是 DP(n<span class="number">-1</span>) 啊！</span><br><span class="line"><span class="number">4.</span> 所以 DP 的转移公式是</span><br><span class="line">    <span class="number">1.</span> DP[n] = (n<span class="number">-1</span>)(DP[n<span class="number">-1</span>] + DP[n<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">![Screen Shot <span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> at <span class="number">17.16</span><span class="number">.10</span>.png](https:<span class="comment">//ws1.sinaimg.cn/large/6a607485gy1gahya0ozdgj20l20c043w.jpg)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三字符字符串组合"><a href="#三字符字符串组合" class="headerlink" title="三字符字符串组合"></a>三字符字符串组合</h2><p>[题目]<br>仅由三个字符 A, B, C 构成字符串，且字符串任意三个相邻元素不能完全相同。如 “ACCCAB” 不合法，”ABBCBCA” 合法。求满足条件的长度为 n 的字符串个数。note: 假定不考虑整数溢出，并且要求时间和空间复杂度不高于 O(N)。</p>
<p>[分析]</p>
<ol>
<li>若当前已经有了所有长度为 n-1 的合法字符串，如何在末端增加一个字符，形成长度为 n 的字符串呢？</li>
<li>将长度为 n-1 字符串分成”末尾两个字符不相等“和”末尾两个字符相等“两种情况，各自数目记做 dp[n-1][0], dp[n-1][1]:<ol>
<li>dp[n][0] = 2 <em> dp[n-1][0] + 2 </em> dp[n-1][1]</li>
<li>dp[n][1] = dp[n-1][0]</li>
<li>初始条件是 dp[1][0] = 3, dp[1][1] = 0</li>
</ol>
</li>
</ol>
<h3 id="改进空间复杂度"><a href="#改进空间复杂度" class="headerlink" title="改进空间复杂度"></a>改进空间复杂度</h3><ol>
<li><mark>状态转移方程总结与改进</mark><ol>
<li>滚动数组法</li>
<li>dp[0] = 2 <em> dp[0] + 2 </em> dp[1]</li>
<li>dp[1] = dp[0]</li>
<li>此法将空间复杂度由 O(N) 降到 O(1)</li>
</ol>
</li>
</ol>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		t = nNonRepeat;</span><br><span class="line">		nNonRepeat = <span class="number">2</span> * (nNonRepeat + nRepeat);</span><br><span class="line">		nRepeat = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nNonRepeat + nRepeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="改进时间复杂度"><a href="#改进时间复杂度" class="headerlink" title="改进时间复杂度"></a>改进时间复杂度</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/2020-01-04-at-15-36-26.png" alt=""></p>
<p>而一个矩阵的 n 次幂可以用递归方法来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix2x2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">	Matrix2x2(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd) : a(aa), b(bb), c(cc), d(dd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd)</span></span>&#123;</span><br><span class="line">		a = aa;</span><br><span class="line">		b = bb;</span><br><span class="line">		c = cc;</span><br><span class="line">		d = dd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMultiply</span><span class="params">(Matrix2x2 &amp; m, Matrix2x2 &amp; n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = m.a * n.a + m.b * n.c;</span><br><span class="line">	<span class="keyword">int</span> b = m.a * n.b + m.b * n.d;</span><br><span class="line">	<span class="keyword">int</span> c = m.c * n.a + m.d * n.c;</span><br><span class="line">	<span class="keyword">int</span> d = m.c * n.b + m.d * n.d;</span><br><span class="line">	m.Set(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixN</span><span class="params">(Matrix2x2 &amp; m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">		m.Set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 单位阵</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 偶数</span></span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;           <span class="comment">// 奇数</span></span><br><span class="line">        Matrix2x2 x = m;</span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">        MatrixMultiply(m, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">	<span class="function">Matrix2x2 <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	MatrixN(m, n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span> * (m.a + m.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/leetcode-greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/31/leetcode-greedy/" itemprop="url">leetcode-greedy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-31T21:10:37-08:00">
                2019-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/31/leetcode-greedy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/31/leetcode-greedy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="稳定匹配问题"><a href="#稳定匹配问题" class="headerlink" title="稳定匹配问题"></a>稳定匹配问题</h2><p>[题目]<br>假如你是一个媒人，有若干个单身男子登门求助，还有同样多的单身女子也前来征婚。如果你已经知道这些女孩在每个男人心目中的排名，以及男孩们在每个女孩心中的排名(1)，你应该怎样为他们牵线配对呢？</p>
<p>这个匹配要稳定：<br>如果男 1 号和女 1 号各自有各自的对象，但男 1 号觉得，比起自己现在的对象，女 1 号更好一些；女 1 号也发现，在自己心目中，男 1 号的排名比现男友更靠前一些。这样一来，这两人就可能会发生外遇，最后扔下各自现在的对象，一起私奔了——因为这个结果对他们两人都更好一些。在一种男女配对的方案中，如果出现了这种情况，我们就说婚姻搭配是不稳定的。</p>
<p>[思路]</p>
<ol>
<li>1962 年，美国数学家 David Gale 和 Lloyd Shapley 发明了一种寻找稳定婚姻的策略。不管男女各有多少人，不管他们各自的偏好如何，应用这种策略后总能得到一个稳定的婚姻搭配。换句话说，他们证明了稳定的婚姻搭配总是存在的。有趣的是，这种策略反映了现实生活中的很多真实情况。</li>
<li>在这种策略中，男人将一轮一轮地去追求他中意的女子，女子可以选择接受或者拒绝她的追求者。第一轮，每个男人都选择自己名单上排在首位的女人，并向她表白。此时，一个女孩儿可能面对的情况有三种：没有人跟她表白，只有一个人跟她表白，有不止一个人跟她表白。在第一种情况下，这个女孩儿什么都不用做，只需要继续等待；在第二种情况下，接受那个人的表白，答应暂时和他做男女朋友；在第三种情况下，从所有追求者中选择自己最中意的那一位，答应和他暂时做男女朋友，并拒绝其他所有的追求者。</li>
<li>第一轮结束后，有些男人已经有女朋友了，有些男人仍然是单身。在第二轮追女行动中，每个单身男都从所有还没拒绝过他的女孩中选出自己最中意的那一个，并向她表白，不管她现在是否是单身。和第一轮一样，女孩儿们需要从表白者中选择最中意的一位，拒绝其他追求者。注意，如果这个女孩儿已经有男朋友了，当她遇到了更好的追求者时，她必须拒绝掉现在的男友，投向新的追求者的怀抱。这样，一些单身男人将会得到女友，那些已经有了女友的人也可能会被甩掉，重新变成光棍。在以后的每一轮中，单身的男人继续追求列表中的下一个女孩儿，女孩儿则从包括现男友在内的所有追求者中选择最好的一个，并对其他人说不。这样一轮一轮地进行下去，直到某个时候所有人都不再单身，下一轮将不会有任何新的表白发生，整个过程自动结束。此时的婚姻搭配就一定是稳定的了。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gahqf5s50kj207w071wei.jpg" alt="StableMatching"></p>
<p>[思考和应用]</p>
<ol>
<li>[历史应用] 历史上，这样的“配对游戏”还真有过实际应用，并且更有意思的是，这个算法的应用居然比算法本身的提出还早 10 年。早在 1952 年，美国就开始用这种办法给医学院的学生安排工作，这被称之为“全国住院医师配对项目”。配对的基本流程就是，各医院从尚未拒绝这一职位的医学院学生中选出最佳人选并发送聘用通知，当学生收到来自各医院的聘用通知后，系统会根据他所填写的意愿表自动将其分配到意愿最高的职位，并拒绝掉其它的职位。如此反复，直到每个学生都分配到了工作。当然，那时人们并不知道这样的流程可以保证工作分配的稳定性，只是凭直觉认为这是很合理的。直到 10 年之后， Gale 和 Shapley 才系统地研究了这个流程，提出了稳定婚姻问题，并证明了这个算法的正确性。</li>
<li>[男女公平吗]<ol>
<li>对男生是 optimal 的，对女生是 pesimal 的。</li>
<li>如果换一下顺序，让女生去追男的，那么结果对女生就是 optimal，对男生就是 pesimal 的。</li>
<li>注意！！！有一些简单的例子你换个顺序做会发现结果一样，这并不名说明上面的 optimal-pesimal 结论有错误，而是因为这个简单的例子只有一种可能的 stable matching. 所以两种方法都会得到这唯一的结果。</li>
<li>只有当有多个 stable solution 存在的时候（每一个solution 里面男 A 都有一个配偶），你会发现，如果是男追女，那么男A 最后的配偶一定是这些 solution 里面的配偶中男A 最喜欢的那个！而女人的配偶一定是这些solution 里面最差的那个。</li>
</ol>
</li>
<li><mark>[现实联系]</mark><ol>
<li><mark>想想生活中，一般都是男追女</mark></li>
<li><mark>那么男生先从自己最喜欢的女生追起来是很符合逻辑的</mark></li>
<li><mark>然后女生呢，只要有男生追自己，那么就先答应着！如果后面碰到更好的，就把男友踹了跟新来者谈恋爱</mark></li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/leetcode-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/leetcode-graph/" itemprop="url">leetcode-graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-28T17:44:02-08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/leetcode-graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/28/leetcode-graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><ul>
<li>图的遍历和搜索</li>
<li>（隐式）图的搜索（连通性）<ul>
<li>重点</li>
<li>8皇后</li>
</ul>
</li>
<li>最短路径<ul>
<li>单源图 (Dijkstra)</li>
<li>任意两点 (floyd)</li>
<li>有负边</li>
</ul>
</li>
<li>最小生成树 (MST)<ul>
<li>Prim</li>
<li>Krusal</li>
</ul>
</li>
<li>拓扑排序 (Topological Sort)</li>
</ul>
<h2 id="图的表示和搜索"><a href="#图的表示和搜索" class="headerlink" title="图的表示和搜索"></a>图的表示和搜索</h2><ul>
<li>图的表示<ul>
<li>邻接矩阵<ul>
<li>NxN 的矩阵，有边是 1，无边是 0</li>
</ul>
</li>
<li>邻接表<ul>
<li>为每个点建立一个链表（数组）存放与之连接的点</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="所有括号匹配的字符串"><a href="#所有括号匹配的字符串" class="headerlink" title="所有括号匹配的字符串"></a>所有括号匹配的字符串</h2><p>[题目]<br>N 对括号能够得到的有效括号序列有哪些？</p>
<p>[例子]<br>N = 3, 有效括号串共 5 个，分别为：</p>
<ol>
<li>()()()</li>
<li>()(())</li>
<li>(())()</li>
<li>(()())</li>
<li>((()))</li>
</ol>
<p>[问题分析]</p>
<ul>
<li>任何一个括号序列，都可以写成形式 (A)B<ul>
<li>A 和 B 都是若干括号对形成的合法串（可以是空串）</li>
<li>若 N=0, 括号序列为空</li>
<li>若 N=1, 括号序列只能是 () 这一种。</li>
</ul>
</li>
<li>算法描述: i 属于 [0, N-1]<ul>
<li>计算 i 对括号的可行序列 A</li>
<li>计算 N-i-1 对括号的可行序列 B</li>
<li>组合得到 (A)B</li>
<li>注：加上额外一对括号 (), 总括号数量是 N 对</li>
</ul>
</li>
</ul>
<p><mark>注意下面算法有直接修改数组最后一个元素! 使用了返回引用的方法！！！</mark><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; AllParentheses(<span class="keyword">int</span> n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; prefix, suffix, result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		prefix = AllParentheses(i);</span><br><span class="line">		suffix = AllParentheses(n-i<span class="number">-1</span>);</span><br><span class="line">		Unit(result, prefix, suffix);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prefix, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; suffix)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> ip = prefix.begin(); ip != prefix.end(); ip++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> is = suffix.begin(); is != suffix.end(); is++)&#123;</span><br><span class="line">			result.push_back(<span class="string">""</span>);</span><br><span class="line">			<span class="built_in">string</span>&amp; r = result.back();    <span class="comment">// 这里返回的是引用！技巧啊！！</span></span><br><span class="line">			r += <span class="string">"("</span>;</span><br><span class="line">			r += *ip;</span><br><span class="line">			r += <span class="string">")"</span>;</span><br><span class="line">			r += *is;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思考]</p>
<ul>
<li>可以通过增加缓存的方式，对已经计算得到的字串直接获取，以空间换时间，降低时间复杂度。</li>
<li>如果只是计算可行括号串的数目，如何计算？<ul>
<li>事实上，数组 A[i] 表示长度为 i 的括号串的可行数目，即著名的 Catalan 数！</li>
</ul>
</li>
<li>Calalan 数（从 0 开始数）<ul>
<li>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, …</li>
</ul>
</li>
</ul>
<h2 id="最小平方划分"><a href="#最小平方划分" class="headerlink" title="最小平方划分"></a>最小平方划分</h2><p>[题目]<br>一个正整数可以由若干个正整数的平方和表示，求整数 201314 最小的平方划分数目。</p>
<p>[我的本来思路]<br>用DP的方法！</p>
<p>假设已知 1, …, n-1 的最小划分保存在数组 split[i] 中。求数 n 最小划分。</p>
<p>只需要遍历 1, …, n/2，然后看哪一个 split[i] + split[n-i] 最小，即是 n 的最小划分。</p>
<p>[优化的思路]<br>我的思路时间复杂度是 O(n^2), 因为对于每一个 n, 我都要考虑到 n/2 种情况。</p>
<p>事实上，这个题目可以优化到 O(n sqrt(n)) 的时间复杂度。具体做法就是考虑 n = a + K^2。<br>也就是说，只需要考虑 1 … K 这么多数字，其中 K = sqrt(n).<br>若 split[n - k^2] + 1 &lt; x (x 是当前的 n 的最小划分数目), 则将 x 更新为 split[n - k^2] + 1</p>
<p><mark>[如何求平方根]</mark><br>可以使用牛顿法。<br>牛顿法就是求一个方程的解的方法。</p>
<p>[题外话]<br>四平方和定理</p>
<ul>
<li>每个正整数均可表示为最多4个整数的平方和。</li>
<li>证明<ul>
<li>首先欧拉发现：如果正整数 m 和 n 能表示成 4 个整数的平方和，则其乘积 mn 也能表示成 4 个整数的平方和。</li>
<li>而由于每个正整数要么是质数，要么是合数，而合数都可以表达成质数的乘积形式。</li>
<li>因此只需要证明每个质数可以表示成四个整数的平方和即可！</li>
<li>拉格朗日和欧拉分别在 1770 和 1773 年做出证明。</li>
</ul>
</li>
</ul>
<h2 id="Palindrome-Partitioning-所有划分"><a href="#Palindrome-Partitioning-所有划分" class="headerlink" title="Palindrome Partitioning 所有划分"></a>Palindrome Partitioning 所有划分</h2><p>[题目]<br>给定一个字符串 str, 将 str 划分成若干子串，使得每一个子串都是回文串。计算 str 的所有可能的划分。</p>
<p>note: 因为单个字符一定是回文串，所以一定有解！</p>
<p>[思路一]</p>
<ul>
<li>若当前计算得到了 str[0 … i-1] 的所有划分，可否添加 str[i … j], 得到更大的划分呢？<ul>
<li>显然，若 str[i…j] 是回文串，则可以添加。</li>
</ul>
</li>
<li>剪枝: 在每一步都可以判断中间结果是否为合法结果<ul>
<li>回溯 + 剪枝：如果某一次发现划分不合法，立刻对该分支限界</li>
</ul>
</li>
</ul>
<p>[思路一的代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSolution</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; oneSolution, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start &gt;= n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPalindrome[start][i])&#123;</span><br><span class="line">			oneSolution.push_back(str.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">			FindSolution(str, n, res, i + <span class="number">1</span>, oneSolution, isPalindrome);</span><br><span class="line">			oneSolution.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二维 DP 来构建 isPalindrome 矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line">		p[i][i] = True;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">				isPalindrome[i][j] = True;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; PalindromePartitioning(<span class="built_in">string</span> str)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalindrome(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">	ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;str&gt; oneSolution;    <span class="comment">// 记录一个解！！！</span></span><br><span class="line">	FindSolution(str, n, res, start, oneSolution, isPalindrome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思路二：动态规划]</p>
<ul>
<li>如果已知 str[0 … i-1] 的所有回文划分结果 res(i)</li>
<li>如何求 str[0 … i] 的所有划分呢？<ul>
<li>如果子串 str[j … i] 是回文串，则将该字串和 res(j) 共同添加到 res(i+1) 中。</li>
</ul>
</li>
<li>算法<ul>
<li>将集合 res 置空</li>
<li>遍历 j(0 &lt;= j &lt; i), 若 str[j … i] 是回文串，则将 {str[j…i], res(j)} 添加到 res(i+1) 中</li>
<li>i 从 0 到 n，一次调用上面两步骤，最终返回 res(n) 即为所求。</li>
</ul>
</li>
</ul>
<p>[思路二的代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">res = &#123;</span></span><br><span class="line"><span class="comment">	&#123;&#123;&#125;&#125;,</span></span><br><span class="line"><span class="comment">	&#123;&#123;"a"&#125;&#125;,</span></span><br><span class="line"><span class="comment">	&#123;&#123;"a","a"&#125;, &#123;"aa"&#125;&#125;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line">		p[i][i] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">				isPalindrome[i][j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; PalindromePartitioning(<span class="built_in">string</span> str)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt; res;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalindrome(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">	ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line">    </span><br><span class="line">    res.push_back(&#123;&#123;&#125;&#125;);</span><br><span class="line">    res.push_back(&#123;&#123;str.substr(<span class="number">0</span>,<span class="number">1</span>)&#125;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; temp;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(isPalindrome[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">auto</span> it: res[j])&#123;    <span class="comment">// "it" is a vector of strings</span></span><br><span class="line">    				it.push_back(str.substr(j, i-j));</span><br><span class="line">    			&#125;</span><br><span class="line">    			temp.push_back(it);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	res.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DFS-与-DP-的思考"><a href="#DFS-与-DP-的思考" class="headerlink" title="DFS 与 DP 的思考"></a>DFS 与 DP 的思考</h3><ol>
<li>DFS 的过程，是计算完成了 str[0…i] 的切分，然后递归调用，继续计算 str[i+1, i+2, … n-1] 的过程；</li>
<li>而 DP 中，假定得到了 str[0 … i-1] 的所有可能切分方案，如何扩展得到 str[0…i] 的切分</li>
<li>从本质上说，二者是等价的：最终都是搜索一颗隐式树<ol>
<li>DFS 显然是深度优先搜索，DP 有点类似于层序遍历的思想。</li>
</ol>
</li>
</ol>
<h3 id="归纳推理的理解"><a href="#归纳推理的理解" class="headerlink" title="归纳推理的理解"></a>归纳推理的理解</h3><ol>
<li>第一数学归纳法，类似于马尔科夫模型，有状态 i 推理得到状态 i+1</li>
<li>第二数学归纳法，则是有状态 0 到 i 一起推理得到状态 i+1.</li>
</ol>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树要求从一个带权无相连通图中选择 n-1 条边并使这个图仍然联通（即得到了一棵生成树），同时还要求树的权重最小。<br>解决这个问题有两个很著名的算法：Prim 和 Kruskal。它们都是<mark>贪心算法</mark>。</p>
<ol>
<li>Prim 算法<ol>
<li>从某个（任意一个）结点出发，选择与该结点邻接的权重最小的边；随着结点的不断加入，每次都选择这些结点发出的边中<mark>权值最小</mark>的：重复 n-1 次。</li>
</ol>
</li>
<li>Kruskal 算法<ol>
<li>将边按照权值递增排序，每次选择权值最小并且不构成环的边，重复 n-1 次。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/leecode-O-n-time-complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/leecode-O-n-time-complexity/" itemprop="url">leecode O(n) time complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-11T19:36:14-08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/11/leecode-O-n-time-complexity/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/11/leecode-O-n-time-complexity/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>O(n) 是什么<ul>
<li>注意 n 是什么？图的节点？边？</li>
<li>扫一遍</li>
<li>两头扫</li>
<li>双重循环，但是内循环变量不减</li>
<li>单调性<ul>
<li>队列</li>
<li>堆栈</li>
</ul>
</li>
<li>组合数学<ul>
<li>下一个排列（上一个排列）</li>
<li>巧妙地证明</li>
<li>计数 != 枚举</li>
</ul>
</li>
<li>动态规划</li>
</ul>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-名人问题"><a href="#1-名人问题" class="headerlink" title="1. 名人问题"></a>1. 名人问题</h2><p>[题目]<br>有 n 个人他们之间认识与否用邻接矩阵表示（1 表示认识，0 表示不认识），并且A认识 B 并不意味着 B 认识 A。<br>名人定义为他不认识任何人且所有人都认识他的人。请求出所有名人。</p>
<p>[分析]<br>最多有几个名人？1 个！</p>
<p>O(n) 的方法：<br>对于两个人 i 和 j，如果 i 认识 j，则 i 显然不是名人，排除掉；<br>如果 i 不认识 j，则 j 显然不是名人，排除掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一：一头扫</span></span><br><span class="line"><span class="comment">// i &lt; j, [0...i-1]没有名人，[i...j-1] 没有名人</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现二：两头扫</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">	<span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">		++i;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		--j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;  <span class="comment">// i认识j或者j不认识i</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>
<h2 id="Trapping-in-Rain-Water-leetcode-0042"><a href="#Trapping-in-Rain-Water-leetcode-0042" class="headerlink" title="Trapping in Rain Water leetcode 0042"></a>Trapping in Rain Water leetcode 0042</h2><h2 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h2><p>[题目]<br>a[i] 表示横坐标为 i 出有一个高度为 a[i] 的竖线。把两个竖线当做一个容器左右边的高度，<br>横轴当做底，问哪两条线段组成的容器容量最大？</p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> n = height.size();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">    		best = max(best, min(height[i], height[j]) * (j - i));</span><br><span class="line">    		<span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">    			++i;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			--j;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大间隔问题"><a href="#最大间隔问题" class="headerlink" title="最大间隔问题"></a><strong>最大间隔问题</strong></h2><p>[题目]<br>给定数组 a，求下标对 i，j 满足 a[i]&lt;=a[j]，并且 j-i 最大。</p>
<p>[分析]</p>
<ul>
<li>假设目前最优解是 d，对于 j，至少要检查 i = j - d - 1 才可能更优。</li>
<li>记录前缀最小值 p[x] = min{p[0…x]}</li>
<li>倒着循环 j，对于每个 j 看一下 p[j-d-1] 是否 &lt;= a[j]，用 p 引导。</li>
<li>如果前面都比 a[j] 大，则这个 j 得不到更优的解。</li>
</ul>
<p><mark>这一题我实在没有想到这个巧妙地思路，我始终局限在两个 pointer 指到元素上面。<br>但是它其实是有一个 “pointer” 是 d！参考下面的代码。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		p[i] = ((i ==<span class="number">0</span>) || (a[i] &lt; p[i<span class="number">-1</span>])) ? a[i] : p[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; best; --j)&#123;</span><br><span class="line">		<span class="keyword">while</span>((j &gt; best) &amp;&amp; (a[j] &gt;= p[j - best <span class="number">-1</span>]))&#123;</span><br><span class="line">			++best;</span><br><span class="line">		&#125;  <span class="comment">// 对于每一个 j, 内层循环都试图找到这个 j 所能允许的最大的 gap.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01-相等的串"><a href="#01-相等的串" class="headerlink" title="01 相等的串"></a>01 相等的串</h2><p>[题目]<br>给定一个 01 串，求它的一个最长的子串满足 0 和 1 的个数相等。</p>
<p>[分析]</p>
<ul>
<li><mark>把 0 看成 -1，1 当做 +1</mark>，还是使用“前缀和”的技巧<ul>
<li><font color="orange">这个把 0 看成 -1 的操作绝了！本来这一段区间内即使 0 1 的数量相等，区间和也有很多种数值可能，现在把 0 当成 -1 以后，这么多的可能都塌缩到一种可能: 0!!</font></li>
</ul>
</li>
<li>如果有两个前缀和相等，则这两个前缀和之间的子串满足 0，1 的个数相等。</li>
<li>需要对前缀和排序吗？那就是 O(nlogn) 的时间复杂度了</li>
<li>优化！不需要排序<ul>
<li>前缀和的范围是[-n…n]，我们加上 n 之后就是 [0…2n]，只要记录<mark>第一次出现</mark>的位置。</li>
<li>本质！用 hash 代替排序。当 hash 值是比较小的非负整数时，可以用做数组下标。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; have((n &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 擦，括号里面就是 2n+1 的意思。</span></span><br><span class="line">	have[n] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = n;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		sum += (s[i] == <span class="string">'0'</span>) ? (<span class="number">-1</span>) : (+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(have[sum] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			best = max(best, i - have[sum] + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			have[sum] = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制矩阵中-1-的个数"><a href="#二进制矩阵中-1-的个数" class="headerlink" title="二进制矩阵中 1 的个数"></a>二进制矩阵中 1 的个数</h2><p>[题目]<br>给定 n * n 的 01 方阵，每一行都是降序的（即先连续的一段 1，再连续的一段 0），求 1 最多的那行中 1 的个数？</p>
<p>[分析]</p>
<ul>
<li>思路一：数出每一行的 1 … 复杂度O(n^2)</li>
<li>思路二：二分法找到每一行 0 和 1 的分界线，复杂度 O(nlogn)</li>
<li>思路三：从左上角开始，如果某个位置是 1，就向右走，如果是 0 则向下走！（我们只需要找到比本行更多的 1 才有意义！）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (best &lt; n) &amp;&amp; (i &lt; n); ++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>((best &lt; n) &amp;&amp; (a[i][best] == <span class="string">'1'</span>))&#123;</span><br><span class="line">			++best;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><ul>
<li>最大子数组和</li>
<li>KMP</li>
<li>Manacher</li>
<li>最大直方图（单调堆栈）</li>
<li>滑动窗口最大值（单调队列）</li>
<li>快排 partition 过程</li>
<li>杨氏矩阵查找<ul>
<li>荷兰国旗问题</li>
<li>First Missing Positive</li>
</ul>
</li>
<li>排列组合相关<ul>
<li>Next/Previous permutation</li>
</ul>
</li>
<li>树相关<ul>
<li>二叉树遍历，（最大、最小）深度，同构，镜像判断，平衡判断</li>
</ul>
</li>
</ul>
<h2 id="下一个排列-leetcode-0031-STL亦如此实现"><a href="#下一个排列-leetcode-0031-STL亦如此实现" class="headerlink" title="下一个排列 leetcode 0031 (STL亦如此实现)"></a>下一个排列 leetcode 0031 (STL亦如此实现)</h2><p>[题目]<br>Next Permutation 找到字典序里的下一个排列。12345 的下一个是 12354，而54321 的下一个是 12345.</p>
<p>[分析]</p>
<ul>
<li>a[0], a[1], …, a[n-1], 下一个排列是字典序比它大，最小的</li>
<li>找到尽可能大的 m, b[0] = a[0], b[1] = a[1], …, b[m-1] = a[m-1], 而 b[m] &gt; a[m], b[m+1 … n-1] 是按照升序排列的。</li>
</ul>
<p>[形象点的分析]</p>
<ul>
<li>目前的排列是: (A)a<a href="B">x</a></li>
<li>下一个排列是: (A)a<a href="B&#39;">y</a><ul>
<li>A 是相同的，A 尽可能长</li>
<li>a[y] &gt; a[x]</li>
<li>B’ 几乎是 B 里面的数排好顺序的结果</li>
</ul>
</li>
<li>如何确定 x？<ul>
<li>一个位置只要右边有数比它大就是候选的 x</li>
<li>a[x] 是最后一个这样的数（最右边）<ul>
<li>a[x] 右边的数，没个数的右边没有比它大的</li>
<li>所以 a[x] 右边的数是按照降序（不升序）排列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[算法 (二找、一交换、一翻转)]</p>
<ul>
<li>找到最后一个严格升序的首位 (a[i] &lt; a[i+1])，定义为 x<ul>
<li>(A) = a[0…x-1], (B) = a[x+1…n-1]</li>
</ul>
</li>
<li>找到 y&gt;x, a[y] &gt; a[x], 且 a[y] 最小<ul>
<li>一定存在，因为 x+1 就是一个候选</li>
<li>a[x] 后面的数都是降序，所以从后往前找到第一个大于 a[x] 的位置就是 y 了</li>
<li>可以二分找到 y，但不影响总体时间复杂度</li>
</ul>
</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转<ul>
<li>交换后 a[x+1…n-1] 仍然是降序（不升）</li>
<li>逆转等于排序</li>
</ul>
</li>
</ul>
<p><mark>这个解法要熟记！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(x = n<span class="number">-2</span>; (x&gt;=<span class="number">0</span>) &amp;&amp; (nums[x] &gt;= nums[x+<span class="number">1</span>]); --x)</span><br><span class="line">	;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		reverse(nums.begin(), nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(y = n - <span class="number">1</span>; nums[y] &lt;= nums[x]; --y)</span><br><span class="line">	;</span><br><span class="line">	swap(nums[x], nums[y]);</span><br><span class="line">	reverse(nums.begin() + x + <span class="number">1</span>, nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考题：上一个排列？"><a href="#思考题：上一个排列？" class="headerlink" title="思考题：上一个排列？"></a>思考题：上一个排列？</h3><p>类似的思路</p>
<ul>
<li>找到最后一个严格降序的首位(a[i] &gt; a[i+1])，定义为 x</li>
<li>找到 y&gt;x, a[y] &lt; a[x], 且 a[y] 最大</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转</li>
</ul>
<h2 id="均分01"><a href="#均分01" class="headerlink" title="均分01"></a>均分01</h2><p>[题目]<br>给定一个01串，签好包含 2n 个 0 和 2n 个 1，你可以把它切成若干段，再把它们任意拼接，要求拼接出两部分，每部分恰好包含 n 个 0，n 个 1，如何使得切得段数最少？</p>
<p>[示例]<br>举例一：0101，从中间切一刀形成(01)(01)，分别作为两部分<br>举例二：0011，切成 3 段 (0)(01)(1), 把中间 (01) 单独作为一部分，生育的 (0)(1) 作为另外一部分。</p>
<p>[思路]<br>这一题其实都不算是算法题我觉得。<br>先考虑前面 2n 个数字，如果里面 1 的个数超过 0，那么把这个长度为 2n 的窗口向右挪，中间肯定在某个位置使得 1 和 0 的个数相等？为啥呢？因为不可能在所有的位置都有 2n 窗口内 1 的个数大于 0 的个数，这与题目的条件 4n 窗口内有 2n 个 1 和 2n 个 0 相冲突！</p>
<p>[答案]<br>如果最前面 2n 个数满足 1 和 0 个数相等，那么就分成两段就可以了；<br>如果不是，那么就分成三部分。</p>
<h2 id="X-的个数"><a href="#X-的个数" class="headerlink" title="X 的个数"></a>X 的个数</h2><p>[题目]<br>给定一个长度为 n 的整数数组 a，下标从 0 开始，再给定一个元素 X，求一个位置 m，满足 0&lt;=m&lt;=n，且 a[0…m-1] 中 X 的个数（如果m=0表示空数组）和 a[m…n-1] 中非 X 的个数（如果 m==n，表示空数组）相等。</p>
<p>[分析]</p>
<ul>
<li>假设 a 中一共有 x 个 X，给定 m，假设 a[0…m-1] 中有 y 个 X，则 a[m…n-1] 中非 X 的个数是 (n-m)-(x-y) = n-m-x+y == y</li>
<li>化简可得 m = n - x</li>
<li>解存在且唯一！</li>
</ul>
<p>[解法]</p>
<ul>
<li>直接统计下有多少个 X 就可以了</li>
<li>O(n) 时间，O(1) 空间</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>[题目]<br>10个硬币，有四个是正面的，在不开灯的情况下，把他们分成两组，如果做可以使得正面的个数相等？（可以手动改变某些硬币的正反面）</p>
<p>[答案]<br>分成两组，一组 6 个，一组 4 个，然后把 4 个的那组所有硬币都翻个面。</p>
<h2 id="PAT-的个数"><a href="#PAT-的个数" class="headerlink" title="PAT 的个数"></a>PAT 的个数</h2><p>[题目]<br>给定一个只包含 P, A, T 的串，求一共出现多少个 “PAT” 子序列？</p>
<p>[分析：计数和枚举不同]</p>
<ul>
<li>p, pa, pat 表示之前出现的 “P”, “PA”, “PAT” 的个数</li>
<li>s[i] == “P”, ++p</li>
<li>s[i] == “A”, pa += p</li>
<li>s[i] == ‘T’, pat += pa</li>
<li>时间复杂度 O(n)，空间复杂度 O(1)</li>
</ul>
<h3 id="思考题-distinct-subsequences-leetcode-115"><a href="#思考题-distinct-subsequences-leetcode-115" class="headerlink" title="思考题 distinct subsequences leetcode 115"></a>思考题 distinct subsequences leetcode 115</h3><p>[题目]<br>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意内层的 for 循环是倒着来算的，这样子可以排除掉出现相同字母的情形。</span></span><br><span class="line"><span class="comment">比如 S = "rabbbit", T = "rabbit"</span></span><br><span class="line"><span class="comment">T 的第三第四个位置都是 'b'</span></span><br><span class="line"><span class="comment">如果你从左往右看 T, 第三个 'b' 那里你把 dp[2]更新了，</span></span><br><span class="line"><span class="comment">这会导致第四个 'b' 那里你用 dp[2] 来计算 dp[3] 出现错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(t.size(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = t.size()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                    dp[j] += j ? dp[j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小平均值子数组-codility"><a href="#最小平均值子数组-codility" class="headerlink" title="最小平均值子数组 codility"></a>最小平均值子数组 codility</h2><p>[题目]<br>给定一个数组，求一个至少包含两个元素的子数组，满足平均值最小。<br>输出子数组的起点，多个的时候输出最小的。</p>
<p>[分析]</p>
<ul>
<li>如果最优解长度为偶数，把它拆成长度为 2 的若干段</li>
<li>如果最优解长度为奇数 (&gt;2), 我们把它柴承长度为 2 的若干段，和一段长度为 3 的段</li>
<li>最优解中每一段的平均值都相等<ul>
<li>如果某一段平均值比最优解小，至少有一段平均值比最优解大，矛盾。</li>
</ul>
</li>
<li>！！！ 一次，只需要考虑长度为 2 和 3 的段计算就可以了。</li>
</ul>
<h2 id="环形最大子数组和-from-itint5-com-Q9"><a href="#环形最大子数组和-from-itint5-com-Q9" class="headerlink" title="环形最大子数组和 from itint5.com Q9"></a>环形最大子数组和 from itint5.com Q9</h2><p>[题目]<br>给定一个数组，是环形的，最后一个元素和第一个元素相接，求最大子数组和。</p>
<p>[分析]</p>
<ul>
<li>环形最大子数组和<ul>
<li>普通最大子数组和，例如 1 2 -4 <mark> 5 6 -9 </mark></li>
<li>开头和结尾的一部分，例如 <mark>1 2 </mark> -4 -5 -6 <mark> 9 </mark></li>
</ul>
</li>
<li>算法<ul>
<li>求普通最大子数组的和</li>
<li>总和减去普通的最小子数组和<ul>
<li>可以考虑对原始数组取相反数，调用最大子数组和模块。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="允许交换一次的最大子数组和"><a href="#允许交换一次的最大子数组和" class="headerlink" title="允许交换一次的最大子数组和"></a>允许交换一次的最大子数组和</h2><p><mark> 这一题非常难！要好好琢磨其 DP 思路 </mark></p>
<p>[题目]<br>给定一个数组，在允许交换两个数的前提下（只允许交换一次，可以不换），求最大子数组的和。</p>
<p>[分析]</p>
<ul>
<li>定义 f[i] 为两部分之和<ul>
<li>以 a[i] 结尾的最大子数组的和（可以为空）</li>
<li>与任意 a[0…i] 里面单独一个元素</li>
<li>以上两部分没有交集</li>
<li>递推式 f[i] = max(f[i-1] + a[i], max(a[0…i]))</li>
</ul>
</li>
<li>定义 g[i]<ul>
<li>以 a[i] 开头的最大子数组和（非空）</li>
<li>递推式 g[i] = max(g[i+1], 0) + a[i]</li>
</ul>
</li>
<li>如果 a[i] 和 a[j] 交换 (j &lt; i), 原来包含 a[i] 的最大子数组和变为<ul>
<li>g[i] - a[i] + f[i-1]</li>
<li>（即要换掉的元素在 f[i-1] 里, <mark>单独存在的那一个</mark>）</li>
</ul>
</li>
<li>如果不交换，答案就是 max{g[i]}</li>
<li>我们只考虑 j &lt; i 的情况，对于 j &gt; i, 把 a 翻转再做一次就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f, g;</span><br><span class="line">	f.resize(n);</span><br><span class="line">	f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> now = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		now = max(now, a[i]);</span><br><span class="line">		f[i] = max(a[i] + f[i<span class="number">-1</span>], now);</span><br><span class="line">	&#125;</span><br><span class="line">	g.resize(n);</span><br><span class="line">	g[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> ans = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		g[i] = max(g[i+<span class="number">1</span>], <span class="number">0</span>) + a[i];</span><br><span class="line">		answer = max(answer, g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		answer = max(answer, g[i] - a[i] + f[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> answer = help(A);</span><br><span class="line">	reverse(A.begin(), A.end());</span><br><span class="line">	answer = max(answer, help(A));</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>计数 != 枚举</li>
<li>没有讲到的问题<ul>
<li>O(n^3) 优化到 O(n^2)</li>
<li>序列相关的问题<ul>
<li>给定一个 1-n 的排列，每次只能把一个数放到序列开头，至少几次能排好循序？</li>
<li>给定一个 1-n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序？</li>
</ul>
</li>
<li>更多前缀、后缀的利用</li>
</ul>
</li>
</ul>
<h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><h3 id="leetcode-53-最大连续子数组和"><a href="#leetcode-53-最大连续子数组和" class="headerlink" title="leetcode 53 最大连续子数组和"></a>leetcode 53 最大连续子数组和</h3><p>[题目]<br>给定一个数组，求最大的连续子数组和。</p>
<p>[分析]</p>
<ul>
<li>方法一 记录最小前缀和（两个前缀和的差就是一段连续的子数组）</li>
<li>方法二 动态规划，记录以每个位置结束的最大子数组的和。</li>
</ul>
<h3 id="leetcode-152-求最大的连续子数组乘积"><a href="#leetcode-152-求最大的连续子数组乘积" class="headerlink" title="leetcode 152 求最大的连续子数组乘积"></a>leetcode 152 求最大的连续子数组乘积</h3><p>[分析]</p>
<ul>
<li>首先要考虑一下是否会溢出</li>
<li>到当前项乘积最大要考虑之前乘积的绝对值，因此要记录<ul>
<li>之前最小乘积</li>
<li>之前最大乘积</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">    	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">int</span> mini = nums[<span class="number">0</span>], maxi = nums[<span class="number">0</span>], ansmin = nums[<span class="number">0</span>], ansmax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> tempmin = min(nums[i], min(mini * nums[i], maxi * nums[i]));</span><br><span class="line">    		<span class="keyword">int</span> tempmax = max(nums[i], max(mini * nums[i], maxi * nums[i]));</span><br><span class="line">    		mini = tempmin;</span><br><span class="line">    		maxi = tempmax;</span><br><span class="line">    		ansmin = min(mini, ansmin);</span><br><span class="line">    		ansmax = max(maxi, ansmax);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ansmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>[题目]<br>一个数组，比如 {1,2,3,4,5} 循环移动一位就是 {2,3,4,5,1}，再移动一位就是 {3,4,5,1,2}.</p>
<p>[分析]</p>
<ul>
<li>长度为 n，把它移动 m 位，和移动 m % n 位是一样的。</li>
<li>翻转前 m 位</li>
<li>翻转后 (n-m) 位</li>
<li>总体再翻转</li>
<li>翻转可以O(n)做到：<ul>
<li>for(int i = from, j = to; i &lt; j; swap(a[i++], a[j–]));</li>
</ul>
</li>
</ul>
<h3 id="单词翻转"><a href="#单词翻转" class="headerlink" title="单词翻转"></a>单词翻转</h3><h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><h2 id="快排-partition"><a href="#快排-partition" class="headerlink" title="快排 partition"></a>快排 partition</h2><ul>
<li>荷兰国旗问题 leetcode 75</li>
<li>奇偶数分开，正负数分开</li>
<li>01 交换排序</li>
<li>交换星号</li>
<li>第一个缺失的整数 leetcode 41</li>
<li>中位数、第k大（小）的书、最大（小）的k个数<ul>
<li>找第 k 大的数关键<ul>
<li>5 数取中做 pivot (3 数取中会退化)</li>
<li>Partition 过程分三段（分两段有相同数会退化）<ul>
<li>算法导论“偷懒”了（它假设了没有相同的数做了分析）</li>
</ul>
</li>
</ul>
</li>
<li>找到最小的 k 个数<ul>
<li>基于 partition 的方法找到的数是无序的</li>
<li>如果要有序建议用堆 O(nlogk)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>[思路一]</p>
<ul>
<li>直接两次快排</li>
<li>第一次把 0 和非 0 分开</li>
<li>第二次把 1 和 2 分开</li>
</ul>
<p>[思路2]<br>循环不变式的应用</p>
<ul>
<li>三个变量 begin, cur, end 把数组分成四个区域<ul>
<li>[0, begin): 所有数据都是 0</li>
<li>[begin, current): 所有数据都是 1</li>
<li>(end, size-1]: 所有数据都是 2</li>
<li>[current, end): 未知</li>
</ul>
</li>
<li>循环不变式<ul>
<li>初值 begin=current=0, end=size-1, 前三个区间都为空集，满足以上四个条件</li>
<li>遍历 current, 根据arr[current] 的值作相应处理，直到区间 [current, end) 为空，即 current==end 时退出。</li>
<li>代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Holland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="keyword">int</span>(arr.size()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(current &lt;= end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[current] == <span class="number">2</span>)&#123;</span><br><span class="line">			swap(arr[end], arr[current]);</span><br><span class="line">			end--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[current] == <span class="number">1</span>)&#123;</span><br><span class="line">			current++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;                  <span class="comment">// if(a[current] == 0)</span></span><br><span class="line">			<span class="keyword">if</span>(current != begin)&#123;</span><br><span class="line">				swap(arr[current], arr[begin]);</span><br><span class="line">			&#125;</span><br><span class="line">			begin++;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>[荷兰国旗与快排的优化]</mark></p>
<p>传统的快排每次选取 pivot，然后把元素分成 &lt;=pivot 和 &gt;pivot 两部分。<br>在有相同元素的时候，每次分割递归的时候还是把 pivot 左边的，pivot 右边的递归。</p>
<p>而使用荷兰国旗思想，则可以优化有大量重复数字的情况。</p>
<p>假设选取的 pivot 呢，有很多相同元素，荷兰国旗的思想就是把元素分成三段！<br>第一段小于 pivot, 第二段等于 pivot, 第三段大于 pivot.</p>
<p>然后递归的时候，中间等于 pivot 的那一段就不需要在处理了！！！<br>因此有很多优化。</p>
<p><mark>快排的最坏情况</mark></p>
<ol>
<li>本来已经是顺序排好了</li>
<li>本来已经是逆序排好了</li>
<li>所有元素都一样！(这个可以用荷兰国旗思想来优化！)</li>
</ol>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><ul>
<li>找出出现次数超过一半的数</li>
<li>推广：找出出现次数大于 1/k 的数，用 (k-1) 个 map，复杂度 O(n * k)，注意 k 是常数的时候就是 O(n).</li>
</ul>
<h2 id="单调堆栈"><a href="#单调堆栈" class="headerlink" title="单调堆栈"></a>单调堆栈</h2><p>[题目]<br>最大直方图</p>
<p>[思路]</p>
<ul>
<li>入栈时左边界确定</li>
<li>出栈时右边界确定</li>
<li>每块只出入栈一次<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="滑动窗口最值-栈和队列-例6"><a href="#滑动窗口最值-栈和队列-例6" class="headerlink" title="滑动窗口最值 (栈和队列 例6)"></a>滑动窗口最值 (栈和队列 例6)</h3><h3 id="codility-题目"><a href="#codility-题目" class="headerlink" title="codility 题目"></a>codility 题目</h3><p>[题目]<br>给定一个数组 A 和整数 K，问有多少对下标 i&lt;=j 满足 max(A[i…j]) - min(A[i…j]) &lt;= K</p>
<p>[分析]</p>
<ul>
<li>如果(i,j)满足条件，则(i+1,j), (i+2,j)…都满足条件。</li>
<li>对每个 i, 找到第一个不满足条件的 j</li>
<li>如何求 [i…j] 的最大最小值<ul>
<li>单调队列</li>
<li>滑动窗口（两个边界都只增大不减）<ul>
<li>滑动出去的不会进来</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qmin, qmax;</span><br><span class="line">	<span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; A.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &lt; A.size())&#123;</span><br><span class="line">			<span class="keyword">while</span>((!qmin.empty()) &amp;&amp; (A[qmin.back()] &gt;= A[j]))&#123;</span><br><span class="line">				qmin.pop_back();</span><br><span class="line">			&#125; <span class="comment">// qmin 里面的元素是单调递增的！</span></span><br><span class="line">			qmin.push_back(j);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>((!qmax.empty()) &amp;&amp; (A[qmax.back()] &lt;= A[j]))&#123;</span><br><span class="line">				qmax.pop_back();</span><br><span class="line">			&#125; <span class="comment">// qmax 里面的元素是单调递减的！</span></span><br><span class="line">			qmax.push_back(j);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(A[qmax.front()] - A[qmin.front()] &lt;= K)&#123;</span><br><span class="line">				++j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  <span class="comment">// 这个 while 循环找到最远的 j。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(qmin.front() == i)&#123;</span><br><span class="line">			qmin.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(qmax.front() == i)&#123;</span><br><span class="line">			qmax.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		answer += j - i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><ul>
<li>树的高度</li>
<li>二叉树对称判断</li>
<li>二叉树平衡判断</li>
<li>二叉树的最小深度</li>
<li>指定和的路径</li>
<li>二叉树双向链表转换</li>
<li>前中后序遍历</li>
</ul>
<h3 id="距离最远的点"><a href="#距离最远的点" class="headerlink" title="距离最远的点"></a>距离最远的点</h3><p>[题目]<br>给定一个无根的树（无向<mark>无环图</mark>），求距离最远的两个点（树的直径）。</p>
<p>[易忽略]</p>
<ul>
<li>对于一个自由树的直径，《算法导论》上的说明是“树中所有最短路径的最大值即为树的直径。”</li>
<li>记住，“无环图”这个概念很重要。</li>
<li>最笨的方法<ul>
<li>就是对每一个节点进行 BFS, 找到最远的点。这个方法时间复杂度是 O(n^2).</li>
</ul>
</li>
<li>简单巧妙的贪心<ul>
<li>以任意一点为根、找到距离它最远的节点 x</li>
<li>以 x 为根找到距离 x 最远的点 y</li>
<li>(x, y) 就是一条直径</li>
</ul>
</li>
<li>如何找最远的点？dfs 求深度</li>
<li>思考：算法证明？</li>
</ul>
<p>[证明]<br>但是在证明定义之前，先证明一个引理：</p>
<p>引理：在一个连通无向无环图中，x、y 和 z 是三个不同的结点。当 x 到 y 的最短路与 y 到 z 的最短路不重合时，x 到 z 的最短路就是这两条最短路的拼接。</p>
<p>证明：假设 x 到 z 有一条不经过 y 的更短路δ(x,z)，则该路与δ(x,y)、δ(y,z)形成一个环，与前提矛盾。</p>
<p>定理：在一个连通无向无环图中，以任意结点出发所能到达的最远结点，一定是该图直径的端点之一。</p>
<p>证明：假设这条直径是δ(s,t)。分两种情况：</p>
<ul>
<li>当出发结点 y 在δ(s,t)时，假设到达的最远结点 z 不是 s,t 中的任一个。这时将δ(y,z)与不与之重合的δ(y,s)拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的直径，与前提矛盾。</li>
<li>当出发结点 y 不在δ(s,t)上时，分两种情况：<ul>
<li>1). 当 y 到达的最远结点 z 横穿δ(s,t)时，记与之相交的结点为 x。此时有δ(y,z)=δ(y,x)+δ(x,z)。而此时δ(y,z)&gt;δ(y,t)，故可得δ(x,z)&gt;δ(x,t)。由1的结论可知该假设不成立。<br>2). 当 y 到达的最远结点 z 与δ(s,t)不相交时，记 y 到 t 的最短路首先与δ(s,t)相交的结点是 x。由假设δ(y,z)&gt;δ(y,x)+δ(x,t)。而δ(y,z)+δ(y,x)+δ(x,s)又可以形成δ(z,s)，而δ(z,s)&gt;δ(x,s)+δ(x,t)+2δ(y,x)=δ(s,t)+2δ(y,x)，显然与题意矛盾。</li>
</ul>
</li>
</ul>
<p>因此定理成立。</p>
<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><p>[题目]<br>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two end nodes</p>
<p>[分析]<br>The diameter of a tree T is the largest of the following quantities:</p>
<ul>
<li>the diameter of T’s left subtree</li>
<li>the diameter of T’s right subtree</li>
<li>the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xz注：这个代码是用 C 实现的，函数的调用需要记录两个变量，</span></span><br><span class="line"><span class="comment">tree height &amp; tree diameter，它这里采用的是通过传递</span></span><br><span class="line"><span class="comment">指针过去来计算得到 height, 然后函数返回的是 tree diameter.</span></span><br><span class="line"><span class="comment">如果使用 C++ 的话，可以让函数返回 vector&lt;int&gt; = &#123;tree_height, tree_diameter&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The second parameter is to store the height of tree. </span></span><br><span class="line"><span class="comment">   Initially, we need to pass a pointer to a location with value </span></span><br><span class="line"><span class="comment">   as 0. So, function should be used as follows: </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   int height = 0; </span></span><br><span class="line"><span class="comment">   struct node *root = SomeFunctionToMakeTree(); </span></span><br><span class="line"><span class="comment">   int diameter = diameterOpt(root, &amp;height); */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOpt</span><span class="params">(struct node *root, <span class="keyword">int</span>* height)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* lh --&gt; Height of left subtree </span></span><br><span class="line"><span class="comment">     rh --&gt; Height of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* ldiameter  --&gt; diameter of left subtree </span></span><br><span class="line"><span class="comment">     rdiameter  --&gt; Diameter of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> ldiameter = <span class="number">0</span>, rdiameter = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    *height = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* diameter is also 0 */</span></span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Get the heights of left and right subtrees in lh and rh </span></span><br><span class="line"><span class="comment">    And store the returned values in ldiameter and ldiameter */</span></span><br><span class="line">  ldiameter = diameterOpt(root-&gt;left, &amp;lh); </span><br><span class="line">  rdiameter = diameterOpt(root-&gt;right, &amp;rh); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Height of current node is max of heights of left and </span></span><br><span class="line"><span class="comment">     right subtrees plus 1*/</span></span><br><span class="line">  *height = max(lh, rh) + <span class="number">1</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> max(lh + rh + <span class="number">1</span>, max(ldiameter, rdiameter)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口相关"><a href="#滑动窗口相关" class="headerlink" title="滑动窗口相关"></a>滑动窗口相关</h2><h3 id="leetcode-209"><a href="#leetcode-209" class="headerlink" title="leetcode 209"></a>leetcode 209</h3><p>[题目]<br>给定一个数组，里面全是正整数，再给一个正整数 s, 求数组里面最少多少个连续的数，满足总和不小于 s.</p>
<p>[分析]</p>
<ul>
<li>核心：大窗口不满足条件，它的任意子窗口也不满足条件。</li>
<li>窗口 [i…j]<ul>
<li>过小，++j</li>
<li>过大, ++i</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">    	<span class="keyword">int</span> answer = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>; j &lt; n; )&#123;</span><br><span class="line">    		<span class="keyword">while</span>((sum &lt; s) &amp;&amp; (j &lt; n))&#123;</span><br><span class="line">    			sum += nums[j++];</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">    			<span class="keyword">for</span>(; sum &gt;= s; sum -= nums[i++])</span><br><span class="line">    			;</span><br><span class="line">    			answer = min(answer, j - i + <span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (answer &gt;= n) ? <span class="number">0</span> : answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子串变位词"><a href="#子串变位词" class="headerlink" title="子串变位词"></a>子串变位词</h3><p>easy TODO</p>
<h3 id="leetcode-76-最短子串包含全部子母"><a href="#leetcode-76-最短子串包含全部子母" class="headerlink" title="leetcode 76 最短子串包含全部子母"></a>leetcode 76 最短子串包含全部子母</h3><p>easy TODO</p>
<h3 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3 无重复字符的最长子串"></a>leetcode 3 无重复字符的最长子串</h3><p>easy TODO</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>长度</li>
<li>（K 个一组）翻转 leetcode 206, 92, 25</li>
<li>插入 leetcode 147</li>
<li>删除 leetcode 203, 82, 83</li>
<li>复制 leetcode 138</li>
<li>求交 leetcode 160</li>
<li>找环 leetcode 141, 142</li>
<li>（倒数）第 k 个元素 leetcode 19</li>
<li>链表判断是否回文</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2-SUM"></a>2-SUM</h3><p>使用hash easy</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>[题目]<br>给定一个 1-n 的排列，每次只能把一个数放到序列末尾，至少几次能排好顺序。</p>
<p>[分析]</p>
<ul>
<li>需要移动 1 吗？不，其他都排好了，1 自然就好了。</li>
<li>如果要移动 x，则我们必须把 (x+1), (x+2), …, n 都移动了</li>
<li>从 1 到 (x-1) 是有序的<ul>
<li>x 有多大？</li>
</ul>
</li>
</ul>
<font color="red">注意这一题跟下面两个题目不一样的地方是：这一题只能把数字移动到末尾。因此我们必须找从数字 1 开始的子序列，看看能达到多大。<br><br>假设可以达到 x，那么说明 x+1, x+2, …, n 都在 x 的前面出现了，那么为了让数组有序，需要依次把 x+1, x+2, …, n 放到数组最后。<br></font>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size(), want = <span class="number">1</span>;  <span class="comment">// 从 1 开始的子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a[i] == want)&#123;  <span class="comment">// 每次找到 want 以后，就加 1.</span></span><br><span class="line">    		++want;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;  <span class="comment">// 这个找的实际上是有多少个数字出现在了比它小的数字的前面。。。</span></span><br><span class="line">    <span class="comment">// want ... n must be moved</span></span><br><span class="line">    <span class="keyword">return</span> n - want + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组排序2"><a href="#数组排序2" class="headerlink" title="数组排序2"></a>数组排序2</h3><p>题目<br>给定一个 1 到 n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序。</p>
<p>分析</p>
<ul>
<li><font color="red">这一题跟上一题不一样，数字可以移动到开头，所以不需要限制从 1 开始找，只需要找到 y 到 x 最长的就可以。</font></li>
<li>把数字 1 到数字 y 移动到开头，把数字 x 到 数字 n 移动到末尾</li>
<li>[y+1…x-1] 必须按顺序出现</li>
<li>所以目的就是要找到最小的 y 和 最大的 x，这样子 移动的数字才最少。</li>
<li>dp[x] 表示从 x 开始在原数组中往后按顺序出现的最长长度<ul>
<li>即 x, x+1, …, x+dp[x]-1 按顺序出现</li>
<li>倒着循环 i, dp[a[i]] = dp[a[i]+1] + 1</li>
</ul>
</li>
</ul>
<font color="orange">我其实觉得很奇怪，这个 dp 序列在更新的时候，不是按照一定的顺序来逐个得到的。而是来回跳。。。（取决于数组 a 里面的数字从右往左出现的顺序）。</font>

<font color="red">想了一个多小时，从上一题的思路到这一题，终于想明白。<br>首先要清楚，之所以 for 循环里面 i 从大到小，意味着数组是从右往左扫。<br>这样子如果扫到了比如 a[5] = 8, 那么 dp[8] 就可以计算出来了。<br>往左走如果 a[4]=7，那么 dp[7] 就可以用 dp[8] 的结果加上 1 得到。<br>为啥呢？因为是从右往左扫的，后遇见 dp[7] 说明 7 比 8 晚遇见，7 在 8 的左边嘛！满足排序的顺序。</font>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size(), m = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 使用 1...n+1 注意下标范围</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		m = max(m, dp[a[i]] = dp[a[i]+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组排序3-NOIP，很难"><a href="#数组排序3-NOIP，很难" class="headerlink" title="数组排序3 NOIP，很难"></a>数组排序3 NOIP，很难</h3><p>[题目描述]<br>给定一个长度为N的数列Ai。<br>你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。<br>求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。</p>
<p>[输入格式]<br>第一行是一个正整数N。<br>第二行是N个正整数Ai。</p>
<p>[输出格式]<br>输出一个整数，表示最少需要的操作次数。</p>
<p>[样例输入]<br>5<br>6 3 7 8 6</p>
<p>[样例输出]<br>2</p>
<p>[题解]</p>
<font color="red">这一题跟上一题不一样的地方在于这一题的数字不一定是 1 到 n，并且数字还可以允许出现重复数字。</font>

<p>经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：</p>
<ul>
<li>子序列单调递增；</li>
<li>若子序列中最小数是L，最大数是R，则子序列必须包含[L+1,R−1]中的数列中的所有数。</li>
</ul>
<p>用单调队列求出满足这两个条件的子序列的最大长度，用n减去就是答案。<br>即这个子序列保持不动，其余数向前或后移动一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE], q[SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"change.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"change.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">		b[a[i]].push_back(i);</span><br><span class="line">		m = max(m, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		reverse(b[i].begin(), b[i].end());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].size(); j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = b[i][j];</span><br><span class="line">			<span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] &gt; k) &#123;</span><br><span class="line">				<span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = max(ans, r - l + <span class="number">2</span> + j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			q[++r] = b[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/排序算法总结/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-10T23:34:42-08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/10/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<h1 id="几个重要的排序法讲解"><a href="#几个重要的排序法讲解" class="headerlink" title="几个重要的排序法讲解"></a>几个重要的排序法讲解</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于<mark>排序效率在同为O(N * logN)的几种排序方法中效率较高</mark>，因此经常被采用，再加上快速排序思想<mark>分治法</mark>也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。</p>
<p>总的说来，要直接默写出快速排序还是有一定难度的，因为本人就自己的理解对快速排序作了下白话解释，希望对大家理解有帮助，达到快速排序，快速搞定.</p>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先从数列中取出一个数作为基准数。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p>对挖坑填数进行总结</p>
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
<p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
<p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
<h2 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h2><p><img src="http://bubkoo.qiniudn.com/shell-sort-animation.gif" alt=""></p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ol>
<p>算法思路：</p>
<ol>
<li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d2(d2 &lt; d1)</li>
<li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</li>
</ol>
<p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="http://bubkoo.qiniudn.com/shell-sort-step1.1.png" alt=""><br>然后分别对 4 个小组进行插入排序，排序后的结果为：</p>
<p>然后，取 d2 = 2，将原数组分为 2 小组，如下图：</p>
<p>然后分别对 2 个小组进行插入排序，排序后的结果为：</p>
<p>最后，取 d3 = 1，进行插入排序后得到最终结果：</p>
<h1 id="各种排序算法的C-代码"><a href="#各种排序算法的C-代码" class="headerlink" title="各种排序算法的C++代码"></a>各种排序算法的C++代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"><span class="comment">//                    Author: qianghaohao(Xqiang)</span></span><br><span class="line"><span class="comment">//                    Mail: qiang.timothy@qq.com</span></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  直接插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 stl 里面的函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = start; i != end; ++i)</span><br><span class="line">    <span class="built_in">std</span>::rotate(<span class="built_in">std</span>::upper_bound(start, i, *i), i, <span class="built_in">std</span>::next(i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  折半插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  二分法找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  希尔排序:</span></span><br><span class="line"><span class="comment">//  a:数组  d:分组间距 n:元素个数</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(2^1.5)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> d, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d; i &lt; n; i++) &#123;</span><br><span class="line">            key = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span>; j -= d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; a[j]) &#123;</span><br><span class="line">                    a[j+d] = a[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+d] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        d -= <span class="number">2</span>;   <span class="comment">//最终要保证d为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 选择排序 selectionSort</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">std</span>::min_element(a.begin() + i, a.end());  <span class="comment">//选最小值</span></span><br><span class="line">      swap(a[i], a[it - a.begin()]);  <span class="comment">//最小值和a[i]交换</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//// 快速排序</span></span><br><span class="line"><span class="comment">//// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//// 稳定性:不稳定</span></span><br><span class="line"><span class="comment">//void QuickSort(vector&lt;int&gt; &amp;a, int low, int high) &#123;</span></span><br><span class="line"><span class="comment">//    int i = low;</span></span><br><span class="line"><span class="comment">//    int j = high;</span></span><br><span class="line"><span class="comment">//    if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//        while (i &lt; j) &#123;   //i == j跳出循环</span></span><br><span class="line"><span class="comment">//            //支点为i</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //支点为j</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//       QuickSort(a, low, i-1);</span></span><br><span class="line"><span class="comment">//	   QuickSort(a, i+1, high);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 快速排序(改进版--避免了交换支点的开销)</span></span><br><span class="line"><span class="comment">/* 时间复杂度:平均是 O(nlogn)，最坏情况和插入排序相同，也是O(n^2)。</span></span><br><span class="line"><span class="comment">比如一个序列5,4,3,2,1，要排为1,2,3,4,5。</span></span><br><span class="line"><span class="comment">或者是序列1，2，3，4，5，虽然已经是排好顺序的了。</span></span><br><span class="line"><span class="comment">但是，按照快速排序方法，每次只会有一个数据进入正确顺序，</span></span><br><span class="line"><span class="comment">不能把数据分成大小相当的两份。</span></span><br><span class="line"><span class="comment">很明显，排序的过程就成了一个歪脖子树，树的深度为n，那时间复杂度就成了O(n^2)。</span></span><br><span class="line"><span class="comment">尽管如此，需要排序的情况几乎都是乱序的，自然性能就保证了。</span></span><br><span class="line"><span class="comment">据书上的测试图来看，在数据量小于20的时候，插入排序具有最好的性能。</span></span><br><span class="line"><span class="comment">当大于20时，快速排序具有最好的性能，归并(merge sort)和堆排序(heap sort)也望尘莫及，</span></span><br><span class="line"><span class="comment">尽管复杂度都为nlog2(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[i];  <span class="comment">//保存支点(最左边的数字)</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;   <span class="comment">//只可能在 i == j 时跳出循环，不会出现 i&gt;j</span></span><br><span class="line">            <span class="comment">//支点为i, 从右边开始找一个小于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pivot &lt;= a[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个数字填到 i 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//支点为j，再从左边开始找一个大于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个大于 pivot 的数字填到 j 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// while 里面的复杂度是 O(n)</span></span><br><span class="line">        <span class="comment">// 循环结束后，说明 i==j，此时左边的值都小于pivot，右边的值都大于pivot</span></span><br><span class="line">        <span class="comment">// 这个时候把 pivot 填写到 i==j 处</span></span><br><span class="line">        <span class="comment">// 之后对左右两边都分别递归做 quicksort</span></span><br><span class="line">       a[i] = pivot;  <span class="comment">//i==j时填入支点</span></span><br><span class="line">       QuickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">	   QuickSort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意，while 里面的复杂度固定是 O(n)，</span></span><br><span class="line"><span class="comment">因为每次比较都会把左指针右移一位或者右指针左移一位。</span></span><br><span class="line"><span class="comment">因此快速排序算法的关键就是减少 while 循环的次数。</span></span><br><span class="line"><span class="comment">那就必须使得每一次while 循环都能保证 pivot 跑到了中间位置。</span></span><br><span class="line"><span class="comment">这个数组被大致等分。</span></span><br><span class="line"><span class="comment">这样子整个算法复杂度就是经典的 divide and conqure 的复杂度 O(nlogn).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用这个代码，更有 C++ 范儿</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(FwdIt first, FwdIt last, Compare cmp = Compare&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> N = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> pivot = <span class="built_in">std</span>::next(first, N/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::nth_element(first, pivot, last, cmp);</span><br><span class="line">    quickSort(first, pivot, cmp);</span><br><span class="line">    quickSort(pivot, last, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  堆排 heapsort</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="comment">//  不适合在元素个数太少的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  调整堆为最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">//(n-1)/2:最后一个有孩子节点的编号</span></span><br><span class="line">        j = <span class="number">2</span>*i;  <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &#123;  <span class="comment">//左右孩子都有</span></span><br><span class="line">            <span class="keyword">if</span> (a[j+<span class="number">1</span>] &gt; a[j]) &#123;  <span class="comment">//选取左右孩子中较大的</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="comment">// 交换--较大的元素调整到根节点</span></span><br><span class="line">        <span class="comment">// 在此也可以用a[0]当作中间变量来交换</span></span><br><span class="line">        <span class="comment">// 相当于temp,因为a[0]在整个排序过程中</span></span><br><span class="line">        <span class="comment">// 没有使用</span></span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用AdjustHeap进行堆排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        AdjustHeap(a, n - i);</span><br><span class="line">        swap(a[<span class="number">1</span>], a[n<span class="number">-1</span>-i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(n)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src中low-mid 和 mid-high两部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid;  <span class="comment">//前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = mid + <span class="number">1</span>;  <span class="comment">//后半部分</span></span><br><span class="line">    <span class="keyword">int</span> n = high;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; m &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src[i] &lt; src[m]) &#123;</span><br><span class="line">            des[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            des[k++] = src[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  合并可能剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        des[k++] = src[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n) &#123;</span><br><span class="line">        des[k++] = src[m++];</span><br><span class="line">    &#125;</span><br><span class="line">    swap_ranges(src.begin() + low, src.begin() + high + <span class="number">1</span>, des.begin());  <span class="comment">//  合并后放回原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  temp:临时向量,保存合并后的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">      mid = first + ((last - first) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      MergeSort(a, first, mid, temp);</span><br><span class="line">      MergeSort(a, mid + <span class="number">1</span>, last, temp);</span><br><span class="line">      MergeArray(a, first, mid, last, temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="comment">//  测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(arr.size());  <span class="comment">//merge sort test</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; arr = &#123;0, 9, 8, 7, 6, 5, 4, 4, 4, 6, 6, 6&#125;;  //heap sort test</span></span><br><span class="line"><span class="comment">// InsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// BinaryInsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// ShellSort(arr, 5, arr.size());</span></span><br><span class="line"><span class="comment">// BubbleSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// SelectSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// QuickSort(arr, 0, arr.size()-1);</span></span><br><span class="line"><span class="comment">// HeapSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// copy(arr.begin() + 1, arr.end(), ostream_iterator&lt;int&gt;(cout, " "));  //heap sort test</span></span><br><span class="line">   MergeSort(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>, temp);</span><br><span class="line">   copy(arr.begin(), arr.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快排为什么快"><a href="#快排为什么快" class="headerlink" title="快排为什么快"></a>快排为什么快</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="external">http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/</a></li>
<li><a href="https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ" target="_blank" rel="external">https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ</a></li>
<li><a href="http://www.inference.org.uk/mackay/sorting/sorting.html" target="_blank" rel="external">http://www.inference.org.uk/mackay/sorting/sorting.html</a></li>
</ul>
<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>我们先来玩一个猜数字游戏：我心里默念一个1~64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1~32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。</p>
<p>我们再来回顾一下这个游戏所蕴含的本质：为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1~10之间，那么一旦发现不是在1~10之间的话就会剩下比N/2更多的可能性需要去考察了。</p>
<p>徐宥在讨论中提到，这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。</p>
<h2 id="称球"><a href="#称球" class="headerlink" title="称球"></a>称球</h2><p>12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。</p>
<p>这个问题是一道流传已久的智力题。网络上也有很多讲解，还有泛化到N个球的情况下的严格证明。也有零星的一些地方提到从信息论的角度来看待最优解法。本来我一直认为这道题目除了试错之外没有其它高妙的思路了，只能一个个方法试，并尽量从结果中寻找信息，然后看看哪种方案最少。</p>
<p>然而，实际上它的确有其它的思路，一个更本质的思路，而且根本用不着信息论这么拗口的知识。</p>
<p>我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。</p>
<p>如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。</p>
<p>为了更清楚的看待这个问题，我们不妨假设有6个球，来考虑一下3、3称和2、2称的区别：</p>
<p>在未称之前，一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后，不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）：1重、2重、3重、4轻、5轻、6轻。即这种称法能排除一半可能性。</p>
<p>现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！我们充分利用了“天平的结果状态可能有三种”这个条件来三等分所有可能性，而不是二等分。</p>
<p>说到这里，剩下的事情就实在很简单了：第二步称法，只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。</p>
<p>MacKay在他的书《Information Theory: Inference and Learning Algorithms》（作者开放免费电子书）里面4.1节专门讲了这个称球问题，还画了一张不错的图，我就照抄了：</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6qe45peoj20d40d875m.jpg" alt="23131201.jpg"></p>
<p>图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现a<b的话剩下的排列可能性就变成n! 2，如果发现a="">b也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持a<b的排列一共有n! 2个，支持a="">b的也是N!/2个，换言之，a<b的概率等于a>b的概率。</b的概率等于a></b的排列一共有n!></b的话剩下的排列可能性就变成n!></p>
<p>我们希望每次在比较a和b的时候，a<b和a>b的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。</b和a></p>
<p>一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。</p>
<h3 id="为什么堆排比快排慢"><a href="#为什么堆排比快排慢" class="headerlink" title="为什么堆排比快排慢"></a>为什么堆排比快排慢</h3><p>回顾一下堆排的过程：</p>
<ol>
<li><p>建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子… 以此类推）</p>
</li>
<li><p>将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。</p>
</li>
<li><p>重复第2步。</p>
</li>
</ol>
<p>这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到——原本剩下多少可能性还是剩下多少可能性。</p>
<p>在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p>
<p>这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。</p>
<p>MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了。具体参考这里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/leetcode-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/leetcode-tree/" itemprop="url">leetcode tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T20:20:05-08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/leetcode-tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h1><p>数的基本操作有</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	tagSTreeNode* left;</span><br><span class="line">	tagSTreeNode* right;</span><br><span class="line"></span><br><span class="line">	tagSTreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; STreeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STreeNode* m_root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(STreeNode* root)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> _Insert(STreeNode* root, <span class="keyword">int</span> val);    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">bool</span> _Insert2(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> _PreOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">void</span> _PreOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder3(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _PostOrder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于任何的树，算法复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Iterative 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* BinaryTree::Find(int v) const &#123;</span><br><span class="line">	if(!m_root) return nullptr;</span><br><span class="line"></span><br><span class="line">	TreeNode* res = m_root;</span><br><span class="line">	while(res)&#123;</span><br><span class="line">		if(v &lt; res-&gt;val)&#123;</span><br><span class="line">			res = res-&gt;left;</span><br><span class="line">		&#125; else if (v &gt; res-&gt;val) &#123;</span><br><span class="line">			res = res-&gt;right;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加一个节点"><a href="#添加一个节点" class="headerlink" title="添加一个节点"></a>添加一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Insert: BST的插入过程是一个递归过程，如果插入结点值比插入位置结点值小，则插入到左子树。反之则插入到右子树中。若插入位置结点的左子树或者右子树为空，则直接插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::Insert(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">return</span> _Insert(m_root, val);    <span class="comment">// 递归算法</span></span><br><span class="line">    <span class="comment">// return _Insert2(val);        // 非递归算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert(TreeNode* root, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    	root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// val 已经在 tree 里面了，插入失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert2(<span class="keyword">int</span> val)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root)&#123;</span><br><span class="line">		m_root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode* pnode = m_root, pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exhausively 找到待插入的位置(nullptr)</span></span><br><span class="line">    <span class="comment">// 此时 pnode 就是那个 nullptr, pcur 是此节点的父节点。</span></span><br><span class="line">	<span class="keyword">while</span>(pnode)&#123;</span><br><span class="line">		pcur = pnode;</span><br><span class="line">		<span class="keyword">if</span>(val &lt; pnode-&gt;val)&#123;</span><br><span class="line">			pnode = pnode-&gt;left;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pnode-&gt;val)&#123;</span><br><span class="line">			pnode = pnode-&gt;right;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  <span class="comment">// while 执行完后 pnode = nullptr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(val &lt; pcur-&gt;val)&#123;</span><br><span class="line">		pcur-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pcur-&gt;val) &#123;</span><br><span class="line">		pcur-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除一个节点</span><br><span class="line"></span><br><span class="line">思想就是：</span><br><span class="line">    递归寻找待删除的 node</span><br><span class="line">    找到以后</span><br><span class="line">    如果node 没有左子树，就把右子树提上来</span><br><span class="line">    如果node 没有右子树，就把左子树提上来</span><br><span class="line">    如果node 既有左子树，又有右子树，这个情况比较复杂</span><br><span class="line">        可以把左子树最大的数字拿过来，也可以把右子树最小的拿过来！</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    /<em><br>    方法一：左子树的最右边的 node 替换上来！！！
    </em>/</p>
<pre><code>TreeNode* deleteNode(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* maxNode = findMax(root-&gt;left);
        root-&gt;val = maxNode-&gt;val;
        root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
    }

    return root;
}

TreeNode* findMax(TreeNode* node){
    while(node-&gt;right)
        node = node-&gt;right;
    return node;
}


/* 
方法二：右子树的最左边的 node 替换上来
*/

TreeNode* deleteNode_way2(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* minNode = findMin(root-&gt;right);
        root-&gt;val = minNode-&gt;val;
        root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
    }

    return root;
}

TreeNode* findMin(TreeNode* node){
    while(node-&gt;left)
        node = node-&gt;left;
    return node;
}
*/
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的3种遍历(include iterative and recursive)</span><br><span class="line">1. 下面四种情况中，只有 2 和 3 能唯一决定一棵树。More generally, if a node has only one child, preorder and postorder do not contain enough information to determine whether that child is a left child or a right child.</span><br><span class="line">    1. preorder and postorder</span><br><span class="line">    2. inorder and postorder</span><br><span class="line">    3. preorder and inorder</span><br><span class="line">    4. level order and postorder</span><br><span class="line"></span><br><span class="line">技巧</span><br><span class="line">1. 二叉搜索树的 in-order traversal 输出一个 sorted array</span><br><span class="line">2. 二叉搜索树的 pre-order traversal 输出一个 array，这个 array 不是 sorted，但是它有个特点就是，右子树的值肯定都大于当前节点。(leetcode-255, verify pre-order sequence of Binary Search Tree)</span><br><span class="line"></span><br><span class="line">### 前序遍历</span><br><span class="line">```c++</span><br><span class="line">void BinaryTree::PreOrder(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	_PreOrder(m_root, visited);</span><br><span class="line">	//_PreOrder2(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归思想去做前序遍历</span><br><span class="line">void BinaryTree::_PreOrder(TreeNode* root, vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	if(!root) return;</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">	_PreOrder(root-&gt;left, visited);</span><br><span class="line">	_PreOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非递归方法的前序遍历</span><br><span class="line">void BinaryTree::_PreOrder2(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	if(!m_root) return;</span><br><span class="line"></span><br><span class="line">	stack&lt;TreeNode*&gt; s;</span><br><span class="line">	s.push(m_root);</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		pcur = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		visited.push_back(pcur-&gt;val);</span><br><span class="line">		if(pcur-&gt;right) s.push(pcur-&gt;right);</span><br><span class="line">		if(pcur-&gt;left) s.push(pcur-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二插查找树中序遍历的结果是升序的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::InOrder(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	_InOrder(m_root, visited);</span><br><span class="line">	<span class="comment">// _InOrder2(visited);</span></span><br><span class="line">	<span class="comment">// _InOrder3(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	_InOrder(root-&gt;left, visited);</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">	_InOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历</span></span><br><span class="line"><span class="comment">  注意，这一个不是按照上面的思路！每次拿出一个节点，把右放进去，再放自己，再放左。</span></span><br><span class="line"><span class="comment">  这样子需要额外记录一下节点是不是第一次访问的信息，写起来麻烦！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的解决思路是每次弹出一个节点，需要一直找左子树，</span></span><br><span class="line"><span class="comment">  走到头，把过程中碰到的节点都压入栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* pcur = m_root;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pcur || !s.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(pcur)&#123;        <span class="comment">// 找最左孩子</span></span><br><span class="line">			s.push(pcur);</span><br><span class="line">			pcur = pcur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">			pcur = s.top();    <span class="comment">// 访问左海子为空的节点</span></span><br><span class="line">		    s.pop();</span><br><span class="line">		    visited.push_back(pcur-&gt;val);</span><br><span class="line">		    pcur = pcur-&gt;right;    <span class="comment">// 转向右孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历 第二种思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放自己，再放左子树节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">	s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">		pcur = s.top().first;</span><br><span class="line">		times = s.top().second;</span><br><span class="line">		s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">		<span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			visited.push_back(pcur-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::PostOrder(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	_PostOrder(m_root, visited);</span><br><span class="line">	<span class="comment">// _PostOrder2(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_PostOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	_PostOrder(root-&gt;left, visited);</span><br><span class="line">	_PostOrder(root-&gt;right, visited);</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的后序遍历（与中序遍历的第三个方法代码区别就只有一行！）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放左子树节点，再放自己。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">	s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">		pcur = s.top().first;</span><br><span class="line">		times = s.top().second;</span><br><span class="line">		s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">		<span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">			s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			visited.push_back(pcur-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据前序中序，计算后续"><a href="#根据前序中序，计算后续" class="headerlink" title="根据前序中序，计算后续"></a>根据前序中序，计算后续</h3><p>[例如]<br>前序遍历: GDAFEMHZ<br>中序遍历: ADEFGHMZ</p>
<p>[思路]<br>两个步骤</p>
<ul>
<li>根据前序中序，构造二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InPre2Post</span><span class="params">(<span class="built_in">string</span> InOrder, <span class="built_in">string</span> PreOrder)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	<span class="keyword">int</span> n1 = InOrder.size();</span><br><span class="line">	<span class="keyword">int</span> n2 = PreOrder.size();</span><br><span class="line">	<span class="keyword">return</span> helper(InOrder, <span class="number">0</span>, n1 - <span class="number">1</span>, PreOrder, <span class="number">0</span>, n2 - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; InOrder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; PreOrder, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">    	res.push_back(InOrder[i]);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">while</span>(InOrder[k] != PreOrder[p])&#123;</span><br><span class="line">    	k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(InOrder, i, k<span class="number">-1</span>, PreOrder, p+<span class="number">1</span>, p+k-i, res);</span><br><span class="line">    helper(InOrder, k+<span class="number">1</span>, j, PreOrder, p+<span class="number">1</span>+k-i, q, res);</span><br><span class="line">    res.push_back(PreOrder[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据后续和中序，计算前序"><a href="#根据后续和中序，计算前序" class="headerlink" title="根据后续和中序，计算前序"></a>根据后续和中序，计算前序</h3><p>思路跟上面的 InPre2Post 基本一模一样。只不过：</p>
<ul>
<li>一个是 InOrder 的第一个元素作为根节点，</li>
<li>一个是 PostOrder 的末尾元素作为根节点。</li>
</ul>
<h2 id="复杂的树结构"><a href="#复杂的树结构" class="headerlink" title="复杂的树结构"></a>复杂的树结构</h2><ul>
<li>AVL 树：最早的平衡二叉树之一。应用相对其他数据结构比较少。Windows 对进程地址空间的管理使用到了 AVL 树。</li>
<li>红黑树：平衡二叉树，广泛用在 C++ 的 STL 中。如 map 和 set 都是用红黑树实现的。</li>
<li>B/B+ 树：用在磁盘文件组织，数据索引，和数据库索引。</li>
<li>Trie树（字典树）：用在统计和排序大量字符串，如自动机。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ol>
<li>Trie 树是一种哈希多叉树，又称字典树、单词查找树、或者前缀树，用于在大量字符串中快速检索。<ol>
<li>英文字母的字典树是一个 26 叉树。</li>
<li>数字的字典树是一个 10 叉树。</li>
</ol>
</li>
<li>典型应用<ol>
<li>统计和排序大量的字符串（但不仅限于字符串），经常被文字处理系统用于文本词频统计。</li>
<li>优点：利用字符串的公共前缀来节约存储空间，最大限度地减少无畏的字符串比较，查询效率比哈希表高。</li>
<li>缺点：如果存在大量字符串且这些字符串基本没有公共前缀，则相应的 Trie 树将非常消耗内存。</li>
</ol>
</li>
<li>基本性质<ol>
<li>根节点不包含字符。除根节点以外每一个节点都只包含一个字符。每个节点有 26 个指针指向子节点，同时自身还有个 bool 变量用来记录当前位置是否可以作为一个字符串的结束位置！</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该根节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
</li>
</ol>
<p>[题目]<br>给定一棵边的权值都是正整数的数，求某两个节点间的路径，使得该路径所包含的所有边权的异或值最大。</p>
<p>[例子]<br>中心点 B 有三个无向边指向 A, C, D，权值分别为 3, 4, 6<br>那么最优的答案就是路径 A-B-D，结果就是 3^4 = 7</p>
<p>[思路]</p>
<ol>
<li>思路一：朴素解法<ol>
<li>枚举所有节点对，求得所有路径异或权。时间复杂度O(n^2).</li>
</ol>
</li>
<li>思路二：<ol>
<li>问题分析<ol>
<li>异或的性质: a^b = (a^c)^(b^c)</li>
<li>因此可以选择一个点作为根节点建立一个数。然后任意两个节点之间的路径的权重的异或值，等于两个节点分别到跟节点的路径的权重异或值，这两个结果再异或一下就可以了。</li>
<li>从根节点到每个节点的异或值可以通过一次深度优先搜索解决，时间复杂度 O(n)</li>
<li><mark>问题转化为求 n 个数中异或值最大的两个数字。</mark></li>
</ol>
</li>
<li>利用 Trie 树的解法<ol>
<li>将数字看成二进制的 0/1 串，先将所有数字从最高位起放入一个二叉 Trie 数中 (这里如果数字的长度不一样，可以使用最大的数字的有效长度，比如最大的数字是 100，那么用 7 个 bit 位就可以表示了。其他的数字也都用 7 个 bit 位表示，不到的话左边补 0)</li>
<li>枚举每个数字 a，从最高位开始，寻找尽量与 a 对应位不同的数字；时间复杂度 O(len)</li>
<li>总体时间复杂度 O(N * len)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png" alt=""></p>
<p>[总结]</p>
<ol>
<li>Trie 树逻辑结构清晰简练，在海量数据中查找某数据，和海量数据规模无关，只和待查找数据长度本身有关，时间复杂度为 O(len)，常认为是 O(1)。<ol>
<li>可以看做是以数据元素为关键字的多 Hash 结构</li>
<li>海量数据的复杂度分析未考虑内存调度问题。</li>
</ol>
</li>
<li>双数组的存储结构比较难，增删困难。实践中，往往离线将海量数据建立 Trie 树双数组结构，少量删除时可以继续使用。若大量删除，则离线建立新的 Trie 树双数组结构，适时替换。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="0117 Populating Next Right Pointers in Each Node II"></a>0117 Populating Next Right Pointers in Each Node II</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一题实际上就是 level order traversal</span></span><br><span class="line"><span class="comment">使用 queue 就很好做了</span></span><br><span class="line"><span class="comment">但是 queue 的空间复杂度是 O(n)</span></span><br><span class="line"><span class="comment">而题目要求是 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决的关键就在于 每一个 node 里都有一个 next pointer</span></span><br><span class="line"><span class="comment">它的存在使得我们没有必要用queue 记录一层所有的 nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法关键：</span></span><br><span class="line"><span class="comment">    在扫描当前level的节点的 children nodes 时候</span></span><br><span class="line"><span class="comment">    更新这些 children nodes 的 next 指针</span></span><br><span class="line"><span class="comment">    这样子，在扫描下一个 level的时候，</span></span><br><span class="line"><span class="comment">    就可以使用这些 next pointer 了！！！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">二刷关键：</span></span><br><span class="line"><span class="comment">    引入一个 dummy node 可以使得代码更简洁！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode *cur; <span class="comment">// cur 指针扫描下一层 的节点;</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;                          <span class="comment">// root 指针用于扫描当前 level</span></span><br><span class="line">            cur = dummy;                        <span class="comment">// cur 指针扫描下一层 的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root) &#123;                       <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;left;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;right;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            root = dummy-&gt;next;                <span class="comment">// root 指针跳到下一层的 dummy 后面第一个有效节点</span></span><br><span class="line">            dummy-&gt;next = <span class="literal">nullptr</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 一刷的代码，不够简洁</span></span><br><span class="line"><span class="comment">    void connect(TreeLinkNode *root) &#123;</span></span><br><span class="line"><span class="comment">        TreeLinkNode *cur = root;         //current node of current level</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while (cur) &#123;</span></span><br><span class="line"><span class="comment">            TreeLinkNode *head = NULL;   // head of the next level</span></span><br><span class="line"><span class="comment">            TreeLinkNode *prev = NULL;   //the leading node on the next level</span></span><br><span class="line"><span class="comment">            while(cur) &#123;       //iterate on the current level</span></span><br><span class="line"><span class="comment">                if (cur-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev  = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                if (cur-&gt;right) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //move to next node           </span></span><br><span class="line"><span class="comment">                cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //move to next level</span></span><br><span class="line"><span class="comment">            cur = head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Find-k-th-smallest-number-of-binary-search-tree"><a href="#Find-k-th-smallest-number-of-binary-search-tree" class="headerlink" title="Find k-th smallest number of binary search tree"></a>Find k-th smallest number of binary search tree</h2><p>==适用于binary search tree 的递归的方法==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements;</span><br><span class="line">        recurse(root, elements, k);</span><br><span class="line">        <span class="keyword">return</span> elements[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; elements, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(elements.size() == k) <span class="keyword">return</span>;        <span class="comment">// 技巧，提前停止</span></span><br><span class="line">        recurse(root-&gt;left, elements, k);</span><br><span class="line">        elements.push_back(root-&gt;val);</span><br><span class="line">        recurse(root-&gt;right, elements, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>==适用于BST的非递归，使用stack的方法！！！（这个非常棒！！！）==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = mystack.top();</span><br><span class="line">                mystack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE BEGIN</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE END</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                </span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>==适用于任何的二叉树(binary tree, not necessarily BST)：先输出所有点(iterative 或 recursive)到array，然后找第 k 个==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 iterative 的方法，输出所有点到 array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    dq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">        TreeNode* temp = dq.front();</span><br><span class="line">        myvec.push_back(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left) dq.push_back(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right) dq.push_back(temp-&gt;right);</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.begin(), myvec.end());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 recursive 的方法，输出所有点到array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    helper(root, myvec);</span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.begin(), myvec.end());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.push_back(root-&gt;<span class="keyword">int</span>);</span><br><span class="line">    helper(root-&gt;left, vec);</span><br><span class="line">    helper(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树是最重要的数据结构，没有之一！</li>
<li>从根节点到叶子的过程，是逐渐细化精确的过程，所以，实践中往往作为海量数据索引。</li>
<li>数只是数据结构，非存储结构。实践中，可以使用数组来存储树。<ul>
<li>思考实例 Huffman 编码、堆排序、并查集等。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
