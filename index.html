<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="//index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zheng Xing">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com///"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-md/" itemprop="url">计算机网络.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-15T21:26:49-07:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-md/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/04/15/计算机网络-md/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93-md/" itemprop="url">操作系统总结.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-15T21:26:34-07:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93-md/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/04/15/操作系统总结-md/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h1><ol>
<li>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li>
<li>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li>
<li>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</li>
<li>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/cpp-STL-generic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/cpp-STL-generic-programming/" itemprop="url">cpp-STL-generic-programming</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-30T22:16:25-07:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/30/cpp-STL-generic-programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/03/30/cpp-STL-generic-programming/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="入门基础知识"><a href="#入门基础知识" class="headerlink" title="入门基础知识"></a>入门基础知识</h1><ol>
<li>C++ Standard Library 标准库 的概念要大于 Standard Template Library (STL, 标准模板库)</li>
<li>标准库以 header files 形式呈现<ol>
<li>C++ 标准库的 header files 不带后缀名，例如 <code>#include &lt;vector&gt;</code></li>
<li>新式 C header files 不带后缀名 .h, 例如 <code>#include &lt;cstdio&gt;</code>. 注意这里在 stdio 前面加上了字符 <code>c</code></li>
<li>老式 C header files 带有后缀名 .h 仍然可用，例如 <code>#include &lt;stdio.h&gt;</code></li>
</ol>
</li>
<li>新式 headers 内的组件封装于 namespace “std”<ol>
<li><code>using namespace std</code></li>
<li><code>using std::cout</code></li>
</ol>
</li>
<li>老式 headers 内的组件不封装于 namespace “std”</li>
<li>STL 六大组件 (<mark>擦感觉我只了解容器算法和迭代器，剩下三个很陌生)<ol>
<li>容器 Containers</li>
<li>分配器 Allocators</li>
<li>算法 Algorithms</li>
<li>迭代器 Iterators</li>
<li>适配器 Adapters</li>
<li>仿函数 Functors</li>
</ol>
</li>
</ol>
<p>Note:</p>
<ol>
<li>下图可以看出来 STL 的整体设计思想跟 OOP 还是有区别的<ol>
<li>OOP 里面我们希望把 data 和 methods 封装到一个类里面去</li>
<li>而 STL 里面数据是放在 container 里面，算法呢，在 algorithms 模块里面，两者通过迭代器 iterator 连接。<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-intro-six-components-1.png" alt=""></li>
</ol>
</li>
</ol>
<p>Note:</p>
<ol>
<li>一个小例子包含STL六大组件，真绝！</li>
<li>bind2nd 在 c++11 后不推荐用了，新版本建议这么用<ol>
<li><code>std::bind(std::less&lt;&gt;(), std::placeholders::_1, 20)</code></li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-intro-six-components-2.png" alt=""></p>
<h1 id="Container-分类和测试"><a href="#Container-分类和测试" class="headerlink" title="Container 分类和测试"></a>Container 分类和测试</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-001.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-002.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-003.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //qsort, bsearch, NULL</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_array().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">long</span>,ASIZE&gt; c;    </span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; ASIZE; ++i) &#123;</span><br><span class="line">        c[i] = rand(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;       </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array.data()= "</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();</span><br><span class="line"></span><br><span class="line">    timeStart = clock();</span><br><span class="line">    ::qsort(c.data(), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs);</span><br><span class="line"><span class="keyword">long</span>* pItem = (<span class="keyword">long</span>*)::bsearch(&amp;target, (c.data()), ASIZE, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), compareLongs); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"qsort()+bsearch(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//    </span></span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>测试代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    //sort()</span></span></span><br><span class="line"><span class="keyword">namespace</span> jj02</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vector</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_vector().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; c;   </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">                 <span class="comment">//曾經最高 i=58389486 then std::bad_alloc</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1073747823</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.data()= "</span> &lt;&lt; c.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vector.capacity()= "</span> &lt;&lt; c.capacity() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line"></span><br><span class="line">                                                                                </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();</span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line">    sort(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sort(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="built_in">string</span>* pItem = (<span class="built_in">string</span>*)::bsearch(&amp;target, (c.data()), </span><br><span class="line">                                   c.<span class="built_in">size</span>(), <span class="keyword">sizeof</span>(<span class="built_in">string</span>), compareStrings); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bsearch(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span> (pItem != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">    test_moveable(<span class="built_in">vector</span>&lt;MyString&gt;(),<span class="built_in">vector</span>&lt;MyStrNoMove&gt;(), value); </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-004-vector-test-result.png" alt=""></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>测试程序如下</p>
<ol>
<li>注意对 list 进行排序这里没有调用全局的 sort 函数，而是使用 lsit 类自己的 sort 函数</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //find()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj03</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_list</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_list().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c;     </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"list.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;        </span><br><span class="line">        </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();      </span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);                      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        </span><br><span class="line">    timeStart = clock();        </span><br><span class="line">    c.sort();                       </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;                </span><br><span class="line">        </span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">    test_moveable(<span class="built_in">list</span>&lt;MyString&gt;(),<span class="built_in">list</span>&lt;MyStrNoMove&gt;(), value);                             </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-005-list-test-result.png" alt=""></p>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h2><p>测试代码</p>
<ol>
<li>没有 <code>push_back</code>, 只有 <code>push_front</code></li>
<li>也没有 <code>.back()</code> 和 <code>.size()</code> 函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj04</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_forward_list</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_forward_list().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line">forward_list&lt;<span class="built_in">string</span>&gt; c;     </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_front(<span class="built_in">string</span>(buf));                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"forward_list.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//536870911</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"forward_list.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    timeStart = clock();            </span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        </span><br><span class="line">    timeStart = clock();        </span><br><span class="line">    c.sort();                       </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.sort(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;        </span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();   </span><br><span class="line">&#125;                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-006-forward-list-test-result.png" alt=""></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-007-deque.png" alt=""></p>
<p>测试程序</p>
<ol>
<li>哈哈</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj05</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_deque</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_deque().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; c;    </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.push_back(<span class="built_in">string</span>(buf));                       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.front()= "</span> &lt;&lt; c.front() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.back()= "</span> &lt;&lt; c.back() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"deque.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1073741821    </span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    timeStart = clock();            </span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        </span><br><span class="line">    timeStart = clock();        </span><br><span class="line">    sort(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());                       </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sort(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    </span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">    test_moveable(<span class="built_in">deque</span>&lt;MyString&gt;(),<span class="built_in">deque</span>&lt;MyStrNoMove&gt;(), value);                               </span><br><span class="line">&#125;                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-008-deque-test-result.png" alt=""></p>
<h2 id="stack-amp-queue"><a href="#stack-amp-queue" class="headerlink" title="stack &amp; queue"></a>stack &amp; queue</h2><p>这个都会了，基本语法不提。只说明一下，注意，这两个东西是没有 iterator 的哦！！</p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>测试实例</p>
<ol>
<li>很显然，全局的 find 函数效率远小于类自带的 find 函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj06</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multiset</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_multiset().......... \n"</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; c;     </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];       </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));                  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multiset.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multiset.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//214748364</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">//比 c.find(...) 慢很多 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        <span class="comment">//比 std::find(...) 快很多                          </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">    test_moveable(<span class="built_in">multiset</span>&lt;MyString&gt;(),<span class="built_in">multiset</span>&lt;MyStrNoMove&gt;(), value);                         </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-009-multiset-test-result.png" alt=""></p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>测试代码</p>
<ol>
<li>multimap 不可以用 <code>[]</code> 做 <code>insertion</code>，只能用 <code>.insert(pair&lt;...,...&gt;)</code> 来做。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj07</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_multimap</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_multimap().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c;   </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            <span class="comment">//multimap 不可使用 [] 做 insertion </span></span><br><span class="line">            c.insert(pair&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt;(i,buf));                         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multimap.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"multimap.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//178956970 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();      </span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);                                </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">        </span><br><span class="line">    c.<span class="built_in">clear</span>();                          </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-010-multimap-test-result.png" alt=""></p>
<h2 id="unordered-multiset"><a href="#unordered-multiset" class="headerlink" title="unordered_multiset"></a>unordered_multiset</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj08</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_multiset</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_multiset().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;<span class="built_in">string</span>&gt; c;   </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.bucket_count()= "</span> &lt;&lt; c.bucket_count() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.load_factor()= "</span> &lt;&lt; c.load_factor() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_load_factor()= "</span> &lt;&lt; c.max_load_factor() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multiset.max_bucket_count()= "</span> &lt;&lt; c.max_bucket_count() &lt;&lt; <span class="built_in">endl</span>;              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.bucket_size(i) &lt;&lt; <span class="string">" elements.\n"</span>;</span><br><span class="line">    &#125;                   </span><br><span class="line">                </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">//比 c.find(...) 慢很多 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        <span class="comment">//比 std::find(...) 快很多                          </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;       </span><br><span class="line">     </span><br><span class="line">    c.<span class="built_in">clear</span>();</span><br><span class="line">    test_moveable(<span class="built_in">unordered_multiset</span>&lt;MyString&gt;(),<span class="built_in">unordered_multiset</span>&lt;MyStrNoMove&gt;(), value);                                     </span><br><span class="line">&#125;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-011-unordered-multiset.png" alt=""></p>
<h2 id="unordered-multimap"><a href="#unordered-multimap" class="headerlink" title="unordered_multimap"></a>unordered_multimap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj09</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_multimap</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_multimap().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c;     </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            <span class="comment">//multimap 不可使用 [] 進行 insertion </span></span><br><span class="line">            c.insert(pair&lt;<span class="keyword">long</span>,<span class="built_in">string</span>&gt;(i,buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multimap.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_multimap.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//357913941 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();      </span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);                                </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-012-unordered-multimap.png" alt=""></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj13</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_set</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_set().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; c;      </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"set.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"set.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//214748364</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">//比 c.find(...) 慢很多 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        <span class="comment">//比 std::find(...) 快很多                          </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-013-set-test-result.png" alt=""></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-014-map.png" alt=""></p>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>测试代码</p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj15</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_set</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_set().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; c;    </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c.insert(<span class="built_in">string</span>(buf));                      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.bucket_count()= "</span> &lt;&lt; c.bucket_count() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.load_factor()= "</span> &lt;&lt; c.load_factor() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.max_load_factor()= "</span> &lt;&lt; c.max_load_factor() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_set.max_bucket_count()= "</span> &lt;&lt; c.max_bucket_count() &lt;&lt; <span class="built_in">endl</span>;           </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i=<span class="number">0</span>; i&lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"bucket #"</span> &lt;&lt; i &lt;&lt; <span class="string">" has "</span> &lt;&lt; c.bucket_size(i) &lt;&lt; <span class="string">" elements.\n"</span>;</span><br><span class="line">    &#125;           </span><br><span class="line">    </span><br><span class="line"><span class="built_in">string</span> target = get_a_target_string();  </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();</span><br><span class="line"><span class="keyword">auto</span> pItem = <span class="built_in">find</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), target);  <span class="comment">//比 c.find(...) 慢很多 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"std::find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;     </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    timeStart = clock();        </span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);        <span class="comment">//比 std::find(...) 快很多                          </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, "</span> &lt;&lt; *pItem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>结果<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-015-unordered-set-test-result.png" alt=""></p>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>测试代码</p>
<ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">namespace</span> jj16</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_unordered_map</span><span class="params">(<span class="keyword">long</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_unordered_map().......... \n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c;      </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, rand());</span><br><span class="line">            c[i] = <span class="built_in">string</span>(buf);         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_map.size()= "</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//357913941</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unordered_map.max_size()= "</span> &lt;&lt; c.max_size() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">long</span> target = get_a_target_long();      </span><br><span class="line">    timeStart = clock();    </span><br><span class="line"><span class="comment">//! auto pItem = find(c.begin(), c.end(), target);  //map 不適用 std::find()           </span></span><br><span class="line"><span class="keyword">auto</span> pItem = c.<span class="built_in">find</span>(target);</span><br><span class="line">                        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c.find(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;         </span><br><span class="line">    <span class="keyword">if</span> (pItem != c.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"found, value="</span> &lt;&lt; (*pItem).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found! "</span> &lt;&lt; <span class="built_in">endl</span>;      </span><br><span class="line">&#125;                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>结果<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-016-unordered-map-test-result.png" alt=""></p>
<h1 id="allocator-分配器"><a href="#allocator-分配器" class="headerlink" title="allocator 分配器"></a>allocator 分配器</h1><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-2.png" alt=""></p>
<p>测试程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;      //abort()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;       //snprintf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    //find()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;   //內含 std::allocator  </span></span></span><br><span class="line">    <span class="comment">//欲使用 std::allocator 以外的 allocator, 得自行 #include &lt;ext\...&gt; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\array_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\mt_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\debug_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\bitmap_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\malloc_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext\new_allocator.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj20</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pass A object to function template impl()，</span></span><br><span class="line"><span class="comment">//而 A 本身是個 class template, 帶有 type parameter T,  </span></span><br><span class="line"><span class="comment">//那麼有無可能在 impl() 中抓出 T, 創建一個 list&lt;T, A&lt;T&gt;&gt; object? </span></span><br><span class="line"><span class="comment">//以下先暫時迴避上述疑問.</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_list_with_special_allocator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__ </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ntest_list_with_special_allocator().......... \n"</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//不能在 switch case 中宣告，只好下面這樣.               //1000000次 </span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, allocator&lt;<span class="built_in">string</span>&gt;&gt; c1;                     <span class="comment">//3140</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::malloc_allocator&lt;<span class="built_in">string</span>&gt;&gt; c2;   <span class="comment">//3110</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::new_allocator&lt;<span class="built_in">string</span>&gt;&gt; c3;      <span class="comment">//3156</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; c4;       <span class="comment">//4922</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::__mt_alloc&lt;<span class="built_in">string</span>&gt;&gt; c5;         <span class="comment">//3297</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>, __gnu_cxx::bitmap_allocator&lt;<span class="built_in">string</span>&gt;&gt; c6;   <span class="comment">//4781                                                      </span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">int</span> choice;</span><br><span class="line"><span class="keyword">long</span> value;     </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"select: "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (1) std::allocator "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (2) malloc_allocator "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (3) new_allocator "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (4) __pool_alloc "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (5) __mt_alloc "</span></span><br><span class="line">         &lt;&lt; <span class="string">" (6) bitmap_allocator "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">    <span class="keyword">if</span> ( choice != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"how many elements: "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;       </span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">10</span>];           </span><br><span class="line"><span class="keyword">clock_t</span> timeStart = clock();                                </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt; value; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">"%d"</span>, i);</span><br><span class="line">            <span class="keyword">switch</span> (choice) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> :    c1.push_back(<span class="built_in">string</span>(buf));  </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> :    c2.push_back(<span class="built_in">string</span>(buf));  </span><br><span class="line">                            <span class="keyword">break</span>;      </span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> :    c3.push_back(<span class="built_in">string</span>(buf)); </span><br><span class="line">                            <span class="keyword">break</span>;      </span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> :    c4.push_back(<span class="built_in">string</span>(buf));  </span><br><span class="line">                            <span class="keyword">break</span>;      </span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> :    c5.push_back(<span class="built_in">string</span>(buf));      </span><br><span class="line">                            <span class="keyword">break</span>;      </span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span> :    c6.push_back(<span class="built_in">string</span>(buf));  </span><br><span class="line">                            <span class="keyword">break</span>;              </span><br><span class="line">                <span class="keyword">default</span>: </span><br><span class="line">                    <span class="keyword">break</span>;      </span><br><span class="line">            &#125;                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(exception&amp; p) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; p.what() &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a lot of push_back(), milli-seconds : "</span> &lt;&lt; (clock()-timeStart) &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//test all allocators' allocate() &amp; deallocate();</span></span><br><span class="line">    <span class="keyword">int</span>* p;     </span><br><span class="line">    allocator&lt;<span class="keyword">int</span>&gt; alloc1;  </span><br><span class="line">    p = alloc1.allocate(<span class="number">1</span>);  </span><br><span class="line">    alloc1.deallocate(p,<span class="number">1</span>);     </span><br><span class="line">                        </span><br><span class="line">    __gnu_cxx::malloc_allocator&lt;<span class="keyword">int</span>&gt; alloc2;  </span><br><span class="line">    p = alloc2.allocate(<span class="number">1</span>);  </span><br><span class="line">    alloc2.deallocate(p,<span class="number">1</span>);     </span><br><span class="line">        </span><br><span class="line">    __gnu_cxx::new_allocator&lt;<span class="keyword">int</span>&gt; alloc3;   </span><br><span class="line">    p = alloc3.allocate(<span class="number">1</span>);  </span><br><span class="line">    alloc3.deallocate(p,<span class="number">1</span>);     </span><br><span class="line">        </span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="keyword">int</span>&gt; alloc4;    </span><br><span class="line">    p = alloc4.allocate(<span class="number">2</span>);  </span><br><span class="line">    alloc4.deallocate(p,<span class="number">2</span>);     <span class="comment">//我刻意令參數為 2, 但這有何意義!! 一次要 2 個 ints? </span></span><br><span class="line">        </span><br><span class="line">    __gnu_cxx::__mt_alloc&lt;<span class="keyword">int</span>&gt; alloc5;  </span><br><span class="line">    p = alloc5.allocate(<span class="number">1</span>);  </span><br><span class="line">    alloc5.deallocate(p,<span class="number">1</span>);     </span><br><span class="line">            </span><br><span class="line">    __gnu_cxx::bitmap_allocator&lt;<span class="keyword">int</span>&gt; alloc6;    </span><br><span class="line">    p = alloc6.allocate(<span class="number">3</span>);  </span><br><span class="line">    alloc6.deallocate(p,<span class="number">3</span>);     <span class="comment">//我刻意令參數為 3, 但這有何意義!! 一次要 3 個 ints? </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>          </span></span><br><span class="line">&#125;                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>首先需要明确，这里只是帮助你理解 STL 的六大组件之一分配器的底层原理，以及 STL 容器是如何使用它们的。<br>在你平时实际工作中，你基本是不会使用这个东西的。</p>
<p>Note:</p>
<ol>
<li>下图为了说明 stl 中 allocator 的实现基本上是层层封装。</li>
<li>先封装了 operator new 和 operator delete</li>
<li>最底层用的还是 C 语言里面的 mallow 和 delete</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-3.png" alt=""></p>
<p>Note:</p>
<ol>
<li>接下来三张图介绍的是三个编译软件(VC, Borland C, Glue C)里面 Allocator 的实现。</li>
<li>老师提到了因为最底层用的是 malloc，而 malloc 会在真实的数据前后加上一些内容，导致对空间的使用不是很高效，如果真实内容很小，那么大量的空间实际上是存储了 cookie data.</li>
<li><mark>突然想到在做 leetcode 动态规划问题的时候，有时候用 stl 三维 vector，每一个维度都用 100 大小，会导致 memory limit error 的问题。而这个时候如果你使用 <code>int res[100][100][100]</code> 却没有内存错误，这充分说明了 STL 的 allocator 的实现对内存使用不友好！！！</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-6.png" alt=""></p>
<p>Note:</p>
<ol>
<li>接下来两张图介绍 Glue 2.9 里面的一个空间友好的实现，类名字叫做 alloc.</li>
<li>主要是呼叫一次 malloc 会得到一个较大的空间，里面可以放很多个 object；而不是对每一个 object 都呼叫一次 malloc<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-7.png" alt=""></li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-8.png" alt=""></p>
<p>Note:</p>
<ol>
<li>可是不知道为啥，Glue 4.5 以后又放弃了上面的那个实现，难道因为内存条便宜了？(23333333)<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-9.png" alt=""></li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-10.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-allocator-11.png" alt=""></p>
<h1 id="深度探索各种容器"><a href="#深度探索各种容器" class="headerlink" title="深度探索各种容器"></a>深度探索各种容器</h1><h2 id="深度探索-list"><a href="#深度探索-list" class="headerlink" title="深度探索 list"></a>深度探索 list</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-1.png" alt=""></p>
<p>图注：</p>
<ol>
<li>STL 的底层实现里面会用到很多的 typedef，自己要习惯！</li>
<li>底层实现：双向链表 和 环状链表！！！</li>
<li>并且为了实现前闭后开的功能，加了一个 dummy tail node！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-2.png" alt=""></li>
</ol>
<p>图注：</p>
<ol>
<li><mark>每一个 container 都有自己的 iterator 类</mark></li>
<li>iterator 类里面一定要有至少五个 typedef</li>
<li><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-3.png" alt=""></li>
</ol>
<p>图注：</p>
<ol>
<li>这里图中用数字 1 标识的地方老师讲的有点问题，我觉得之所以 <code>*this</code> 没有用到 <code>operator*()</code>，是因为这里的 <code>this</code> 是 iterator 的指针，而不是一个 iterator 本身。</li>
<li>重载的函数 <code>operator*()</code> 只有在使用 <code>*iter</code> 的时候，也就是 <code>*</code> 要作用在 iterator 本身，而不是 iterator 的指针。<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-4.png" alt=""></li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-5.png" alt=""></p>
<p>图注：</p>
<ol>
<li>Glue 两个版本下，list 实现的对比</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-6.png" alt=""></p>
<p>图注：</p>
<ol>
<li>新版本里面多了很多个继承。这里 <code>_List_impl</code> 类还要继承自 allocator 类挺奇怪！</li>
<li>这里还有个要注意的地方是，新版本的 sizeof(list) 是 8，因为其类本身没有数据，大小等于父类 <code>_List_base</code> 大小；而父类含有的 <code>_List_impl</code> 有一个 <code>_list_node_base</code>，其中含有两个指针，所以大小是 8.</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-list-7.png" alt=""></p>
<h2 id="迭代器设计原则和-iterator-traits"><a href="#迭代器设计原则和-iterator-traits" class="headerlink" title="迭代器设计原则和 iterator traits"></a>迭代器设计原则和 iterator traits</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-iterator-traits-6.png" alt=""></p>
<h2 id="深度探索-vector"><a href="#深度探索-vector" class="headerlink" title="深度探索 vector"></a>深度探索 vector</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-vector-7.png" alt=""></p>
<h2 id="深度探索-array-forward-list"><a href="#深度探索-array-forward-list" class="headerlink" title="深度探索 array, forward list"></a>深度探索 array, forward list</h2><p>萃取机分为两部分，一部分操作指针，一部分操作 class 类型。</p>
<p>侯捷老师也觉得这个 G4.9 编译器的实现没有上面的简洁。不知道好处到底在哪里。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-array-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-array-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-forward-list-1.png" alt=""></p>
<h2 id="深度探索-deque-queue-stack"><a href="#深度探索-deque-queue-stack" class="headerlink" title="深度探索 deque, queue, stack"></a>深度探索 deque, queue, stack</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-1.png" alt=""></p>
<p>上图注：</p>
<ol>
<li>deque 在内存里是分段连续的！连续是假象，分段是事实。</li>
<li>图中间偏下位置有一个 vector，里面放的是指针，指向各个缓冲区，它是核心！</li>
<li>如何扩充：<ol>
<li>如果最后一个缓冲区用完了，那么就新开辟一个缓冲区，并且在那个 vector 里加上指针指向新开辟的缓冲区。</li>
<li>同理，如果是往头部插入数据，则也会重新开辟缓冲区，并且在那个 vector 的左边加上指针指向新开辟的缓冲区。</li>
<li><mark>所以这个 vector 应该是把目前的有效指针放在中间位置，这样子两边会有空来放新的指针。</mark></li>
</ol>
</li>
<li>蓝色部分是每一个缓冲区都有一个自己的蓝色区域<ol>
<li>蓝色部分有四个元素，first 和 last 分别指向缓冲区的头和尾</li>
<li>node 指向控制中心，也就是上面说的放有指针的 vector</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-2.png" alt=""></p>
<p>上图注：</p>
<ol>
<li><code>map_pointer</code> 是 <code>T**</code> 类型，因为它指向的是一个 vector of 指针啊！</li>
<li>一个 deque 对象本身是 40 个 byte。<ol>
<li>两个 iterator 各自占用 16.</li>
<li>一个指针是 4</li>
<li>一个整形是 4</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-3.png" alt=""></p>
<p>上图注：</p>
<ol>
<li>deque 的迭代器大小是 16，因为里面有 4 个指针！（在 32 位电脑上）</li>
<li>注意里面有五个东西必须定义！（作为 STL 迭代器大家族的成员！）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-4.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-5.png" alt=""></p>
<p>上两个图注：</p>
<ol>
<li>哈哈哈</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-7.png" alt=""></p>
<p>上图注：</p>
<ol>
<li>这里计算两个 iterator 的距离很符合直观啊！<ol>
<li>先算出来中间间隔了几个完整的 buffer，这里是 <code>node - x.node - 1</code>，需要额外减去 1 哦！</li>
<li>尾巴部分的剩余元素是 <code>cur - first</code></li>
<li>头部的剩余元素是 <code>last - cur</code></li>
</ol>
</li>
<li></li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-8.png" alt=""></p>
<p>上图注：</p>
<ol>
<li>一个很好地编程大家风范就是：用后加加（postfix ++）去调用前加加（prefix ++）</li>
<li></li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-9.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-10.png" alt=""></p>
<p>上两图注：</p>
<ol>
<li>这里就是如何一次把 iterator 移动好几个位置的代码了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-11.png" alt=""></p>
<p>上图注：</p>
<ol>
<li>这里是 G4.9 版本的代码。类似的，侯捷大神觉得：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-deque-12.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-queue-stack-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-queue-stack-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-queue-stack-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-queue-stack-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-stl-container-in-depth-queue-stack-5.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/11/leetcode-mics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/leetcode-mics/" itemprop="url">leetcode-mics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-11T00:12:45-07:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/11/leetcode-mics/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/03/11/leetcode-mics/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="求和-很多限制条件"><a href="#求和-很多限制条件" class="headerlink" title="求和(很多限制条件)"></a>求和(很多限制条件)</h2><p>[题目]</p>
<ol>
<li>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</li>
</ol>
<p>[分析]</p>
<ol>
<li>这道题目出自《贱指offer》</li>
<li>首先看到说不能使用公式直接计算（公式中包含乘除法），所以可以考虑使用递归进行求解。</li>
<li>但是递归中一般需要使用 if 来指定返回条件，而这里不允许使用 if，所以无法使用普通的递归思路。</li>
<li>直接看代码！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这里的思路就是利用 C++ 语言中在处理 <code>A &amp;&amp; B</code> 时候的规则.</li>
<li>只有 A 为 true，才会执行 B, 根据 B 的结果返回。</li>
<li>如果 A 为 false, 不会执行 B, 直接返回 false.</li>
<li>因此这里使用这么个技巧使得 n 在不为 0 的时候都会执行右边的赋值和递归运算，从而得到结果。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/design-pattern/" itemprop="url">design-pattern</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-15T21:09:00-08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/Python/design-pattern/" itemprop="url" rel="index">
                    <span itemprop="name">design pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/15/design-pattern/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/15/design-pattern/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Creational-Patterns"><a href="#Creational-Patterns" class="headerlink" title="Creational Patterns"></a>Creational Patterns</h1><h2 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h2><h2 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h2><h2 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h2><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    static  A&amp; getInstance();</span><br><span class="line">    setup() &#123;&#x2F;&#x2F;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    A();</span><br><span class="line">    A(const A&amp; rhs);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&amp; A::getInstance()&#123;</span><br><span class="line">    static A a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A::getInstance().setup();</span><br></pre></td></tr></table></figure>

<p>解释一下</p>
<ol>
<li>注意这里面的 Constructor 都是在 private 区域(参考<a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#Can-constructor-be-private" target="_blank" rel="noopener">private constructor</a>)，因此你不能使用 <code>A a1;</code> 这种方式去生成一个 object;</li>
<li>你只能用 <code>A a1 = A::getInstance()</code> 这种方式去获得一个 object.</li>
</ol>
<h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><h3 id="原型模式的作用"><a href="#原型模式的作用" class="headerlink" title="原型模式的作用"></a>原型模式的作用</h3><ol>
<li>基本就是你需要从A的实例得到一份与A内容相同，但是又互不干扰的实例的话，就需要使用原型模式。</li>
<li>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这个其实和C++的拷贝构造函数的作用是相似的（但不相同），实际上就是动态抽取 当前对象 运行时 的 状态。</li>
<li>当然有的时候，如果我们并不需要基于现有的对象复制新的对象，或者我们需要的就是一个干净的空对象，那么我的首先还是工厂模式或者抽象工厂模式。</li>
</ol>
<h3 id="为什么需要原型模式？"><a href="#为什么需要原型模式？" class="headerlink" title="为什么需要原型模式？"></a>为什么需要原型模式？</h3><ol>
<li>为什么不用new直接新建对象，而要用原型模式？<ol>
<li>首先，用new新建对象不能获取当前对象运行时的状态，其次就算new了新对象，在将当前对象的值复制给新对象，效率也不如原型模式高。</li>
</ol>
</li>
<li>为什么不直接使用拷贝构造函数，而要使用原型模式？<ol>
<li>原型模式与拷贝构造函数是不同的概念，拷贝构造函数涉及的类是已知的，原型模式涉及的类可以是未知的（基类的拷贝构造函数只能复制得到基类的对象）。</li>
<li>原型模式生成的新对象可能是一个派生类。拷贝构造函数生成的新对象只能是类本身。原型模式是描述了一个通用方法(或概念)，它不管是如何实现的，而拷贝构造则是描述了一个具体实现方法。</li>
</ol>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>资源优化场景<ol>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
</ol>
</li>
<li>性能和安全要求的场景<ol>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
</ol>
</li>
<li>一个对象多个修改者的场景<ol>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ol>
</li>
<li>结合使用<ol>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为浑然一体，大家可以随手拿来使用。</li>
</ol>
</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>
<li>实现原型模式每个派生类都必须实现 Clone接口。</li>
<li>逃避构造函数的约束。</li>
</ol>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p> 在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。</p>
<p>在c++中，怎么实现原型模式呢？实际上就拷贝构造函数，而且有时候还涉及到深拷贝，这个自行研究c++深拷贝机制。下面给出最简单的一种实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     Prototype()&#123;&#125;</span><br><span class="line">     ~Prototype()&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> Prototype *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> :</span><span class="keyword">public</span> Prototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcretePrototypeA() :member(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~ConcretePrototypeA()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ConcretePrototypeA(<span class="keyword">const</span> ConcretePrototypeA &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        member = rhs.member;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ConcretePrototypeA* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy of self"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototypeA(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成对像</span></span><br><span class="line">    ConcretePrototypeA *conPro = <span class="keyword">new</span> ConcretePrototypeA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制自身</span></span><br><span class="line">    ConcretePrototypeA * conPro1 = conPro-&gt;clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制自身</span></span><br><span class="line">    ConcretePrototypeA * conPro2 = conPro-&gt;clone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro;</span><br><span class="line">    conPro = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro1;</span><br><span class="line">    conPro1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> conPro2;</span><br><span class="line">    conPro2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实现了一个最简单的原型模式，但是已经将原型模式的基本实现原理展现出来了。而有的时候，当调用Clone获得了一个复制的对象以后，需要改变对象的状态，此时就可能需要在ConcretePrototype类中添加一个Initialize操作，专门用于初始化克隆对象。由于在clone的内部调用的是复制构造函数，而此处又涉及到深复制和浅复制的问题。所以，在实际操作的过程中，这些问题，都需要进行仔细的考虑。</p>
<p>来看一个稍微复杂点的例子：类含有指针成员，这里就涉及到了拷贝构造函数的深拷贝。其实这里例子还需要一个拷贝复制函数，很简单，就是要考虑到自赋值的情况就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resume()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Resume* <span class="title">clone</span><span class="params">()</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Resume()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span>*name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResumeA</span> :</span> <span class="keyword">public</span> Resume</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    ResumeA()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ResumeA(<span class="keyword">const</span> <span class="keyword">char</span> *str)  <span class="comment">//构造函数  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResumeA(<span class="keyword">const</span> ResumeA &amp;rhs) <span class="comment">//拷贝构造函数  </span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name, rhs.name);</span><br><span class="line">    &#125;</span><br><span class="line">                </span><br><span class="line">    ResumeA&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResumeA&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(rhs.name);</span><br><span class="line">        name = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(name, rhs.name);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function">ResumeA* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ResumeA name : "</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResumeA(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ~ResumeA()</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span>[] name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resume *r = <span class="keyword">new</span> ResumeA(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    Resume *r1 = r-&gt;clone();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">delete</span> r1;</span><br><span class="line">    r1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-prototype-1.png" alt=""></p>
<p>Discussion. Image base class provides the mechanism for storing, finding, and cloning the prototype for all derived classes. Each derived class specifies a private static data member whose initialization “registers” a prototype of itself with the base class. When the client asks for a “clone” of a certain type, the base class finds the prototype and calls clone() on the correct derived class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> imageType</span><br><span class="line">&#123;</span><br><span class="line">  LSAT, SPOT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Image *<span class="title">findAndClone</span><span class="params">(imageType)</span></span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> imageType <span class="title">returnType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Image *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// As each subclass of Image is declared, it registers its prototype</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addPrototype</span><span class="params">(Image *<span class="built_in">image</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _prototypes[_nextSlot++] = <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// addPrototype() saves each registered prototype here</span></span><br><span class="line">    <span class="keyword">static</span> Image *_prototypes[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _nextSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Image *Image::_prototypes[];</span><br><span class="line"><span class="keyword">int</span> Image::_nextSlot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Client calls this public static member function when it needs an instance</span></span><br><span class="line"><span class="comment">// of an Image subclass</span></span><br><span class="line"><span class="function">Image *<span class="title">Image::findAndClone</span><span class="params">(imageType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _nextSlot; i++)</span><br><span class="line">    <span class="keyword">if</span> (_prototypes[i]-&gt;returnType() == type)</span><br><span class="line">      <span class="keyword">return</span> _prototypes[i]-&gt;clone();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandSatImage</span>:</span> <span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LSAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"LandSatImage::draw "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When clone() is called, call the one-argument ctor with a dummy arg</span></span><br><span class="line">    <span class="function">Image *<span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LandSatImage(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// This is only called from clone()</span></span><br><span class="line">    LandSatImage(<span class="keyword">int</span> dummy)</span><br><span class="line">    &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Mechanism for initializing an Image subclass - this causes the</span></span><br><span class="line">    <span class="comment">// default ctor to be called, which registers the subclass's prototype</span></span><br><span class="line">    <span class="keyword">static</span> LandSatImage _landSatImage;</span><br><span class="line">    <span class="comment">// This is only called when the private static data member is initiated</span></span><br><span class="line">    <span class="comment">// 也就是说这个构造函数只会被执行一次！！！</span></span><br><span class="line">    LandSatImage()</span><br><span class="line">    &#123;</span><br><span class="line">        addPrototype(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Nominal "state" per instance mechanism</span></span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the subclass's prototype</span></span><br><span class="line">LandSatImage LandSatImage::_landSatImage;</span><br><span class="line"><span class="comment">// Initialize the "state" per instance mechanism</span></span><br><span class="line"><span class="keyword">int</span> LandSatImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpotImage</span>:</span> <span class="keyword">public</span> Image</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">imageType <span class="title">returnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"SpotImage::draw "</span> &lt;&lt; _id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Image *<span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpotImage(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    SpotImage(<span class="keyword">int</span> dummy)</span><br><span class="line">    &#123;</span><br><span class="line">        _id = _count++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    SpotImage()</span><br><span class="line">    &#123;</span><br><span class="line">        addPrototype(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> SpotImage _spotImage;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpotImage SpotImage::_spotImage;</span><br><span class="line"><span class="keyword">int</span> SpotImage::_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simulated stream of creation requests</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM_IMAGES = <span class="number">8</span>;</span><br><span class="line">imageType input[NUM_IMAGES] =</span><br><span class="line">&#123;</span><br><span class="line">  LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Image *images[NUM_IMAGES];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Given an image type, find the right prototype, and return a clone</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    images[i] = Image::findAndClone(input[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Demonstrate that correct image objects have been cloned</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    images[i]-&gt;draw();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Free the dynamic memory</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_IMAGES; i++)</span><br><span class="line">    <span class="keyword">delete</span> images[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<pre><code>LandSatImage::draw 1
LandSatImage::draw 2
LandSatImage::draw 3
SpotImage::draw 1
LandSatImage::draw 4
SpotImage::draw 2
SpotImage::draw 3
LandSatImage::draw 5</code></pre><p>注意：</p>
<ol>
<li>我擦，这个例子看了我很久！！！</li>
<li>第一个要注意的地方是，两个子类都含有 static data members, 你必须在类的定义后面紧接着去定义它们（系统对它们的内存分配发生在这一步）！</li>
<li>第二个要注意的地方是，父类的 <code>Image *Image::_prototypes[];</code> 数组里面包含每一种子类！也就是说，有多少个子类，这个数组就有多少个元素！！！不会多，也不会少！<ol>
<li>因为看代码可以知道，这个数组的改变只有通过 <code>addPrototype</code> 函数！</li>
<li>而这个函数只有在子类的 static data member 初始化的时候才会被调用。而这个 static data member 只有一个。</li>
</ol>
</li>
<li>第三个要注意的是，不要搞混了主函数里的 images 数组和上面提到的 <code>_prototypes[]</code> 数组！</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工厂方法模式、抽象工厂模式、建造者模式和原型模式都是创建型模式。工厂方法模式适用于生产较复杂，一个工厂生产单一的一种产品的时候；抽象工厂模式适用于一个工厂生产多个相互依赖的产品；建造者模式着重于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；原型模式则更强调的是从自身复制自己，创建要给和自己一模一样的对象。</p>
<p>原型模式作为创建型模式中最特殊的一个模式，具体的创建过程，是由对象本身提供，这样我们在很多的场景下可以很方便的快速的构建新的对象。但是，原型模式的最大缺点是继承原型的子类都要实现Clone操作，这个是很困难的。例如，当所考虑的类已经存在时就难以新增Clone操作。当内部包括一些不支持拷贝或者有循环引用的对象时，实现克隆可能也会很困难。说以说，每一种设计模式都有它的优点和缺点，在设计的时候，我们需要进行权衡各方面的因素，扬长避短。</p>
<h1 id="Structural-Patterns"><a href="#Structural-Patterns" class="headerlink" title="Structural Patterns"></a>Structural Patterns</h1><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-composite.png" alt=""></p>
<h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><h2 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h2><h2 id="Flyweight"><a href="#Flyweight" class="headerlink" title="Flyweight"></a>Flyweight</h2><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h1 id="Behavioral-Patterns"><a href="#Behavioral-Patterns" class="headerlink" title="Behavioral Patterns"></a>Behavioral Patterns</h1><h2 id="Chain-of-responsibility"><a href="#Chain-of-responsibility" class="headerlink" title="Chain of responsibility"></a>Chain of responsibility</h2><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h2 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h2><h2 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h2><h2 id="Template-Method"><a href="#Template-Method" class="headerlink" title="Template Method"></a>Template Method</h2><p>在文章 <a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8" target="_blank" rel="noopener">cpp-summary</a> 里面介绍虚函数，虚函数表，和虚表指针的时候，那里提到了虚函数的一个常见用法。</p>
<p>就是可以用基类的指针数组去统一管理所有的子类对象。</p>
<p>此处介绍虚函数的另一个常见用法。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-template-method-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-template-method-2.png" alt=""></p>
<p>图的注解</p>
<ol>
<li>这个模式的思路是：<ol>
<li>在你开发一个基类的时候，比如打开一个文件，有一些基本的操作可以在基类完成（比如输出要打开的文件的名字，以及其他状态的描述输出）</li>
<li>但是呢，如何打开一个具体的文件，这个操作需要由将来其他人实现的子类来实现。</li>
</ol>
</li>
</ol>
<h2 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h2><p>相关的 OOD 概念有： Delegation 委托 + Inheritance 继承</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-observer-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-design-pattern-observer-2.png" alt=""></p>
<p>图的注解：</p>
<ol>
<li>图一是背景介绍，包括两个例子<ol>
<li>例一，讲的是对于同一个文件，我现在打开了四个窗口，比如四个窗口分别看同一个 word 文档的不同页面。</li>
<li>例二，讲的是同一个数据，我们有几种不同的表现形式，eg. 原始数据的直接展示，统计直方图，etc.</li>
</ol>
</li>
<li>图二是如何使用 delegation 和 inheritance 来设计这个类<ol>
<li>Subject 类里面包括有 Observer 类的指针，这个是 delegation 关系。</li>
<li>同时 Observer 也是一个基类，它可以由很多不同的子类实现不同的功能，比如上面的例二。</li>
</ol>
</li>
</ol>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h2 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h2><h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/python-good-code-examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/python-good-code-examples/" itemprop="url">python-good-code-examples</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T23:50:27-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/python-good-code-examples/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/python-good-code-examples/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="25-个有用代码段"><a href="#25-个有用代码段" class="headerlink" title="25 个有用代码段"></a>25 个有用代码段</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 交换变量的值</span></span><br><span class="line"><span class="comment">#    在 C++ 语言里面，不使用第三个变量的情况下去交换两个变量的值需要一定的技巧（使用运算符或者使用 XOR 操作）</span></span><br><span class="line"><span class="comment">#    而在 Python 里面很简单</span></span><br><span class="line">a, b = b, a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查是否是偶数</span></span><br><span class="line"><span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将多行数据变成行列表</span></span><br><span class="line"><span class="keyword">return</span> lines.split(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查找对象使用的内存</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.getsizeof(<span class="number">5</span>))  <span class="comment"># 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 翻转字符串</span></span><br><span class="line"><span class="comment">#    在 C++ 里面有 std::reverse 可以使用</span></span><br><span class="line">str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 字符串复制 n 次</span></span><br><span class="line">str = <span class="string">"Python"</span></span><br><span class="line">str * <span class="number">3</span>    <span class="comment"># PythonPythonPython</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 检查字符串是否回文</span></span><br><span class="line"><span class="keyword">return</span> str == str[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 将字符串列表合并为单个字符串</span></span><br><span class="line">strings = [<span class="string">"abc"</span>, <span class="string">"dsf"</span>, <span class="string">"wer"</span>, <span class="string">"uiods"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">","</span>.join(strings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 查找列表的第一个元素</span></span><br><span class="line">list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. 找到两个列表的元素并集</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a + list_b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. 查找给定列表中所有元素, 重复的只算一次</span></span><br><span class="line"><span class="keyword">return</span> list(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. 求列表元素的平均值</span></span><br><span class="line"><span class="keyword">return</span> sum(list_a, <span class="number">0.0</span>) / len(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13. 判断列表中元素是不是没有重复的</span></span><br><span class="line"><span class="keyword">return</span> len(list_a) == len(set(list_a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14. 求列表元素的 frequency</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">count = Counter(list_a)</span><br><span class="line">print(count)    <span class="comment"># &#123;2: 3, 3: 3, 1: 1, 4: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 15. 找到列表中出现次数最多的那个</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">return</span> max(set(numbers), key = numbers.count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 16. 角度转换成弧度</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">deg = <span class="number">90</span></span><br><span class="line"><span class="keyword">return</span> (deg * math.pi) / <span class="number">180.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 17. 计算一段代码的耗时</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line">a,b = <span class="number">5</span>,<span class="number">10</span></span><br><span class="line">c = a+b</span><br><span class="line">end_time = time.time()</span><br><span class="line">time_taken = (end_time- start_time)*(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line">print(<span class="string">"Time taken in micro_seconds:"</span>, time_taken) <span class="comment"># Time taken in micro_seconds: 39.577484130859375</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 18. 找到一组数字的最大公约数 gcd</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">numbers = [<span class="number">24</span>, <span class="number">108</span>, <span class="number">90</span>]</span><br><span class="line"><span class="keyword">return</span> reduce(math.gcd, numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 19. 找到字符串所有出现过的字符（多次出现的只考虑一次）</span></span><br><span class="line">str = <span class="string">"abcbcabdb"</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(set(str))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 20. 使用 lambda 函数</span></span><br><span class="line">x = <span class="keyword">lambda</span> a, b, c : a + b + c</span><br><span class="line">print(x(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>))    <span class="comment"># 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map(multiply, list_a)</span><br><span class="line">print(list(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 21. 使用 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">result = map</span><br><span class="line"></span><br><span class="line"><span class="comment">## 22. 使用 filter 函数</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, arr))</span><br><span class="line">print(arr)    <span class="comment"># [2, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 23. 使用 list comprehensions</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">squares = [number**<span class="number">2</span> <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 24. 使用 slicing operation</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(arr, d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> arr[d:] + arr[:d]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    arr = rotate(arr, <span class="number">2</span>)</span><br><span class="line">    print(arr)    <span class="comment"># [3, 4, 5, 1, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 25. 使用 chained 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">a, b = <span class="number">5</span>, <span class="number">10</span></span><br><span class="line">print((subtract <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> add)(a, b))    <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p>25 题还是挺有意思的，看出来可以把函数当成一个 first clas object 来玩儿了。</p>
<h1 id="一百题"><a href="#一百题" class="headerlink" title="一百题"></a>一百题</h1><h1 id="一些数据结构用-Python-里面如何操作"><a href="#一些数据结构用-Python-里面如何操作" class="headerlink" title="一些数据结构用 Python 里面如何操作"></a>一些数据结构用 Python 里面如何操作</h1><h2 id="stack-and-heap"><a href="#stack-and-heap" class="headerlink" title="stack and heap"></a>stack and heap</h2><p>比如判断括号组成的字符串是否合法这道题目，C++ 实现的话需要用到 STL 的 stack 和 heap.<br>在 Python 里面如何做呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#### remove first item from a list  ###</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-1: list.pop()</span></span><br><span class="line"><span class="comment"># list.pop(i) will remove the item at index "i"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.pop(<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-2: list.remove()</span></span><br><span class="line"><span class="comment"># list.remove(x) will remove the first element that equal to "x"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.remove(l[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-3: slicing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = l[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method-4: del</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"><span class="comment">#### remove lat item from a list  ###</span></span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># Method-1: l.pop()</span></span><br><span class="line"><span class="comment"># Method-2: l = l[:-1]</span></span><br><span class="line"><span class="comment"># Method-3: del l[-1]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/cpp-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/cpp-summary/" itemprop="url">cpp-summary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T17:28:42-08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/04/cpp-summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/04/cpp-summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h1><h2 id="一些基础的点"><a href="#一些基础的点" class="headerlink" title="一些基础的点"></a>一些基础的点</h2><h3 id="constructor-initialization-list"><a href="#constructor-initialization-list" class="headerlink" title="constructor initialization list"></a>constructor initialization list</h3><ol>
<li>initialization list 要注意，是证明你是 C++ 老手的一个点。</li>
<li>它的执行顺序是按照你在 class 里面定义的顺序来得；</li>
<li>它跟在函数体里面实现的区别在于<ol>
<li>函数体里的实现是赋值操作，编译器还是需要先进行初始化操作，然后进入函数体执行赋值操作。</li>
<li>initialization list 里面是初始化操作，避免了多余的赋值操作。</li>
</ol>
</li>
<li>对于 primitive types，写在函数体里面进行赋值也不会有太大损失；不过最好也是统一写到 initialization list 那里吧！</li>
<li>有时候不仅仅是时间上的考虑，对于 const member data 来说，你必须放在 initialization list 那里，函数体里面不能进行赋值！</li>
</ol>
<h3 id="object-数据初始化顺序"><a href="#object-数据初始化顺序" class="headerlink" title="object 数据初始化顺序"></a>object 数据初始化顺序</h3><ol>
<li>对于类的数据来说，永远是先初始化基类的数据，然后对于当前子类来说，按照定义的顺序来初始化！</li>
<li>The relative order of initialization of non-local static objects defined in different translation units is underfined.<ol>
<li>A <code>translation unit</code> is the source code giving rise to a single object file. It’s basically a single source file, plus all of its <code>#include</code> files.</li>
<li>设想你需要初始化 static object B 和 A, 但是呢，B 的初始化需要先让 A 去初始化才行。这个时候你完全没有办法保证编译器会先初始化 A。怎么办？</li>
<li><mark>解决办法就是类似于 Singleton 设计得思想，把 B 的初始化放到一个函数里面，然后在函数体里面先去调用另一个函数去获得 static A object 的 reference，这样子就可以保证 A 会在 B 之前初始化了。</mark></li>
</ol>
</li>
</ol>
<h3 id="overloading"><a href="#overloading" class="headerlink" title="overloading"></a>overloading</h3><p>编译器是如何处理 overloading 的。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overloading-function-different-names.png" alt=""></p>
<p>此处注意如果你的参数列表都有默认值，有可能看起来跟其他同名函数不同，实际上却可能一样。</p>
<h3 id="big-three-三个特殊函数"><a href="#big-three-三个特殊函数" class="headerlink" title="big three 三个特殊函数"></a>big three 三个特殊函数</h3><p><mark>如果类里有指针，必须有(1) copy constructor (2) copy op= 拷贝赋值函数 (3) destructor. 三大函数</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.h 文件 ///////////////////////////////////////////</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    <span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line">    ~<span class="keyword">String</span>();</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_c_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_data&#125;;    <span class="comment">// 这里还需要提一句！这个函数须是 const 类型的！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// String.cpp 文件</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)&#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cstr) + <span class="number">1</span>];    <span class="comment">// strlen 不会考虑字符串末尾的 '\n' 字符</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 未指定初值时候</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];    <span class="comment">// 注意这里直接取另一个 instance 的私有数据！！因为同一类的不同 instance 互为 friend.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">String</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;    <span class="comment">// 检测自我赋值(self assignment)，这个能写出来就是高手！！！</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;    <span class="comment">// 不止是效率问题，是会出错！！！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> <span class="keyword">String</span>&amp; str)&#123;</span><br><span class="line">    os &lt;&lt; str.get_c_str();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="default-delete"><a href="#default-delete" class="headerlink" title="=default, =delete"></a>=default, =delete</h3><p>我们知道，对于 big three 这些函数，如果你没有定义，那么编译器会帮你生成一个！</p>
<p>而如果你自行定义了一个 ctor, 那么编译器就不会再给你一个 default ctor.<br>如果你强制加上 <code>=default</code>, 就可以重新获得并使用编译器给你的 default ctor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Zoo(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2): d1(i1), d2(i2) &#123;&#125;;</span><br><span class="line">    Zoo(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">delete</span>;    <span class="comment">// copy constructor</span></span><br><span class="line">    Zoo(Zoo&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// move constructor</span></span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Zoo&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Zoo() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++标准库里面使用 <code>=delete</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-1.png" alt=""></p>
<p>C++标准库里面使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-2.png" alt=""></p>
<p>C++标准库里面 destructor 使用 <code>=default</code> 的例子！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-3.png" alt=""></p>
<p>具体的实例！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-5.png" alt=""></p>
<p><mark>非常棒的用法！！！</mark><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-keyword-default-delete-7.png" alt=""></p>
<h3 id="override-amp-final"><a href="#override-amp-final" class="headerlink" title="override &amp; final"></a>override &amp; final</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-override-keyword.png" alt=""></p>
<p>下面介绍 final 关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种情况作用在 class 上面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> <span class="title">final</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> Base1 &#123;&#125;;</span><br><span class="line"> <span class="comment">// [Error] cannot derive from 'final' base 'Base1' in derived type 'Derived1'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况作用在函数上面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> Base2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;  <span class="comment">// [Error] overriding final function 'virtual void Base2::f()'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 编译器如何对待 new</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化为</span></span><br><span class="line"><span class="keyword">String</span>* ps;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="keyword">String</span>));  <span class="comment">// 分配内存, 内部会调用 malloc</span></span><br><span class="line">ps = <span class="keyword">static_cast</span>&lt;<span class="keyword">String</span>*&gt;(mem);    <span class="comment">// 转型</span></span><br><span class="line">ps-&gt;<span class="keyword">String</span>::<span class="keyword">String</span>(<span class="string">"Hello"</span>);    <span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 编译器如何对待 delete</span></span><br><span class="line"><span class="keyword">String</span>* ps = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述操作会被编译器转化成</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>(ps);    <span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;    <span class="comment">// 释放内存，内部调用 free(ps);</span></span><br></pre></td></tr></table></figure>

<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-2.png" alt=""></p>
<p>注一</p>
<ol>
<li>那一大块 32 byte 灰色区域是 debug mode 才会有的，Release mode 不存在这一块。图中左一左三对应 debug mode 下的空间；</li>
<li>绿色部分是实际的数据；</li>
<li>VC 里面实际分配的区间长度一定是 16 的倍数，所以这里要加上 padding 使得长度由 52 变成 64;</li>
<li>00000041 代表这一块区间有多长，这个数字是16进制的，因此是 64 byte</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-dynamic-allocated-memory-3.png" alt=""></p>
<p>注二：</p>
<ol>
<li>这里主要强调 array 情况下的内存分配</li>
<li>注意清楚 array 的空间一定要使用 delete[] ps 而不是 delete ps<ol>
<li>使用 delete ps 会造成内存泄漏，但是这个内存泄漏跟想得不太一样，不是 ps 直接指向的那一块空间泄露了，而是 ps 指向的空间里面的保存的指针二次指向的内存出现了泄露。</li>
<li><font color="red">如果这里不是 String 类，而是 Complex class，那么因为 Complex 的私有数据没有指针，所以就不会出现上面的情况。也就是说，即使你没有使用 deletep[] pc，其实也不会造成内存泄漏问题！</font></li>
</ol>
</li>
</ol>
<h4 id="重载-new-amp-delete"><a href="#重载-new-amp-delete" class="headerlink" title="重载 ::new &amp; ::delete"></a>重载 ::new &amp; ::delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-0.png" alt=""></p>
<h4 id="重载-operator-new-amp-operator-delete"><a href="#重载-operator-new-amp-operator-delete" class="headerlink" title="重载 operator new &amp; operator delete"></a>重载 operator new &amp; operator delete</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-5.png" alt=""></p>
<h4 id="重载-new-amp-delete-1"><a href="#重载-new-amp-delete-1" class="headerlink" title="重载 new() &amp; delete()"></a>重载 new() &amp; delete()</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-8.png" alt=""></p>
<h5 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h5><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-overload-new-delete-9.png" alt=""></p>
<h3 id="类的大小-sizeof"><a href="#类的大小-sizeof" class="headerlink" title="类的大小 sizeof"></a>类的大小 sizeof</h3><ol>
<li>[易错易忽略] 一定要注意，不要说类的大小，而要说类的对象的大小。<ol>
<li>类的大小是什么？确切地说，类只是一个类型定义，它没有大小可言。</li>
<li>用 sizeof 对一个类型名操作，得到的是具有该类型实体的大小。</li>
<li>如果 <code>Class A; A obj</code>，那么 <code>sizeof(A) == sizeof(obj)</code></li>
</ol>
</li>
<li>一个对象的大小 <mark>大于等于</mark> 所有 非静态成员 大小的总和。为什么是大于等于而不是正好想等呢？超出的部分有如下两方面：<ol>
<li>C++对象模型本身 对于具有虚函数的类型来说，需要有一个方法为它的实体提供类型信息(RTTI)和虚函数入口，常见的方法是建立一个虚函数入口表，这个表可为相同类型的对象共享，因此对象中需要有一个指向虚函数表的指针，此外，为了支持RTTI，许多编译器都把该类型信息放在虚函数表中。但是，是否必须采用这种实现方法，C++标准没有规定，但是这几户是主流编译器均采用的一种方案。</li>
<li>编译器优化 因为对于大多数CPU来说，CPU字长的整数倍操作起来更快，因此对于这些成员加起来如果不够这个整数倍，有可能编译器会插入多余的内容凑足这个整数倍，此外，有时候相邻的成员之间也有可能因为这个目的被插入空白，这个叫做“补齐”(padding)。所以，C++ 标准紧紧规定成员的排列按照类定义的顺序, 但是不要求在存储器中是紧密排列的。</li>
</ol>
</li>
<li>基于上述两点，可以说用sizeof对类名操作，得到的结果是该类的对象在存储器中所占据的字节大小，由于静态成员变量不在对象中存储，因此这个结果等于各非静态数据成员（不包括成员函数）的总和加上编译器额外增加的字节。后者依赖于不同的编译器实现，C++标准对此不做任何保证。</li>
<li>C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1。 如果在类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表VTable，在32位机器上，一个对象会增加4个字节来存储此指针，它是实现面向对象中多态的关键。而虚函数本身和其他成员函数一样，是不占用对象的空间的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch1; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="keyword">char</span> ch2; <span class="comment">//占用1字节</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> in;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    D d;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=1   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象c扩充为2个字，但是对象b为什么没扩充为1个字呢（空类的对象一个字节，含一个char的类类对象也为一个字节。）？</span></span><br><span class="line">    <span class="comment">// 因为B类只有一个成员变量，普通成员函数不占用内存。</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(c) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">    <span class="comment">//对象c实际上只有6字节有用数据，但是按照上面第二点编译器优化，编译器将此扩展为两个字（add charles 字节对齐），即8字节</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(d) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//result=8   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述：</p>
<ol>
<li>一个类中，虚函数、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间的。</li>
<li>对象大小= vptr(可能不止一个，这个很难确定，不过试过，类中定义了一个virtual函数，仍然为占用4个字节) + 所有非静态数据成员大小 + </li>
<li>类a，b明明是空类，它的大小应该为为０，为什么编译器输出的结果为１呢？这就是我们刚才所说的实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址．所以a，b的大小为１．</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></span><br><span class="line">pivate: </span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span>&#123;</span> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">int</span> b::data1=<span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(a)="</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(b)="</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么类b多了一个数据成员，却大小和类a的大小相同呢？因为：类b的静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员．但是它不影响类的大小，不管这个类实际产生　了多少实例，还是派生了多少新的类，静态成员数据在类中永远只有一个实体存在，而类的非静态数据成员只有被实例化的时候，他们才存在．但是类的静态数据成员一旦被声明，无论类是否被实例化，它都已存在．可以这么说，类的静态数据成员是一种特殊的全局变量．<br>所以a，b的大小相同．</p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>这里讨论 <code>sizeof</code> 一个 <code>struct</code> 时候的结果。</p>
<p>[三大规则]</p>
<ol>
<li>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节,则要从４的整数倍地址开始存储。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.</li>
</ol>
<p>[举例]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;             <span class="comment">//[0]...[3]</span></span><br><span class="line">    <span class="keyword">double</span> weight;      <span class="comment">//[8]...[15]　　　　　　原则１</span></span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">height</span>;       <span class="comment">//[16]..[19], 总长要为８的整数倍,补齐[20]...[23]　　　　　原则３</span></span><br><span class="line">&#125;BB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aa</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">2</span>];     <span class="comment">//[0],[1]</span></span><br><span class="line">    <span class="keyword">int</span>  id;          <span class="comment">//[4]...[7]　　　　　　　　　　原则１</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> score;     <span class="comment">//[8]....[15]　　　　</span></span><br><span class="line">    short grade;      <span class="comment">//[16],[17]　　　　　　　　</span></span><br><span class="line">    BB b;             <span class="comment">//[24]......[47]　　　　　　　　　　原则２</span></span><br><span class="line">&#125;AA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AA a;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="keyword">sizeof</span>(BB)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是: 48 24</span></span><br></pre></td></tr></table></figure>

<p>[#pragma pack()]<br>在代码前加一句#pragma pack(1),你会很高兴的发现,上面的代码输出为</p>
<p>32 16<br>bb是4+8+4=16,aa是2+4+8+2+16=32;</p>
<p>这不是理想中的没有内存对齐的世界吗.没错,#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.</p>
<p>明白了不? </p>
<p>那 <code>#pragma pack(2)</code> 的结果又是多少呢?对不起,５分钟到了,自己去测试吧.</p>
<p>ps:Vc,Vs等编译器默认是#pragma pack(8)，所以测试我们的规则会正常；注意gcc默认是#pragma pack(4)，并且gcc只支持1,2,4对齐。套用三原则里计算的对齐值是不能大于#pragma pack指定的n值。</p>
<h3 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h3><p>C++ 里面模板的使用一共有四种情况：</p>
<ol>
<li>函数模板</li>
<li>类模板</li>
<li>成员模板</li>
<li>模板参数</li>
</ol>
<h4 id="class-template"><a href="#class-template" class="headerlink" title="[class template]"></a>[class template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-template.png" alt=""></p>
<h4 id="function-template"><a href="#function-template" class="headerlink" title="[function template]"></a>[function template]</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-function-template.png" alt=""></p>
<p>注意：</p>
<ol>
<li>class template 里面 template 后面方括号里面的关键字是 Typename</li>
<li>function template 里面 template 后面方括号里面的关键字是 class T, 这两者的作用是一样的，Typename 出现的晚一点。</li>
<li>对于 class template, 在实际生成具体数据的时候，需要指明数据的类型, 比如 vector<int> 指明了这是一个 int 类型的 vector</li>
<li>而对于 function template，在实际调用执行这个函数的时候，并没有显式地说明输入数据的类型, 比如 min(a, b)<ol>
<li>此时如上图所示，<mark>编译器会自动推导该调用哪个（argument deduction）</mark>.</li>
</ol>
</li>
<li>最后想说明的是，STL 里面一大块就是 algorithm 算法，它们都是用 template 来实现的！！！<ol>
<li>这样子保证了解耦，比如上面的 min(a, b) algorithm 里面会使用”&lt;” 运算符，而这个运算符会由各个 class 的设计者去实现 &lt; operator 的重载！！</li>
</ol>
</li>
</ol>
<h4 id="member-template"><a href="#member-template" class="headerlink" title="member template"></a>member template</h4><p>成员模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line"></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line"></span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>, <span class="title">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;U1, U2&gt;) :</span> first(p.first), second(p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个具体例子，假设我们有两个父类，每个父类都一个子类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> <span class="keyword">public</span> Base1 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> <span class="keyword">public</span> Base2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们打算这么用</span></span><br><span class="line">pair&lt;Derived1, Derived2&gt; p;</span><br><span class="line"></span><br><span class="line">pair&lt;Base1, Base2&gt; p2(p);   // 这个操作可以吗？？？</span><br></pre></td></tr></table></figure>

<p>上面的操作是可以的！</p>
<p>在看另一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>:</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(_Tp1* __p)</span> : __shared_ptr&lt;_Tp&gt;<span class="params">(__p)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体用的时候是这样子</span></span><br><span class="line">Base1* ptr = <span class="keyword">new</span> Derived1;    <span class="comment">// 这个叫做指针的 up-cast</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Base1&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> Derived1)</span></span>;    <span class="comment">// 模拟 up-cast</span></span><br></pre></td></tr></table></figure>

<h4 id="template-template-parameter"><a href="#template-template-parameter" class="headerlink" title="template template parameter"></a>template template parameter</h4><p>模板模板参数是指：模板的参数又是一个模板。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&gt;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; elem)</span></span>&#123;</span><br><span class="line">        elems.push_back(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(empty()) <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Stack&lt;&gt;::pop empty!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> elem = elems.back();</span><br><span class="line">        elems.pop_back();</span><br><span class="line">        <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; elems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这段代码几个要注意的地方：</p>
<ol>
<li>模板的第一个参数是T类型，第二个参数的类型是一个模板，而这个模板具有一个类型参数。此处因为这个形参名字没有被使用，所以省略了。</li>
<li>第二个参数那里按照规定只能用 <code>class Container</code> 不能是 <code>typename Container</code></li>
<li>第二个参数有默认值，是 <code>std::vector</code></li>
</ol>
<p>那么如何使用它呢？有两种方法</p>
<ol>
<li>第一个是只提供一个参数，第二个参数使用默认的。<code>Stack&lt;int&gt; mys</code></li>
<li>如果要提供两种参数的话，第二个参数要提供一个模板类。  <code>Stack&lt;int, some_user_defined_template&gt;</code></li>
</ol>
<p><font color = 'red'>Warning!!!</font><br>有了上面的定义，我们期望可以这样使用 Stack：<code>Stack&lt;int, std::deque&gt; intStack</code>，但编译器却给了我们一个教训。</p>
<p>std::deque类模板在stl库中的定义有两个类型参数，第一个参数是元素类型，第二个参数是分配器allocator的类型。虽然std::deque的第二个类型参数有默认值，但是当编译器使用std::deque替换Container时却会严格匹配参数，默认值被忽略了。</p>
<p>需要将代码修改成如下的样子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Elem, <span class="keyword">typename</span> Allocator = <span class="built_in">std</span>::allocator&lt;Elem&gt;&gt; class Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&gt;</span><br><span class="line"><span class="comment">// class Stack 的内容如上，没有变化</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>Stack&lt;int, std::deque&gt; intStack</code> 就可以编译通过了。</p>
<p>下面再考虑一个问题？如下的定义还算是模板模板参数吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = <span class="built_in">list</span>&lt;T&gt;&gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从使用方法上考虑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用方法有两种：</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; s2;</span><br></pre></td></tr></table></figure>

<p>第一种，只指定了第一个模板参数，使用第二个默认的模板参数。</p>
<p>第二种，指定了两个模板参数。</p>
<p>但是！这不是模板模板参数。因为，一旦指定了第一个模板参数，那么第二个参数的类型就会确定，而真正的模板模板参数，第二个模板参数和第一个模板参数的类型是没有关系的，可以指定为第一个模板参数的类型，也可以指定为其他类型。因此，这不是模板模板参数!!!</p>
<h3 id="variadic-templates-C-11"><a href="#variadic-templates-C-11" class="headerlink" title="variadic templates (C++11)"></a>variadic templates (C++11)</h3><p>侯捷老师说，这个东西是 C++11 里面类似于核弹级别的东西，需要好好体会！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates.png" alt=""></p>
<p>Note:</p>
<ol>
<li>不仅参数的数量随意！每个参数的 type 也随意！</li>
<li>注意有两处出现了 <code>...</code>, 一处位置在 <code>Types</code> 左边，一个的位置在 <code>Types</code> 的右边。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-2.png" alt=""><br>Note:</p>
<ol>
<li>这个例子讲得是 hash function 的设计，其中每个 hash_val 的调用关系都画出来了。</li>
<li>第二个同名函数在递归调用的最后，会调用到第三个同名函数。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-3.png" alt=""><br>Note:</p>
<ol>
<li>这个例子是类的递归继承！</li>
</ol>
<p>[重新回到这个核弹]<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-0.png" alt=""></p>
<p>例一</p>
<ol>
<li><code>sizeof...(args)</code> 可以给出 number of arguments, 注意 <code>...</code> 出现的位置</li>
<li>当有多个函数符合情况时，<mark>编译器会倾向于调用更特化的函数。</mark><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-1.png" alt=""></li>
</ol>
<p>例二</p>
<ol>
<li>这个处理的好简单啊<ol>
<li>比如都没考虑 <code>*s</code> 里面是不是一定各自间隔一个空格</li>
<li>而且也没有考虑格式输出的情况，eg <code>%4.2f</code>, <code>%03d</code><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-2.png" alt=""></li>
</ol>
</li>
</ol>
<p>例三</p>
<ol>
<li>注意左边的线条的起点有点错误，应该是 <code>__max_element</code><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-3.png" alt=""></li>
</ol>
<p>例四</p>
<ol>
<li>上面那跟虚线应该指向下面第二个 maximum 函数，图上画错了</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-4.png" alt=""></p>
<p>例五</p>
<ol>
<li>哈哈</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-5.png" alt=""></p>
<p><mark>例六: 递归继承，令人拍案叫绝的实现方式啊！！！</mark></p>
<ol>
<li>在 tuple 类的 constructor 的 initializer list 那里出现的 inherited 不是创建 temp object, 而是调用父类的 constructor.</li>
<li>一个函数的 return type 可以写在左手边，也可以用 decltype 写在右手边。</li>
<li>第一种实现有点问题，就是编译器会在这里 <code>typename Head::type head() {return m_head}</code> 报错！</li>
<li>所以侯老师有了第二种实现方法，用了 decltype</li>
<li>但是实际上第一种实现只需要简单的修改成 <code>Head head() {return m_head}</code>就可以让编译器接受的。我在看视频的时候也想到了！嘿嘿</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-6-1.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-6-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-6-3.png" alt=""></p>
<p>例七：递归组合</p>
<ol>
<li>这个跟上一个有微妙的区别<ol>
<li>递归继承是通过继承方式，<code>tuple&lt;Tail...&gt;</code> 是父类。</li>
<li>递归组合这里 <code>tup&lt;Tail...&gt;</code> 是类的一个成员变量。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-variadic-templates-4-7.png" alt=""></p>
<h3 id="alias-template-template-typedef-C-11"><a href="#alias-template-template-typedef-C-11" class="headerlink" title="alias template (template typedef) C++11"></a>alias template (template typedef) C++11</h3><p>下图注解：</p>
<ol>
<li>这里要注意的就是 “template + using” 的做法竟然不能用 define 来替代！</li>
<li>注意这里是给 template 起化名，我在用 ITK 库的时候虽然也用了 using 关键字，但是并不是对 template 起化名，而是对一个确定的东西起别名！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-1.png" alt=""></li>
</ol>
<p>下面两个图：</p>
<ol>
<li>左边的是侯老师的一个想法，希望实现一个函数可以接收两个那样的东西，然后完成一系列的测试。</li>
<li>但是写出来原型代码后，侯老师意识到这个实现是天方夜谭，需要的功能是完全不被支持的！</li>
<li>右边的写法是，侯老师意识到了传递给函数的一定是一个东西，一个 object, 而不能是一个 type.<ol>
<li>因此调用函数的方式变成了 <code>test_moveable(list(), MyString())</code>。加上括号就变成了 object 嘛。</li>
</ol>
</li>
<li>注意右边在函数定义的上面有加上了一句话，显示得说明了 Container 和 T 都是模板，但这个时候函数里面的一句话有报错了。</li>
<li>侯老师接着把函数里面的 <code>Container&lt;T&gt; c</code> 改成 <code>typename Container&lt;T&gt; c</code> 试图强制让编译器认为 Container 是一个模板，但还是有错。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-3.png" alt=""></p>
<p>下面三个图注解：</p>
<ol>
<li>上面的做法怎么样都搞不定了，侯老师只好改变了函数接收的参数。</li>
<li>这里有个厉害的操作是他获取 <code>value_type</code> 的方式！</li>
<li>图中的方式可行，是因为 container 一定有 iterator 一定有 value_type, 那如果没有呢？<ol>
<li>就需要 <a href="https://zheng-xing.github.io/2020/01/04/cpp-summary/#template-template-parameter" target="_blank" rel="noopener">template template parameter</a> 了。</li>
</ol>
</li>
<li>但是只用 template template parameter 好像不行</li>
<li>最后是用了 template template parameter 和 alias template 一起才完美解决了问题。<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-4.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-5.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-alias-templates-6.png" alt=""></li>
</ol>
<h3 id="specialization-模板特化"><a href="#specialization-模板特化" class="headerlink" title="specialization 模板特化"></a>specialization 模板特化</h3><p>有特化就有泛化，而泛化指的就是模板。generic programming 泛型编程，说的是泛化。</p>
<p>下面的代码就是一个模板，一个泛化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">hash</span> &#123;</span></span><br><span class="line">    <span class="comment">// 此处省略了具体的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>有泛化的版本了，为什么还需要特化？</mark></p>
<ol>
<li>上面的模板呢可能对于大多数类型的 Key, 都可以直接用。</li>
<li>但是呢，对于一些特殊的 Key 类型，我们有更好的实现，不需要那么复杂。此时就不希望程序自动使用泛化的那个版本。</li>
<li>这个时候我们当然可以另外的去新建一个 (template) class，但是这样子程序员使用者就必须要知道这两个类的名字，还需要记住它们分别适用于哪些 Key</li>
<li>而模板特化呢，就允许我们使用相同的名字，但是里面的实现可以完全不一样！</li>
<li><mark>事实上，可以理解成编译器对于模板的特化是当做一个全新的 class 对待，因此里面的内容可以完全不同。</mark></li>
</ol>
<p>下面的代码介绍的就是特化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span>                <span class="comment">// "Key" 已经被绑定了，所以这里尖括号里面是空白！</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些语法的说明</p>
<ol>
<li>模板那一行写得是 template&lt;&gt;, 其中的 <code>template</code> 告诉编译器后面跟着得是模板类型，留空的 <code>&lt;&gt;</code> 表示没有模板参数。（因为我们把唯一的 class Key 换成了一个具体的类型）。</li>
<li><mark>只要看到 <code>template&lt;&gt;</code> 就知道这是个特化的模板。</mark></li>
<li>hash 后面紧跟的尖括号里面具体给出了我们要建立一个怎样的 hash 类。</li>
</ol>
<p>下面两个例子来自 STL 源代码。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-specialization-example-1.png" alt=""></p>
<h3 id="partial-specialization-偏特化"><a href="#partial-specialization-偏特化" class="headerlink" title="partial specialization 偏特化"></a>partial specialization 偏特化</h3><p>两种“偏”</p>
<ol>
<li>个数上</li>
<li>范围上</li>
</ol>
<h4 id="个数上的偏"><a href="#个数上的偏" class="headerlink" title="个数上的偏"></a>个数上的偏</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处省略了实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc=...&gt;</span><br><span class="line">class <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>, Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 特殊的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="范围上"><a href="#范围上" class="headerlink" title="范围上"></a>范围上</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是特化版本，针对指针类型的特殊实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">// 这里的 T 只是一个名称而已，别跟上面弄混淆了，T 也可以改成 U 什么的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 省略了实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client 代码</span></span><br><span class="line">C&lt;<span class="built_in">string</span>&gt; obj1;</span><br><span class="line">C&lt;<span class="built_in">string</span>*&gt; obj2;</span><br></pre></td></tr></table></figure>

<h4 id="STL-中的例子"><a href="#STL-中的例子" class="headerlink" title="STL 中的例子"></a>STL 中的例子</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-template-specialization-example-3.png" alt=""></p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using directive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二 using declaration</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法三：不展开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &lt;&lt; ...;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Can-constructor-be-private"><a href="#Can-constructor-be-private" class="headerlink" title="Can constructor be private?"></a>Can constructor be private?</h3><p>constructor 会在创建一个当前类的对象的时候自动被调用。</p>
<p>虽然默认情况下 constructors 被定义在 public 区间，但是它其实是可以被定义在 private 区间的，下面介绍一下在什么情况下我们这么用！</p>
<h4 id="Using-Friend-Class"><a href="#Using-Friend-Class" class="headerlink" title="Using Friend Class"></a>Using Friend Class</h4><p>If we want that class should not be instantiated by anyone else but only by a friend class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;</span><br><span class="line">        A a1;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor of B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出是</p>
<pre><code>constructor of A
constructor of B</code></pre><h4 id="Singleton-design-pattern"><a href="#Singleton-design-pattern" class="headerlink" title="Singleton design pattern"></a>Singleton design pattern</h4><p>这一个例子可以参考博客文章 <a href="https://zheng-xing.github.io/2020/01/15/design-pattern/" target="_blank" rel="noopener">design pattern</a>.</p>
<h4 id="Named-Constructor-Idiom"><a href="#Named-Constructor-Idiom" class="headerlink" title="Named Constructor Idiom"></a>Named Constructor Idiom</h4><p>如果有多个 Constructor 的时候容易出错，万一某两个的参数列表都一样咋整？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// ambiguous nature of constructor </span></span><br><span class="line"><span class="comment">// with same no of parameters of same type </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Rectangular coordinates </span></span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Polar coordinates (radius and angle) </span></span><br><span class="line">    Point(<span class="keyword">float</span> r, <span class="keyword">float</span> a);      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// error: ‘Point::Point(float, float)’ cannot </span></span><br><span class="line">    <span class="comment">// be overloaded </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Ambiguous: Which constructor to be called ? </span></span><br><span class="line">    Point p = Point(<span class="number">5.7</span>, <span class="number">1.2</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个问题可以用下面的方法解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPP program to demonstrate </span></span><br><span class="line"><span class="comment">// named constructor idiom </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>  </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">float</span> x1, y1; </span><br><span class="line">    Point(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">    &#123; </span><br><span class="line">        x1 = x; </span><br><span class="line">        y1 = y; </span><br><span class="line">    &#125;; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// polar(radius, angle) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Polar</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular(x, y) </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Point <span class="title">Rectangular</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function for displaying of coordinates </span></span><br><span class="line"><span class="keyword">void</span> Point :: <span class="built_in">display</span>() </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;x1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"y :: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;y1 &lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return polar coordinates </span></span><br><span class="line">Point Point :: Polar(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x*<span class="built_in">cos</span>(y), x*<span class="built_in">sin</span>(y)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// return rectangular coordinates </span></span><br><span class="line">Point Point :: Rectangular(<span class="keyword">float</span> x, <span class="keyword">float</span> y) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> Point(x,y); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Polar coordinates </span></span><br><span class="line">    Point pp = Point::Polar(<span class="number">5.7</span>, <span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"polar coordinates \n"</span>; </span><br><span class="line">    pp.<span class="built_in">display</span>(); </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// rectangular coordinates </span></span><br><span class="line">    Point pr = Point::Rectangular(<span class="number">5.7</span>,<span class="number">1.2</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangular coordinates \n"</span>; </span><br><span class="line">    pr.<span class="built_in">display</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是调用了 public 的函数而已，而这些函数会去调用定义在 private 区域的 Constructor.</p>
<h3 id="Constructor-Delegation"><a href="#Constructor-Delegation" class="headerlink" title="Constructor Delegation"></a>Constructor Delegation</h3><p>没想到这个东西是 C++ 11 才出现的。就是为了让一个 Constructor 去启动另个 Constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    A() </span><br><span class="line">    &#123; </span><br><span class="line">        x = <span class="number">0</span>; </span><br><span class="line">        y = <span class="number">0</span>; </span><br><span class="line">        z = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Constructor delegation  </span></span><br><span class="line">    A(<span class="keyword">int</span> z) : A() </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">this</span>-&gt;z = z; <span class="comment">// Only update z </span></span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; y &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; z; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">A <span class="title">obj</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line">    obj.show(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用 <code>A()</code> 要放到 initialization list 那里，不可以放到 <code>{}</code> 里面。</p>
<h3 id="conversion-function-转换函数"><a href="#conversion-function-转换函数" class="headerlink" title="conversion function 转换函数"></a>conversion function 转换函数</h3><p>从一个例子开始</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>) : m_denominator(den), m_numerator(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) (m_numerator) / (m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">4</span> + f;    <span class="comment">// 调用 operator double()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是解释</p>
<ol>
<li>转换函数不止可以是 <code>double</code> 类型，只要是之前出现过的，编译器认识的类型都可以去转换；</li>
<li>编译器在看到 <code>double d = 4 + f</code> 的时候会去看很多东西以确定这个操作是合理的<ol>
<li>比如它会去看有没有一个全局的函数重载了 <code>+</code>，这个函数会接受一个 <code>int</code> 和一个 <code>Fraction</code> 类别</li>
<li>它当然还会去看 <code>f</code> 能不能变成 int, float, double 的类型，这样子就可以跟 4 进行相加的操作了。</li>
</ol>
</li>
<li>如果你同时再定一个 <code>operator int() const{}</code> 转换函数，那么编译器会报错 <code>error: ambiguous overload for &#39;operator+&#39; (operand types are &#39;int&#39; and &#39;Fraction&#39;)</code>.</li>
</ol>
<h4 id="标准库的一个例子"><a href="#标准库的一个例子" class="headerlink" title="标准库的一个例子"></a>标准库的一个例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&lt;bool, Alloc&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __bit_reference reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    reference <span class="keyword">operator</span>[] (size_type n)&#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + difference_type(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说明一下</p>
<ol>
<li>上面这个例子用到了 proxy 设计模式，因为 operator[] 重载的函数需要返回 bool 值啊，这里却用了另一个 reference 代替返回的类型；</li>
<li>可是为什么 reference 类型的可以用在这里呢？明明需要返回的是 bool 类型？那么，reference 类型的类定义里面一定包含了如何将 bool 转换成 bool 类型的定义！！！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">bit_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> !(!(*p &amp; mask));&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h3><p>explicit 关键字用途很窄，基本上都是用来放在 constructor 前面。</p>
<h4 id="non-explicit-one-argument-ctor"><a href="#non-explicit-one-argument-ctor" class="headerlink" title="non-explicit-one-argument ctor"></a>non-explicit-one-argument ctor</h4><p>一个正确的用法！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// 编译器看到这里会发现确实有个 + 运算符</span></span><br><span class="line">                            <span class="comment">// 调用 non-explicit constructor 将 4 转为 Fraction 类型</span></span><br><span class="line">                            <span class="comment">// 然后调用 operator+</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="conversion-function-vs-non-explicit-one-argument-constructor"><a href="#conversion-function-vs-non-explicit-one-argument-constructor" class="headerlink" title="conversion function vs non-explicit-one-argument constructor"></a>conversion function vs non-explicit-one-argument constructor</h4><p>注意，下面这个代码会让编译器有歧义，它不知道该怎么处理.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fraction(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! ambiguous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="explicit-one-argument-ctor"><a href="#explicit-one-argument-ctor" class="headerlink" title="explicit-one-argument ctor"></a>explicit-one-argument ctor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit 在这里的意思是如果我没有显示地用你去做转换，编译器你不要自作聪明！</span></span><br><span class="line">    <span class="comment">// 不要调用我去把其他的 int 类型转变成 Fraction 类型。</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> den=<span class="number">1</span>)</span></span></span><br><span class="line">      : m_numerator(num), m_denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(m_numerator) / m_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="keyword">const</span> Fraction&amp; f)&#123;</span><br><span class="line">        <span class="keyword">return</span> Fraction(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_numerator;</span><br><span class="line">    <span class="keyword">int</span> m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br><span class="line">    Fraction d2 = f + <span class="number">4</span>;    <span class="comment">// Error!! conversion from 'double' to 'Fraction' requested.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-11-explicit-for-ctors-taking-more-than-one-argument"><a href="#C-11-explicit-for-ctors-taking-more-than-one-argument" class="headerlink" title="C++11 explicit for ctors taking more than one argument"></a>C++11 explicit for ctors taking more than one argument</h4><p>上面的例子只针对有一个实参的 ctor. C++11 里面引入了多个实参的支持！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-explicit-keyword.png" alt=""></p>
<h3 id="range-based-for-C-11"><a href="#range-based-for-C-11" class="headerlink" title="range-based for C++11"></a>range-based for C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-1.png" alt=""><br>这个图解释了一下编译器会把 range based for 语句翻译成什么样子！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-range-based-for-2.png" alt=""></p>
<p>这个例子主要是用来说明 for loop 里面可能会报错，这个错误报错位置跟来源可能会在代码上离得比较远。<br>不过如果错误信息足够详细的话问题也不大！</p>
<h3 id="pointer-like-classes"><a href="#pointer-like-classes" class="headerlink" title="pointer-like classes"></a>pointer-like classes</h3><h4 id="关于智能指针"><a href="#关于智能指针" class="headerlink" title="关于智能指针"></a>关于智能指针</h4><p>这个代码来自于早期版本的标准库代码，C++ 2.0 (C++ 11) 以后改动了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* p) : px(p) &#123;&#125;    <span class="comment">// 接受一个天然的指针！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="keyword">long</span>* pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;    <span class="comment">// 把 new 出来的指针包装成一个智能指针！</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line"></span><br><span class="line">    sp-&gt;method();    <span class="comment">// 变成 px-&gt;method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ol>
<li>任何一个智能指针类一定含有一个真正的指针在类里面；</li>
<li>任何一个智能指针类别一定有两个重载函数 <code>operator *()</code> 和 <code>operator-&gt;()</code>，并且它们的写法就跟这个例子里面一样；</li>
<li><mark>操作符 <code>-&gt;</code> 有个特点，它返回的东西可以接着用 <code>-&gt;</code>。比如这里的 <code>sp-&gt;method()</code> 中的 <code>sp-&gt;</code> 应该变成 <code>px</code>，但是这样子 <code>px</code> 怎么样去指向 <code>method</code> 呢，它还可以用 <code>-&gt;</code>。</mark></li>
</ol>
<h4 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator 迭代器"></a>iterator 迭代器</h4><p>迭代器要比智能指针多支持一些操作符！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;    <span class="comment">// 改个名而已</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;                       <span class="comment">// 真正的那个指针！！！</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node == x.node;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> node != x.node;&#125;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (*node).data;        <span class="comment">// *node 返回的是 struct 的 object</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;node = (link_type)((*node).next); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;node = (link_type)((*node).prev); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;self tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* prev;</span><br><span class="line">    <span class="keyword">void</span>* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用端的代码</span></span><br><span class="line"><span class="built_in">list</span>&lt;Foo&gt;::iterator ite;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">*ite;    <span class="comment">// 获得一个 Foo object</span></span><br><span class="line">ite-&gt;method();</span><br><span class="line">  <span class="comment">// 意思是调用 Foo::method()</span></span><br><span class="line">  <span class="comment">// 相当于 (*ite).method()</span></span><br><span class="line">  <span class="comment">// 相当于 (&amp;(*ite))-&gt;method()</span></span><br></pre></td></tr></table></figure>

<h3 id="function-like-classes-仿函数-functor"><a href="#function-like-classes-仿函数-functor" class="headerlink" title="function-like classes 仿函数 functor"></a>function-like classes 仿函数 functor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">identity</span> :</span> <span class="keyword">public</span> unary_function&lt;T, T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select1st</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">select2nd</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::second_type&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> Pair::second_type&amp; </span><br><span class="line">    <span class="keyword">operator</span>() (<span class="keyword">const</span> Pair&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>辅助代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    pair() : first(T1()), second(T2()) &#123;&#125;</span><br><span class="line">    pair(<span class="keyword">const</span> T1&amp; a, <span class="keyword">const</span> T2&amp; b) : first(a), second(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="base-classes-for-functor"><a href="#base-classes-for-functor" class="headerlink" title="base classes for functor"></a>base classes for functor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">plus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">minus</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x - y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">equal_to</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x == y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这些奇怪的 <code>unary_function</code> 和 <code>binary_function</code> 到底是个啥玩意？？？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line">    <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处没有细讲，请参考侯捷老师专门的STL课程。</p>
<p>另外注意的是，这些class 没有成员变量的哦！只有一些 <code>typedef</code> 而已。</p>
<h2 id="object-relationships-有关"><a href="#object-relationships-有关" class="headerlink" title="object relationships 有关"></a>object relationships 有关</h2><h3 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h3><ol>
<li>Background<ol>
<li>Life is full of recurring patterns, relationships, and hierarchies between objects, so is programming.</li>
</ol>
</li>
<li>relationships between object<ol>
<li>a circle “is a “ shape</li>
<li>a house “has a” bedroom</li>
<li>I “use a” mechanical keyboard</li>
<li>mail “depend on” mailman to be delievered</li>
<li>I am “member of” Pingpang club</li>
</ol>
</li>
</ol>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><ol>
<li>主要用来描述 “has a” 关系的。<ol>
<li>Your computer “has a” CPU.</li>
<li>C++ concepts like structs and classes are both composite types.</li>
</ol>
</li>
<li>有两种 composition 子类<ol>
<li>composition</li>
<li>aggregation</li>
</ol>
</li>
<li>composition 子类满足条件<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can only belong to one object (class) at a time</li>
<li>The part (member) has its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
</li>
<li>说人话<ol>
<li>object 建立的时候创建 the part，object 摧毁的时候 part 也被摧毁</li>
<li>object manages part’s lifetime</li>
<li>part 不知道 object 的存在</li>
</ol>
</li>
</ol>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><p>Many games and simulations have creatures or objects that move around a board, map, or screen. One thing that all of these creatures/objects have in common is that they all have a location. In this example, we are going to create a creature class that uses a point class to hold the creature’s location.</p>
<p>First, let’s design the point class. Our creature is going to live in a 2d world, so our point class will have 2 dimensions, X and Y. We will assume the world is made up of discrete squares, so these dimensions will always be integers.</p>
<p>Point2D.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT2D_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT2D_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// A default constructor</span></span><br><span class="line">    Point2D()</span><br><span class="line">        : m_x(<span class="number">0</span>), m_y(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// A specific constructor</span></span><br><span class="line">    Point2D(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        : m_x(x), m_y(y)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// An overloaded output operator</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access functions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Note that because we’ve implemented all of our functions in the header file (for the sake of keeping the example concise), there is no Point2D.cpp.</p>
<p>This Point2d class is a composition of its parts: location values x and y are part-of Point2D, and their lifespan is tied to that of a given Point2D instance.</p>
<p>Now let’s design our Creature. Our Creature is going to have a few properties: a name, which will be a string, and a location, which will be our Point2D class.</p>
<p>Creature.h:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CREATURE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATURE_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point2D.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    Point2D m_location;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Creature(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> Point2D &amp;location)</span><br><span class="line">        : m_name(name), m_location(location)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Creature &amp;creature)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; creature.m_name &lt;&lt; <span class="string">" is at "</span> &lt;&lt; creature.m_location;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_location.setPoint(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p><mark>注意这里可以这么改写Code</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="title">printToStream</span><span class="params">(<span class="built_in">std</span>::ostream&amp; out, <span class="keyword">const</span> Point2D &amp;<span class="built_in">point</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  out &lt;&lt; <span class="string">'('</span> &lt;&lt; <span class="built_in">point</span>.m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.m_y &lt;&lt; <span class="string">')'</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">printToStream(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="built_in">point</span>);</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p><strong>[Variants on the composition theme]</strong></p>
<p>Although most compositions directly create their parts when the composition is created and directly destroy their parts when the composition is destroyed, there are some variations of composition that bend these rules a bit.</p>
<p>For example:</p>
<ol>
<li>A composition may defer creation of some parts until they are needed. For example, a string class may not create a dynamic array of characters until the user assigns the string some data to hold.</li>
<li>A composition may opt to use a part that has been given to it as input rather than create the part itself.</li>
<li>A composition may delegate destruction of its parts to some other object (e.g. to a garbage collection routine).</li>
</ol>
<p>The key point here is that the composition should manage its parts without the user of the composition needing to manage anything.</p>
<p><strong>[Composition and subclasses]</strong></p>
<p>One question that new programmers often ask when it comes to object composition is, “When should I use a subclass instead of direct implementation of a feature?”. For example, instead of using the Point2D class to implement the Creature’s location, we could have instead just added 2 integers to the Creature class and written code in the Creature class to handle the positioning. However, making Point2D its own class has a number of benefits:</p>
<ol>
<li>Each individual class can be kept relatively simple and straightforward, focused on performing one task well. This makes those classes easier to write and much easier to understand, as they are more focused. For example, Point2D only worries about point-related stuff, which helps keep it simple. <mark>可以找人去负责 Point2D class, 另外的人去负责 Creature class.</mark></li>
<li>Each subclass can be self-contained, which makes them reusable. For example, we could reuse our Point2D class in a completely different application. Or if our creature ever needed another point (for example, a destination it was trying to get to), we can simply add another Point2D member variable.</li>
<li>The parent class can have the subclasses do most of the hard work, and instead focus on coordinating the data flow between the subclasses. This helps lower the overall complexity of the parent object, because it can delegate tasks to its children, who already know how to do those tasks. For example, when we move our Creature, it delegates that task to the Point class, which already understands how to set a point. Thus, the Creature class does not have to worry about how such things would be implemented.</li>
</ol>
<p>A good rule of thumb is that each class should be built to accomplish a single task. That task should either be the storage and manipulation of some kind of data (e.g. Point2D, std::string), OR the coordination of subclasses (e.g. Creature). Ideally not both.</p>
<p>In this case of our example, it makes sense that Creature shouldn’t have to worry about how Points are implemented, or how the name is being stored. Creature’s job isn’t to know those intimate details. Creature’s job is to worry about how to coordinate the data flow and ensure that each of the subclasses knows what it is supposed to do. It’s up to the individual subclasses to worry about how they will do it.</p>
<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><p><strong>[满足条件]</strong></p>
<ol>
<li>The part (member) is part of the object (class)</li>
<li>The part (member) can belong to more than one object (class) at a time</li>
<li>The part (member) does not have its existence managed by the object (class)</li>
<li>The part (member) does not know about the existence of the object (class)</li>
</ol>
<p><strong>[与 composition 异同]</strong></p>
<ol>
<li>共同点<ol>
<li>都是 part-whole 关系</li>
</ol>
</li>
<li>不同点<ol>
<li>parts 可以同时属于多个 object</li>
<li>object 不负责创建和摧毁 parts</li>
</ol>
</li>
</ol>
<p><strong>[具体例子]</strong></p>
<ol>
<li>每个人都有个家庭住址，但是家庭住址可以属于多个人。</li>
<li>人住进来之前家庭地址就存在了</li>
<li>人搬走后家庭地址依然存在</li>
<li>人知道他住在哪里，而一个家庭地址不知道住的是谁(假定是这样子的)</li>
</ol>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>Because aggregations are similar to compositions in that they are both part-whole relationships, they are implemented almost identically, and the difference between them is mostly semantic. In a composition, we typically add our parts to the composition using normal member variables (or pointers where the allocation and deallocation process is handled by the composition class).</p>
<p>In an aggregation, we also add parts as member variables. However, these member variables are typically either references or pointers that are used to point at objects that have been created outside the scope of the class. Consequently, an aggregation usually either takes the objects it is going to point to as constructor parameters, or it begins empty and the subobjects are added later via access functions or operators.</p>
<p>Because these parts exist outside of the scope of the class, when the class is destroyed, the pointer or reference member variable will be destroyed (but not deleted). Consequently, the parts themselves will still exist.</p>
<p>Let’s take a look at a Teacher and Department example in more detail. In this example, we’re going to make a couple of simplifications: First, the department will only hold one teacher. Second, the teacher will be unaware of what department they’re part of.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Teacher(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span><br><span class="line">        : m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Teacher *m_teacher; <span class="comment">// This dept holds only one teacher for simplicity, but it could hold many teachers</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Department(Teacher *teacher = <span class="literal">nullptr</span>)</span><br><span class="line">        : m_teacher(teacher)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create a teacher outside the scope of the Department</span></span><br><span class="line">    Teacher *teacher = <span class="keyword">new</span> Teacher(<span class="string">"Bob"</span>); <span class="comment">// create a teacher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a department and use the constructor parameter to pass</span></span><br><span class="line">        <span class="comment">// the teacher to it.</span></span><br><span class="line">        <span class="function">Department <span class="title">dept</span><span class="params">(teacher)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="comment">// dept goes out of scope here and is destroyed</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Teacher still exists here because dept did not delete m_teacher</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; teacher-&gt;getName() &lt;&lt; <span class="string">" still exists!"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> teacher;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里假定了 teacher 不知道工作的 department.</p>
<h4 id="总结-composition-和-aggregation"><a href="#总结-composition-和-aggregation" class="headerlink" title="总结 composition 和 aggregation"></a>总结 composition 和 aggregation</h4><ol>
<li>compositions<ol>
<li>Typically use normal member variables</li>
<li>Can use pointer members if the class handles object allocation/deallocation itself</li>
<li>Responsible for creation/destruction of parts</li>
</ol>
</li>
<li>Agreegations<ol>
<li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregate class</li>
<li>Not responsible for creating/destroying parts</li>
</ol>
</li>
</ol>
<p>It is worth noting that the concepts of composition and aggregation are not mutually exclusive, and can be mixed freely within the same class. It is entirely possible to write a class that is responsible for the creation/destruction of some parts but not others. For example, our Department class could have a name and a Teacher. The name would probably be added to the Department by composition, and would be created and destroyed with the Department. On the other hand, the Teacher would be added to the department by aggregation, and created/destroyed independently.</p>
<p>While aggregations can be extremely useful, they are also potentially more dangerous. Because aggregations do not handle deallocation of their parts, that is left up to an external party to do so. If the external party no longer has a pointer or reference to the abandoned parts, or if it simply forgets to do the cleanup (assuming the class will handle that), then memory will be leaked.</p>
<p>For this reason, compositions should be favored over aggregations.</p>
<h3 id="Association"><a href="#Association" class="headerlink" title="Association"></a>Association</h3><h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><h3 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation 委托"></a>Delegation 委托</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-relation-delegation.png" alt=""></p>
<p>图的注解：</p>
<ol>
<li>“pimpl”: pointer to implementation</li>
<li>这个概念跟 composition 其实只有一点微妙的区别，一个含有 object, 一个含有指针。</li>
<li>图中左下角介绍的东西有点类似 shared ptr 啊，三个指针指向同一个东西。如果有一个要改动东西，那么会发生 “copy on write”，即拷贝一个出来让它修改。</li>
</ol>
<h2 id="class-有关"><a href="#class-有关" class="headerlink" title="class 有关"></a>class 有关</h2><h3 id="概念题"><a href="#概念题" class="headerlink" title="概念题"></a>概念题</h3><p>[Differnce with struct]</p>
<ol>
<li>The only difference between “class” and “struct” is whether the beginning content in the class body (before first appearance of “private”/“public” keyword) is public or private. For class, that part is private. For struct, that part is public.</li>
</ol>
<p>[Method 定义的位置]</p>
<ol>
<li>定义在 class body 中的话，是要求这些 function become inline, thus avoid function call overhead.</li>
<li>定义在 class body 外的话，就会有 function call.</li>
</ol>
<p>[Compiler generated functions]</p>
<ol>
<li>Compilter silently write 4 functions if they are not explicitly declared:<ol>
<li>Copy constructor</li>
<li>Copy Assignment Operator</li>
<li>Destructor</li>
<li>Default Constructor (Only if there is no constructor declared)<ol>
<li>If there exists copy constructor, then compiler will not generate default constructor.</li>
<li>However, if there exists some constructor (not copy constructor), compiler will generate copy constructor if needed.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="不同关系下的构造与析构函数"><a href="#不同关系下的构造与析构函数" class="headerlink" title="不同关系下的构造与析构函数"></a>不同关系下的构造与析构函数</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-composition.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-class-constructor-destructor-with-inheritance-and-composition.png" alt=""></p>
<h3 id="虚指针和虚函数表"><a href="#虚指针和虚函数表" class="headerlink" title="虚指针和虚函数表"></a>虚指针和虚函数表</h3><p>多态背后的技术叫做动态绑定！底层的实现是使用虚函数表。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了实现C++的多态<mark>（关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>）</mark>，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h4 id="类的虚表"><a href="#类的虚表" class="headerlink" title="类的虚表"></a>类的虚表</h4><p>每个包含了虚函数的类都包含一个虚表。</p>
<p>我们知道，当一个类 A 继承另一个类 B 时，类 A 会继承类 B 的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可以调用这些虚函数。<br>换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>简单的例子，看一下下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，类 <code>A</code> 有虚函数，因此它有一个虚表。</p>
<p>类 <code>A</code> 的虚表如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table.png" alt=""></p>
<p><mark>虚表是一个指针数组，其元素是虚函数的指针。每个元素对应一个虚函数的函数指针。<br>需要指出的是，普通的函数，即非虚函数，其调用并不需要经过虚表。<br>因此虚表的元素并不包括普通函数的函数指针。</mark></p>
<h4 id="虚表指针"><a href="#虚表指针" class="headerlink" title="虚表指针"></a>虚表指针</h4><p><mark>虚表是属于类的，而不是属于某个具体的对象！一个类只需要一个虚表即可！同一个类的所有对象都使用同一个虚表。</mark></p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，<mark>编译器在类中添加了一个指针，<code>*__vptr</code>, 用来指向虚表。</mark><br>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-pointer.png" alt=""></p>
<p>再重复一遍！一个继承类的基类如果包含虚函数，那么这个继承类也有自己的虚表，这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>下面讲一下 C++ 是如何利用虚表和虚表指针实现动态绑定的。先看一段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 A 是基类，类 B 继承类 A，类 C 又继承类 B。<br>它们三个的对象模型如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/classA-virtual-table-with-object-model.png" alt=""></p>
<p>[关于上图的几点说明]</p>
<ol>
<li>由于<mark>这三个类都有虚函数，故编译器为每个类都创建了一个虚表</mark>，即类 A 有虚表 vtbl_A, 类 B 有虚表 vtbl_B, 类 C 有虚表 vtbl_C. 类A, B, C 的<code>对象</code>都拥有一个虚表指针， <code>*__vptr</code>, 用来指向自己所属类的虚表。</li>
<li>图中最左边一列给出了三个类的各自的一个对象。其中 B 类对象 b 中黑框圈中的部分是基类的内容。C 类对象 c 里面黑框圈中的部分是基类 B 的内容。</li>
<li>类 A 包括两个虚函数，故 vtbl_A 包含两个指针，分别指向 A::vfunc1() 和 A::vfunc2().</li>
<li>类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了 B::vfunc1() 函数，故 vtbl_B 的两个指针分别指向 B::vfunc1() 和 A::vfunc2().</li>
<li>类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了 C::vfunc2() 函数，故 vtbl_C 的两个指针分别指向 B::vfunc1() (指向继承的最近的一个类的函数) 和 C::vfunc2().</li>
<li>因此一共有四个非虚函数，以及四个虚函数。</li>
<li>图三看起来有点复杂，但是核心还是：<mark>对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数</mark>。抓住这个核心思想，就可以快速将这几个类的对象模型在脑中想象出来！</li>
<li>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</li>
</ol>
<p>假设我们定义一个类 B 的对象如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>这里要注意了，虽然 <code>p</code> 是基类的指针，只能指向基类的部分，但是虚表指针也属于基类的部分，亦即 <code>b</code> 实例内存中的虚表指针也属于基类部分。所以 <code>p</code> 可以访问到对象 <code>bObject</code> 的虚表指针. <code>bObject</code> 的虚表指针指向类 <code>B</code> 的虚表，所以 <code>p</code> 可以访问到 <code>vtbl_B</code>. </mark></p>
<p>当我们使用 <code>p</code> 来调用 <code>vfunc1()</code> 函数时候，会发横什么现象?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B bObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在执行 <code>p-&gt;vfunc1()</code> 时会发现 <code>p</code> 是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤：</p>
<ol>
<li>首先，根据虚表指针 <code>p-&gt;__vptr</code> 来访问对象 <code>bObject</code> 对应的虚表。虽然指针 <code>p</code> 是基类 <code>A*</code> 类型，但是 <code>*__vptr</code> 也是基类的一部分，所以可以通过 <code>p-&gt;__vptr</code> 访问到对象对应的虚表。</li>
<li>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 <code>p-&gt;vfunc1()</code> 的调用，<code>vtbl_B</code> 的第一项即是 <code>vfunc1</code> 对应的条目。</li>
<li>最后，根据虚表中找到的函数指针，调用函数。从上图可以看出，<code>vtbl_B</code> 的第一项指向 <code>B::vfunc1()</code>，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>B::vfunc1()</code> 函数。</li>
</ol>
<p>而如果 <code>p</code> 指向类 <code>A</code> 的对象，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A aObject;  <span class="comment">// bObject 是 B 的一个对象，故包含一个虚表指针，指向类 B 的虚表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来用基类指针指向子类对象</span></span><br><span class="line">    A *p = &amp; aObject;</span><br><span class="line">    p-&gt;vfunc1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>aObject</code> 在创建时，它的虚表指针 <code>__vptr</code> 已设置为指向 <code>vtbl_A</code>，这样 <code>p-&gt;__vptr</code> 就指向 <code>vtbl_A</code>. <code>vfunc1</code> 在 <code>vtbl_A</code> 对应的条目指向了 <code>A::vfunc1()</code> 函数，所以 <code>p-&gt;vfunc1()</code> 实质会调用 <code>A::vfunc1()</code> 函数。</p>
<p><mark>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。</mark></p>
<p>[动态绑定]</p>
<ol>
<li>先明确<code>静态绑定</code>。编译器对静态绑定的处理是会生成一个 <code>call some_address</code> 的汇编命令。这个 <code>some_address</code> 是固定了的。</li>
<li>而我们把<mark>经过虚表调用虚函数的过程称为动态绑定</mark>，其表现出来的现象称为<mark>运行时多态</mark>。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</li>
</ol>
<p>那么，<mark>什么时候会执行函数的动态绑定？</mark>这需要符合以下三个条件。</p>
<ol>
<li>通过指针来调用函数</li>
<li>指针 upcast 向上转型（继承类向基类的转换称为 upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ol>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h4 id="基类指针调用子类非虚函数"><a href="#基类指针调用子类非虚函数" class="headerlink" title="基类指针调用子类非虚函数"></a>基类指针调用子类非虚函数</h4><p>使用基类的指针可以去调用子类的非虚函数吗？<br>回忆一下好像没有这么用过，一直都是拿基类指针调用了子类的虚函数。</p>
<p>事实上这个是可以的。但是要注意，<mark>此时被调用的函数实际上是基类的函数！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123;x=i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class show():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A class virtual display():x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> i,<span class="keyword">int</span> j):A(i) &#123; y=j;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class show(): y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span><span class="comment">//前面有无virtual都可以</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B class virtual display():y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a(5),*pa;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    pa=&amp;b;</span><br><span class="line">    pa-&gt;show();</span><br><span class="line">    pa-&gt;<span class="built_in">display</span>();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析</p>
<ol>
<li>这个例子里面类 B 继承了类 A，而类 A 和类 B 都有一个 show() 函数。</li>
<li>类B的实例 <code>b</code> 里面含有基类部分，也含有自己的部分。注意了！<mark>基类部分里面含有一个虚表指针，也含有一个 A::show()；而子类的部分呢含有 B::show()。</li>
<li><code>pa</code> 是基类的指针，因此指向的是子类实例<code>b</code>中的基类部分那一块！所以调用的 <code>pa-&gt;show()</code> 是基类的 <code>A::show()</code>。</li>
<li>而 <code>pa-&gt;display()</code> 则通过基类部分的虚表指针指向了子类 <code>B</code> 的虚函数表，然后调用到了 <code>B::display()</code>。</li>
</ol>
<p>最终的输出是</p>
<pre><code>A class show():x=10
B class virtual display():y=20</code></pre><p>[总结]<br>基类的指针指向派生类的对象，当调用同名的成员函数时：</p>
<ol>
<li>如果在基类中成员函数为<font color='red'>虚函数</font>，那么基类指针调用的就是<font color='red'>派生类</font>的同名函数。<code>virtual void display()</code>;<ol>
<li>可以这么理解：因为该函数是虚的，所以会找真正实现的那个函数，所以调用派生类B中的 B class virtual display.</li>
</ol>
</li>
<li>如果基类中成员函数为<font color='red'>非虚函数</font>，则调用的是<font color='red'>基类</font>的成员函数。<code>void show()</code>;<ol>
<li>因为基类是非虚的，已经完全实现了，所以没有必要再调用派生类的了，就调用基类的A class show()</li>
</ol>
</li>
</ol>
<h4 id="底层解释-汇编语言"><a href="#底层解释-汇编语言" class="headerlink" title="底层解释-汇编语言"></a>底层解释-汇编语言</h4><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-object-model-dynamic-binding-2.png" alt=""></p>
<h4 id="用-C-能实现吗"><a href="#用-C-能实现吗" class="headerlink" title="用 C 能实现吗?"></a>用 C 能实现吗?</h4><p>如果我们不使用这一套体系，用 C 一般怎么实现用一个指针的列表去访问各个子类的函数呢？</p>
<p>通常情况下我们必须针对每个指针，通过一系列的 if else 语句先去判断是哪一类对象的函数，然后再去调用相应的函数。</p>
<p>但是这样子不好的是，如果后来又新加了一个类别，那么我们就必须去重新改动 if else 那一部分的代码，多添加一个 else 语句去支持新增加的类别。</p>
<h4 id="虚函数另一用法-template-method"><a href="#虚函数另一用法-template-method" class="headerlink" title="虚函数另一用法: template method"></a>虚函数另一用法: template method</h4><p>这里的 template method 是一种设计模式，具体可以参考<a href="https://zheng-xing.github.io/2020/01/15/design-pattern/#Template-Method" target="_blank" rel="noopener">here</a>.</p>
<h3 id="构造函数可以是虚函数吗？"><a href="#构造函数可以是虚函数吗？" class="headerlink" title="构造函数可以是虚函数吗？"></a>构造函数可以是虚函数吗？</h3><h4 id="C-不可以"><a href="#C-不可以" class="headerlink" title="C++ 不可以"></a>C++ 不可以</h4><p>简答回答是不可以！C++ 的作者在他<a href="http://www.stroustrup.com/bs_faq2.html#virtual-ctor" target="_blank" rel="noopener">个人主页</a>已经回答了，原样复制过来</p>
<p>A virtual call is a mechanism to get work done given partial information. In particular, “virtual” allows us to call a function knowing only an interfaces and not the exact type of the object. <mark>To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a “call to a constructor” cannot be virtual.</mark></p>
<p>意思就是，虚拟函数调用只需要知道部分信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。<br>如果你调用一个虚拟构造函数，编译器怎么知道你想构建继承树上的哪种类型呢？所以这在逻辑上是一个悖论。</p>
<p>Techniques for using an indirection when you ask to create an object are often referred to as “Virtual constructors”. For example, see TC++PL3 15.6.2.</p>
<p>For example, here is a technique for generating an object of an appropriate type using an abstract class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span>  <span class="comment">// interface to object creation functions</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user</span><span class="params">(<span class="keyword">const</span> F&amp; fac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* p = fac.make_an_A(); <span class="comment">// make an A of the appropriate type</span></span><br><span class="line">    B* q = fac.make_a_B();  <span class="comment">// make a B of the appropriate type</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FX</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AX(); &#125; <span class="comment">// AX is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BX();  &#125; <span class="comment">// BX is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FY</span> :</span> F &#123;</span><br><span class="line">    <span class="function">A* <span class="title">make_an_A</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AY(); &#125; <span class="comment">// AY is derived from A</span></span><br><span class="line">    <span class="function">B* <span class="title">make_a_B</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> BY();  &#125; <span class="comment">// BY is derived from B</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FX x;</span><br><span class="line">    FY y;</span><br><span class="line">    user(x);    <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(y);    <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line"></span><br><span class="line">    user(FX()); <span class="comment">// this user makes AXs and BXs</span></span><br><span class="line">    user(FY()); <span class="comment">// this user makes AYs and BYs</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a variant of what is often called “the factory pattern”. The point is that user() is completely isolated from knowledge of classes such as AX and AY.</p>
<h4 id="Delphi-却支持"><a href="#Delphi-却支持" class="headerlink" title="Delphi 却支持"></a>Delphi 却支持</h4><p>那么Delphi为什么能够支持虚拟构造函数呢？Delphi有一种类类型，储存着某个类的meta data。<br>TClass是所有自定义类类型（不是自定义类型）的祖先类。构建一个新对象的时候，事实上是调用TClass的某个子类（即自定义类类型）的虚拟Create方法，而这个子类储存了相关类的meta<br>data，因此避免了“虚拟构造函数不知道具体类型信息”的问题。这可以视为factory<br>pattern的一种通用实现，在语言级别非常优雅和完美地解决了这个问题。</p>
<p>资料来自<a href="https://www.zhihu.com/question/35632207/answer/63936329" target="_blank" rel="noopener">这里</a></p>
<h1 id="fundamental-concept-基本概念"><a href="#fundamental-concept-基本概念" class="headerlink" title="fundamental concept 基本概念"></a>fundamental concept 基本概念</h1><h2 id="heap-or-stack-memory"><a href="#heap-or-stack-memory" class="headerlink" title="heap or stack memory"></a>heap or stack memory</h2><p><mark>C语言里面不能把一个很长的 array 放到 stack 上。</mark></p>
<p>使用 C 语法时候</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一个语句会出现 stack overflow 错误</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式一</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="built_in">malloc</span>(<span class="number">1000000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式二</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式三</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">1000000</span>];  <span class="comment">// allocated in data segment</span></span><br></pre></td></tr></table></figure>

<p>使用 C++ STL 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// will allocate the vector, i.e. the header info, on the stack, but the elements on the free store "heap".</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * vect = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// allocates everything on the free store.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>*&gt; vect;</span><br><span class="line"><span class="comment">// will allocate the vector on the stack and a bunch of pointers on the free store</span></span><br><span class="line"><span class="comment">// But where these pointer is determined by how you use them</span></span><br><span class="line"><span class="comment">// You could point element 0 to the free store and element 1 to the stack.</span></span><br></pre></td></tr></table></figure>

<h2 id="nullptr-and-std-nullptr-t-C-11"><a href="#nullptr-and-std-nullptr-t-C-11" class="headerlink" title="nullptr and std::nullptr_t (C++11)"></a>nullptr and std::nullptr_t (C++11)</h2><ol>
<li>C++11 允许使用 nullptr 来代替 0 或者 NULL，to specify that a pointer refers to no value (which differs from having an undefined value). This new feature especially helps to avoid mistakes that occurred when a null pointer was interpreted as an integral value. </li>
</ol>
<p>举例来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有如下两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方式会调用到哪个函数呢？</span></span><br><span class="line">f(<span class="number">0</span>);          <span class="comment">// calls f(int)</span></span><br><span class="line">f(<span class="literal">NULL</span>);       <span class="comment">// calls f(int) if NULL is 0, ambiguous otherwise</span></span><br><span class="line">f(<span class="literal">nullptr</span>);    <span class="comment">// calls f(void*)</span></span><br></pre></td></tr></table></figure>

<ol>
<li><font color='red'>nullptr</font> is a new keyword. It automatically converts into each pointer type but not to any integral type. It has type <font color='red'>std::nullptr_t</font>, defined in <code>&lt;</code><font color='red'>cstddef</font><code>&gt;</code>, so you can now even overload operations for the case that a null pointer is passed. Note that <font color='red'>std::nullptr_t</font> counts as a fundamental data type.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/stddef.h 文件包含有如下语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="keyword">nullptr_t</span></span>;</span><br></pre></td></tr></table></figure>


<h2 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h2><p>Most of the times compilers will do optimization to the code to speed up the program. For example in the below code,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>( a == <span class="number">10</span>)&#123;</span><br><span class="line">     <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compiler may think that value of ‘a’ is not getting changed from the program and replace it with ‘while(true)’, which will result in an infinite loop. In actual scenario the value of ‘a’ may be getting updated from outside of the program.<br>Volatile keyword is used to tell compiler that the variable declared using volatile may be used from outside the current scope so that compiler wont apply any optimization. This matters only in case of multi-threaded applications.<br>In the above example if variable ‘a’ was declared using volatile, compiler will not optimize it. In shot, value of the volatile variables will be read from the memory location directly.</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>此处参考了《Effective C++》.</p>
<h3 id="什么是-const"><a href="#什么是-const" class="headerlink" title="什么是 const"></a>什么是 const</h3><p><code>const</code> objects 就是这个 object 不能被改变，<mark>编译器在编译的时候会检查程序有没有试图去修改 object 的内容</mark>。</p>
<p>如果你声明某个 variable 是 const，在声明的那个语句中你就必须给它初始化！因为后面你就没有机会再修改了！编译器会发现你试图对 <code>const</code> object 修改，就编译错误！</p>
<h3 id="几种用途"><a href="#几种用途" class="headerlink" title="几种用途"></a>几种用途</h3><p><code>const</code> 可以用在如下几个地方:</p>
<ol>
<li>Outside of classes, we can use it for constants at global or namespace scope.</li>
<li>For objects declared <code>static</code> at file, function, or block scope.</li>
<li>Inside classes, can be used for both static and non-static data members.</li>
</ol>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, non-const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;    <span class="comment">// non-constant pointer, const data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// constant pointer, non-constant data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> p = greeting;    <span class="comment">// const pointer, const data</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子就需要记住一点: <mark> 如果 <code>const</code> 出现在 <code>*</code> 的左边，那么数据是 <code>const</code> 的；如果 <code>const</code> 在 <code>*</code> 的右边，那么指针是 <code>const</code> 的。</mark></p>
<font color='red'>
    易混淆！当数据是 `const` 时候，`type` 和 `const` 这两个先后顺序可以改变的。谁在前面都一样。
</font>

<p>看这个例子，两种表示方式没有区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Widget <span class="keyword">const</span> *pw)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="const-iterator"><a href="#const-iterator" class="headerlink" title="const iterator"></a>const iterator</h3><p><mark>注意 STL iterator 有专门的 <code>const_iterator</code> 语法，表示这个迭代器不会修改 container 里面的数据内容。直接在普通 iterator 的前面加上 <code>const</code> 的意思是另外一种，表示这个迭代器本身是 constant 的。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();    <span class="comment">// iter acts like a T* const, 即指针是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 操作可以执行。因为数据不是 const</span></span><br><span class="line">++iter;                                            <span class="comment">// 报错！iter 是 const 类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();   <span class="comment">// cIter acts like a const T*, 即数据是 const</span></span><br><span class="line">*iter = <span class="number">10</span>;                                        <span class="comment">// 报错！*cIter is const</span></span><br><span class="line">++iter;                                            <span class="comment">// 没毛病! 改变指针</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><mark>If the container itself is const, you can only use const iterator to access its elements.</mark></li>
<li>==begin()== returns const_iterator if the container is const, and returns non-const iterator if the container is not const. (But you can always use ==auto==)</li>
<li>cbegin(), cend() returns const_iterator.</li>
</ol>
<h3 id="类成员函数的-const"><a href="#类成员函数的-const" class="headerlink" title="类成员函数的 const"></a>类成员函数的 const</h3><p><mark>某些类里面的函数要不要加 const 并不是无所谓的！！！</mark>见这个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class complex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    complex(double r &#x3D; 0, double i &#x3D; 0) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    complex&amp; operator +&#x3D; (const complex&amp;);</span><br><span class="line">    double real() const &#123;return m_r;&#125;</span><br><span class="line">    double imag() const &#123;return m_i;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_r, m_i;</span><br><span class="line">    friend complex&amp; __doapl (complex*, const complex&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    const complex c1(2, 1);</span><br><span class="line">    cout &lt;&lt; c1.real();</span><br><span class="line">    cout &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>因为这里 complex c1 被声明成了 const 类型，那么作用在这个 object 身上的所有函数也都必须声明成 const 类型，不管这个函数本身是否有修改 c1 内容！！！所以 real() 的定义必须加上 const, 这个例子里面是加了的。如果没加的话就会有错。</mark></p>
<p><font color='red'>这个例子告诉我们，在设计成员函数的时候，可以加 <code>const</code> 的时候一定要加上，以避免其他使用者犯错。他们会觉得这是类设计者的错误！</font></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-const-intro.png" alt="const"></p>
<h3 id="不加const为啥不行"><a href="#不加const为啥不行" class="headerlink" title="不加const为啥不行"></a>不加const为啥不行</h3><ol>
<li>上面也提到了，一旦某些时候你把一个 object 声明成了 const，那么这个 object 只能调用那些 const 成员函数。<ol>
<li>至于什么时候会把一个 <code>object</code> 声明成 <code>const</code>。比如函数调用时候，pass by reference to const.</li>
</ol>
</li>
</ol>
<p>第二个例子，重载乘法运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rational a, b, c;</span><br><span class="line">    <span class="keyword">if</span>(a * b = c)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子里面，由于程序员不小心把<code>==</code> 写成了 <code>=</code>。这个时候如果你按照上面把乘法运算符重载后，返回的是 <code>const</code> 类型，那么编译器在这里就会提醒你不能给 <code>a*b</code> 的结果赋值，方便你检查出这个 typo 了。</p>
<p>而如果你没有把返回值定义成 <code>const</code> 类型，就会</p>
<h3 id="physical-vs-logical-constness"><a href="#physical-vs-logical-constness" class="headerlink" title="physical vs logical constness"></a>physical vs logical constness</h3><p>编译器只会检查 physical constness 或者叫做 bitwise constness. 即检查是否对一个 const object 的直接内容作了修改。<br>如果没有，就可以编译通过。</p>
<p><mark>但是！如果类对象里含有指针，那么对指针指向的空间的内容进行修改，编译器是不会报错的！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pString[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 operator[] 的定义里面并没有修改内容啊，所以编译器不报错。</span></span><br><span class="line"><span class="comment">// 但是</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> MyString <span class="title">str</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;str[<span class="number">0</span>];</span><br><span class="line">    *pc = <span class="string">"J"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数里面事实上修改了 str 的内容，这与 str 是一个 const object 矛盾了！！！</span></span><br><span class="line"><span class="comment">// 可惜编译器发现不了这个问题！！！</span></span><br></pre></td></tr></table></figure>

<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>有时候你希望 const object 的意思是对 object 的某些数据内容不能修改，但是 object 可能也含有一些辅助数据，你希望 const 不作用在它们上面，那怎么办呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pString;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> strLength;        <span class="comment">// these data members may always be modified,</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;      <span class="comment">// even in const member functions</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">MyString::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;     <span class="comment">// 如果没有上面的 mutable 关键字，那么这个函数是 const 类型</span></span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;              <span class="comment">// 不可以对变量 strLength, lengthIsValid 进行修改！</span></span><br><span class="line">        strLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pString);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="noexcept-c-11"><a href="#noexcept-c-11" class="headerlink" title="noexcept c++11"></a>noexcept c++11</h2><p>注：</p>
<ol>
<li>第一个图中这个例子好二啊！就想说：当我不暴怒的时候我是不会暴怒的。。。</li>
<li>第二个图里之所以定义了两个 move constructor 是因为作者肯定发现了某种比 copy constructor 更高效的实现方法（这里并没有给出细节）。<ol>
<li>这个时候为了让编译器去调用这个 move constructor 就需要加上 noexcept 关键字。</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-noexcept.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-noexcept-2.png" alt=""></p>
<h2 id="decltype-c-11"><a href="#decltype-c-11" class="headerlink" title="decltype c++11"></a>decltype c++11</h2><p>[decltype简介]</p>
<ol>
<li>我们之前使用的<code>typeid</code>运算符来查询一个变量的类型，这种类型查询在运行时进行。<code>RTTI</code>机制为每一个类型产生一个<code>type_info</code>类型的数据，而<code>typeid</code>查询返回的变量相应<code>type_info</code>数据，通过<code>name</code>成员函数返回类型的名称。同时在<code>C++11</code>中<code>typeid</code>还提供了<code>hash_code</code>这个成员函数，用于返回类型的唯一哈希值。<mark>RTTI会导致运行时效率降低，且在泛型编程中，我们更需要的是编译时就要确定类型，RTTI并无法满足这样的要求。编译时类型推导的出现正是为了泛型编程，在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导</mark>。</li>
<li>而编译时类型推导，除了我们说过的auto关键字，还有本文的decltype。</li>
<li>decltype与auto关键字一样，用于进行<mark>编译时类型推导</mark>，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</li>
</ol>
<p>[用法]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推导出表达式类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a;    <span class="comment">// 推导结果为 int. 因此 a 的类型是 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 using/typedef 合用，用于定义类型。</span></span><br><span class="line"><span class="comment">// 这样子就和 auto 一样，提高了代码的可读性。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">size_t</span> = <span class="keyword">decltype</span>(<span class="keyword">sizeof</span>(<span class="number">0</span>));    <span class="comment">// sizeof(a) 的返回值为 size_t 类型。</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ptrdiff_t</span> = <span class="keyword">decltype</span>((<span class="keyword">int</span>*)<span class="number">0</span> - (<span class="keyword">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">nullptr_t</span> = <span class="keyword">decltype</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(vec.<span class="built_in">begin</span>())</span> vectype</span>;</span><br><span class="line"><span class="keyword">for</span>(vectype i = vec.<span class="built_in">begin</span>(); i != vec.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重用匿名类型。</span></span><br><span class="line"><span class="comment">// 在C++中，我们有时候会遇上一些匿名类型，如:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d ;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;anon_s;</span><br><span class="line"><span class="comment">// 而借助decltype，我们可以重新使用这个匿名的结构体</span></span><br><span class="line"><span class="keyword">decltype</span>(anon_s) as ;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型编程中结合auto，用于追踪函数的返回值类型。这也是decltype最大的用途了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line">auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx*_Ty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面以侯捷老师的几个图镇楼！主要是介绍了 decltype 的三种用法！不过我第一次看视频后还是比较懵，所以加了上面的这些介绍。<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-1.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-3.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-4.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-5.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-decltype-6.png" alt=""></p>
<h2 id="lambda-c-11"><a href="#lambda-c-11" class="headerlink" title="lambda c++11"></a>lambda c++11</h2><p>note</p>
<ol>
<li>同时可以看一下后面的 “三种定义 Comparison Function 的方法”</li>
<li>注意看一下第六，第七张图！<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-1.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-2.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-3.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-4.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-5.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-6.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-7.png" alt=""><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-cpp11-lambda-8.png" alt=""></li>
</ol>
<h2 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h2><ol>
<li>相同 class 的各个 objects 互为 friends（友元）。</li>
</ol>
<h2 id="三种-function-parameters"><a href="#三种-function-parameters" class="headerlink" title="三种 function parameters"></a>三种 function parameters</h2><ol>
<li>someFunction(vector<double> vec)</li>
<li>someFunction(const vector<double>&amp; vec)</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Local variables that are declared to be static </span></span><br><span class="line"><span class="comment">are preserved across invocations of the function.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Thus, we'll construct and initialize the string name</span></span><br><span class="line"><span class="comment">only on the first call to someFunction.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">someFunction</span><span class="params">(balabala)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> name = <span class="string">"Zheng Xing"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-static-intro.png" alt=""></p>
<p>注意点：</p>
<ol>
<li>non-static data members 存在于每个 instances object 里面；而 static data members, member functions, static member functions 是 class 拥有的，所有的 instances 共享！</li>
<li>什么时候使用 static data members<ol>
<li>当你这一个 class 的所有 objects 都拥有并且一样的那些数据</li>
</ol>
</li>
<li>什么时候用 static member functions<ol>
<li><mark> static member function 与正常的 member functions 的区别在于静态的函数没有 this 指针，因此也就无法访问非静态的数据，它只能够处理 static data members.</li>
</ol>
</li>
<li>调用 static member functions的两种方法<ol>
<li>通过 class name 调用</li>
<li>通过 object 调用</li>
<li>参考下面的代码</li>
</ol>
</li>
<li>一个概念<ol>
<li>Static objects inside functions are known as local static objects (because they’re local to a function).</li>
<li>The other kinds of static objects are known as non-local static objects.</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> m_rate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_rate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; x)</span> </span>&#123;m_rate = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Account::m_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Account::set_rate(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    Account a;</span><br><span class="line">    a.set_rate(<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个经典的应用是设计 Singleton 的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">setup</span>() &#123;<span class="comment">//...&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A();</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; rhs);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A::getInstance().setup();</span></span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li>reference data must be assigned at initialization</li>
<li>reference data cannot be reassigned</li>
</ol>
<p>注意两个概念</p>
<ol>
<li>return by value vs return by reference (to const)</li>
<li>pass by value vs pass by reference</li>
</ol>
<p>reference 有指针的速度，同时使用的时候很方便，在传递的时候不需要知道类型到底是 value 还是 reference。</p>
<p><mark> 函数是否返回 reference 要看你是不是在函数里面搞了一个临时变量，是的话，千万不能返回 reference.</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="built_in">complex</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; a, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(a.real() + b.real(), a.imag() + b.imag());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>same signature</mark><br>下面两个函数不能同时存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span> </span>&#123;&#125;    <span class="comment">// Ambiguity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多提一句，可以通过添加 const 来区别两个函数。</span></span><br><span class="line"><span class="comment">// 比如下面两个函数是不同的，编译器不会报错。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="and-初始化方法"><a href="#and-初始化方法" class="headerlink" title="() and = 初始化方法"></a>() and = 初始化方法</h2><ol>
<li>container<T> c(c2)<ol>
<li>defines c as a container that is a copy of c2</li>
</ol>
</li>
<li>container<T> c = c2<ol>
<li>same</li>
</ol>
</li>
</ol>
<h2 id="default-value-initialization"><a href="#default-value-initialization" class="headerlink" title="default/value initialization"></a>default/value initialization</h2><ol>
<li>local variables of built-in type that are not explicitly initialized are undefined.</li>
<li>class type says what initializer to use if there is not one specified.</li>
<li>(Accerated C++, P125) When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is ==value-initialized==, which, for simple types such as int, is equivalent to setting the value to zero.</li>
</ol>
<h2 id="overloading-1"><a href="#overloading-1" class="headerlink" title="overloading"></a>overloading</h2><p>Several functions with the same name.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>) : m_r(r), m_i(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">complex</span>&amp; <span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_i;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_r, m_i;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">complex</span>&amp; __doapl (<span class="built_in">complex</span>*, <span class="keyword">const</span> <span class="built_in">complex</span>&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; __doapl(<span class="built_in">complex</span>* ths, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths;        <span class="comment">// 返回指针所指向的东西！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">complex</span>&amp; complext::<span class="keyword">operator</span> += (<span class="keyword">const</span> <span class="built_in">complex</span>&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>, r);    <span class="comment">// 任何一个成员函数都有一个隐藏的 this 指针！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> <span class="built_in">complex</span>&amp; x)&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"("</span> &lt;&lt; real(x) &lt;&lt; <span class="string">","</span> &lt;&lt; imag(x) &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">complex</span> <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.real();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.imag();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里操作符 &lt;&lt; 的结果可以返回 ostream reference.</p>
<p><mark>注意，操作符 += 的重载的返回值不能是 void 类型哦！你要考虑到有人可能会连续加的情况！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c3 += c2 += c1;</span><br></pre></td></tr></table></figure>

<p><mark><a href="https://en.cppreference.com/w/cpp/language/operators" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/operators</a></mark><br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-operator-overloading-example-1.png" alt=""></p>
<h3 id="重载-lt-lt-符号"><a href="#重载-lt-lt-符号" class="headerlink" title="重载 &lt;&lt; 符号"></a>重载 &lt;&lt; 符号</h3><p>此处的东西来自<a href="https://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/" target="_blank" rel="noopener">这里</a>.</p>
<p>最简单的思想：若想去打印 object 内容，我们可以定义一些 public 方法去获得私有变量内容，然后输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现支持我们这样的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; <span class="built_in">point</span>.getX() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getY() &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">point</span>.getZ() &lt;&lt; <span class="string">")"</span>;</span><br></pre></td></tr></table></figure>

<p>进阶思路一：能不能定一个函数来重复使用呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x, m_y, m_z;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">double</span> x=<span class="number">0.0</span>, <span class="keyword">double</span> y=<span class="number">0.0</span>, <span class="keyword">double</span> z=<span class="number">0.0</span>): m_x(x), m_y(y), m_z(z)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_z; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">", "</span> &lt;&lt; m_z &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><mark>注意 print 虽然写到了 class 定义里面，但是它不是 member function。</mark></p>
<p>上面的思路确实比最初的思路好了，但是它的缺点在于我们不能在 cout 的中间使用，必须得这么用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span>;                <span class="comment">// 这里要分成三个命令来写，不能串起来了。。。</span></span><br><span class="line">    point.print();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶思路二：能不能这样子写？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">point</span><span class="params">(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"My point is: "</span> &lt;&lt; <span class="built_in">point</span> &lt;&lt; <span class="string">" in Cartesian space.\n"</span>;</span><br></pre></td></tr></table></figure>

<p>答案是可以的，就是去重载 &lt;&lt; 操作符。</p>
<p><mark>[几个注意点]</mark></p>
<ol>
<li><font color="red">重载函数的定义最开始要注明 friend 关键字，因为这个函数要获得私有变量信息！</font></li>
<li><font color="red">这个重载函数不能定义成 member function, 即不能加上 “String::operator&lt;&lt;”, 因为 member function 自动得把当前 object 作为第一个参数传递给函数。<ol>
<li>这样子首先顺序就不对了，因为我们希望 cout 作为第一个参数，</li>
<li>其次呢，我们如果放两个参数进去 cout 和 Point&amp; ，但是调用这个函数的 object 本身也会传递一个 this，这样子就变成三个参数了。 </font></li>
</ol>
</li>
<li><font color="red">注意返回的类型是 reference 类型，不能是 void，否则无法使用多个操作符串起来用！！！也不能返回 value 类型，因为 cout 本身也不允许 being copied.</font></li>
<li><font color="red"></font></li>
</ol>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载 ="></a>重载 =</h3><p>以上面的 complex 类来考虑，如果要支持 c3 = c1 + c2 的操作，需要如何重载 = 操作符？</p>
<p><mark>因为 c1 + c2 会返回 temporary object, 所以我们不能传递一个 reference, 如果要使用 reference, 需要传递一个 const reference.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个实现是错误的！！！</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(other.real(), other.imag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误原因</span></span><br><span class="line"><span class="comment">// 1. 函数里面新建了一个 temporary object，它是没法返回给 complex&amp; 类型的</span></span><br><span class="line"><span class="comment">// 2. 这个东西其实是"拷贝赋值函数"，因此它是属于当前 class 的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的实现</span></span><br><span class="line"><span class="built_in">complex</span>&amp; <span class="built_in">complex</span>::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">complex</span>&amp; other)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;real = other.real();</span><br><span class="line">    <span class="keyword">this</span>-&gt;imag = other.imag();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><p>就是一个可以被赋值的东西。denote a nontemporary object.</p>
<ol>
<li>variable</li>
<li>reference</li>
<li>the result of calling a function that returns a reference.</li>
</ol>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>==( * iter).name== is the same as ==iter-&gt;name==</p>
<h2 id="initialization"><a href="#initialization" class="headerlink" title="initialization"></a>initialization</h2><h3 id="uniform-initialization-C-11"><a href="#uniform-initialization-C-11" class="headerlink" title="uniform initialization C++11"></a>uniform initialization C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-uniform-initialization.png" alt=""></p>
<h3 id="initializer-list-C-11"><a href="#initializer-list-C-11" class="headerlink" title="initializer list C++11"></a>initializer list C++11</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-1.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-3.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-4.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-5.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-initialization-initializer-list-9.png" alt=""></p>
<h2 id="三种定义-Comparison-Function-的方法"><a href="#三种定义-Comparison-Function-的方法" class="headerlink" title="三种定义 Comparison Function 的方法"></a>三种定义 Comparison Function 的方法</h2><h3 id="一：Define-operator-lt"><a href="#一：Define-operator-lt" class="headerlink" title="一：Define operator&lt;()"></a>一：Define operator&lt;()</h3><p>在自定义的数据结构里面定义好 &lt; 运算符的意义.</p>
<p>注意：operator&lt;() 参数只有一个！！！并且 operator 是 const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sort the edges in decreasing order</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &gt; other.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果你不喜欢这种语法，只有一个参数，</span></span><br><span class="line"><span class="comment">却比较两个objects，那么你可以用下面的方式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge a, Edge b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This way it is much clearer that you are </span></span><br><span class="line"><span class="comment">comparing a and b, not *this and other. </span></span><br><span class="line"><span class="comment">Note also that friend function is like static function; </span></span><br><span class="line"><span class="comment">it cannot access member variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二：定义-comparison-function"><a href="#二：定义-comparison-function" class="headerlink" title="二：定义 comparison function"></a>二：定义 comparison function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stringVec.<span class="built_in">begin</span>(), stringVec.<span class="built_in">end</span>(), comp);</span><br></pre></td></tr></table></figure>

<h3 id="三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object"><a href="#三：定义-operator-，实际就是-functor。但是要注意-map-set-里面传入的是type-而sort-的第三个参数不能传递这个-type，必须传递一个-object" class="headerlink" title="三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object."></a>三：定义 operator()()，实际就是 functor。但是要注意, map, set 里面传入的是type, 而sort 的第三个参数不能传递这个 type，必须传递一个 object.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了上面的定义，你就可以这样用：</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, cmp&gt; myset;  <span class="comment">// cmp 是 type</span></span><br><span class="line"><span class="comment">// 或者这样（cmp 也是 type）</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, cmp&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个错误用法</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="comment">// cmp 是type，sort需要 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法-1</span></span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmp());</span><br><span class="line"><span class="comment">// 正确写法-2</span></span><br><span class="line">cmp cmpobject;</span><br><span class="line">sort(stringArray.<span class="built_in">begin</span>(), stringArray.<span class="built_in">end</span>(), cmpobject);</span><br></pre></td></tr></table></figure>
<p>注意，虽然 set, map 里面只能使用 functor/type</p>
<p>实际上他们也可以用 function 的方法，但是容易用错，</p>
<p>不过这里还是给出来看一下。</p>
<ol>
<li><code>comp</code> 比较函数的 type 我们知道是 <code>bool (*)(string, string)</code> 类型！</li>
<li>lambda 函数的类型我们不知道！所以这里用了 <code>auto</code> 和 <code>decltype</code> 关键字来巧妙地传递 lambda function 的 type.<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">You can use comparison function for STL containers</span></span><br><span class="line"><span class="comment">by passing them as the first argument of the constructor, </span></span><br><span class="line"><span class="comment">and specifying the function type as the additional template argument. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">size</span>() &lt; str2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;string, bool (*)(string, string)&gt; myset(comp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lambda function 也是一个 object, 使用 decltype 可以获得 type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp = [](<span class="built_in">string</span> a, <span class="built_in">string</span> b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>; &#125;;</span><br><span class="line">priority_queue&lt;string, vector&lt;int&gt;, decltype(comp)&gt; mypq(comp);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后的用法可以参考 <code>decltype</code>.</p>
<h3 id="二-vs-三"><a href="#二-vs-三" class="headerlink" title="二 vs 三"></a>二 vs 三</h3><ol>
<li>方法三 compiler 很容易 inline，所以效率高！lambda 函数默认是 inline 的。</li>
</ol>
<h3 id="STL-内置的函数对象"><a href="#STL-内置的函数对象" class="headerlink" title="STL 内置的函数对象"></a>STL 内置的函数对象</h3><p>STL提供的函数对象</p>
<ol>
<li>用于算术运算的函数对象：<ol>
<li>一元函数对象(一个参数) ：negate</li>
<li>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</li>
</ol>
</li>
<li>用于关系运算、逻辑运算的函数对象(要求返回值为bool)<ol>
<li>一元谓词(一个参数)：logical_not</li>
<li>二元谓词(两个参数)：equalto、notequalto、greater、less、greaterequal、lessequal、logicaland、logical_or</li>
</ol>
</li>
</ol>
<h1 id="泛型设计"><a href="#泛型设计" class="headerlink" title="泛型设计"></a>泛型设计</h1><h2 id="泛型设计的基本概念"><a href="#泛型设计的基本概念" class="headerlink" title="泛型设计的基本概念"></a>泛型设计的基本概念</h2><h3 id="目的：为啥需要泛型程序设计"><a href="#目的：为啥需要泛型程序设计" class="headerlink" title="目的：为啥需要泛型程序设计"></a>目的：为啥需要泛型程序设计</h3><ol>
<li>编写不依赖于具体数据类型的程序</li>
<li>将算法从具体的数据结构中抽象出来，成为通用的</li>
<li>C++ 的模板为泛型程序设计奠定了关键的基础</li>
</ol>
<h3 id="术语一：概念"><a href="#术语一：概念" class="headerlink" title="术语一：概念"></a>术语一：概念</h3><p>概念是指：用来界定具备一定功能的数据类型。例如：</p>
<ol>
<li>将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable</li>
<li>将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable</li>
<li>将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable</li>
</ol>
<p>对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：</p>
<ol>
<li>Sortable既是Comparable的子概念，也是Assignable的子概念</li>
</ol>
<h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><p>模型（model）：符合一个概念的数据类型称为该概念的模型，例如：</p>
<ol>
<li>int型是Comparable概念的模型。</li>
<li>静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）</li>
</ol>
<h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><p>很多STL的实现代码就是使用概念来命名模板参数的。</p>
<p>为概念赋予一个名称，并使用该名称作为模板参数名。例如</p>
<p>表示insertionSort这样一个函数模板的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Sortable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">insertionSort</span>(<span class="title">Sortable</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>);</span></span><br></pre></td></tr></table></figure>

<h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><h3 id="STL的基本组件"><a href="#STL的基本组件" class="headerlink" title="STL的基本组件"></a>STL的基本组件</h3><ol>
<li>容器（container）</li>
<li>迭代器（iterator）</li>
<li>函数对象（function object）</li>
<li>算法（algorithms）</li>
</ol>
<h3 id="STL的基本组件间的关系"><a href="#STL的基本组件间的关系" class="headerlink" title="STL的基本组件间的关系"></a>STL的基本组件间的关系</h3><ol>
<li>Iterators（迭代器）是算法和容器的桥梁。</li>
<li>将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。</li>
<li>将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分。</li>
<li>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-iterator-container.png" alt=""></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>transform算法的一种实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>, <span class="title">class</span> <span class="title">UnaryFunction</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIterator</span> <span class="title">transform</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">UnaryFunction</span> <span class="title">op</span>) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">        *result = op(*first);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transform算法顺序遍历first和last两个迭代器所指向的元素；</p>
<p>将每个元素的值作为函数对象op的参数；</p>
<p>将op的返回值通过迭代器result顺序输出；</p>
<p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回.</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是算法和容器的桥梁</p>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通过迭代器间接操作</li>
</ol>
<p>算法和容器独立</p>
<ol>
<li>增加新的算法，无需影响容器的实现</li>
<li>增加新的容器，原有的算法也能适用</li>
</ol>
<h3 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h3><p>顺序容器包括：</p>
<ol>
<li>向量、双端队列、列表、单向链表、数组</li>
</ol>
<h4 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h4><p>特点</p>
<ol>
<li>一个可以扩展的动态数组</li>
<li>随机访问、在尾部插入或删除元素快</li>
<li>在中间或头部插入或删除元素慢</li>
</ol>
<p>向量的容量</p>
<ol>
<li>容量(capacity)：实际分配空间的大小</li>
<li>s.capacity() ：返回当前容量</li>
<li>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</li>
</ol>
<h4 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h4><p>特点</p>
<ol>
<li>在两端插入或删除元素快</li>
<li>在中间插入或删除元素慢</li>
<li>随机访问较快，但比向量容器慢</li>
</ol>
<p>例10-5 奇偶排序<br>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    istream_iterator&lt;int&gt; i1(cin), i2;  //建立一对输入流迭代器</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line">    sort(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line">    <span class="comment">//以下循环遍历s1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>)    <span class="comment">//偶数放到s2尾部</span></span><br><span class="line">             s2.push_back(*iter);</span><br><span class="line">         <span class="keyword">else</span>       <span class="comment">//奇数放到s2首部</span></span><br><span class="line">             s2.push_front(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s2的结果输出</span></span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==心得一：输出 vector 到标准输出我一般都是用 for 循环一个一个喂给 cout，这里却用 iterator 和 copy 函数很简洁得做到了（上段代码倒数第三句）==</p>
<p>==心得二：这个方法思路很好啊！！==</p>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h4><p>特点</p>
<ol>
<li>在任意位置插入和删除元素都很快</li>
<li>不支持随机访问</li>
</ol>
<p>接合(splice)操作</p>
<ol>
<li>==s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到s1中p所指向元素之前==</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> names1[] = &#123; <span class="string">"Alice"</span>, <span class="string">"Helen"</span>, <span class="string">"Lucy"</span>, <span class="string">"Susan"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> names2[] = &#123; <span class="string">"Bob"</span>, <span class="string">"David"</span>, <span class="string">"Levin"</span>, <span class="string">"Mike"</span> &#125;;</span><br><span class="line">    <span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line">    <span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line">    <span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line">    s2.splice(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line">    advance(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter2 = s2.<span class="built_in">begin</span>();  <span class="comment">//iter2指向s2首</span></span><br><span class="line">    ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line">    advance(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line">    <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line">    s1.splice(iter1, s2, iter2, iter3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别将s1和s2输出</span></span><br><span class="line">    copy(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    copy(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h4><ol>
<li>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</li>
<li>未定义insert、emplace和erase操作，而定义了insertafter、emplaceafter和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</li>
<li>不支持size操作。</li>
</ol>
<h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><ol>
<li>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</li>
<li>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大小。</li>
<li>不能动态地改变容器大小</li>
</ol>
<h4 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h4><p>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容器所需要执行的操作来决定选择哪一种容器。</p>
<ol>
<li>如果需要执行大量的随机访问操作，而且当扩展容器时只需要向容器尾部加入新的元素，就应当选择向量容器vector；</li>
<li>如果需要少量的随机访问操作，需要在容器两端插入或删除元素，则应当选择双端队列容器deque；</li>
<li>如果不需要对容器进行随机访问，但是需要在中间位置插入或者删除元素，就应当选择列表容器list或forward_list；</li>
<li>如果需要数组，array相对于内置数组类型而言，是一种更安全、更容易使用的数组类型。</li>
</ol>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ol>
<li>容器适配器</li>
<li>函数适配器</li>
<li>迭代器适配器</li>
</ol>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>STL提供了三个==容器适配器==：</p>
<ol>
<li>queue</li>
<li>priority_queue</li>
<li>stack</li>
</ol>
<p>这些适配器都是包装了vector、list、deque中某个顺序容器的包装器。<br>stack和queue是容器，但是他们==在本质上是适配器，他们本身并没有实现什么结构和算法，而是把deque拿过来，接口改造一下，实现了自己需要的功能==。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-deque-class.png" alt=""></p>
<p>注意：</p>
<ol>
<li>适配器没有提供迭代器，也不能同时插入或删除多个元素</li>
</ol>
<h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><h4 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/massive-data-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/massive-data-analysis/" itemprop="url">massive-data-analysis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T19:22:40-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/massive-data-analysis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/massive-data-analysis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>倒排索引的索引表中的每一项都包括一个属性值和具有该属性值得各记录的地址。</li>
<li>因为不是由记录来确定属性值，而是由属性来确定记录，因而成为倒排索引（inverted index）。</li>
<li>带有倒排索引的文件称为倒排索引文件，简称倒排文件（inverted file）。</li>
</ol>
<h3 id="倒排列表"><a href="#倒排列表" class="headerlink" title="倒排列表"></a>倒排列表</h3><ol>
<li>倒排列表记录了某个单词位于哪些文档中。在给定的文档语料中，一般会有多个文档包含某单词，每个文档有唯一的编号(DocID)，单词在这个文档中出现的次数(TF)及单词在文档中哪些位置出现等信息，与一个文档相关的信息被称作倒排索引项（posting），包含这个单词的一系列倒排索引项形成了列表结构，这就是某个单词对应的倒排列表。</li>
</ol>
<h3 id="在实践中的另外一个应用"><a href="#在实践中的另外一个应用" class="headerlink" title="在实践中的另外一个应用"></a>在实践中的另外一个应用</h3><ol>
<li>跳跃链表、跳跃表、跳表</li>
<li>GIS 中的 POI(point of Interest 查询)<ol>
<li>部分匹配：戴尔外星人电脑，外星人电脑</li>
<li>跳跃匹配：中国科技大学，中科大</li>
</ol>
</li>
</ol>
<p>POI 信息点 搜索总框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFileObject::Search</span><span class="params">(LPCTSTR lpszContent, <span class="keyword">int</span> nIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lpszContent || !lpszContent[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CreateSearchTree(nIndex);</span><br><span class="line"></span><br><span class="line">    SearchFuzzy(lpszContent, nIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai417992qj20li0d8tg3.jpg" alt="Screen Shot 2020-01-01 at 20.35.19.png"></p>
<h2 id="simHash-算法"><a href="#simHash-算法" class="headerlink" title="simHash 算法"></a>simHash 算法</h2><h3 id="算法起源和步骤"><a href="#算法起源和步骤" class="headerlink" title="算法起源和步骤"></a>算法起源和步骤</h3><ol>
<li>问题的起源：设计比较两篇文章相似度的算法。</li>
<li>simHash 算法分为 5 个步骤：<ol>
<li>分词</li>
<li>Hash</li>
<li>加权</li>
<li>合并</li>
<li>降维</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai2j6ly1hj211c0oi1fv.jpg" alt="Screen Shot 2020-01-01 at 19.43.21.png"></p>
<p>注意！！！</p>
<ol>
<li>上面”加权“那一项中是吧 W(CSDN)=100101 看成 6 个位置（6个数字，分别是 1, 0, 0, 1, 0, 1），然后再把 0 当成 -1 来计算乘积。</li>
<li>上面的”合并“那一项最后得到的是”9, -9, 1, -1, 1, 9“，图中漏写了最后的”9“。</li>
<li>权重的计算可以使用 TF-IDF 方法！</li>
</ol>
<h3 id="simHash-的应用"><a href="#simHash-的应用" class="headerlink" title="simHash 的应用"></a>simHash 的应用</h3><ol>
<li>每篇文档得到 simHash 签名值后，接着计算两个签名的海明距离即可。根据经验值，对 64 位的 SimHash 值，海明距离在 3 以内的可以认为相似度较高。</li>
<li>海明距离的求法：两个二进制数去异或操作，结果中 1 的个数就是海明距离。</li>
</ol>
<p>[对simHash的分块处理]</p>
<ol>
<li>如何将其扩展到海量数据呢？比如如何在海量的样本库中查询与其海明距离在 3 以内的记录呢？</li>
<li>一种方案是查找待查询文本的 64 为 simHash code 所有 3 位以内变化的组合</li>
<li>大约 43744 个。</li>
</ol>
<h3 id="进一步的思考"><a href="#进一步的思考" class="headerlink" title="进一步的思考"></a>进一步的思考</h3><ol>
<li>完全丢掉了位置信息和语义信息<ol>
<li>考虑使用 WordNet 影响 Hash 值？</li>
<li>考虑使用主题模型、标签传递算法等机器学习方法来分析语义</li>
</ol>
</li>
<li>允许交换，算一次变换：如 meter 和 metre<ol>
<li>能否写出递推关系式</li>
<li>还能设计出 O(n^2)的算法吗？</li>
</ol>
</li>
<li>如果计算字符串的语义距离，怎么考虑？<ol>
<li>WordNet 是由 Princeton 大学的心理学家，语言学家和计算机工程师联合设计得一种基于认知语言学的英语词典。它不光是把单词以字母顺序排列，而且按照单次的意义组成一个”单次的网络“。</li>
</ol>
</li>
</ol>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><ol>
<li>布隆过滤器(Bloom Filter)是由 Burton Howard Bloom 于 1970 年提出的，他是一种空间高效的概率性数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单，爬虫(Crawler)的网址判重等问题中经常被用到。</li>
<li>哈希表也能用于判断元素是否在集合中，但是 Bloom Filter 只需要哈希表的 1/8 或 1/4 的空间复杂度就能完成同样的问题。Bloom Filter 可以插入元素，但不可以删除已有元素。集合中的元素越多，误报率(false positive rate)越大，但是不会漏报 (false negative).</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rg9avlj20nu0gitit.jpg" alt="Screen Shot 2020-01-01 at 20.40.37.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai4rqrt0aj20mg0cgafh.jpg" alt="Screen Shot 2020-01-01 at 21.00.25.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai50f2nggj20lq0doq8u.jpg" alt="Screen Shot 2020-01-01 at 21.09.10.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai521tg4fj20o80e0wmi.jpg" alt="Screen Shot 2020-01-01 at 21.10.46.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5bt06y8j20me0eawkm.jpg" alt="Screen Shot 2020-01-01 at 21.20.12.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gai5ck8aqjj20oc0g8dqk.jpg" alt="Screen Shot 2020-01-01 at 21.20.57.png"></p>
<h3 id="Bloom-Filter-特点"><a href="#Bloom-Filter-特点" class="headerlink" title="Bloom Filter 特点"></a>Bloom Filter 特点</h3><ol>
<li>优点：相比于其他的数据结构，Bloom Filter 在空间和时间方面有巨大的优势。Bloom Filter 存储空间是线性的，插入和查询时间都是常数。另外，Hash 函数相互之间没有关系，方便由硬件并行实现。Bloom Filter 不存储元素本身，在某些对保密要求非常严格的场合有优势。</li>
<li>很容易想到把位向量变成整数数组，每插入一个元素相应的计数器加 1，这样删除元素是将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在 Bloom Filter 里面。这一点单凭这个过滤器是无法保证的。另外计数器下溢出也会造成问题（槽的值已经是 0 了，仍然执行删除操作）。</li>
</ol>
<h3 id="Bloom-Filter-用例"><a href="#Bloom-Filter-用例" class="headerlink" title="Bloom Filter 用例"></a>Bloom Filter 用例</h3><ol>
<li>Google 著名分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的 IO 次数。</li>
<li>Squid 网页代理缓存服务器在 cachedigests 中使用了 BloomFilter</li>
<li>Venti 文档存储系统采用 BloomFilter 来检测先前存储的数据；</li>
<li>SPIN 模型检测器使用 BloomFilter 在大规模验证问题时跟踪可达状态空间</li>
<li>Google Chrome 浏览器使用 BloomFilter 加速安全浏览服务</li>
<li>在很多 Key-Value 系统中也是用 BloomFilter 来加快查询过程，如 HBase, Accumulo, Leveldb<ol>
<li>一般而言，value 保存在磁盘中，访问磁盘需要花费大量时间，然而使用 BloomFilter 可以快速判断某个 Key 是否存在，因此可以避免很多不必要的磁盘 IO 操作；另外，引入布隆过滤器会带来一定的内存消耗。</li>
<li>如果你真的非常在意 false positive 的话，那么可以在 Bloom Filter 给出“存在”的结论时候，再去磁盘真的查询一次看看到底在不在。</li>
</ol>
</li>
</ol>
<h2 id="跳跃链表（skip-list）"><a href="#跳跃链表（skip-list）" class="headerlink" title="跳跃链表（skip list）"></a>跳跃链表（skip list）</h2><ol>
<li>Treaps/RB-Tree/BTree</li>
<li>跳跃链表是一种随机化数据结构，基于并联的链表，其效率与 RBTree 相当。具有简单、高效、动态（Simple, Effective, Dynamic）的特点。</li>
<li>跳跃链表对有序的链表副驾辅助结构，在链表中的查找可以快速的跳过部分节点（由此得名）。<ol>
<li>查找、增加、删除的期望时间都是 O(logN)</li>
<li>with high probability (W.H.P. ~ 1 - 1/(n^alpha))</li>
</ol>
</li>
<li>跳跃链表在并行计算中非常有用，数据插入可以再跳表的不同部分并行进行，而不用全局的数据结构重新平衡。</li>
<li>跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速跑道“，这里在层 i 中的元素按某个固定的概率 p 出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现。<ol>
<li>为什么是 1/(1-p)?</li>
</ol>
</li>
<li>优势<ol>
<li>编程方便</li>
<li>尤其方便将增删改查操作扩展成并行算法！</li>
</ol>
</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8c6p5coj20na0eqtg7.jpg" alt="Screen Shot 2020-01-02 at 19.29.50.png"></p>
<p>由上图可以看出来，要找一个元素，先在最上层找，找不到再往下走一层找。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8grgkdvj20ns0gcti8.jpg" alt="Screen Shot 2020-01-02 at 19.54.17.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8ip6lijj20lu0caqa8.jpg" alt="Screen Shot 2020-01-02 at 19.56.13.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj8kf7iagj20nk0fqdsc.jpg" alt="Screen Shot 2020-01-02 at 19.57.54.png"></p>
<mark>
    注意上面这个计算有错！
    k = ln(N) 这个结果没什么毛病。但是 T(N) 的表达有问题 T(N) = ln(N) * N^(1 / ln(N))
    而乘法号后面的 N^(1 / ln(N)) 等于数学常量 e
    因此 T(N) = e * ln(N)
</mark>


<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol>
<li>随着底层链表的插入，某一段上的数据将不满足理想链表的要求，需要做些调整。<ol>
<li>将底层链表这一段上元素的中位数在拷贝到上层链表中；</li>
<li>重新计算上层链表，使得上层链表仍然是底层链表的 1/e;</li>
<li>如果上述操作过程中，上层链表不满足要求，继续上上层链表的操作。</li>
</ol>
</li>
<li>新的数据应该在上层甚至上上层链表中吗？因为要找 1/e 的数据放在上层链表，因此：<mark>抛硬币！</mark></li>
<li>插入元素后的跳表维护<ol>
<li>考察待需要提升的某段节点</li>
<li>若抛硬币得到的随机数 p &lt; 1/e, 则提升到上层，继续抛硬币，直到 p &gt; 1/e<ol>
<li>或者到了顶层仍然 p &lt; 1/e, 建立一个新的顶层</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol>
<li>在某层链表上找到了该元素，则删除；如果该层链表不是底层链表，就跳转到下一层，继续本操作</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gaj9wczbs7j20os0coahp.jpg" alt="Screen Shot 2020-01-02 at 20.43.55.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSSkipNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    tagSSkipNode* pNext;</span><br><span class="line">    tagSSkipNode* pNextLayer;</span><br><span class="line"></span><br><span class="line">    tagSSkipNode(<span class="keyword">int</span> v) : value(v), pNext(<span class="literal">nullptr</span>), pNextLayer(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; SSkipNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSkipList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SSkipNode* m_pHead;</span><br><span class="line">    <span class="keyword">int</span> m_nSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CSkipList()&#123;</span><br><span class="line">        m_pHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);</span><br><span class="line">        m_nSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">SSkipNode* <span class="title">Find</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">SSkipNode* <span class="title">FindIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_nSize &lt;= <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintLayer</span><span class="params">(<span class="keyword">const</span> SSkipNode* pNode)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsSuccess</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand() &gt; RAND_MAX * <span class="number">0.36787944117</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find</span></span><br><span class="line"><span class="function">SSkipNode* <span class="title">CSkipList::Find</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; (cur-&gt;value &lt; value))    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while 结束后 cur-&gt;value 不小于 value, 而 pre-&gt;value 小于 value</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSkipList::Insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead-&gt;pNext)&#123;</span><br><span class="line">        m_pHead-&gt;pNext = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">        m_nSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SSkipNode*&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;    <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;    <span class="comment">// 已经存在，这里的思想是是不允许插入。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 当然也可以修改数据结构，记录一下次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.push(pre);    <span class="comment">// 记录插入点</span></span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入到 pre 的后面，cur 的前面</span></span><br><span class="line">    SSkipNode* now = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">    now-&gt;pNext = cur;</span><br><span class="line">    pre-&gt;pNext = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机上升</span></span><br><span class="line">    SSkipNode* nowInLayer;</span><br><span class="line">    SSkipNode* pLayerHead;</span><br><span class="line">    <span class="keyword">while</span>(!path.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!IsSuccess())&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop();    <span class="comment">// 第一次到这里的时候，这个是最下层的，没有用的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到层的插入位置</span></span><br><span class="line">        <span class="keyword">if</span>(path.empty())&#123;</span><br><span class="line">            pre = m_pHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = path.top();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成节点</span></span><br><span class="line">        nowInLayer = <span class="keyword">new</span> SSkipNode(value);</span><br><span class="line">        nowInLayer-&gt;pNextLayer = now;</span><br><span class="line">        <span class="keyword">if</span>(path.empty())&#123;    <span class="comment">// 说明顶层后仍然成功，则新建层</span></span><br><span class="line">            pLayerHead = <span class="keyword">new</span> SSkipNode(<span class="number">0</span>);    <span class="comment">// 生成层的新头指针</span></span><br><span class="line">            pLayerHead-&gt;pNext = m_pHead-&gt;pNext;</span><br><span class="line">            pLayerHead-&gt;pNextLayer = m_pHead-&gt;pNextLayer;</span><br><span class="line">            m_pHead-&gt;pNextLayer = pLayerHead;    <span class="comment">// 退化到下一层</span></span><br><span class="line">            m_pHead-&gt;pNext = nowInLayer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nowInLayer-&gt;pNext = pre-&gt;pNext;</span><br><span class="line">            pre-&gt;pNext = nowInLayer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为下次上升作准备</span></span><br><span class="line">        now = nowInLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nSize++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CSkipList::Delete</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_pHead) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    SSkipNode* pre = m_pHead;</span><br><span class="line">    SSkipNode* cur = m_pHead-&gt;pNext;</span><br><span class="line">    SSkipNode* pHeadPre = <span class="literal">nullptr</span>;</span><br><span class="line">    SSkipNode* pHead = m_pHead;</span><br><span class="line">    <span class="keyword">bool</span> bDelete = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;value &lt; value)&#123;   <span class="comment">// 当前值小，则遍历下一个</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur &amp;&amp; cur-&gt;value == value)&#123;</span><br><span class="line">            bDelete = <span class="literal">true</span>;</span><br><span class="line">            pre-&gt;pNext = cur-&gt;pNext;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            <span class="keyword">if</span>(!pHead-&gt;pNext)&#123;    <span class="comment">// 该层没有元素，则删除该层</span></span><br><span class="line">                <span class="keyword">if</span>（pHead == m_pHead)&#123;    <span class="comment">// 顶层</span></span><br><span class="line">                    SSkipNode* pNL = m_pHead-&gt;pNextLayer;</span><br><span class="line">                    m_pHead-&gt;pNextLayer = pNL ? pNL-&gt;pNextLayer : <span class="literal">nullptr</span>;</span><br><span class="line">                    m_pHead-&gt;pNext = pNL ? pNL-&gt;pNext : <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pHeadPre-&gt;pNextLayer = pHead-&gt;pNextLayer;</span><br><span class="line">                    <span class="keyword">delete</span> pHead;</span><br><span class="line">                    pHead = pHeadPre</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pHead;</span><br><span class="line">                cur = pre-&gt;pNext;</span><br><span class="line">                <span class="keyword">continue</span>;    <span class="comment">// 删除该层后，pre/cur 已经向下移动了一层</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;pNextLayer) <span class="keyword">break</span>;</span><br><span class="line">        pre = pre-&gt;pNextLayer;</span><br><span class="line">        cur = pre-&gt;pNext;</span><br><span class="line"></span><br><span class="line">        pHeadPre = pHead;</span><br><span class="line">        pHead = pHead-&gt;pNextLayer;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nSize--;</span><br><span class="line">    <span class="keyword">return</span> bDelete;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)&#123;</span><br><span class="line">    CSkipList sl;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;    <span class="comment">// 随机插入数据</span></span><br><span class="line">        sl.Insert(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sl.Print();</span><br><span class="line">    <span class="keyword">while</span>(!sl.IsEmpty())&#123;</span><br><span class="line">        SSkipNode* p = sl.FindIndex(rand() % sl.GetSize());</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = p-&gt;value;</span><br><span class="line">            <span class="keyword">if</span>(sl.Delete(num))&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Delete "</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sl.Print();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"==================\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><ol>
<li>MD5 (Message Digest Algorithm)，消息摘要算法，用以提供消息的完整性保护。</li>
</ol>
<h3 id="框架理解"><a href="#框架理解" class="headerlink" title="框架理解"></a>框架理解</h3><ol>
<li>对于长度为 512bit 的信息，可以通过处理，得到长度为 128bit 的摘要</li>
<li>初始化摘要 0x0123456789ABCDEFFEDCBA9876543210<ol>
<li>A = 0x01234567</li>
<li>B = 0x89ABCDEF</li>
<li>C = 0xFEDCBA98</li>
<li>D = 0x76543210</li>
</ol>
</li>
<li>现在的工作，是要用长度为512 位的信息，变换初始摘要</li>
<li>定义变量 a，b，c，d，分别记录 A，B，C，D</li>
<li>将 512 bit 的信息按照 32 bit 一组，分成 16 组；分别记为 Mj (0 &lt;= j &lt;= 15)</li>
<li>取某正数 s, t_k, 定义函数 FF(a,b,c,d,Mj,s,t_k) = (a+F(b,c,d)+Mj+t_k) &lt;&lt; s</li>
<li>利用 Mj 分别进行信息提取，将结果保存到 a<ol>
<li>其中，F(X,Y,Z) = (X &amp; Y) | (~X &amp; Z)</li>
</ol>
</li>
<li>经过以上 16 次变换，a，b，c，d 带有了 Mj 的信息</li>
<li>事实上经过四轮这样的变换（4轮 * 16次 = 64 次）</li>
<li>经过 64 次变换后，将 a，b，c，d 累加给 A，B，C，D</li>
<li>此时，完成了 512 bit 信息的提取；进行下一个 512 bit 信息的相同操作。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbqj9ymdj20m80giwjo.jpg" alt="Screen Shot 2020-01-02 at 21.47.31.png"></p>
<h3 id="细致算法"><a href="#细致算法" class="headerlink" title="细致算法"></a>细致算法</h3><ol>
<li>在算法中，首先要对信息进行填充，使其长度对 512 求余的结果是 448</li>
<li>填充的方法如下，在信息的后面填充一个 1 和若干个 0，知道满足上面的条件。然后在这个结果后面附加一个以 64 位二进制表示的原始信息长度 length</li>
<li>经过这两步的处理，数据总长度为 N * 512 + 448 + 64 = (N+1) * 512.</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbs4sb7nj20lk0ds14h.jpg" alt="Screen Shot 2020-01-02 at 21.49.07.png"></p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gajbv3nfevj20m40goh3v.jpg" alt="Screen Shot 2020-01-02 at 21.51.56.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/leetcode-math/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/leetcode-math/" itemprop="url">leetcode-math</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T10:44:36-08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/leetcode-math/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/leetcode-math/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h1><h2 id="本福特定律"><a href="#本福特定律" class="headerlink" title="本福特定律"></a>本福特定律</h2><p>本福特定律（本福特法则，Frank Benford），又称第一数字定律，是指在实际生活得出的一组数据中，以 1 为首位数字出现的概率约为总数的三成；是直观想象 1/9 的三倍。</p>
<ul>
<li>阶乘，素数数列，斐波那契数列</li>
<li>住宅地址号码</li>
<li>经济数据反欺诈（检验是否符合本定律）</li>
<li>选举投票发欺诈</li>
</ul>
<table>
<thead>
<tr>
<th>数字</th>
<th>出现概率</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.1%</td>
</tr>
<tr>
<td>2</td>
<td>17.6%</td>
</tr>
<tr>
<td>3</td>
<td>12.5%</td>
</tr>
<tr>
<td>4</td>
<td>9.7%</td>
</tr>
<tr>
<td>5</td>
<td>7.9%</td>
</tr>
<tr>
<td>6</td>
<td>6.7%</td>
</tr>
<tr>
<td>7</td>
<td>5.8%</td>
</tr>
<tr>
<td>8</td>
<td>5.1%</td>
</tr>
<tr>
<td>9</td>
<td>4.6%</td>
</tr>
</tbody></table>
<h2 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h2><p>[题目]<br>给定 N 个数，设计算法，输出随机排列的一个结果。</p>
<p>[思路]</p>
<ol>
<li>直接一个数字一个数字的选择就可以了</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % (b - a + <span class="number">1</span>) + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomShuffle2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;    <span class="comment">// i 是待生成的第几个数</span></span><br><span class="line">        j = Random2(i, a.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思考]</p>
<ol>
<li>其实 STL 里面有 std::random_shuffle 可以直接得到结果。</li>
</ol>
<h2 id="0650-2-Keys-keyboard"><a href="#0650-2-Keys-keyboard" class="headerlink" title="0650 2 Keys keyboard"></a>0650 2 Keys keyboard</h2><p>[题目]</p>
<ul>
<li>屏幕上开始有一个 A, 你的键盘只有 <code>copy all</code> 和 <code>paste</code> 两个功能键</li>
<li>给定 N, 问你需要操作多少次键盘才可以获得 N 个 A.</li>
<li>Example<ul>
<li>N = 3, copy all + paste + paste 需要三次</li>
<li>N = 4, c + p + p + p 或者 c + p + c + p 需要四次</li>
</ul>
</li>
</ul>
<p>[思路一：我的思路]</p>
<ul>
<li>使用 DP，如果已知 ans[i] 了，那么可以对它进行 copy all + K 个 paste 获得后面的值</li>
<li>时间复杂度为 O( (1 + 1/2 + 1/3 + … + 1/N) * N ) 复杂度 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans[n + <span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j = j + i)&#123;</span><br><span class="line">            ans[j] = ans[i] + j / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路二：数学观察]</p>
<ul>
<li>如果 n 为质数，那么 n 是多少，就需要多少次。</li>
<li><mark>如果 n 为合数，那么其需要的次数等于将其分解质因数的操作次数的和！</mark><ul>
<li>比如，30 = 1 * 3 * 2 * 5。那么我们首先复制 1，进行两次粘贴得到 3. 然后复制 3，进行一次粘贴得到 6；然后复制 6，进行 4 次粘贴得到 30. 总共需要 3 + 2 + 5 = 10 次<ul>
<li>1 * 3 就代表需要 3 个 1，怎么办呢？复制一次，粘贴两次</li>
<li>1 * 3 的结果再 * 2, 也就是需要 2 个 3，怎么办？复制一次 3个星，粘贴就好了啊！</li>
</ul>
</li>
<li>注意，由于分解的质因数顺序可以改变，也就意味着我们操作顺序可以不同。比如我们同样可以: 30 = 5 * 2 * 3. 即先复制 1, 进行四次粘贴得到 5; 然后复制 5, 进行一次粘贴得到 10; 然后复制 10，进行两次粘贴得到 30.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p>[题目]<br>编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。</p>
<p>[分析]</p>
<ol>
<li>经典的思路是使用环形链表，模拟这个步骤来找到最终结果。但是这个并非最优的解决办法。</li>
<li>我们可以使用递归的思想去做！<ol>
<li>定义递归函数 f(n, m)，很显然 f(1, m) = 1</li>
<li>我们需要找到 f(n, m) 和 f(n-1, m) 之间的关系。</li>
<li>刚开始的编号为: 1, …, m-2, m-1, m, m+1, m+2, …, n, …</li>
<li>考虑删除前和删除后的编号转换关系<ol>
<li>删除前 —- 删除后</li>
<li>… —— …</li>
<li>m-2  —-  n-2</li>
<li>m-1  —-  n-1</li>
<li>m  ——  无（因为编号被删除了）</li>
<li>m+1  —-  1 (因为下次就从这里报数了)</li>
<li>m+2  —-  2</li>
<li>…  —-  …</li>
</ol>
</li>
<li>新的环中只有 n-1 个节点。且删除前编号为 m+1, m+2, m+3 的节点成了删除后编号为 1, 2, 3 的节点</li>
<li>假设 old 为删除之前的节点编号，new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为:<ol>
<li>old = (new + m - 1) % n + 1</li>
<li>注意！有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? n : (f(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0172-n的阶乘后边有多少0"><a href="#0172-n的阶乘后边有多少0" class="headerlink" title="0172 n的阶乘后边有多少0"></a>0172 n的阶乘后边有多少0</h2><p>[题目]<br>给定数字 n, 求 n! 后缀有多少个 0.</p>
<p>[分析]</p>
<ol>
<li>只需要看有多少个 5</li>
<li>有些数字里面有 2 个，3个，多个 5</li>
<li>总共有 sum = N / 5 + N / 25 + N / 125 + … 个 5 存在</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + f(n/<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0319-开关灯泡"><a href="#0319-开关灯泡" class="headerlink" title="0319 开关灯泡"></a>0319 开关灯泡</h2><p>[题目]</p>
<ol>
<li>初始时有 n 个灯泡关闭。</li>
<li>第 1 轮，你打开所有的灯泡。</li>
<li>第 2 轮，每两个灯泡关闭一次。</li>
<li>第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。</li>
<li>第 i 轮，每 i 个灯泡切换一次开关。对于第 n 轮，你只切换最后一个灯泡的开关。</li>
<li>找出 n 轮后有多少个亮着的灯泡。</li>
</ol>
<p>[例子]</p>
<ol>
<li>示例:</li>
<li>输入: 3</li>
<li>输出: 1 </li>
<li>解释: <ol>
<li>初始时, 灯泡状态 [关闭, 关闭, 关闭].</li>
<li>第一轮后, 灯泡状态 [开启, 开启, 开启].</li>
<li>第二轮后, 灯泡状态 [开启, 关闭, 开启].</li>
<li>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ol>
<li>这个题目评级为 hard, 但是这道题实际上是一道数学题目</li>
<li>想象一下位置为 k 的灯泡会被改变多少次呢？<ol>
<li>第一步的时候肯定是变亮了</li>
<li>第二步的时候取决于 k 是不是奇数，也就是 k 除以 2 能否整除，或者说 2 是不是 k 的约数</li>
<li>第三部的时候取决于 3 是不是 k 的约数</li>
</ol>
</li>
<li><mark>以此类推。第 k 个灯泡变化的次数，等于 k 的约数的个数</mark><ol>
<li>如果有奇数个约数，那么最后灯泡是亮的</li>
<li>如果有偶数个约数，那么最后灯泡是暗的</li>
</ol>
</li>
<li>所以问题可以转变成，<mark>1 到 n 这 n 个数字里面有多少个数字拥有奇数个约数？</mark></li>
<li>有一个数学知识就是：只有完全平方数才有奇数个约数！<ol>
<li>为什么？</li>
<li>因为如果 m 是 k 的约数，那么 <code>k/m</code> 也是 k 的约数</li>
<li>m 和 k/m 一定是成对出现的</li>
<li>因此，一个数字的约数个数是偶数个，除非最中间的两个约数相等了，也就是 <code>m = k/m</code>，也就意味着 <code>k = m^2</code></li>
<li>因此, 完全平方数才有奇数个约数</li>
</ol>
</li>
<li>1 到 n 里面有多少个完全平方数可以直接计算如下<ol>
<li><code>int(sqrt(n))</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h2><p>[题目]</p>
<ol>
<li>给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作：<ol>
<li>令 x 为你数组里所有元素的和</li>
<li>选择满足 <code>0 &lt;= i &lt; target.size()</code> 的任意下标 i ，并让 A[i] = x 。</li>
<li>你可以重复该过程任意次</li>
</ol>
</li>
<li>如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。</li>
</ol>
<p>[例子一]</p>
<ol>
<li>输入: target = [9, 3, 5]</li>
<li>输出: true</li>
<li>解释<ol>
<li>从 [1, 1, 1] 开始</li>
<li>和为 3， A[1] = 3, 数组变成 [1, 3, 1]</li>
<li>和为 5， a[2] = 5, 数组变成 [1, 3, 5]</li>
<li>和为 9， a[0] = 9, 数组变成 [9, 3, 5]</li>
</ol>
</li>
</ol>
<p>[例子二]</p>
<ol>
<li>输入: target = [1, 1, 1, 2]</li>
<li>输出: false</li>
</ol>
<p>[思路]</p>
<ol>
<li>正着考虑很麻烦，因为要遍历各种可能的位置去放数组的和，BFS, DFS 这种复杂度都很高</li>
<li>DP 的话看起来很难找到状态转移方程</li>
<li>正着考虑不行就反向考虑！<ol>
<li>注意到数组里最大的那个数字一定是最后一步得到的，因此它是倒数第二步的数组里所有元素的和。</li>
<li>因此只需要把这个数字减去其他所有的数字，就得到了它倒数第二步的数字！</li>
<li>以此类推，可以逐渐得到前面所有步骤的数组。</li>
</ol>
</li>
<li>那么这里又存在一个问题，如何动态找出所有元素中的最大值？<ol>
<li>这个简单，我们可以借助 最大堆 这个数据结构，它可以帮助我们在 logn 的时间维护一个排序好的序列。</li>
</ol>
</li>
<li>有了这些，这道题基本上就可以解决了。以上就是最为基本的解题思路.</li>
<li>不过！！这道题目会存在一些比较极端的 case，比如 [1, 100000000] ，因此我们要对之前的解法进行优化。我们之前说过，我们需要考虑 sum 还有就是 max，但是当 max 相对于其他元素过于大的时候，我们需要对这一个元素反复做同样的事情很多次，这个过程能否简化呢？这里我们可以用一个取余的方法做到：<ol>
<li>[2, 100]</li>
<li>sum = 102, max = 100, other = 2  </li>
<li>sum = 100, max = 98, other = 2</li>
<li>sum = 98, max = 96, other = 2</li>
<li>…</li>
<li>// 如果 max 与 other 差距过大，每次迭代我们其实都在更新 max</li>
<li>// 因为 other 没有变，每次 max 减去的都是相同的值</li>
<li>// 这里，我们可以利用取余的方式来使得 max 一次性更新到刚好比 other 小的值</li>
<li>// end_max = max % other</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : target) &#123;</span><br><span class="line">        pq.offer(i);</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.peek() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = pq.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 other</span></span><br><span class="line">        sum -= max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other = 1，不管 max 是多少，都可以通过 1 不断迭代而成</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是反向推，只减不加</span></span><br><span class="line">        <span class="comment">// other 小于 1，说明无法构建</span></span><br><span class="line">        <span class="comment">// other 必须小于 max 来保证 max 的正常迭代递减，不然 max 无法递减到 1</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= <span class="number">0</span> || max &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过取余操作将 max 迭代到比 other 小的地方</span></span><br><span class="line">        max %= sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other + prev_max = prev_sum</span></span><br><span class="line">        sum += max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prev_max 放入队列，继续迭代</span></span><br><span class="line">        pq.offer(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="最小方差和分割数组"><a href="#最小方差和分割数组" class="headerlink" title="最小方差和分割数组"></a>最小方差和分割数组</h2><p>[题目]</p>
<ul>
<li>给你一个数组，求一个k值，使得前k个数的方差 + 后面n-k个数的方差最小 ，时间复杂度可以到O(n)。</li>
</ul>
<p>[思路]</p>
<ul>
<li>根据方差公式D(X)=E(x^2)-[E(X)]^2</li>
</ul>
<p>[代码]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minVariance</span><span class="params">(arr)</span>:</span></span><br><span class="line">    sum=<span class="number">0</span></span><br><span class="line">    square_sum=<span class="number">0</span></span><br><span class="line">    length=len(arr)</span><br><span class="line">    left_var=[<span class="number">0</span>]*length</span><br><span class="line">    right_var=[<span class="number">0</span>]*length</span><br><span class="line">　　<span class="comment">#从左到右求每一段的方差</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        sum+=arr[i]</span><br><span class="line">        square_sum+=arr[i]*arr[i]</span><br><span class="line">        left_var[i]=square_sum/(i+<span class="number">1</span>)-(sum/(i+<span class="number">1</span>))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    square_sum = <span class="number">0</span></span><br><span class="line">    <span class="comment">#从右到左求每一段的方差</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(length<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        sum+=arr[j]</span><br><span class="line">        square_sum += arr[j] * arr[j]</span><br><span class="line">        right_var[j] = square_sum / (length-j) - (sum / (length-j)) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">#二者合并，找出方差最小的两断</span></span><br><span class="line">    index=<span class="number">0</span></span><br><span class="line">    variance=left_var[<span class="number">0</span>]+right_var[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(length<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> left_var[k]+right_var[k+<span class="number">1</span>]&lt;variance:</span><br><span class="line">            variance=left_var[k]+right_var[k]</span><br><span class="line">            index=k+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url">leetcode-dp-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-31T21:35:23-08:00">
                2019-12-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/31/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/31/leetcode-dp-动态规划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h2><p>[题目]<br>给定不超过 100 万元的现金总额，兑换成数量不限的 100, 50, 20, 10, 5, 2, 1 的组合，共有多少种组合呢？</p>
<p>[思路一]<br>这个是视频里讲得思路</p>
<ul>
<li>定义 dp[i][j]: 使用面额小于等于 i 的钱币，凑成 j 元钱，宫有多少种组合方法</li>
<li>dp[100][500] = dp[50][500] + dp[100][400]</li>
<li>dp[i][j] = dp[i_small][j] + dp[i][j-1]<ul>
<li>不考虑下界溢出的情况</li>
</ul>
</li>
</ul>
<p>[思路二]<br>我觉得把，用个一维的数组来做 dp 就可以了。</p>
<p>DP[target] 表示用给定的钱币凑出来 target 的组合数量，那么<br>DP[target] 显然等于 DP[target-1] + DP[target-2] + DP[target-5] + … + DP[target-100]</p>
<p>就跟走楼梯的方法一模一样啊！！！</p>
<h2 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h2><p>[题目]<br>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p>[分析]<br>直接使用 DP 的话因为要考虑删除字符，有点不好理解，这里先转化成一个对齐的问题！</p>
<table>
<thead>
<tr>
<th>S</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>D</td>
<td>B</td>
<td>-</td>
<td>F</td>
<td>G</td>
</tr>
</tbody></table>
<ol>
<li>S = “ABCF”, T = “DBFG”</li>
<li>对应位置相同时候不扣分，不同则扣一分（修改了）</li>
<li>两个特殊字符”-“ 不会对应</li>
<li>S 位置 “-“ 代表增加字符</li>
<li>T 位置 “-“ 代表删掉字符</li>
<li>目标是使得扣分最少</li>
</ol>
<p>这个问题的 DP 思路就很好想到了</p>
<ol>
<li>假定 DP[i][j] 表示 S[0…i-1] 和 T[0…j-1] 对齐了</li>
<li>现在需要看 S[i] == T[j] ?<ol>
<li>如果相等, 说明 DP[i+1][j+1] = DP[i][j]</li>
<li>如果不相等，则有三种操作方式<ol>
<li>S[i] 替换成 T[j], DP[i+1][j+1] = DP[i][j] + 1</li>
<li>删掉 S[i], DP[i+1][j+1] = DP[i][j+1] + 1</li>
<li>删掉 T[j], DP[i+1][j+1] = DP[i+1][j] + 1</li>
</ol>
</li>
</ol>
</li>
<li>初值<ol>
<li>DP[0][j] = j, DP[i][0] = i</li>
</ol>
</li>
<li>同样，空间可以优化一下，稍微需要点技巧。</li>
</ol>
<h2 id="两次走棋盘"><a href="#两次走棋盘" class="headerlink" title="两次走棋盘"></a>两次走棋盘</h2><p>[题目]</p>
<ul>
<li>Maximum points from top left of matrix to bottom right and return back</li>
<li>给定 MxN 的矩阵，每个位置是一个非负的权值，从左上角开始，每次只能朝右和下走，走到右下角；然后，从右下角开始，每次只能超左和上走，走到左上角。求权值总和最大的路径。若相同格子走过两次，则该位置的权值只算一次。</li>
</ul>
<p>[思路]</p>
<ol>
<li>错误的思路一：贪心，先从左上到右下，再从右下到左上！这样子做选的路径两条路将会一模一样，因为重复的结点权值只算一次，这样子肯定不行。</li>
<li>错误的思路二：接错误一，如果你第一次走的时候把走过的结点权值改成 0，然后第二次走再选最大的路径。这样子也是不对的！</li>
<li>正确的思路：这题的一个技巧是把第二个图翻转过来，跟第一条路放到一起，二者同时走，即从左上角同时出发有两条路，终点都是右下角！</li>
<li>有了这个转换之后，显然，就可以用 row1, col1, row2, row4 来表示状态了！注意在任何时刻都满足条件： row1 + col1 = row2 + col2. 因此可以只用三个变量 row1, col1, row2 来表示状态。</li>
<li>在任意时刻，如果两条路汇合到同一个位置，那么这个位置的权值只计算一次，如果在两个不同的位置，那么两个权值都计算上！</li>
</ol>
<p>[代码]<br>这里的代码是自上而下的一个 DP.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; goldMatrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col2 = row1 + col1 - row2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>(), n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if they reach bottom right location</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == m<span class="number">-1</span> &amp;&amp; row1 == row2 &amp;&amp; col1 == n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> goldMatrix[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(row1 == m || row2 == m || col1 == n || col2 == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The same state has been calculated previously</span></span><br><span class="line">    <span class="keyword">if</span>(dp[row1][col1][row2] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row1][col1][row2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// They are at the same spot</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == row2)&#123; </span><br><span class="line">        res += goldMatrix[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += (goldMatrix[row1][col1] + goldMatrix[row2][col2]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move right</span></span><br><span class="line">    dp1 = helper(row1, col1+<span class="number">1</span>, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move down</span></span><br><span class="line">    dp2 = helper(row1, col1+<span class="number">1</span>, row2+<span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move right</span></span><br><span class="line">    dp3 = helper(row1+<span class="number">1</span>, col, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move down</span></span><br><span class="line">    dp4 = helper(row1 + <span class="number">1</span>, col, row2 + <span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    res += <span class="built_in">max</span>(dp1, <span class="built_in">max</span>(dp2, <span class="built_in">max</span>(dp3, dp4)));</span><br><span class="line"></span><br><span class="line">    dp[row1][col1][row2] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collectGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; goldMatrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, goldMatrix, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 错位排列</span><br><span class="line">[问题]</span><br><span class="line"><span class="number">1.</span> 把数字 <span class="number">1</span> 到 n 做个排列，要求数字 i 不能位于第 i 个位置。问：这样的排列一共有多少种?</span><br><span class="line"><span class="number">2.</span> 这个问题最早是由 Danial Bernoulli （著名的伯努利家族成员）提出的。</span><br><span class="line"></span><br><span class="line">[思路]</span><br><span class="line"><span class="number">1.</span> (n<span class="number">-1</span>)! 这个结果是不对的，不能排除掉重复的结果！</span><br><span class="line"><span class="number">2.</span> 先考虑 n</span><br><span class="line">    <span class="number">1.</span> n 可以放置在 <span class="number">1</span> 到 n<span class="number">-1</span> 一共 n<span class="number">-1</span> 种可能。假设放在了 k 位置</span><br><span class="line"><span class="number">3.</span> 现在考虑数字 k，有两种情况</span><br><span class="line">    <span class="number">1.</span> 第一种情况，数字 k 放到了 位置 n，那么剩下的可能就是 DP(n<span class="number">-2</span>) 了。</span><br><span class="line">    <span class="number">2.</span> 第二种情况下，数字 k 不能放到位置 n，这时候把数字 k 想象成数字 n（数字 n 本来已经用掉了，可以用 k 替代它继续做问题），而剩下的 n<span class="number">-2</span> 个数字也各有一个位置不能放！其实这就是 DP(n<span class="number">-1</span>) 啊！</span><br><span class="line"><span class="number">4.</span> 所以 DP 的转移公式是</span><br><span class="line">    <span class="number">1.</span> DP[n] = (n<span class="number">-1</span>)(DP[n<span class="number">-1</span>] + DP[n<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">![Screen Shot <span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> at <span class="number">17.16</span><span class="number">.10</span>.png](https:<span class="comment">//ws1.sinaimg.cn/large/6a607485gy1gahya0ozdgj20l20c043w.jpg)</span></span><br></pre></td></tr></table></figure>

<h2 id="三字符字符串组合"><a href="#三字符字符串组合" class="headerlink" title="三字符字符串组合"></a>三字符字符串组合</h2><p>[题目]<br>仅由三个字符 A, B, C 构成字符串，且字符串任意三个相邻元素不能完全相同。如 “ACCCAB” 不合法，”ABBCBCA” 合法。求满足条件的长度为 n 的字符串个数。note: 假定不考虑整数溢出，并且要求时间和空间复杂度不高于 O(N)。</p>
<p>[分析]</p>
<ol>
<li>若当前已经有了所有长度为 n-1 的合法字符串，如何在末端增加一个字符，形成长度为 n 的字符串呢？</li>
<li>将长度为 n-1 字符串分成”末尾两个字符不相等“和”末尾两个字符相等“两种情况，各自数目记做 dp[n-1][0], dp[n-1][1]:<ol>
<li>dp[n][0] = 2 * dp[n-1][0] + 2 * dp[n-1][1]</li>
<li>dp[n][1] = dp[n-1][0]</li>
<li>初始条件是 dp[1][0] = 3, dp[1][1] = 0</li>
</ol>
</li>
</ol>
<h3 id="改进空间复杂度"><a href="#改进空间复杂度" class="headerlink" title="改进空间复杂度"></a>改进空间复杂度</h3><ol start="3">
<li><mark>状态转移方程总结与改进</mark><ol>
<li>滚动数组法</li>
<li>dp[0] = 2 * dp[0] + 2 * dp[1]</li>
<li>dp[1] = dp[0]</li>
<li>此法将空间复杂度由 O(N) 降到 O(1)</li>
</ol>
</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t = nNonRepeat;</span><br><span class="line">        nNonRepeat = <span class="number">2</span> * (nNonRepeat + nRepeat);</span><br><span class="line">        nRepeat = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nNonRepeat + nRepeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进时间复杂度"><a href="#改进时间复杂度" class="headerlink" title="改进时间复杂度"></a>改进时间复杂度</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/2020-01-04-at-15-36-26.png" alt=""></p>
<p>而一个矩阵的 n 次幂可以用递归方法来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix2x2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    Matrix2x2(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd) : a(aa), b(bb), c(cc), d(dd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd)</span></span>&#123;</span><br><span class="line">        a = aa;</span><br><span class="line">        b = bb;</span><br><span class="line">        c = cc;</span><br><span class="line">        d = dd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMultiply</span><span class="params">(Matrix2x2 &amp; m, Matrix2x2 &amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = m.a * n.a + m.b * n.c;</span><br><span class="line">    <span class="keyword">int</span> b = m.a * n.b + m.b * n.d;</span><br><span class="line">    <span class="keyword">int</span> c = m.c * n.a + m.d * n.c;</span><br><span class="line">    <span class="keyword">int</span> d = m.c * n.b + m.d * n.d;</span><br><span class="line">    m.Set(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixN</span><span class="params">(Matrix2x2 &amp; m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        m.Set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 单位阵</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 偶数</span></span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           <span class="comment">// 奇数</span></span><br><span class="line">        Matrix2x2 x = m;</span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">        MatrixMultiply(m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Matrix2x2 <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    MatrixN(m, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * (m.a + m.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打气球-leetcode-312"><a href="#打气球-leetcode-312" class="headerlink" title="打气球 leetcode 312"></a>打气球 leetcode 312</h2><p>[题目]<br>给定一串气球，要全部打坏。每个气球上有一个整数，打坏它的得分等于它和左右邻居上的一共三个整数的乘积。<br>如果没有左右邻居，那么视为 1，求最大总得分。</p>
<p>[分析]</p>
<ol>
<li>这个题目拿到手一看就是用 DP</li>
<li>可以先假定用 <code>DP[i][j]</code> 表示气球 i 到气球 j 这一串气球都打完的得分是多少。</li>
<li>问题的难点在于？<ol>
<li>DP 的递推式该怎么样写？</li>
<li>打完一个气球后，本来不相邻的邻居现在变成邻居了，怎么办？</li>
</ol>
</li>
<li>关键思路在于: <mark>总有最后一个消灭的气球</mark></li>
<li>假定 <code>DP[i][j]</code> 里面气球 k 最后一个打破<ol>
<li>那么 <code>DP[i][k-1]</code> 是一个子问题，要最大得分</li>
<li><code>DP[k+1][j]</code> 也是一个子问题，要最大得分</li>
<li>两个字问题被气球 k 隔离，“边界”的气球不会变</li>
</ol>
</li>
<li>因此递推关系式如下<ol>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[k-1] * nums[k] * nums[k+1])\)</li>
<li><mark>上面的式子是错误的！</mark></li>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[i-1] * nums[k] * nums[j+1])\)</li>
<li>要注意如果 k-1 &lt; i, 那么 <code>DP[i][k-1]</code> 要理解成 0</li>
</ol>
</li>
<li>最终结果是 <code>DP[0][n-1]</code></li>
<li>更新顺序是: (j-i) 从小到大</li>
<li>时间复杂度 O(N^3)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">DP</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i+len) &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                DP[i][j] = <span class="built_in">max</span>(dp[i][j], ((i &lt;= k<span class="number">-1</span>) ? DP[i][k<span class="number">-1</span>] : <span class="number">0</span>) + ((k + <span class="number">1</span> &lt;= j) ? DP[k+<span class="number">1</span>][j] : <span class="number">0</span>)</span><br><span class="line">                + ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? nums[i<span class="number">-1</span>] : <span class="number">1</span>) * nums[k] * ((j + <span class="number">1</span> &lt; n) ? nums[j + <span class="number">1</span>] : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Count-Square-Submatrices-with-All-Ones-lc1277"><a href="#Count-Square-Submatrices-with-All-Ones-lc1277" class="headerlink" title="Count Square Submatrices with All Ones lc1277"></a>Count Square Submatrices with All Ones lc1277</h2><p>[题目]</p>
<ul>
<li>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</li>
<li>1 x 1 的方阵也算进来</li>
</ul>
<p>[思路一]</p>
<ul>
<li>这一题特别像找 largest square matrix with all ones 那道题</li>
<li>当时我用了辅助矩阵去记录行里面最长的连续 1 个数，列里面最长的连续 1 的个数。</li>
<li>这里也可以用类似的，代码如下</li>
</ul>
<p>[代码一]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> rowContinuousOnes[m][n];</span><br><span class="line">    <span class="keyword">int</span> colContinuousOnes[m][n];</span><br><span class="line">    <span class="keyword">int</span> largestSquare[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            rowContinuousOnes[i][j] = j == <span class="number">0</span> ? matrix[i][j] : (matrix[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> + rowContinuousOnes[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            colContinuousOnes[i][j] = i == <span class="number">0</span> ? matrix[i][j] : (matrix[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> + colContinuousOnes[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                largestSquare[i][j] = matrix[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largestSquare[i][j] = <span class="built_in">min</span>(&#123;largestSquare[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>, rowContinuousOnes[i][j], colContinuousOnes[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += largestSquare[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路二]</p>
<ul>
<li>实际上，我们不需要使用这两个辅助的矩阵就可以完成 dp 矩阵的递归！</li>
<li>只需要利用 dp 本身就可以了。</li>
<li>递推关系如下<ul>
<li>dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.</li>
<li>dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.</li>
<li>If A[i][j] == 0, no possible square.</li>
<li>If A[i][j] == 1,<ul>
<li>we compare the size of square dp[i-1][j-1], dp[i-1][j] and dp[i][j-1].</li>
<li>min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 is the maximum size of square that we can find.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); res += A[i][j++])</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &amp;&amp; i &amp;&amp; j)</span><br><span class="line">                A[i][j] += <span class="built_in">min</span>(&#123;A[i - <span class="number">1</span>][j - <span class="number">1</span>], A[i - <span class="number">1</span>][j], A[i][j - <span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/%5C/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/%5C/page/4/">4</a><a class="extend next" rel="next" href="/%5C/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
