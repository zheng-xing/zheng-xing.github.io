<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/28/leetcode-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/28/leetcode-graph/" itemprop="url">leetcode-graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-28T17:44:02-08:00">
                2019-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/28/leetcode-graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/28/leetcode-graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><ul>
<li>图的遍历和搜索</li>
<li>（隐式）图的搜索（连通性）<ul>
<li>重点</li>
<li>8皇后</li>
</ul>
</li>
<li>最短路径<ul>
<li>单源图 (Dijkstra)</li>
<li>任意两点 (floyd)</li>
<li>有负边</li>
</ul>
</li>
<li>最小生成树 (MST)<ul>
<li>Prim</li>
<li>Krusal</li>
</ul>
</li>
<li>拓扑排序 (Topological Sort)</li>
</ul>
<h2 id="图的表示和搜索"><a href="#图的表示和搜索" class="headerlink" title="图的表示和搜索"></a>图的表示和搜索</h2><ul>
<li>图的表示<ul>
<li>邻接矩阵<ul>
<li>NxN 的矩阵，有边是 1，无边是 0</li>
</ul>
</li>
<li>邻接表<ul>
<li>为每个点建立一个链表（数组）存放与之连接的点</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="所有括号匹配的字符串"><a href="#所有括号匹配的字符串" class="headerlink" title="所有括号匹配的字符串"></a>所有括号匹配的字符串</h2><p>[题目]<br>N 对括号能够得到的有效括号序列有哪些？</p>
<p>[例子]<br>N = 3, 有效括号串共 5 个，分别为：</p>
<ol>
<li>()()()</li>
<li>()(())</li>
<li>(())()</li>
<li>(()())</li>
<li>((()))</li>
</ol>
<p>[问题分析]</p>
<ul>
<li>任何一个括号序列，都可以写成形式 (A)B<ul>
<li>A 和 B 都是若干括号对形成的合法串（可以是空串）</li>
<li>若 N=0, 括号序列为空</li>
<li>若 N=1, 括号序列只能是 () 这一种。</li>
</ul>
</li>
<li>算法描述: i 属于 [0, N-1]<ul>
<li>计算 i 对括号的可行序列 A</li>
<li>计算 N-i-1 对括号的可行序列 B</li>
<li>组合得到 (A)B</li>
<li>注：加上额外一对括号 (), 总括号数量是 N 对</li>
</ul>
</li>
</ul>
<p><mark>注意下面算法有直接修改数组最后一个元素! 使用了返回引用的方法！！！</mark><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; AllParentheses(<span class="keyword">int</span> n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; prefix, suffix, result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		prefix = AllParentheses(i);</span><br><span class="line">		suffix = AllParentheses(n-i<span class="number">-1</span>);</span><br><span class="line">		Unit(result, prefix, suffix);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prefix, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; suffix)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> ip = prefix.begin(); ip != prefix.end(); ip++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> is = suffix.begin(); is != suffix.end(); is++)&#123;</span><br><span class="line">			result.push_back(<span class="string">""</span>);</span><br><span class="line">			<span class="built_in">string</span>&amp; r = result.back();    <span class="comment">// 这里返回的是引用！技巧啊！！</span></span><br><span class="line">			r += <span class="string">"("</span>;</span><br><span class="line">			r += *ip;</span><br><span class="line">			r += <span class="string">")"</span>;</span><br><span class="line">			r += *is;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思考]</p>
<ul>
<li>可以通过增加缓存的方式，对已经计算得到的字串直接获取，以空间换时间，降低时间复杂度。</li>
<li>如果只是计算可行括号串的数目，如何计算？<ul>
<li>事实上，数组 A[i] 表示长度为 i 的括号串的可行数目，即著名的 Catalan 数！</li>
</ul>
</li>
<li>Calalan 数（从 0 开始数）<ul>
<li>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, …</li>
</ul>
</li>
</ul>
<h2 id="最小平方划分"><a href="#最小平方划分" class="headerlink" title="最小平方划分"></a>最小平方划分</h2><p>[题目]<br>一个正整数可以由若干个正整数的平方和表示，求整数 201314 最小的平方划分数目。</p>
<p>[我的本来思路]<br>用DP的方法！</p>
<p>假设已知 1, …, n-1 的最小划分保存在数组 split[i] 中。求数 n 最小划分。</p>
<p>只需要遍历 1, …, n/2，然后看哪一个 split[i] + split[n-i] 最小，即是 n 的最小划分。</p>
<p>[优化的思路]<br>我的思路时间复杂度是 O(n^2), 因为对于每一个 n, 我都要考虑到 n/2 种情况。</p>
<p>事实上，这个题目可以优化到 O(n sqrt(n)) 的时间复杂度。具体做法就是考虑 n = a + K^2。<br>也就是说，只需要考虑 1 … K 这么多数字，其中 K = sqrt(n).<br>若 split[n - k^2] + 1 &lt; x (x 是当前的 n 的最小划分数目), 则将 x 更新为 split[n - k^2] + 1</p>
<p><mark>[如何求平方根]</mark><br>可以使用牛顿法。<br>牛顿法就是求一个方程的解的方法。</p>
<p>[题外话]<br>四平方和定理</p>
<ul>
<li>每个正整数均可表示为最多4个整数的平方和。</li>
<li>证明<ul>
<li>首先欧拉发现：如果正整数 m 和 n 能表示成 4 个整数的平方和，则其乘积 mn 也能表示成 4 个整数的平方和。</li>
<li>而由于每个正整数要么是质数，要么是合数，而合数都可以表达成质数的乘积形式。</li>
<li>因此只需要证明每个质数可以表示成四个整数的平方和即可！</li>
<li>拉格朗日和欧拉分别在 1770 和 1773 年做出证明。</li>
</ul>
</li>
</ul>
<h2 id="Palindrome-Partitioning-所有划分"><a href="#Palindrome-Partitioning-所有划分" class="headerlink" title="Palindrome Partitioning 所有划分"></a>Palindrome Partitioning 所有划分</h2><p>[题目]<br>给定一个字符串 str, 将 str 划分成若干子串，使得每一个子串都是回文串。计算 str 的所有可能的划分。</p>
<p>note: 因为单个字符一定是回文串，所以一定有解！</p>
<p>[思路一]</p>
<ul>
<li>若当前计算得到了 str[0 … i-1] 的所有划分，可否添加 str[i … j], 得到更大的划分呢？<ul>
<li>显然，若 str[i…j] 是回文串，则可以添加。</li>
</ul>
</li>
<li>剪枝: 在每一步都可以判断中间结果是否为合法结果<ul>
<li>回溯 + 剪枝：如果某一次发现划分不合法，立刻对该分支限界</li>
</ul>
</li>
</ul>
<p>[思路一的代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSolution</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; oneSolution, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start &gt;= n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPalindrome[start][i])&#123;</span><br><span class="line">			oneSolution.push_back(str.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">			FindSolution(str, n, res, i + <span class="number">1</span>, oneSolution, isPalindrome);</span><br><span class="line">			oneSolution.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二维 DP 来构建 isPalindrome 矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line">		p[i][i] = True;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">				isPalindrome[i][j] = True;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; PalindromePartitioning(<span class="built_in">string</span> str)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = str.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;str&gt;&gt; res;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalindrome(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">	ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;str&gt; oneSolution;    <span class="comment">// 记录一个解！！！</span></span><br><span class="line">	FindSolution(str, n, res, start, oneSolution, isPalindrome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思路二：动态规划]</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/leecode-O-n-time-complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/leecode-O-n-time-complexity/" itemprop="url">leecode O(n) time complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-11T19:36:14-08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/11/leecode-O-n-time-complexity/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/11/leecode-O-n-time-complexity/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>O(n) 是什么<ul>
<li>注意 n 是什么？图的节点？边？</li>
<li>扫一遍</li>
<li>两头扫</li>
<li>双重循环，但是内循环变量不减</li>
<li>单调性<ul>
<li>队列</li>
<li>堆栈</li>
</ul>
</li>
<li>组合数学<ul>
<li>下一个排列（上一个排列）</li>
<li>巧妙地证明</li>
<li>计数 != 枚举</li>
</ul>
</li>
<li>动态规划</li>
</ul>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-名人问题"><a href="#1-名人问题" class="headerlink" title="1. 名人问题"></a>1. 名人问题</h2><p>[题目]<br>有 n 个人他们之间认识与否用邻接矩阵表示（1 表示认识，0 表示不认识），并且A认识 B 并不意味着 B 认识 A。<br>名人定义为他不认识任何人且所有人都认识他的人。请求出所有名人。</p>
<p>[分析]<br>最多有几个名人？1 个！</p>
<p>O(n) 的方法：<br>对于两个人 i 和 j，如果 i 认识 j，则 i 显然不是名人，排除掉；<br>如果 i 不认识 j，则 j 显然不是名人，排除掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一：一头扫</span></span><br><span class="line"><span class="comment">// i &lt; j, [0...i-1]没有名人，[i...j-1] 没有名人</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">		i = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现二：两头扫</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">	<span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">		++i;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		--j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">	<span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;  <span class="comment">// i认识j或者j不认识i</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>
<h2 id="Trapping-in-Rain-Water-leetcode-0042"><a href="#Trapping-in-Rain-Water-leetcode-0042" class="headerlink" title="Trapping in Rain Water leetcode 0042"></a>Trapping in Rain Water leetcode 0042</h2><h2 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h2><p>[题目]<br>a[i] 表示横坐标为 i 出有一个高度为 a[i] 的竖线。把两个竖线当做一个容器左右边的高度，<br>横轴当做底，问哪两条线段组成的容器容量最大？</p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> n = height.size();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">    		best = max(best, min(height[i], height[j]) * (j - i));</span><br><span class="line">    		<span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">    			++i;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			--j;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大间隔问题"><a href="#最大间隔问题" class="headerlink" title="最大间隔问题"></a><strong>最大间隔问题</strong></h2><p>[题目]<br>给定数组 a，求下标对 i，j 满足 a[i]&lt;=a[j]，并且 j-i 最大。</p>
<p>[分析]</p>
<ul>
<li>假设目前最优解是 d，对于 j，至少要检查 i = j - d - 1 才可能更优。</li>
<li>记录前缀最小值 p[x] = min{p[0…x]}</li>
<li>倒着循环 j，对于每个 j 看一下 p[j-d-1] 是否 &lt;= a[j]，用 p 引导。</li>
<li>如果前面都比 a[j] 大，则这个 j 得不到更优的解。</li>
</ul>
<p><mark>这一题我实在没有想到这个巧妙地思路，我始终局限在两个 pointer 指到元素上面。<br>但是它其实是有一个 “pointer” 是 d！参考下面的代码。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		p[i] = ((i ==<span class="number">0</span>) || (a[i] &lt; p[i<span class="number">-1</span>])) ? a[i] : p[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; best; --j)&#123;</span><br><span class="line">		<span class="keyword">while</span>((j &gt; best) &amp;&amp; (a[j] &gt;= p[j - best <span class="number">-1</span>]))&#123;</span><br><span class="line">			++best;</span><br><span class="line">		&#125;  <span class="comment">// 对于每一个 j, 内层循环都试图找到这个 j 所能允许的最大的 gap.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01-相等的串"><a href="#01-相等的串" class="headerlink" title="01 相等的串"></a>01 相等的串</h2><p>[题目]<br>给定一个 01 串，求它的一个最长的子串满足 0 和 1 的个数相等。</p>
<p>[分析]</p>
<ul>
<li><mark>把 0 看成 -1，1 当做 +1</mark>，还是使用“前缀和”的技巧<ul>
<li><font color="orange">这个把 0 看成 -1 的操作绝了！本来这一段区间内即使 0 1 的数量相等，区间和也有很多种数值可能，现在把 0 当成 -1 以后，这么多的可能都塌缩到一种可能: 0!!</font></li>
</ul>
</li>
<li>如果有两个前缀和相等，则这两个前缀和之间的子串满足 0，1 的个数相等。</li>
<li>需要对前缀和排序吗？那就是 O(nlogn) 的时间复杂度了</li>
<li>优化！不需要排序<ul>
<li>前缀和的范围是[-n…n]，我们加上 n 之后就是 [0…2n]，只要记录<mark>第一次出现</mark>的位置。</li>
<li>本质！用 hash 代替排序。当 hash 值是比较小的非负整数时，可以用做数组下标。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; have((n &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 擦，括号里面就是 2n+1 的意思。</span></span><br><span class="line">	have[n] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = n;</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		sum += (s[i] == <span class="string">'0'</span>) ? (<span class="number">-1</span>) : (+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(have[sum] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			best = max(best, i - have[sum] + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			have[sum] = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制矩阵中-1-的个数"><a href="#二进制矩阵中-1-的个数" class="headerlink" title="二进制矩阵中 1 的个数"></a>二进制矩阵中 1 的个数</h2><p>[题目]<br>给定 n * n 的 01 方阵，每一行都是降序的（即先连续的一段 1，再连续的一段 0），求 1 最多的那行中 1 的个数？</p>
<p>[分析]</p>
<ul>
<li>思路一：数出每一行的 1 … 复杂度O(n^2)</li>
<li>思路二：二分法找到每一行 0 和 1 的分界线，复杂度 O(nlogn)</li>
<li>思路三：从左上角开始，如果某个位置是 1，就向右走，如果是 0 则向下走！（我们只需要找到比本行更多的 1 才有意义！）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (best &lt; n) &amp;&amp; (i &lt; n); ++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>((best &lt; n) &amp;&amp; (a[i][best] == <span class="string">'1'</span>))&#123;</span><br><span class="line">			++best;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><ul>
<li>最大子数组和</li>
<li>KMP</li>
<li>Manacher</li>
<li>最大直方图（单调堆栈）</li>
<li>滑动窗口最大值（单调队列）</li>
<li>快排 partition 过程</li>
<li>杨氏矩阵查找<ul>
<li>荷兰国旗问题</li>
<li>First Missing Positive</li>
</ul>
</li>
<li>排列组合相关<ul>
<li>Next/Previous permutation</li>
</ul>
</li>
<li>树相关<ul>
<li>二叉树遍历，（最大、最小）深度，同构，镜像判断，平衡判断</li>
</ul>
</li>
</ul>
<h2 id="下一个排列-leetcode-0031-STL亦如此实现"><a href="#下一个排列-leetcode-0031-STL亦如此实现" class="headerlink" title="下一个排列 leetcode 0031 (STL亦如此实现)"></a>下一个排列 leetcode 0031 (STL亦如此实现)</h2><p>[题目]<br>Next Permutation 找到字典序里的下一个排列。12345 的下一个是 12354，而54321 的下一个是 12345.</p>
<p>[分析]</p>
<ul>
<li>a[0], a[1], …, a[n-1], 下一个排列是字典序比它大，最小的</li>
<li>找到尽可能大的 m, b[0] = a[0], b[1] = a[1], …, b[m-1] = a[m-1], 而 b[m] &gt; a[m], b[m+1 … n-1] 是按照升序排列的。</li>
</ul>
<p>[形象点的分析]</p>
<ul>
<li>目前的排列是: (A)a<a href="B">x</a></li>
<li>下一个排列是: (A)a<a href="B&#39;">y</a><ul>
<li>A 是相同的，A 尽可能长</li>
<li>a[y] &gt; a[x]</li>
<li>B’ 几乎是 B 里面的数排好顺序的结果</li>
</ul>
</li>
<li>如何确定 x？<ul>
<li>一个位置只要右边有数比它大就是候选的 x</li>
<li>a[x] 是最后一个这样的数（最右边）<ul>
<li>a[x] 右边的数，没个数的右边没有比它大的</li>
<li>所以 a[x] 右边的数是按照降序（不升序）排列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[算法 (二找、一交换、一翻转)]</p>
<ul>
<li>找到最后一个严格升序的首位 (a[i] &lt; a[i+1])，定义为 x<ul>
<li>(A) = a[0…x-1], (B) = a[x+1…n-1]</li>
</ul>
</li>
<li>找到 y&gt;x, a[y] &gt; a[x], 且 a[y] 最小<ul>
<li>一定存在，因为 x+1 就是一个候选</li>
<li>a[x] 后面的数都是降序，所以从后往前找到第一个大于 a[x] 的位置就是 y 了</li>
<li>可以二分找到 y，但不影响总体时间复杂度</li>
</ul>
</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转<ul>
<li>交换后 a[x+1…n-1] 仍然是降序（不升）</li>
<li>逆转等于排序</li>
</ul>
</li>
</ul>
<p><mark>这个解法要熟记！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(x = n<span class="number">-2</span>; (x&gt;=<span class="number">0</span>) &amp;&amp; (nums[x] &gt;= nums[x+<span class="number">1</span>]); --x)</span><br><span class="line">	;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		reverse(nums.begin(), nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(y = n - <span class="number">1</span>; nums[y] &lt;= nums[x]; --y)</span><br><span class="line">	;</span><br><span class="line">	swap(nums[x], nums[y]);</span><br><span class="line">	reverse(nums.begin() + x + <span class="number">1</span>, nums.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思考题：上一个排列？"><a href="#思考题：上一个排列？" class="headerlink" title="思考题：上一个排列？"></a>思考题：上一个排列？</h3><p>类似的思路</p>
<ul>
<li>找到最后一个严格降序的首位(a[i] &gt; a[i+1])，定义为 x</li>
<li>找到 y&gt;x, a[y] &lt; a[x], 且 a[y] 最大</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转</li>
</ul>
<h2 id="均分01"><a href="#均分01" class="headerlink" title="均分01"></a>均分01</h2><p>[题目]<br>给定一个01串，签好包含 2n 个 0 和 2n 个 1，你可以把它切成若干段，再把它们任意拼接，要求拼接出两部分，每部分恰好包含 n 个 0，n 个 1，如何使得切得段数最少？</p>
<p>[示例]<br>举例一：0101，从中间切一刀形成(01)(01)，分别作为两部分<br>举例二：0011，切成 3 段 (0)(01)(1), 把中间 (01) 单独作为一部分，生育的 (0)(1) 作为另外一部分。</p>
<p>[思路]<br>这一题其实都不算是算法题我觉得。<br>先考虑前面 2n 个数字，如果里面 1 的个数超过 0，那么把这个长度为 2n 的窗口向右挪，中间肯定在某个位置使得 1 和 0 的个数相等？为啥呢？因为不可能在所有的位置都有 2n 窗口内 1 的个数大于 0 的个数，这与题目的条件 4n 窗口内有 2n 个 1 和 2n 个 0 相冲突！</p>
<p>[答案]<br>如果最前面 2n 个数满足 1 和 0 个数相等，那么就分成两段就可以了；<br>如果不是，那么就分成三部分。</p>
<h2 id="X-的个数"><a href="#X-的个数" class="headerlink" title="X 的个数"></a>X 的个数</h2><p>[题目]<br>给定一个长度为 n 的整数数组 a，下标从 0 开始，再给定一个元素 X，求一个位置 m，满足 0&lt;=m&lt;=n，且 a[0…m-1] 中 X 的个数（如果m=0表示空数组）和 a[m…n-1] 中非 X 的个数（如果 m==n，表示空数组）相等。</p>
<p>[分析]</p>
<ul>
<li>假设 a 中一共有 x 个 X，给定 m，假设 a[0…m-1] 中有 y 个 X，则 a[m…n-1] 中非 X 的个数是 (n-m)-(x-y) = n-m-x+y == y</li>
<li>化简可得 m = n - x</li>
<li>解存在且唯一！</li>
</ul>
<p>[解法]</p>
<ul>
<li>直接统计下有多少个 X 就可以了</li>
<li>O(n) 时间，O(1) 空间</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>[题目]<br>10个硬币，有四个是正面的，在不开灯的情况下，把他们分成两组，如果做可以使得正面的个数相等？（可以手动改变某些硬币的正反面）</p>
<p>[答案]<br>分成两组，一组 6 个，一组 4 个，然后把 4 个的那组所有硬币都翻个面。</p>
<h2 id="PAT-的个数"><a href="#PAT-的个数" class="headerlink" title="PAT 的个数"></a>PAT 的个数</h2><p>[题目]<br>给定一个只包含 P, A, T 的串，求一共出现多少个 “PAT” 子序列？</p>
<p>[分析：计数和枚举不同]</p>
<ul>
<li>p, pa, pat 表示之前出现的 “P”, “PA”, “PAT” 的个数</li>
<li>s[i] == “P”, ++p</li>
<li>s[i] == “A”, pa += p</li>
<li>s[i] == ‘T’, pat += pa</li>
<li>时间复杂度 O(n)，空间复杂度 O(1)</li>
</ul>
<h3 id="思考题-distinct-subsequences-leetcode-115"><a href="#思考题-distinct-subsequences-leetcode-115" class="headerlink" title="思考题 distinct subsequences leetcode 115"></a>思考题 distinct subsequences leetcode 115</h3><p>[题目]<br>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意内层的 for 循环是倒着来算的，这样子可以排除掉出现相同字母的情形。</span></span><br><span class="line"><span class="comment">比如 S = "rabbbit", T = "rabbit"</span></span><br><span class="line"><span class="comment">T 的第三第四个位置都是 'b'</span></span><br><span class="line"><span class="comment">如果你从左往右看 T, 第三个 'b' 那里你把 dp[2]更新了，</span></span><br><span class="line"><span class="comment">这会导致第四个 'b' 那里你用 dp[2] 来计算 dp[3] 出现错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(t.size(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = t.size()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                    dp[j] += j ? dp[j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小平均值子数组-codility"><a href="#最小平均值子数组-codility" class="headerlink" title="最小平均值子数组 codility"></a>最小平均值子数组 codility</h2><p>[题目]<br>给定一个数组，求一个至少包含两个元素的子数组，满足平均值最小。<br>输出子数组的起点，多个的时候输出最小的。</p>
<p>[分析]</p>
<ul>
<li>如果最优解长度为偶数，把它拆成长度为 2 的若干段</li>
<li>如果最优解长度为奇数 (&gt;2), 我们把它柴承长度为 2 的若干段，和一段长度为 3 的段</li>
<li>最优解中每一段的平均值都相等<ul>
<li>如果某一段平均值比最优解小，至少有一段平均值比最优解大，矛盾。</li>
</ul>
</li>
<li>！！！ 一次，只需要考虑长度为 2 和 3 的段计算就可以了。</li>
</ul>
<h2 id="环形最大子数组和-from-itint5-com-Q9"><a href="#环形最大子数组和-from-itint5-com-Q9" class="headerlink" title="环形最大子数组和 from itint5.com Q9"></a>环形最大子数组和 from itint5.com Q9</h2><p>[题目]<br>给定一个数组，是环形的，最后一个元素和第一个元素相接，求最大子数组和。</p>
<p>[分析]</p>
<ul>
<li>环形最大子数组和<ul>
<li>普通最大子数组和，例如 1 2 -4 <mark> 5 6 -9 </mark></li>
<li>开头和结尾的一部分，例如 <mark>1 2 </mark> -4 -5 -6 <mark> 9 </mark></li>
</ul>
</li>
<li>算法<ul>
<li>求普通最大子数组的和</li>
<li>总和减去普通的最小子数组和<ul>
<li>可以考虑对原始数组取相反数，调用最大子数组和模块。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="允许交换一次的最大子数组和"><a href="#允许交换一次的最大子数组和" class="headerlink" title="允许交换一次的最大子数组和"></a>允许交换一次的最大子数组和</h2><p><mark> 这一题非常难！要好好琢磨其 DP 思路 </mark></p>
<p>[题目]<br>给定一个数组，在允许交换两个数的前提下（只允许交换一次，可以不换），求最大子数组的和。</p>
<p>[分析]</p>
<ul>
<li>定义 f[i] 为两部分之和<ul>
<li>以 a[i] 结尾的最大子数组的和（可以为空）</li>
<li>与任意 a[0…i] 里面单独一个元素</li>
<li>以上两部分没有交集</li>
<li>递推式 f[i] = max(f[i-1] + a[i], max(a[0…i]))</li>
</ul>
</li>
<li>定义 g[i]<ul>
<li>以 a[i] 开头的最大子数组和（非空）</li>
<li>递推式 g[i] = max(g[i+1], 0) + a[i]</li>
</ul>
</li>
<li>如果 a[i] 和 a[j] 交换 (j &lt; i), 原来包含 a[i] 的最大子数组和变为<ul>
<li>g[i] - a[i] + f[i-1]</li>
<li>（即要换掉的元素在 f[i-1] 里, <mark>单独存在的那一个</mark>）</li>
</ul>
</li>
<li>如果不交换，答案就是 max{g[i]}</li>
<li>我们只考虑 j &lt; i 的情况，对于 j &gt; i, 把 a 翻转再做一次就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f, g;</span><br><span class="line">	f.resize(n);</span><br><span class="line">	f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> now = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		now = max(now, a[i]);</span><br><span class="line">		f[i] = max(a[i] + f[i<span class="number">-1</span>], now);</span><br><span class="line">	&#125;</span><br><span class="line">	g.resize(n);</span><br><span class="line">	g[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">int</span> ans = a[n<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		g[i] = max(g[i+<span class="number">1</span>], <span class="number">0</span>) + a[i];</span><br><span class="line">		answer = max(answer, g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		answer = max(answer, g[i] - a[i] + f[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> answer = help(A);</span><br><span class="line">	reverse(A.begin(), A.end());</span><br><span class="line">	answer = max(answer, help(A));</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>计数 != 枚举</li>
<li>没有讲到的问题<ul>
<li>O(n^3) 优化到 O(n^2)</li>
<li>序列相关的问题<ul>
<li>给定一个 1-n 的排列，每次只能把一个数放到序列开头，至少几次能排好循序？</li>
<li>给定一个 1-n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序？</li>
</ul>
</li>
<li>更多前缀、后缀的利用</li>
</ul>
</li>
</ul>
<h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><h3 id="leetcode-53-最大连续子数组和"><a href="#leetcode-53-最大连续子数组和" class="headerlink" title="leetcode 53 最大连续子数组和"></a>leetcode 53 最大连续子数组和</h3><p>[题目]<br>给定一个数组，求最大的连续子数组和。</p>
<p>[分析]</p>
<ul>
<li>方法一 记录最小前缀和（两个前缀和的差就是一段连续的子数组）</li>
<li>方法二 动态规划，记录以每个位置结束的最大子数组的和。</li>
</ul>
<h3 id="leetcode-152-求最大的连续子数组乘积"><a href="#leetcode-152-求最大的连续子数组乘积" class="headerlink" title="leetcode 152 求最大的连续子数组乘积"></a>leetcode 152 求最大的连续子数组乘积</h3><p>[分析]</p>
<ul>
<li>首先要考虑一下是否会溢出</li>
<li>到当前项乘积最大要考虑之前乘积的绝对值，因此要记录<ul>
<li>之前最小乘积</li>
<li>之前最大乘积</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">    	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">int</span> mini = nums[<span class="number">0</span>], maxi = nums[<span class="number">0</span>], ansmin = nums[<span class="number">0</span>], ansmax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    		<span class="keyword">int</span> tempmin = min(nums[i], min(mini * nums[i], maxi * nums[i]));</span><br><span class="line">    		<span class="keyword">int</span> tempmax = max(nums[i], max(mini * nums[i], maxi * nums[i]));</span><br><span class="line">    		mini = tempmin;</span><br><span class="line">    		maxi = tempmax;</span><br><span class="line">    		ansmin = min(mini, ansmin);</span><br><span class="line">    		ansmax = max(maxi, ansmax);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ansmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>[题目]<br>一个数组，比如 {1,2,3,4,5} 循环移动一位就是 {2,3,4,5,1}，再移动一位就是 {3,4,5,1,2}.</p>
<p>[分析]</p>
<ul>
<li>长度为 n，把它移动 m 位，和移动 m % n 位是一样的。</li>
<li>翻转前 m 位</li>
<li>翻转后 (n-m) 位</li>
<li>总体再翻转</li>
<li>翻转可以O(n)做到：<ul>
<li>for(int i = from, j = to; i &lt; j; swap(a[i++], a[j–]));</li>
</ul>
</li>
</ul>
<h3 id="单词翻转"><a href="#单词翻转" class="headerlink" title="单词翻转"></a>单词翻转</h3><h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><h2 id="快排-partition"><a href="#快排-partition" class="headerlink" title="快排 partition"></a>快排 partition</h2><ul>
<li>荷兰国旗问题 leetcode 75</li>
<li>奇偶数分开，正负数分开</li>
<li>01 交换排序</li>
<li>交换星号</li>
<li>第一个缺失的整数 leetcode 41</li>
<li>中位数、第k大（小）的书、最大（小）的k个数<ul>
<li>找第 k 大的数关键<ul>
<li>5 数取中做 pivot (3 数取中会退化)</li>
<li>Partition 过程分三段（分两段有相同数会退化）<ul>
<li>算法导论“偷懒”了（它假设了没有相同的数做了分析）</li>
</ul>
</li>
</ul>
</li>
<li>找到最小的 k 个数<ul>
<li>基于 partition 的方法找到的数是无序的</li>
<li>如果要有序建议用堆 O(nlogk)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>[思路一]</p>
<ul>
<li>直接两次快排</li>
<li>第一次把 0 和非 0 分开</li>
<li>第二次把 1 和 2 分开</li>
</ul>
<p>[思路2]<br>循环不变式的应用</p>
<ul>
<li>三个变量 begin, cur, end 把数组分成四个区域<ul>
<li>[0, begin): 所有数据都是 0</li>
<li>[begin, current): 所有数据都是 1</li>
<li>(end, size-1]: 所有数据都是 2</li>
<li>[current, end): 未知</li>
</ul>
</li>
<li>循环不变式<ul>
<li>初值 begin=current=0, end=size-1, 前三个区间都为空集，满足以上四个条件</li>
<li>遍历 current, 根据arr[current] 的值作相应处理，直到区间 [current, end) 为空，即 current==end 时退出。</li>
<li>代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Holland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="keyword">int</span>(arr.size()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(current &lt;= end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[current] == <span class="number">2</span>)&#123;</span><br><span class="line">			swap(arr[end], arr[current]);</span><br><span class="line">			end--;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[current] == <span class="number">1</span>)&#123;</span><br><span class="line">			current++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;                  <span class="comment">// if(a[current] == 0)</span></span><br><span class="line">			<span class="keyword">if</span>(current != begin)&#123;</span><br><span class="line">				swap(arr[current], arr[begin]);</span><br><span class="line">			&#125;</span><br><span class="line">			begin++;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>[荷兰国旗与快排的优化]</mark></p>
<p>传统的快排每次选取 pivot，然后把元素分成 &lt;=pivot 和 &gt;pivot 两部分。<br>在有相同元素的时候，每次分割递归的时候还是把 pivot 左边的，pivot 右边的递归。</p>
<p>而使用荷兰国旗思想，则可以优化有大量重复数字的情况。</p>
<p>假设选取的 pivot 呢，有很多相同元素，荷兰国旗的思想就是把元素分成三段！<br>第一段小于 pivot, 第二段等于 pivot, 第三段大于 pivot.</p>
<p>然后递归的时候，中间等于 pivot 的那一段就不需要在处理了！！！<br>因此有很多优化。</p>
<p><mark>快排的最坏情况</mark></p>
<ol>
<li>本来已经是顺序排好了</li>
<li>本来已经是逆序排好了</li>
<li>所有元素都一样！(这个可以用荷兰国旗思想来优化！)</li>
</ol>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><ul>
<li>找出出现次数超过一半的数</li>
<li>推广：找出出现次数大于 1/k 的数，用 (k-1) 个 map，复杂度 O(n * k)，注意 k 是常数的时候就是 O(n).</li>
</ul>
<h2 id="单调堆栈"><a href="#单调堆栈" class="headerlink" title="单调堆栈"></a>单调堆栈</h2><p>[题目]<br>最大直方图</p>
<p>[思路]</p>
<ul>
<li>入栈时左边界确定</li>
<li>出栈时右边界确定</li>
<li>每块只出入栈一次<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="滑动窗口最值-栈和队列-例6"><a href="#滑动窗口最值-栈和队列-例6" class="headerlink" title="滑动窗口最值 (栈和队列 例6)"></a>滑动窗口最值 (栈和队列 例6)</h3><h3 id="codility-题目"><a href="#codility-题目" class="headerlink" title="codility 题目"></a>codility 题目</h3><p>[题目]<br>给定一个数组 A 和整数 K，问有多少对下标 i&lt;=j 满足 max(A[i…j]) - min(A[i…j]) &lt;= K</p>
<p>[分析]</p>
<ul>
<li>如果(i,j)满足条件，则(i+1,j), (i+2,j)…都满足条件。</li>
<li>对每个 i, 找到第一个不满足条件的 j</li>
<li>如何求 [i…j] 的最大最小值<ul>
<li>单调队列</li>
<li>滑动窗口（两个边界都只增大不减）<ul>
<li>滑动出去的不会进来</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qmin, qmax;</span><br><span class="line">	<span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; A.size(); i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &lt; A.size())&#123;</span><br><span class="line">			<span class="keyword">while</span>((!qmin.empty()) &amp;&amp; (A[qmin.back()] &gt;= A[j]))&#123;</span><br><span class="line">				qmin.pop_back();</span><br><span class="line">			&#125; <span class="comment">// qmin 里面的元素是单调递增的！</span></span><br><span class="line">			qmin.push_back(j);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>((!qmax.empty()) &amp;&amp; (A[qmax.back()] &lt;= A[j]))&#123;</span><br><span class="line">				qmax.pop_back();</span><br><span class="line">			&#125; <span class="comment">// qmax 里面的元素是单调递减的！</span></span><br><span class="line">			qmax.push_back(j);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(A[qmax.front()] - A[qmin.front()] &lt;= K)&#123;</span><br><span class="line">				++j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  <span class="comment">// 这个 while 循环找到最远的 j。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(qmin.front() == i)&#123;</span><br><span class="line">			qmin.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(qmax.front() == i)&#123;</span><br><span class="line">			qmax.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		answer += j - i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><ul>
<li>树的高度</li>
<li>二叉树对称判断</li>
<li>二叉树平衡判断</li>
<li>二叉树的最小深度</li>
<li>指定和的路径</li>
<li>二叉树双向链表转换</li>
<li>前中后序遍历</li>
</ul>
<h3 id="距离最远的点"><a href="#距离最远的点" class="headerlink" title="距离最远的点"></a>距离最远的点</h3><p>[题目]<br>给定一个无根的树（无向<mark>无环图</mark>），求距离最远的两个点（树的直径）。</p>
<p>[易忽略]</p>
<ul>
<li>对于一个自由树的直径，《算法导论》上的说明是“树中所有最短路径的最大值即为树的直径。”</li>
<li>记住，“无环图”这个概念很重要。</li>
<li>最笨的方法<ul>
<li>就是对每一个节点进行 BFS, 找到最远的点。这个方法时间复杂度是 O(n^2).</li>
</ul>
</li>
<li>简单巧妙的贪心<ul>
<li>以任意一点为根、找到距离它最远的节点 x</li>
<li>以 x 为根找到距离 x 最远的点 y</li>
<li>(x, y) 就是一条直径</li>
</ul>
</li>
<li>如何找最远的点？dfs 求深度</li>
<li>思考：算法证明？</li>
</ul>
<p>[证明]<br>但是在证明定义之前，先证明一个引理：</p>
<p>引理：在一个连通无向无环图中，x、y 和 z 是三个不同的结点。当 x 到 y 的最短路与 y 到 z 的最短路不重合时，x 到 z 的最短路就是这两条最短路的拼接。</p>
<p>证明：假设 x 到 z 有一条不经过 y 的更短路δ(x,z)，则该路与δ(x,y)、δ(y,z)形成一个环，与前提矛盾。</p>
<p>定理：在一个连通无向无环图中，以任意结点出发所能到达的最远结点，一定是该图直径的端点之一。</p>
<p>证明：假设这条直径是δ(s,t)。分两种情况：</p>
<ul>
<li>当出发结点 y 在δ(s,t)时，假设到达的最远结点 z 不是 s,t 中的任一个。这时将δ(y,z)与不与之重合的δ(y,s)拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的直径，与前提矛盾。</li>
<li>当出发结点 y 不在δ(s,t)上时，分两种情况：<ul>
<li>1). 当 y 到达的最远结点 z 横穿δ(s,t)时，记与之相交的结点为 x。此时有δ(y,z)=δ(y,x)+δ(x,z)。而此时δ(y,z)&gt;δ(y,t)，故可得δ(x,z)&gt;δ(x,t)。由1的结论可知该假设不成立。<br>2). 当 y 到达的最远结点 z 与δ(s,t)不相交时，记 y 到 t 的最短路首先与δ(s,t)相交的结点是 x。由假设δ(y,z)&gt;δ(y,x)+δ(x,t)。而δ(y,z)+δ(y,x)+δ(x,s)又可以形成δ(z,s)，而δ(z,s)&gt;δ(x,s)+δ(x,t)+2δ(y,x)=δ(s,t)+2δ(y,x)，显然与题意矛盾。</li>
</ul>
</li>
</ul>
<p>因此定理成立。</p>
<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><p>[题目]<br>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two end nodes</p>
<p>[分析]<br>The diameter of a tree T is the largest of the following quantities:</p>
<ul>
<li>the diameter of T’s left subtree</li>
<li>the diameter of T’s right subtree</li>
<li>the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xz注：这个代码是用 C 实现的，函数的调用需要记录两个变量，</span></span><br><span class="line"><span class="comment">tree height &amp; tree diameter，它这里采用的是通过传递</span></span><br><span class="line"><span class="comment">指针过去来计算得到 height, 然后函数返回的是 tree diameter.</span></span><br><span class="line"><span class="comment">如果使用 C++ 的话，可以让函数返回 vector&lt;int&gt; = &#123;tree_height, tree_diameter&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The second parameter is to store the height of tree. </span></span><br><span class="line"><span class="comment">   Initially, we need to pass a pointer to a location with value </span></span><br><span class="line"><span class="comment">   as 0. So, function should be used as follows: </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   int height = 0; </span></span><br><span class="line"><span class="comment">   struct node *root = SomeFunctionToMakeTree(); </span></span><br><span class="line"><span class="comment">   int diameter = diameterOpt(root, &amp;height); */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOpt</span><span class="params">(struct node *root, <span class="keyword">int</span>* height)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* lh --&gt; Height of left subtree </span></span><br><span class="line"><span class="comment">     rh --&gt; Height of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* ldiameter  --&gt; diameter of left subtree </span></span><br><span class="line"><span class="comment">     rdiameter  --&gt; Diameter of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> ldiameter = <span class="number">0</span>, rdiameter = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    *height = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* diameter is also 0 */</span></span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Get the heights of left and right subtrees in lh and rh </span></span><br><span class="line"><span class="comment">    And store the returned values in ldiameter and ldiameter */</span></span><br><span class="line">  ldiameter = diameterOpt(root-&gt;left, &amp;lh); </span><br><span class="line">  rdiameter = diameterOpt(root-&gt;right, &amp;rh); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Height of current node is max of heights of left and </span></span><br><span class="line"><span class="comment">     right subtrees plus 1*/</span></span><br><span class="line">  *height = max(lh, rh) + <span class="number">1</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> max(lh + rh + <span class="number">1</span>, max(ldiameter, rdiameter)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口相关"><a href="#滑动窗口相关" class="headerlink" title="滑动窗口相关"></a>滑动窗口相关</h2><h3 id="leetcode-209"><a href="#leetcode-209" class="headerlink" title="leetcode 209"></a>leetcode 209</h3><p>[题目]<br>给定一个数组，里面全是正整数，再给一个正整数 s, 求数组里面最少多少个连续的数，满足总和不小于 s.</p>
<p>[分析]</p>
<ul>
<li>核心：大窗口不满足条件，它的任意子窗口也不满足条件。</li>
<li>窗口 [i…j]<ul>
<li>过小，++j</li>
<li>过大, ++i</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> n = nums.size();</span><br><span class="line">    	<span class="keyword">int</span> answer = n;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>; j &lt; n; )&#123;</span><br><span class="line">    		<span class="keyword">while</span>((sum &lt; s) &amp;&amp; (j &lt; n))&#123;</span><br><span class="line">    			sum += nums[j++];</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">    			<span class="keyword">for</span>(; sum &gt;= s; sum -= nums[i++])</span><br><span class="line">    			;</span><br><span class="line">    			answer = min(answer, j - i + <span class="number">1</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (answer &gt;= n) ? <span class="number">0</span> : answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子串变位词"><a href="#子串变位词" class="headerlink" title="子串变位词"></a>子串变位词</h3><p>easy TODO</p>
<h3 id="leetcode-76-最短子串包含全部子母"><a href="#leetcode-76-最短子串包含全部子母" class="headerlink" title="leetcode 76 最短子串包含全部子母"></a>leetcode 76 最短子串包含全部子母</h3><p>easy TODO</p>
<h3 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3 无重复字符的最长子串"></a>leetcode 3 无重复字符的最长子串</h3><p>easy TODO</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>长度</li>
<li>（K 个一组）翻转 leetcode 206, 92, 25</li>
<li>插入 leetcode 147</li>
<li>删除 leetcode 203, 82, 83</li>
<li>复制 leetcode 138</li>
<li>求交 leetcode 160</li>
<li>找环 leetcode 141, 142</li>
<li>（倒数）第 k 个元素 leetcode 19</li>
<li>链表判断是否回文</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2-SUM"></a>2-SUM</h3><p>使用hash easy</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>[题目]<br>给定一个 1-n 的排列，每次只能把一个数放到序列末尾，至少几次能排好顺序。</p>
<p>[分析]</p>
<ul>
<li>需要移动 1 吗？不，其他都排好了，1 自然就好了。</li>
<li>如果要移动 x，则我们必须把 (x+1), (x+2), …, n 都移动了</li>
<li>从 1 到 (x-1) 是有序的<ul>
<li>x 有多大？</li>
</ul>
</li>
</ul>
<font color="red">注意这一题跟下面两个题目不一样的地方是：这一题只能把数字移动到末尾。因此我们必须找从数字 1 开始的子序列，看看能达到多大。<br><br>假设可以达到 x，那么说明 x+1, x+2, …, n 都在 x 的前面出现了，那么为了让数组有序，需要依次把 x+1, x+2, …, n 放到数组最后。<br></font>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size(), want = <span class="number">1</span>;  <span class="comment">// 从 1 开始的子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a[i] == want)&#123;  <span class="comment">// 每次找到 want 以后，就加 1.</span></span><br><span class="line">    		++want;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;  <span class="comment">// 这个找的实际上是有多少个数字出现在了比它小的数字的前面。。。</span></span><br><span class="line">    <span class="comment">// want ... n must be moved</span></span><br><span class="line">    <span class="keyword">return</span> n - want + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组排序2"><a href="#数组排序2" class="headerlink" title="数组排序2"></a>数组排序2</h3><p>题目<br>给定一个 1 到 n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序。</p>
<p>分析</p>
<ul>
<li><font color="red">这一题跟上一题不一样，数字可以移动到开头，所以不需要限制从 1 开始找，只需要找到 y 到 x 最长的就可以。</font></li>
<li>把数字 1 到数字 y 移动到开头，把数字 x 到 数字 n 移动到末尾</li>
<li>[y+1…x-1] 必须按顺序出现</li>
<li>所以目的就是要找到最小的 y 和 最大的 x，这样子 移动的数字才最少。</li>
<li>dp[x] 表示从 x 开始在原数组中往后按顺序出现的最长长度<ul>
<li>即 x, x+1, …, x+dp[x]-1 按顺序出现</li>
<li>倒着循环 i, dp[a[i]] = dp[a[i]+1] + 1</li>
</ul>
</li>
</ul>
<font color="orange">我其实觉得很奇怪，这个 dp 序列在更新的时候，不是按照一定的顺序来逐个得到的。而是来回跳。。。（取决于数组 a 里面的数字从右往左出现的顺序）。</font>

<font color="red">想了一个多小时，从上一题的思路到这一题，终于想明白。<br>首先要清楚，之所以 for 循环里面 i 从大到小，意味着数组是从右往左扫。<br>这样子如果扫到了比如 a[5] = 8, 那么 dp[8] 就可以计算出来了。<br>往左走如果 a[4]=7，那么 dp[7] 就可以用 dp[8] 的结果加上 1 得到。<br>为啥呢？因为是从右往左扫的，后遇见 dp[7] 说明 7 比 8 晚遇见，7 在 8 的左边嘛！满足排序的顺序。</font>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.size(), m = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// 使用 1...n+1 注意下标范围</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		m = max(m, dp[a[i]] = dp[a[i]+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组排序3-NOIP，很难"><a href="#数组排序3-NOIP，很难" class="headerlink" title="数组排序3 NOIP，很难"></a>数组排序3 NOIP，很难</h3><p>[题目描述]<br>给定一个长度为N的数列Ai。<br>你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。<br>求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。</p>
<p>[输入格式]<br>第一行是一个正整数N。<br>第二行是N个正整数Ai。</p>
<p>[输出格式]<br>输出一个整数，表示最少需要的操作次数。</p>
<p>[样例输入]<br>5<br>6 3 7 8 6</p>
<p>[样例输出]<br>2</p>
<p>[题解]</p>
<font color="red">这一题跟上一题不一样的地方在于这一题的数字不一定是 1 到 n，并且数字还可以允许出现重复数字。</font>

<p>经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：</p>
<ul>
<li>子序列单调递增；</li>
<li>若子序列中最小数是L，最大数是R，则子序列必须包含[L+1,R−1]中的数列中的所有数。</li>
</ul>
<p>用单调队列求出满足这两个条件的子序列的最大长度，用n减去就是答案。<br>即这个子序列保持不动，其余数向前或后移动一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE], q[SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"change.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"change.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">		b[a[i]].push_back(i);</span><br><span class="line">		m = max(m, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		reverse(b[i].begin(), b[i].end());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].size(); j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = b[i][j];</span><br><span class="line">			<span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] &gt; k) &#123;</span><br><span class="line">				<span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = max(ans, r - l + <span class="number">2</span> + j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			q[++r] = b[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/排序算法总结/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-10T23:34:42-08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/排序算法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/10/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<h1 id="几个重要的排序法讲解"><a href="#几个重要的排序法讲解" class="headerlink" title="几个重要的排序法讲解"></a>几个重要的排序法讲解</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于<mark>排序效率在同为O(N*logN)的几种排序方法中效率较高</mark>，因此经常被采用，再加上快速排序思想<mark>分治法</mark>也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。</p>
<p>总的说来，要直接默写出快速排序还是有一定难度的，因为本人就自己的理解对快速排序作了下白话解释，希望对大家理解有帮助，达到快速排序，快速搞定.</p>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先从数列中取出一个数作为基准数。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p>对挖坑填数进行总结</p>
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
<p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
<p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
<h4 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h4><p><img src="http://bubkoo.qiniudn.com/shell-sort-animation.gif" alt=""></p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ol>
<p>算法思路：</p>
<ol>
<li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d2(d2 &lt; d1)</li>
<li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</li>
</ol>
<p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="http://bubkoo.qiniudn.com/shell-sort-step1.1.png" alt=""><br>然后分别对 4 个小组进行插入排序，排序后的结果为：</p>
<p>然后，取 d2 = 2，将原数组分为 2 小组，如下图：</p>
<p>然后分别对 2 个小组进行插入排序，排序后的结果为：</p>
<p>最后，取 d3 = 1，进行插入排序后得到最终结果：</p>
<h1 id="各种排序算法的C-代码"><a href="#各种排序算法的C-代码" class="headerlink" title="各种排序算法的C++代码"></a>各种排序算法的C++代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"><span class="comment">//                    Author: qianghaohao(Xqiang)</span></span><br><span class="line"><span class="comment">//                    Mail: qiang.timothy@qq.com</span></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  直接插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 stl 里面的函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = start; i != end; ++i)</span><br><span class="line">    <span class="built_in">std</span>::rotate(<span class="built_in">std</span>::upper_bound(start, i, *i), i, <span class="built_in">std</span>::next(i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  折半插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  二分法找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  希尔排序:</span></span><br><span class="line"><span class="comment">//  a:数组  d:分组间距 n:元素个数</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(2^1.5)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> d, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d; i &lt; n; i++) &#123;</span><br><span class="line">            key = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span>; j -= d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; a[j]) &#123;</span><br><span class="line">                    a[j+d] = a[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+d] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        d -= <span class="number">2</span>;   <span class="comment">//最终要保证d为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 选择排序 selectionSort</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">std</span>::min_element(a.begin() + i, a.end());  <span class="comment">//选最小值</span></span><br><span class="line">      swap(a[i], a[it - a.begin()]);  <span class="comment">//最小值和a[i]交换</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//// 快速排序</span></span><br><span class="line"><span class="comment">//// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//// 稳定性:不稳定</span></span><br><span class="line"><span class="comment">//void QuickSort(vector&lt;int&gt; &amp;a, int low, int high) &#123;</span></span><br><span class="line"><span class="comment">//    int i = low;</span></span><br><span class="line"><span class="comment">//    int j = high;</span></span><br><span class="line"><span class="comment">//    if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//        while (i &lt; j) &#123;   //i == j跳出循环</span></span><br><span class="line"><span class="comment">//            //支点为i</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //支点为j</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//       QuickSort(a, low, i-1);</span></span><br><span class="line"><span class="comment">//	   QuickSort(a, i+1, high);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 快速排序(改进版--避免了交换支点的开销)</span></span><br><span class="line"><span class="comment">/* 时间复杂度:平均是 O(nlogn)，最坏情况和插入排序相同，也是O(n^2)。</span></span><br><span class="line"><span class="comment">比如一个序列5,4,3,2,1，要排为1,2,3,4,5。</span></span><br><span class="line"><span class="comment">或者是序列1，2，3，4，5，虽然已经是排好顺序的了。</span></span><br><span class="line"><span class="comment">但是，按照快速排序方法，每次只会有一个数据进入正确顺序，</span></span><br><span class="line"><span class="comment">不能把数据分成大小相当的两份。</span></span><br><span class="line"><span class="comment">很明显，排序的过程就成了一个歪脖子树，树的深度为n，那时间复杂度就成了O(n^2)。</span></span><br><span class="line"><span class="comment">尽管如此，需要排序的情况几乎都是乱序的，自然性能就保证了。</span></span><br><span class="line"><span class="comment">据书上的测试图来看，在数据量小于20的时候，插入排序具有最好的性能。</span></span><br><span class="line"><span class="comment">当大于20时，快速排序具有最好的性能，归并(merge sort)和堆排序(heap sort)也望尘莫及，</span></span><br><span class="line"><span class="comment">尽管复杂度都为nlog2(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[i];  <span class="comment">//保存支点(最左边的数字)</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;   <span class="comment">//只可能在 i == j 时跳出循环，不会出现 i&gt;j</span></span><br><span class="line">            <span class="comment">//支点为i, 从右边开始找一个小于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pivot &lt;= a[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个数字填到 i 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//支点为j，再从左边开始找一个大于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个大于 pivot 的数字填到 j 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// while 里面的复杂度是 O(n)</span></span><br><span class="line">        <span class="comment">// 循环结束后，说明 i==j，此时左边的值都小于pivot，右边的值都大于pivot</span></span><br><span class="line">        <span class="comment">// 这个时候把 pivot 填写到 i==j 处</span></span><br><span class="line">        <span class="comment">// 之后对左右两边都分别递归做 quicksort</span></span><br><span class="line">       a[i] = pivot;  <span class="comment">//i==j时填入支点</span></span><br><span class="line">       QuickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">	   QuickSort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意，while 里面的复杂度固定是 O(n)，</span></span><br><span class="line"><span class="comment">因为每次比较都会把左指针右移一位或者右指针左移一位。</span></span><br><span class="line"><span class="comment">因此快速排序算法的关键就是减少 while 循环的次数。</span></span><br><span class="line"><span class="comment">那就必须使得每一次while 循环都能保证 pivot 跑到了中间位置。</span></span><br><span class="line"><span class="comment">这个数组被大致等分。</span></span><br><span class="line"><span class="comment">这样子整个算法复杂度就是经典的 divide and conqure 的复杂度 O(nlogn).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用这个代码，更有 C++ 范儿</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(FwdIt first, FwdIt last, Compare cmp = Compare&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> N = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> pivot = <span class="built_in">std</span>::next(first, N/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::nth_element(first, pivot, last, cmp);</span><br><span class="line">    quickSort(first, pivot, cmp);</span><br><span class="line">    quickSort(pivot, last, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  堆排 heapsort</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="comment">//  不适合在元素个数太少的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  调整堆为最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">//(n-1)/2:最后一个有孩子节点的编号</span></span><br><span class="line">        j = <span class="number">2</span>*i;  <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &#123;  <span class="comment">//左右孩子都有</span></span><br><span class="line">            <span class="keyword">if</span> (a[j+<span class="number">1</span>] &gt; a[j]) &#123;  <span class="comment">//选取左右孩子中较大的</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="comment">// 交换--较大的元素调整到根节点</span></span><br><span class="line">        <span class="comment">// 在此也可以用a[0]当作中间变量来交换</span></span><br><span class="line">        <span class="comment">// 相当于temp,因为a[0]在整个排序过程中</span></span><br><span class="line">        <span class="comment">// 没有使用</span></span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用AdjustHeap进行堆排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        AdjustHeap(a, n - i);</span><br><span class="line">        swap(a[<span class="number">1</span>], a[n<span class="number">-1</span>-i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(n)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src中low-mid 和 mid-high两部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid;  <span class="comment">//前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = mid + <span class="number">1</span>;  <span class="comment">//后半部分</span></span><br><span class="line">    <span class="keyword">int</span> n = high;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; m &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src[i] &lt; src[m]) &#123;</span><br><span class="line">            des[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            des[k++] = src[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  合并可能剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        des[k++] = src[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n) &#123;</span><br><span class="line">        des[k++] = src[m++];</span><br><span class="line">    &#125;</span><br><span class="line">    swap_ranges(src.begin() + low, src.begin() + high + <span class="number">1</span>, des.begin());  <span class="comment">//  合并后放回原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  temp:临时向量,保存合并后的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">      mid = first + ((last - first) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      MergeSort(a, first, mid, temp);</span><br><span class="line">      MergeSort(a, mid + <span class="number">1</span>, last, temp);</span><br><span class="line">      MergeArray(a, first, mid, last, temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="comment">//  测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(arr.size());  <span class="comment">//merge sort test</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; arr = &#123;0, 9, 8, 7, 6, 5, 4, 4, 4, 6, 6, 6&#125;;  //heap sort test</span></span><br><span class="line"><span class="comment">// InsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// BinaryInsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// ShellSort(arr, 5, arr.size());</span></span><br><span class="line"><span class="comment">// BubbleSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// SelectSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// QuickSort(arr, 0, arr.size()-1);</span></span><br><span class="line"><span class="comment">// HeapSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// copy(arr.begin() + 1, arr.end(), ostream_iterator&lt;int&gt;(cout, " "));  //heap sort test</span></span><br><span class="line">   MergeSort(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>, temp);</span><br><span class="line">   copy(arr.begin(), arr.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快排为什么快"><a href="#快排为什么快" class="headerlink" title="快排为什么快"></a>快排为什么快</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="external">http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/</a></li>
<li><a href="https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ" target="_blank" rel="external">https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ</a></li>
<li><a href="http://www.inference.org.uk/mackay/sorting/sorting.html" target="_blank" rel="external">http://www.inference.org.uk/mackay/sorting/sorting.html</a></li>
</ul>
<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>我们先来玩一个猜数字游戏：我心里默念一个1~64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1~32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。</p>
<p>我们再来回顾一下这个游戏所蕴含的本质：为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1~10之间，那么一旦发现不是在1~10之间的话就会剩下比N/2更多的可能性需要去考察了。</p>
<p>徐宥在讨论中提到，这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。</p>
<h2 id="称球"><a href="#称球" class="headerlink" title="称球"></a>称球</h2><p>12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。</p>
<p>这个问题是一道流传已久的智力题。网络上也有很多讲解，还有泛化到N个球的情况下的严格证明。也有零星的一些地方提到从信息论的角度来看待最优解法。本来我一直认为这道题目除了试错之外没有其它高妙的思路了，只能一个个方法试，并尽量从结果中寻找信息，然后看看哪种方案最少。</p>
<p>然而，实际上它的确有其它的思路，一个更本质的思路，而且根本用不着信息论这么拗口的知识。</p>
<p>我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。</p>
<p>如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。</p>
<p>为了更清楚的看待这个问题，我们不妨假设有6个球，来考虑一下3、3称和2、2称的区别：</p>
<p>在未称之前，一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后，不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）：1重、2重、3重、4轻、5轻、6轻。即这种称法能排除一半可能性。</p>
<p>现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！我们充分利用了“天平的结果状态可能有三种”这个条件来三等分所有可能性，而不是二等分。</p>
<p>说到这里，剩下的事情就实在很简单了：第二步称法，只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。</p>
<p>MacKay在他的书《Information Theory: Inference and Learning Algorithms》（作者开放免费电子书）里面4.1节专门讲了这个称球问题，还画了一张不错的图，我就照抄了：</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6qe45peoj20d40d875m.jpg" alt="23131201.jpg"></p>
<p>图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现a<b的话剩下的排列可能性就变成n! 2，如果发现a="">b也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持a<b的排列一共有n! 2个，支持a="">b的也是N!/2个，换言之，a<b的概率等于a>b的概率。</b的概率等于a></b的排列一共有n!></b的话剩下的排列可能性就变成n!></p>
<p>我们希望每次在比较a和b的时候，a<b和a>b的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。</b和a></p>
<p>一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。</p>
<h3 id="为什么堆排比快排慢"><a href="#为什么堆排比快排慢" class="headerlink" title="为什么堆排比快排慢"></a>为什么堆排比快排慢</h3><p>回顾一下堆排的过程：</p>
<ol>
<li><p>建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子… 以此类推）</p>
</li>
<li><p>将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。</p>
</li>
<li><p>重复第2步。</p>
</li>
</ol>
<p>这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到——原本剩下多少可能性还是剩下多少可能性。</p>
<p>在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p>
<p>这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。</p>
<p>MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了。具体参考这里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/leetcode-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/leetcode-tree/" itemprop="url">leetcode tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T20:20:05-08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/leetcode-tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h1><p>数的基本操作有</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	tagSTreeNode* left;</span><br><span class="line">	tagSTreeNode* right;</span><br><span class="line"></span><br><span class="line">	tagSTreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; STreeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STreeNode* m_root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(STreeNode* root)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> _Insert(STreeNode* root, <span class="keyword">int</span> val);    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">bool</span> _Insert2(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> _PreOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">void</span> _PreOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder3(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _PostOrder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于任何的树，算法复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Iterative 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* BinaryTree::Find(int v) const &#123;</span><br><span class="line">	if(!m_root) return nullptr;</span><br><span class="line"></span><br><span class="line">	TreeNode* res = m_root;</span><br><span class="line">	while(res)&#123;</span><br><span class="line">		if(v &lt; res-&gt;val)&#123;</span><br><span class="line">			res = res-&gt;left;</span><br><span class="line">		&#125; else if (v &gt; res-&gt;val) &#123;</span><br><span class="line">			res = res-&gt;right;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return res;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加一个节点"><a href="#添加一个节点" class="headerlink" title="添加一个节点"></a>添加一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Insert: BST的插入过程是一个递归过程，如果插入结点值比插入位置结点值小，则插入到左子树。反之则插入到右子树中。若插入位置结点的左子树或者右子树为空，则直接插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::Insert(<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">return</span> _Insert(m_root, val);    <span class="comment">// 递归算法</span></span><br><span class="line">    <span class="comment">// return _Insert2(val);        // 非递归算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert(TreeNode* root, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    	root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// val 已经在 tree 里面了，插入失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert2(<span class="keyword">int</span> val)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root)&#123;</span><br><span class="line">		m_root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode* pnode = m_root, pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exhausively 找到待插入的位置(nullptr)</span></span><br><span class="line">    <span class="comment">// 此时 pnode 就是那个 nullptr, pcur 是此节点的父节点。</span></span><br><span class="line">	<span class="keyword">while</span>(pnode)&#123;</span><br><span class="line">		pcur = pnode;</span><br><span class="line">		<span class="keyword">if</span>(val &lt; pnode-&gt;val)&#123;</span><br><span class="line">			pnode = pnode-&gt;left;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pnode-&gt;val)&#123;</span><br><span class="line">			pnode = pnode-&gt;right;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  <span class="comment">// while 执行完后 pnode = nullptr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(val &lt; pcur-&gt;val)&#123;</span><br><span class="line">		pcur-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pcur-&gt;val) &#123;</span><br><span class="line">		pcur-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除一个节点</span><br><span class="line"></span><br><span class="line">思想就是：</span><br><span class="line">    递归寻找待删除的 node</span><br><span class="line">    找到以后</span><br><span class="line">    如果node 没有左子树，就把右子树提上来</span><br><span class="line">    如果node 没有右子树，就把左子树提上来</span><br><span class="line">    如果node 既有左子树，又有右子树，这个情况比较复杂</span><br><span class="line">        可以把左子树最大的数字拿过来，也可以把右子树最小的拿过来！</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    /<em><br>    方法一：左子树的最右边的 node 替换上来！！！
    </em>/</p>
<pre><code>TreeNode* deleteNode(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* maxNode = findMax(root-&gt;left);
        root-&gt;val = maxNode-&gt;val;
        root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
    }

    return root;
}

TreeNode* findMax(TreeNode* node){
    while(node-&gt;right)
        node = node-&gt;right;
    return node;
}


/* 
方法二：右子树的最左边的 node 替换上来
*/

TreeNode* deleteNode_way2(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* minNode = findMin(root-&gt;right);
        root-&gt;val = minNode-&gt;val;
        root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
    }

    return root;
}

TreeNode* findMin(TreeNode* node){
    while(node-&gt;left)
        node = node-&gt;left;
    return node;
}
*/
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的3种遍历(include iterative and recursive)</span><br><span class="line">1. 下面四种情况中，只有 2 和 3 能唯一决定一棵树。More generally, if a node has only one child, preorder and postorder do not contain enough information to determine whether that child is a left child or a right child.</span><br><span class="line">    1. preorder and postorder</span><br><span class="line">    2. inorder and postorder</span><br><span class="line">    3. preorder and inorder</span><br><span class="line">    4. level order and postorder</span><br><span class="line"></span><br><span class="line">技巧</span><br><span class="line">1. 二叉搜索树的 in-order traversal 输出一个 sorted array</span><br><span class="line">2. 二叉搜索树的 pre-order traversal 输出一个 array，这个 array 不是 sorted，但是它有个特点就是，右子树的值肯定都大于当前节点。(leetcode-255, verify pre-order sequence of Binary Search Tree)</span><br><span class="line"></span><br><span class="line">### 前序遍历</span><br><span class="line">```c++</span><br><span class="line">void BinaryTree::PreOrder(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	_PreOrder(m_root, visited);</span><br><span class="line">	//_PreOrder2(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归思想去做前序遍历</span><br><span class="line">void BinaryTree::_PreOrder(TreeNode* root, vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	if(!root) return;</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">	_PreOrder(root-&gt;left, visited);</span><br><span class="line">	_PreOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非递归方法的前序遍历</span><br><span class="line">void BinaryTree::_PreOrder2(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">	if(!m_root) return;</span><br><span class="line"></span><br><span class="line">	stack&lt;TreeNode*&gt; s;</span><br><span class="line">	s.push(m_root);</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	while(!s.empty())&#123;</span><br><span class="line">		pcur = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		visited.push_back(pcur-&gt;val);</span><br><span class="line">		if(pcur-&gt;right) s.push(pcur-&gt;right);</span><br><span class="line">		if(pcur-&gt;left) s.push(pcur-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二插查找树中序遍历的结果是升序的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::InOrder(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	_InOrder(m_root, visited);</span><br><span class="line">	<span class="comment">// _InOrder2(visited);</span></span><br><span class="line">	<span class="comment">// _InOrder3(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	_InOrder(root-&gt;left, visited);</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">	_InOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历</span></span><br><span class="line"><span class="comment">  注意，这一个不是按照上面的思路！每次拿出一个节点，把右放进去，再放自己，再放左。</span></span><br><span class="line"><span class="comment">  这样子需要额外记录一下节点是不是第一次访问的信息，写起来麻烦！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的解决思路是每次弹出一个节点，需要一直找左子树，</span></span><br><span class="line"><span class="comment">  走到头，把过程中碰到的节点都压入栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* pcur = m_root;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pcur || !s.empty())&#123;</span><br><span class="line">		<span class="keyword">while</span>(pcur)&#123;        <span class="comment">// 找最左孩子</span></span><br><span class="line">			s.push(pcur);</span><br><span class="line">			pcur = pcur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">			pcur = s.top();    <span class="comment">// 访问左海子为空的节点</span></span><br><span class="line">		    s.pop();</span><br><span class="line">		    visited.push_back(pcur-&gt;val);</span><br><span class="line">		    pcur = pcur-&gt;right;    <span class="comment">// 转向右孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历 第二种思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放自己，再放左子树节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">	s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">		pcur = s.top().first;</span><br><span class="line">		times = s.top().second;</span><br><span class="line">		s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">		<span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			visited.push_back(pcur-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BinaryTree::PostOrder(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	_PostOrder(m_root, visited);</span><br><span class="line">	<span class="comment">// _PostOrder2(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_PostOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">	_PostOrder(root-&gt;left, visited);</span><br><span class="line">	_PostOrder(root-&gt;right, visited);</span><br><span class="line">	visited.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的后序遍历（与中序遍历的第三个方法代码区别就只有一行！）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放左子树节点，再放自己。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">	s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> times;</span><br><span class="line">	TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">		pcur = s.top().first;</span><br><span class="line">		times = s.top().second;</span><br><span class="line">		s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">		<span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">			s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">				s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			visited.push_back(pcur-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据前序中序，计算后续"><a href="#根据前序中序，计算后续" class="headerlink" title="根据前序中序，计算后续"></a>根据前序中序，计算后续</h3><p>[例如]<br>前序遍历: GDAFEMHZ<br>中序遍历: ADEFGHMZ</p>
<p>[思路]<br>两个步骤</p>
<ul>
<li>根据前序中序，构造二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InPre2Post</span><span class="params">(<span class="built_in">string</span> InOrder, <span class="built_in">string</span> PreOrder)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	<span class="keyword">int</span> n1 = InOrder.size();</span><br><span class="line">	<span class="keyword">int</span> n2 = PreOrder.size();</span><br><span class="line">	<span class="keyword">return</span> helper(InOrder, <span class="number">0</span>, n1 - <span class="number">1</span>, PreOrder, <span class="number">0</span>, n2 - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; InOrder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; PreOrder, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">    	res.push_back(InOrder[i]);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">while</span>(InOrder[k] != PreOrder[p])&#123;</span><br><span class="line">    	k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(InOrder, i, k<span class="number">-1</span>, PreOrder, p+<span class="number">1</span>, p+k-i, res);</span><br><span class="line">    helper(InOrder, k+<span class="number">1</span>, j, PreOrder, p+<span class="number">1</span>+k-i, q, res);</span><br><span class="line">    res.push_back(PreOrder[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据后续和中序，计算前序"><a href="#根据后续和中序，计算前序" class="headerlink" title="根据后续和中序，计算前序"></a>根据后续和中序，计算前序</h3><p>思路跟上面的 InPre2Post 基本一模一样。只不过：</p>
<ul>
<li>一个是 InOrder 的第一个元素作为根节点，</li>
<li>一个是 PostOrder 的末尾元素作为根节点。</li>
</ul>
<h2 id="复杂的树结构"><a href="#复杂的树结构" class="headerlink" title="复杂的树结构"></a>复杂的树结构</h2><ul>
<li>AVL 树：最早的平衡二叉树之一。应用相对其他数据结构比较少。Windows 对进程地址空间的管理使用到了 AVL 树。</li>
<li>红黑树：平衡二叉树，广泛用在 C++ 的 STL 中。如 map 和 set 都是用红黑树实现的。</li>
<li>B/B+ 树：用在磁盘文件组织，数据索引，和数据库索引。</li>
<li>Trie树（字典树）：用在统计和排序大量字符串，如自动机。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="0117 Populating Next Right Pointers in Each Node II"></a>0117 Populating Next Right Pointers in Each Node II</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一题实际上就是 level order traversal</span></span><br><span class="line"><span class="comment">使用 queue 就很好做了</span></span><br><span class="line"><span class="comment">但是 queue 的空间复杂度是 O(n)</span></span><br><span class="line"><span class="comment">而题目要求是 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决的关键就在于 每一个 node 里都有一个 next pointer</span></span><br><span class="line"><span class="comment">它的存在使得我们没有必要用queue 记录一层所有的 nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法关键：</span></span><br><span class="line"><span class="comment">    在扫描当前level的节点的 children nodes 时候</span></span><br><span class="line"><span class="comment">    更新这些 children nodes 的 next 指针</span></span><br><span class="line"><span class="comment">    这样子，在扫描下一个 level的时候，</span></span><br><span class="line"><span class="comment">    就可以使用这些 next pointer 了！！！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">二刷关键：</span></span><br><span class="line"><span class="comment">    引入一个 dummy node 可以使得代码更简洁！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode *cur; <span class="comment">// cur 指针扫描下一层 的节点;</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;                          <span class="comment">// root 指针用于扫描当前 level</span></span><br><span class="line">            cur = dummy;                        <span class="comment">// cur 指针扫描下一层 的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root) &#123;                       <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;left;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;right;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            root = dummy-&gt;next;                <span class="comment">// root 指针跳到下一层的 dummy 后面第一个有效节点</span></span><br><span class="line">            dummy-&gt;next = <span class="literal">nullptr</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 一刷的代码，不够简洁</span></span><br><span class="line"><span class="comment">    void connect(TreeLinkNode *root) &#123;</span></span><br><span class="line"><span class="comment">        TreeLinkNode *cur = root;         //current node of current level</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while (cur) &#123;</span></span><br><span class="line"><span class="comment">            TreeLinkNode *head = NULL;   // head of the next level</span></span><br><span class="line"><span class="comment">            TreeLinkNode *prev = NULL;   //the leading node on the next level</span></span><br><span class="line"><span class="comment">            while(cur) &#123;       //iterate on the current level</span></span><br><span class="line"><span class="comment">                if (cur-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev  = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                if (cur-&gt;right) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //move to next node           </span></span><br><span class="line"><span class="comment">                cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //move to next level</span></span><br><span class="line"><span class="comment">            cur = head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Find-k-th-smallest-number-of-binary-search-tree"><a href="#Find-k-th-smallest-number-of-binary-search-tree" class="headerlink" title="Find k-th smallest number of binary search tree"></a>Find k-th smallest number of binary search tree</h2><p>==适用于binary search tree 的递归的方法==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements;</span><br><span class="line">        recurse(root, elements, k);</span><br><span class="line">        <span class="keyword">return</span> elements[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; elements, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(elements.size() == k) <span class="keyword">return</span>;        <span class="comment">// 技巧，提前停止</span></span><br><span class="line">        recurse(root-&gt;left, elements, k);</span><br><span class="line">        elements.push_back(root-&gt;val);</span><br><span class="line">        recurse(root-&gt;right, elements, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>==适用于BST的非递归，使用stack的方法！！！（这个非常棒！！！）==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = mystack.top();</span><br><span class="line">                mystack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE BEGIN</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE END</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                </span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>==适用于任何的二叉树(binary tree, not necessarily BST)：先输出所有点(iterative 或 recursive)到array，然后找第 k 个==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 iterative 的方法，输出所有点到 array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    dq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">        TreeNode* temp = dq.front();</span><br><span class="line">        myvec.push_back(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left) dq.push_back(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right) dq.push_back(temp-&gt;right);</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.begin(), myvec.end());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 recursive 的方法，输出所有点到array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    helper(root, myvec);</span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.begin(), myvec.end());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.push_back(root-&gt;<span class="keyword">int</span>);</span><br><span class="line">    helper(root-&gt;left, vec);</span><br><span class="line">    helper(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树是最重要的数据结构，没有之一！</li>
<li>从根节点到叶子的过程，是逐渐细化精确的过程，所以，实践中往往作为海量数据索引。</li>
<li>数只是数据结构，非存储结构。实践中，可以使用数组来存储树。<ul>
<li>思考实例 Huffman 编码、堆排序、并查集等。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/leetcode-linked-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/08/leetcode-linked-list/" itemprop="url">leetcode linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-08T11:16:04-08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/leetcode-linked-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/08/leetcode-linked-list/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目总体分析"><a href="#题目总体分析" class="headerlink" title="题目总体分析"></a>题目总体分析</h1><p>TODO</p>
<h1 id="C-相关操作语法"><a href="#C-相关操作语法" class="headerlink" title="C++ 相关操作语法"></a>C++ 相关操作语法</h1><p>TODO</p>
<h1 id="Python-相关操作语法"><a href="#Python-相关操作语法" class="headerlink" title="Python 相关操作语法"></a>Python 相关操作语法</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="翻转单链表"><a href="#翻转单链表" class="headerlink" title="翻转单链表"></a>翻转单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头开始翻</span></span><br><span class="line">ListNode *result = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line">	temp = head-&gt;next;</span><br><span class="line">	head-&gt;next = result;</span><br><span class="line">	result = head;</span><br><span class="line">	head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### TODO 思考：翻转部分链表 leetcode <span class="number">92</span></span><br><span class="line">- 如何找到第 m 个元素和第 n 个元素</span><br><span class="line">- 如何处理前面和后面</span><br><span class="line">    - 保存前面部分最后一个元素</span><br><span class="line">    - 保存后面部分第一个元素</span><br><span class="line">    - 特殊情况？</span><br><span class="line"></span><br><span class="line">### TODO 思考： 每 k 个元素翻转一次 leetcode <span class="number">25</span></span><br><span class="line">- 前面翻好的部分（小链表）</span><br><span class="line">- 要翻转的部分（K 个）</span><br><span class="line">- 后面没处理的部分（小链表）</span><br><span class="line">- 不足 k 个怎么办？</span><br><span class="line"></span><br><span class="line">## 单链表含有环 leetcode <span class="number">0141</span>, <span class="number">0142</span></span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line">- 假设链表起点到圈起点距离是 a，相遇点到圈起点距离是 b</span><br><span class="line">- 那么有</span><br><span class="line">    - slow pointer 走了 a + b</span><br><span class="line">    - fast pointer 走了 a + b + k*n == <span class="number">2</span>*(a+b)</span><br><span class="line">    - 从而 a + b = k * n</span><br><span class="line">- 如何找圈的起点</span><br><span class="line">    - 相遇后，把 slow pointer 拉回链表起点，fast pointer 从相遇点继续走。</span><br><span class="line">    - 注意这个时候两个指针都一步一步的走</span><br><span class="line">    - 这个时候二者会在圈起点相遇！！！</span><br><span class="line">- 如何找圈长</span><br><span class="line">    - 相遇后，slow pointer 再走一圈并统计长度就是圈长。</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head)&#123;</span><br><span class="line">    	ListNode *p1 = head, *p2 = head;</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">    		<span class="keyword">if</span>((!p2) || (p2-&gt;next == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    		p1 = p1-&gt;next;</span><br><span class="line">    	&#125; <span class="keyword">while</span>(p1 != p2);</span><br><span class="line">    	<span class="keyword">for</span>(p1 = head; p1 != p2; p1 = p1-&gt;next, p2 = p2-&gt;next)</span><br><span class="line">    	;</span><br><span class="line">    	<span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个单链表是否相交-leetcode-160"><a href="#两个单链表是否相交-leetcode-160" class="headerlink" title="两个单链表是否相交 leetcode 160"></a>两个单链表是否相交 leetcode 160</h2><p>就是检测是否是 Y 型结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tempA = headA, *tempB = headB;</span><br><span class="line">        <span class="keyword">int</span> lenA, lenB;</span><br><span class="line">        <span class="keyword">for</span>(lenA = <span class="number">0</span>; tempA; tempA = tempA-&gt;next) lenA++;</span><br><span class="line">        <span class="keyword">for</span>(lenB = <span class="number">0</span>; tempB; tempB = tempB-&gt;next) lenB++;</span><br><span class="line">        tempA = headA;</span><br><span class="line">        tempB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; i++) tempA = tempA-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; i++) tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tempA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempA == tempB) <span class="keyword">return</span> tempA;</span><br><span class="line">            tempA = tempA-&gt;next;</span><br><span class="line">            tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复制带随机指针的链表-leetcode-138"><a href="#复制带随机指针的链表-leetcode-138" class="headerlink" title="复制带随机指针的链表 leetcode 138"></a>复制带随机指针的链表 leetcode 138</h2><p>方法一：使用 map&lt;旧地址，新地址&gt;</p>
<p>方法二：不用 map</p>
<ul>
<li>插入：每个旧节点后面插入一个自身的“复本”</li>
<li>复制 random 指针<ul>
<li>一个旧节点 a 的复本是 a-&gt;next</li>
<li>a-&gt;ranom 的复本是 a-&gt;random-&gt;next</li>
<li>新节点的random 指针 a-&gt;next-&gt;random = a-&gt;random-&gt;next (空值单独判断)</li>
</ul>
</li>
<li>拆分<ul>
<li>旧节点链表是奇数项</li>
<li>新节点链表是偶数项<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(RandomListNode *now = head; now; )&#123;</span><br><span class="line">    		RandomListNode *copy = <span class="keyword">new</span> RandomListNode(now-&gt;label);</span><br><span class="line">    		copy-&gt;next = now-&gt;next;</span><br><span class="line">    		now-&gt;next = copy;</span><br><span class="line">    		now = copy-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(RandomListNode *now = head; now; now = now-&gt;next-&gt;next)&#123;</span><br><span class="line">    		now-&gt;next-&gt;random = (now-&gt;random == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : now-&gt;random-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	RandomListNode *h = head-&gt;next, *t = h, *tail = head;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		tail = tail-&gt;next = t-&gt;next;</span><br><span class="line">    		<span class="keyword">if</span>(!tail)</span><br><span class="line">    		    <span class="keyword">break</span>;</span><br><span class="line">    		t = t-&gt;next = tail-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="链表-partition-leetcode-86"><a href="#链表-partition-leetcode-86" class="headerlink" title="链表 partition leetcode 86"></a>链表 partition leetcode 86</h2><p>链表里存放整数，给定 x 把比 x 小的节点放到比 x 大的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	    ListNode *h1 = <span class="literal">nullptr</span>, *t1 = <span class="literal">nullptr</span>, *h2 = <span class="literal">nullptr</span>, *t2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span>( ; head; head = head-&gt;next)&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">	    		<span class="keyword">if</span>(t1)&#123;    <span class="comment">// 需要看一下是不是 nullptr</span></span><br><span class="line">	    			t1 = t1-&gt;next = head;</span><br><span class="line">	    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    			h1 = t1 = head;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2)&#123;</span><br><span class="line">	    		t2 = t2-&gt;next = head;</span><br><span class="line">	    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    		h2 = t2 = head;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(t2) t2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	    <span class="keyword">if</span>(t1) t1-&gt;next = h2;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> h1? h1 : h2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/leetcode-stack-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/leetcode-stack-queue/" itemprop="url">leetcode stack queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-07T17:23:44-08:00">
                2019-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/leetcode-stack-queue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/07/leetcode-stack-queue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><p>TODO</p>
<h1 id="C-相关语法操作"><a href="#C-相关语法操作" class="headerlink" title="C++ 相关语法操作"></a>C++ 相关语法操作</h1><p>TODO</p>
<p>用自定义 greater 决定最大堆，最小堆。</p>
<h1 id="python-相关语法操作"><a href="#python-相关语法操作" class="headerlink" title="python 相关语法操作"></a>python 相关语法操作</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="用两个队列实现一个栈"><a href="#用两个队列实现一个栈" class="headerlink" title="用两个队列实现一个栈"></a>用两个队列实现一个栈</h2><p>思路：用两个队列来回倒，保证一个队列是空的。<br>用空队列临时存储除队尾外所有元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入栈：维护一个队列是空的。时间复杂度: O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) q1.push(x)</span><br><span class="line">    <span class="keyword">else</span> q2.push(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">出栈：用一个队列临时存放元素。时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pop():</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty())&#123;</span><br><span class="line">    	<span class="keyword">while</span>(q1.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    		q2.push(q1.front());</span><br><span class="line">    		q1.pop();</span><br><span class="line">    	&#125;</span><br><span class="line">    	q1.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 类似操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用两个堆栈实现一个队列"><a href="#用两个堆栈实现一个队列" class="headerlink" title="用两个堆栈实现一个队列"></a>用两个堆栈实现一个队列</h2><p>思路：使用两个堆栈。s1 负责 push, s2 负责 pop.<br>注意这个跟上一个题目不一样，因为不是每次 pop 都需要重新翻一次数据。<br>如果负责 pop 的 s2 里面还有数据的话，可以直接 pop.<br>这样子最终的 amotized complexity is O(1).<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push(x): <span class="comment">//O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// 均摊O(1) 每个元素出入两个栈各一次。</span></span><br><span class="line">    <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">    	<span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">    		s2.push(s1.top());</span><br><span class="line">    		s1.pop();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();</span><br></pre></td></tr></table></figure></p>
<h2 id="支持查找最小值的栈"><a href="#支持查找最小值的栈" class="headerlink" title="支持查找最小值的栈"></a>支持查找最小值的栈</h2><p>题目：一个堆栈除了支持 push, pop 外还要支持一个操作: getMin 得到当前堆栈里所有元素的最小值。</p>
<p>思路一：用两个堆栈，s1 正常使用，s2 在 getMin 的时候使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：用两个堆栈，s1 维护原来的值，s2 维护最小值，他们元素个数一样多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):  <span class="comment">// O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line">    <span class="keyword">if</span>(!s2.empty() &amp;&amp; s2.top() &lt; x) s2.push(s2.top())</span><br><span class="line">    <span class="keyword">else</span> s2.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// O(1)</span></span><br><span class="line">    s1.pop()</span><br><span class="line">    s2.pop()</span><br><span class="line"></span><br><span class="line">getMin:  <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> s2.top()</span><br></pre></td></tr></table></figure>
<h3 id="变型：维护最小值的-queue"><a href="#变型：维护最小值的-queue" class="headerlink" title="变型：维护最小值的 queue"></a>变型：维护最小值的 queue</h3><p>==维护队列单调性！！！==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用两个双端队里，记录最大值的双端队列保持单调递减性，记录最小值的双端队列保持单调递增性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minque;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxque;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	que.push(val);</span><br><span class="line">	<span class="keyword">while</span> ((!minque.empty()) &amp;&amp; (minque.back() &gt; val))</span><br><span class="line">		minque.pop_back();</span><br><span class="line">	minque.push_back(val);</span><br><span class="line">	<span class="keyword">while</span> ((!maxque.empty()) &amp;&amp; (maxque.back() &lt; val))</span><br><span class="line">		maxque.pop_back();</span><br><span class="line">	maxque.push_back(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value = que.front();</span><br><span class="line">	que.pop();</span><br><span class="line">	<span class="keyword">if</span> (minque.front() == value)</span><br><span class="line">		minque.pop_front();</span><br><span class="line">	<span class="keyword">if</span> (maxque.front() == value)</span><br><span class="line">		maxque.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> minque.front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> maxque.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="直方图中最大面积矩形-leetcode-84"><a href="#直方图中最大面积矩形-leetcode-84" class="headerlink" title="直方图中最大面积矩形 leetcode 84"></a>直方图中最大面积矩形 leetcode 84</h2><p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想还是维持一个单调的栈。</span></span><br><span class="line"><span class="comment">这里栈内元素大小是递增的。一旦来了一个小的元素，那么会把栈顶比此元素大的一个一个 pop 出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = height.size(), area = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexes.empty() &amp;&amp; height[indexes.top()] &gt; height[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[indexes.top()];   <span class="comment">// 以当前栈顶值为高度的矩形，此时右边界已经确定，就是刚扫描到的 height[i]。</span></span><br><span class="line">                indexes.pop();    <span class="comment">// 而左边界就是栈里下面压着的那一个 index. 因为下面压着的 index 那个高度小于它。</span></span><br><span class="line">                <span class="keyword">int</span> l = indexes.empty() ? <span class="number">-1</span> : indexes.top();  </span><br><span class="line">                area = max(area, h * (i - l - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            indexes.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sliding-window-maximum"><a href="#sliding-window-maximum" class="headerlink" title="sliding window maximum"></a>sliding window maximum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dq 只需要保存 k 个内容就可以，这里是保存 index，</span></span><br><span class="line"><span class="comment">此处关键是 dq 保存所有的 k 个 index 吗？</span></span><br><span class="line"><span class="comment">显然不是，它只会保存有用的信息。</span></span><br><span class="line"><span class="comment">什么才是有用的信息？是那些有可能成为 maximum 的点。</span></span><br><span class="line"><span class="comment">这里的操作和之前 0456 - 132 Pattern 解法中的操作类似。</span></span><br><span class="line"><span class="comment">在考虑 num[i] 的时候，把 num[i] 跟 dequeue 的最后一个值(实际是index对应位置的值)比较</span></span><br><span class="line"><span class="comment">如果小于 nums[i]，那么就 pop_back()，直到遇到比 nums[i] 大的</span></span><br><span class="line"><span class="comment">这个操作保证了 dequeue 中的数值一定是递减数列</span></span><br><span class="line"><span class="comment">此时 de.front() 对应的值就是位置 i(含) 之前 k 个值中最大的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">dq 中保存的是 index，所以第8行和第10行用 nums[dq.back()], nums[dq.front()].</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">心得体会</span></span><br><span class="line"><span class="comment">我发现这个用 stack(0456) 或者queue存储 maximum/minimum 的技巧，</span></span><br><span class="line"><span class="comment">对于比较大小或者 max/min 的题目很有效啊。</span></span><br><span class="line"><span class="comment">主要就是 stack/queue 的“两端”是对应的是 current maximum/minimum</span></span><br><span class="line"><span class="comment">可以用O(1)直接找到并作比较。</span></span><br><span class="line"><span class="comment">如果直接在一个范围内找 max 作比较，那就需要 O(n) 去找了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">答案里分析 time complexity 的时候都提到了 amotized O(n)，</span></span><br><span class="line"><span class="comment">这个是因为 for loop 里面那个 while 的次数是变得，可能为 O(1) ，也可能为 O(n).</span></span><br><span class="line"><span class="comment">换个角度，每个元素最多被添加一次pop一次，因此算法复杂度是 amotized O(n).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/leetcode-数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/04/leetcode-数组/" itemprop="url">leetcode 数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-04T21:39:38-08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/04/leetcode-数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/04/leetcode-数组/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><pre><code>查找和排序
    二分查找: 貌似都可以使用或者不使用递归！
    元素交换
    排序，中位数
    归并
    位运算
    前缀和的应用
动态规划
排列组合
</code></pre><h1 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h1><h1 id="python-list"><a href="#python-list" class="headerlink" title="python list"></a>python list</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="局部极小值-leetcode-162"><a href="#局部极小值-leetcode-162" class="headerlink" title="局部极小值 leetcode 162"></a>局部极小值 leetcode 162</h2><p>一个给定的不包含相同元素的整数数组，每个局部极小值的定义是一个值比左右相邻的（如果存在）都小的值。求它的一个局部极小值。</p>
<pre><code>分析：首先要问清楚边界条件如何处理，在这里假定边界条件是比它大的。

这里规定用数组下标 a[1, ..., n]表示那 n 个整数，定义 a[0] = a[n+1] = 无穷大。

递归的思路是，如果子数组 a[p, q] 满足条件 a[p] &lt; a[p-1], a[q] &lt; a[q+1]，则它包含一个局部极小值。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：不使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：使用递归思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[m+<span class="number">1</span>]) <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, m+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数值等于下标的元素"><a href="#数值等于下标的元素" class="headerlink" title="数值等于下标的元素"></a>数值等于下标的元素</h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<p>样例<br>输入：[-3, -1, 1, 3, 5]<br>输出：3</p>
<p>注意:如果不存在，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环有序数组查找元素-leetcode-153"><a href="#循环有序数组查找元素-leetcode-153" class="headerlink" title="循环有序数组查找元素 leetcode 153"></a>循环有序数组查找元素 leetcode 153</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1</p>
<p>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：二分法</span></span><br><span class="line"><span class="comment">找中间一个元素，因为数组有 shift，所以中间元素只有两种可能：</span></span><br><span class="line"><span class="comment">要么在左半段，中间元素数值大于两端的数值；</span></span><br><span class="line"><span class="comment">要么在右半段，中间元素数值小于两端的数值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，有个特殊情况就是如果 shift=0，那么只有一个左半段存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == j) <span class="keyword">return</span> min(nums[i], nums[j]);</span><br><span class="line">        <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, m, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环有序数组查找元素-leetcode-154"><a href="#循环有序数组查找元素-leetcode-154" class="headerlink" title="循环有序数组查找元素 leetcode 154"></a>循环有序数组查找元素 leetcode 154</h2><p>TODO</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>【思路】<br>就是动态规划！注意空间复杂度可以不用建立二维数组，只使用两个一维向量就可以了。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>【思路】</p>
<ul>
<li>方法一：其实这一题可以转换为最长公共子序列的问题<ul>
<li>先对数组进行排序</li>
<li>计算排序后数组和原来数组的最长公共子序列，这个就是最长递增的子序列</li>
<li>复杂度为排序的复杂度 = O(nlogn)</li>
</ul>
</li>
<li>方法二：直接用动态规划<ul>
<li>方法很直接</li>
<li>时间复杂度是 O(n^2)</li>
</ul>
</li>
</ul>
<h2 id="第一个缺失的正整数-leetcode-41"><a href="#第一个缺失的正整数-leetcode-41" class="headerlink" title="第一个缺失的正整数 leetcode 41"></a>第一个缺失的正整数 leetcode 41</h2><p>[题目]<br>给一个数组，找到从 1 开始第一个不在里面的正整数。</p>
<p>[例如]<br>输入：[3, 4, -1, 1]<br>输出：2.</p>
<p><mark>循环不变式</mark></p>
<ul>
<li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则钙元素即为所求。</li>
<li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li>
</ul>
<p><mark>利用循环不变式设计算法</mark><br>假定前 i-1 个数已经找到，并且依次存放在 A[1,2,…,i-1]中，继续考察 A[i]:</p>
<ul>
<li>若 A[i]<i 且="" a[i]="">=1, 则 A[i] 在 A[1,2,…,i-1] 中已经出现过，可以直接丢弃。<ul>
<li>若 A[i] 为负，则更应该丢弃它</li>
</ul>
</i></li>
<li>若 A[i]&gt;i 且 A[i] &lt;= N, 则 A[i] 应该位于后面的位置上，则将 A[A[i]] 和 A[i] 交换。<ul>
<li>若 A[i]&gt;=N, 由于缺失数据一定小于 N, 则 A[i] 丢弃</li>
</ul>
</li>
<li>若 A[i]=i, 则 A[i] 位于正确的位置上，则 i 加 1，循环不变式扩大，继续比较后面的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">分析：数组下标从 0 开始，</span><br><span class="line">我们得目的是让 a[i] == i + 1</span><br><span class="line">每次循环</span><br><span class="line">	1. 要么 i+1</span><br><span class="line">	2. 要么 n-1</span><br><span class="line">	3. 要么有一个数被放到正确的位置</span><br><span class="line"></span><br><span class="line">有一点要记住！一旦一个元素被放到正确的位置以后，那么它的位置就不会改变了！</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt; A, int n)&#123;</span><br><span class="line">    	for(int i = 0; i &lt; n; )&#123;</span><br><span class="line">    		if(A[i] == i + 1)&#123;  // A[i]刚好位置正确</span><br><span class="line">    			++i;</span><br><span class="line">    		&#125; else if ((A[i] &lt;= i) || (A[i] &gt; n) || (A[A[i] - 1] == A[i]))&#123;  // 当前元素可以丢掉了！</span><br><span class="line">    			A[i] = A[--n];  // 快速丢弃 A[i]，就是把最后一个元素移过来，同时长度减去一。</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">    			swap(A[i], A[A[i] - 1]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return n+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元素最大间距-leetcode-164-“maximum-Gap”"><a href="#元素最大间距-leetcode-164-“maximum-Gap”" class="headerlink" title="元素最大间距 leetcode 164 “maximum Gap”"></a>元素最大间距 leetcode 164 “maximum Gap”</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:<br>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.</p>
<p>Example 2:<br>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.</p>
<p>Note:<br>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值x, 最小值y，如果 x==y 答案是0.</span></span><br><span class="line"><span class="comment">把数放进 n+1 个桶。</span></span><br><span class="line"><span class="comment">	每个桶大小是 d = (x-y)/(n+1) 浮点数</span></span><br><span class="line"><span class="comment">	每个桶区间是 [y + i*d, y + (i+1) * d) (i=0, 1, 2, ..., n)</span></span><br><span class="line"><span class="comment">		注意是左闭右开的区间，最后一个桶是双闭区间。</span></span><br><span class="line"><span class="comment">		最小的数在 0 号桶里，最大的数在 n 号桶里。</span></span><br><span class="line"><span class="comment">		第一个桶非空，最后一个桶非空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	【鸽笼原理】中间有空桶，空桶左右两侧肯定有元素。</span></span><br><span class="line"><span class="comment">	最大间隙出现在一个非空桶的最大值和下一个非空桶的最小值之间。</span></span><br><span class="line"><span class="comment">	如何判断数 r 出现在哪个桶里</span></span><br><span class="line"><span class="comment">		(r-y)*(n+1)/(x-y) （整数运算，注意 r==x 时候，答案取 n）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">code is from: https://leetcode.com/problems/maximum-gap/discuss/50644/Pigeon-hole-principle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxE = *max_element(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">int</span> minE = *min_element(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxA(n,INT_MIN);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minA(n,INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">        maxA[index] = max(maxA[index],nums[i]);</span><br><span class="line">        minA[index] = min(minA[index],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        gap = max(gap,minA[i]-prev);</span><br><span class="line">        prev = maxA[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出现一次的数"><a href="#出现一次的数" class="headerlink" title="出现一次的数"></a>出现一次的数</h2><h2 id="出现-3-次的数-leetcode-137"><a href="#出现-3-次的数-leetcode-137" class="headerlink" title="出现 3 次的数 leetcode 137"></a>出现 3 次的数 leetcode 137</h2><p>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,3,2]<br>Output: 3<br>Example 2:</p>
<p>Input: [0,1,0,1,0,1,99]<br>Output: 99</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个思路是最直接，最清晰的！就是把每一个 bit 位分开来看。</span></span><br><span class="line"><span class="comment">把当前 bit 位出现的 1 的总次数除以 3，如果可以整除，</span></span><br><span class="line"><span class="comment">那么最终结果在这个 bit 位上就是 0，如果不能整除，最终结果在这个 bit 位上就是 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To solve this problem using only constant space, you have to rethink how the numbers are being represented in computers -- using bits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you sum the ith bit of all numbers and mod 3, it must be either 0 or 1 due to the constraint of this problem where each number must appear either three times or once. This will be the ith bit of that "single number".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We can improve this based on the previous solution using three bitmask variables:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. ones as a bitmask to represent the ith bit had appeared once.</span></span><br><span class="line"><span class="comment">2. twos as a bitmask to represent the ith bit had appeared twice.</span></span><br><span class="line"><span class="comment">3. threes as a bitmask to represent the ith bit had appeared three times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">When the ith bit had appeared for the third time, clear the ith bit of both ones and twos to 0. The final answer will be the value of ones.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];</span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举一反三的思考"><a href="#举一反三的思考" class="headerlink" title="举一反三的思考"></a>举一反三的思考</h3><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers" target="_blank" rel="external">这里</a> 对于这类题目做了一个 generalization 的总结。</p>
<p>generalization 后题目变成：一个数组里面除了一个数字出现了 p 次，其他所有数字都出现了 k 次，那么请找出这个出现了 p 次的数字。</p>
<p>其思想也是对于每个 bit 位单独考虑，看看 1 出现了多少次保存在 count 中。并且保证 1 在出现了 k 次之后，count 会归零。</p>
<p>对于单独的一个 bit 位置来说<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 32-bit 的数字来说<br><img src="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png" alt="haha"></p>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 2, p = 1</span></span><br><span class="line"><span class="comment">k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 3, p = 1</span></span><br><span class="line"><span class="comment">k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = '11', then k1 = 1, k2 = 1, so we have mask = ~(x1 &amp; x2). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; x2);</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. </span></span><br><span class="line">                    <span class="comment">// If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 5, p = 3</span></span><br><span class="line"><span class="comment">k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = '101', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, x3  = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x3 ^= x2 &amp; x1 &amp; i;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">            x3 &amp;= mask;</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. </span></span><br><span class="line">                    <span class="comment">// If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2 | x3).</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-100-缺少的两个数"><a href="#1-100-缺少的两个数" class="headerlink" title="1-100 缺少的两个数"></a>1-100 缺少的两个数</h2><p>解方程？ 位运算？</p>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>找出超过一半的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">分析：众数出现的次数大于其他所有数出现次数之和。</span><br><span class="line">	每次扔掉两个不同的数，众数不变</span><br><span class="line">		如果扔掉一个众数，和一个非众数</span><br><span class="line">		如果扔掉两个非众数</span><br><span class="line">	如何实现？和 x 不同就扔掉</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int count = 0, x;</span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">	if (count == 0) &#123;</span><br><span class="line">		x = a[i];</span><br><span class="line">		count = 1;</span><br><span class="line">	&#125; else if (x == a[i]) &#123;</span><br><span class="line">		++count;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		--count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意有的题目要数一下 x 出现次数是否确实超过一半（众数可能不存在）。</span><br></pre></td></tr></table></figure>
<p>TODO:<br>思考题：如何找到所有出现次数严格大于总数 1/k 的数？<br>提示：保存(k - 1)个数。<br>如何查找？hash? map?</p>
<h2 id="几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><a href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240" class="headerlink" title="几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240"></a>几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</h2><h3 id="leetcode-0011"><a href="#leetcode-0011" class="headerlink" title="leetcode 0011"></a>leetcode 0011</h3><p>题目：<br>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>
<p>分析：<br>这一题的解法比较巧妙，想通了后就特别简单。</p>
<p>绝妙的思路：<br>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.<br>In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.<br>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by —).</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p><mark>注意：上面划线部分没有细说，但是你必须要搞懂。<br>事实上，如果 2 3 4 5 的高度超过 1，那么由于 1 的高度的限制，水桶的整体高度不会超过 1 的高度。<br>同时又由于 2 3 4 5 距离 1 相对于 6 距离 1 更近，<br>所以<br>(1,2) (1,3) (1,4) (1,5) 肯定小于 (1,6)<br>另一种情形，如果 2 3 4 5 的高度小于 1，那么<br>(1,2) (1,3) (1,4) (1,5) 更小于 (1,6) 了。<br>因此这四种情形都不用计算了！！！！</mark></p>
<p> we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<h3 id="leetcode-0167-Two-Sum-2-Input-array-is-sorted"><a href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted" class="headerlink" title="leetcode 0167 Two Sum 2 Input array is sorted"></a>leetcode 0167 Two Sum 2 Input array is sorted</h3><p>题目：<br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>思路分析：<br>For those of you who are wondering how this works, here is a quick explanation:<br>Each sum is characterized by two indices (i, j), where 0 &lt;= i &lt; j &lt; n with n the length of the input array. If we were to compute them explicitly, we end up with an n-by-n matrix.<br>If the input array is not sorted, to search for the target, there is no good way but comparing it with elements from the above matrix one by one. This is the naive O(n^2) solution. Of course you can use a HashMap to memorize visited elements and cut down the time to O(n) so we have the classic space-time tradeoff.<br>Now if the input array is sorted, the n-by-n summation matrix will have the following properties:<br>Integers in each row are sorted in ascending order from left to right.<br>Integers in each column are sorted in ascending order from top to bottom.<br>To find the target, we do not have to scan the whole matrix now since it exhibits some partial order. We may start from the top-right (or bottom-left) corner, then proceed to the next row or previous column depending on the relationship between the matrix element and the target until either it is found or all rows and columns are exhausted. The key here is that we can get rid of a whole row or column due to the two properties of the matrix specified above.<br>If you have finished leetcode problem “240. Search a 2D Matrix II”, you will find that this is exactly the same problem, except now of the two indices, the first has to be smaller than the second. Time complexity for “leetcode 240” is O(m + n), while for this problem we have m = n, plus the indices constraint so the time complexity will be O(n). Also we do not need the HashMap now so space complexity will be O(1).</p>
<h3 id="leetcode-240-Search-a-2D-Matrix-II"><a href="#leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="leetcode 240 Search a 2D Matrix II"></a>leetcode 240 Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,<br>Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>Given target = 5, return true.<br>Given target = 20, return false.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We start search the matrix from top right corner, initialize the current position to top right corner, </span></span><br><span class="line"><span class="comment">if the target is greater than the value in current position, then the target can not be in entire row </span></span><br><span class="line"><span class="comment">of current position because the row is sorted, if the target is less than the value in current position, </span></span><br><span class="line"><span class="comment">then the target can not in the entire column because the column is sorted too. </span></span><br><span class="line"><span class="comment">We can rule out one row or one column each time, so the time complexity is O(m+n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; matrix.size() &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[m][n])&#123;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[m][n])&#123;</span><br><span class="line">                --n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些题目的 算法复杂度优化 都是转化为矩阵分析。<br>本来要考虑的情况是矩阵的所有元素 O(m*n)，<br>但是每次计算其中一个元素，并做了比较以后，<br>可以排除一整行或者一整列的元素，<br>因此变成了 O(m+n)的算法。</p>
<h2 id="Trapping-Rain-Water-leetcode-0042"><a href="#Trapping-Rain-Water-leetcode-0042" class="headerlink" title="Trapping Rain Water leetcode 0042"></a>Trapping Rain Water leetcode 0042</h2><p>题目：<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water"></p>
<p>分析：<br>我本来想的是这些水只能 trap 在两个“峰”中间，<br>所以我们可以从左到右找这些峰，<br>然后分别计算中间trap了多少水。<br>这个算法的复杂度也算是O(n),<br>但是实现起来应该比较复杂，<br>主要是在于山峰的寻找上。<br>比如说山峰的判断可以是当前高度大于左右两边，<br>但是如果有当前高度等于左边或者右边怎么办？<br>如果山峰在边界怎么办？<br>都不太好处理。</p>
<p>discuss forum 里面有个好算法<br>没有通过寻找山峰<br>就是分别看每个 bin<br>计算每个 bin 能存储的水量<br>为了达到这个目的<br>算法需要两个变量来记录 maxleft 和 maxright。<br>在保证右边有更高的 bin 的时候，<br>左边每个 bin 保存的水量等于 maxleft 减去 当前高度。<br>同理，<br>在保证左边有更高的 bin 的时候，<br>右边每个 bin 保存的水量等于 maxright 减去当前高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size()<span class="number">-1</span>, res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt;= maxleft)&#123;</span><br><span class="line">                    maxleft = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxleft - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt;= maxright)&#123;</span><br><span class="line">                    maxright = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxright - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中第 10 行和第 17 行对 res 做了改变。</span></span><br><span class="line"><span class="comment">我好奇的是第 10 行用 maxleft 减，</span></span><br><span class="line"><span class="comment">如果 maxleft 大于 maxright的话，不应该拿 maxright 来减吗？？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事实上，maxleft 大于 maxright 的话，</span></span><br><span class="line"><span class="comment">left pointer 肯定指向了 maxleft，</span></span><br><span class="line"><span class="comment">这个时候程序按照逻辑，</span></span><br><span class="line"><span class="comment">会进入到 else 语句（14到19行），</span></span><br><span class="line"><span class="comment">所以达到目的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><mark><br>第 10 行运行的时候 maxleft 一定是小于 maxright，准确说是小于 right pointer 指向的位置的高度 ,<br>第 17 行运行的时候 maxright 一定小于 maxleft，准确说是小于 left pointer 指向的位置的高度。<br>left 或者 right pointer 有一个肯定位于目前浏览到的所有 bin 的最高的那一个，然后保持不动，另外一个 pointer 移动.<br></mark></p>
<h2 id="数组中连续一段和，绝对值最小"><a href="#数组中连续一段和，绝对值最小" class="headerlink" title="数组中连续一段和，绝对值最小"></a>数组中连续一段和，绝对值最小</h2><p>思路：先计算前缀和，然后排序。整体复杂度就是排序的复杂度 O(nlogn).</p>
<h2 id="Cantor-数组"><a href="#Cantor-数组" class="headerlink" title="Cantor 数组"></a>Cantor 数组</h2><p>[题目]</p>
<p>[思路]</p>
<ul>
<li>观察第一个元素，你就能知道思路了</li>
<li>第一个元素是 3，说明后面的元素中有三个小于这个元素，那么第一个元素只可能是 4 啊！！！</li>
<li>然后依次找到第二个，三个，。。。元素就可以了</li>
</ul>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; CantorRecovery(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)&#123;</span><br><span class="line">		temp.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(temp[j] &gt; <span class="number">0</span>) k--;</span><br><span class="line">        	<span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        		res.push_back(temp[j]);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="subset-sum"><a href="#subset-sum" class="headerlink" title="subset sum"></a>subset sum</h2><p>[题目]<br>Given a set of positive integers and an integer s, is there any non-empty subset whose sum is s.</p>
<p>[ref]<br><a href="https://www.techiedelight.com/subset-sum-problem/" target="_blank" rel="external">https://www.techiedelight.com/subset-sum-problem/</a></p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">	<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">	<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">	<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">	<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return true if we can get subset by including or excluding the</span></span><br><span class="line">	<span class="comment">// current item</span></span><br><span class="line">	<span class="keyword">return</span> include || exclude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>带记忆的算法代码</mark></p>
<ul>
<li>这里记忆的是：前面 n 个数里面能不能凑出来一个 sum.</li>
<li>算法是从右往前逐个看是否包括每个元素的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a map to store solutions of subproblems</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct a unique map key from dynamic elements of the input</span></span><br><span class="line">	<span class="built_in">string</span> key = to_string(n) + <span class="string">"|"</span> + to_string(sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if sub-problem is seen for the first time, solve it and</span></span><br><span class="line">	<span class="comment">// store its result in a map</span></span><br><span class="line">	<span class="keyword">if</span> (lookup.find(key) == lookup.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">		<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">		<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">		<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">		<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// assign true if we can get subset by including or excluding the</span></span><br><span class="line">		<span class="comment">// current item</span></span><br><span class="line">		lookup[key] = include || exclude;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return solution to current sub-problem</span></span><br><span class="line">	<span class="keyword">return</span> lookup[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/30/leetcode-string/" itemprop="url">leetcode string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T00:29:46-08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/30/leetcode-string/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/30/leetcode-string/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-string-用法"><a href="#C-string-用法" class="headerlink" title="C++ string 用法"></a>C++ string 用法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br></pre></td></tr></table></figure>
<h2 id="特性描述"><a href="#特性描述" class="headerlink" title="特性描述"></a>特性描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;    <span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">s.substr(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// "bcd"</span></span><br><span class="line"></span><br><span class="line">s.append(<span class="string">"h"</span>);    <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.find(<span class="string">"cd"</span>);    <span class="comment">// 返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br><span class="line"></span><br><span class="line">s.rfind(<span class="string">"cd"</span>);    <span class="comment">// 从后往前找，还是返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)    <span class="comment">// val 转换成 string</span></span><br><span class="line"></span><br><span class="line">stoi(s,p,b)    <span class="comment">// 把字符串s从p开始转换成b进制的int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">os &lt;&lt; i;    <span class="comment">// 把 int 类型传递给 output string stream</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the data is "</span> + os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(<span class="string">"12"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">is &gt;&gt; i;    <span class="comment">// 把 input string steam 传递给 int 类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="Python-string-用法"><a href="#Python-string-用法" class="headerlink" title="Python string 用法"></a>Python string 用法</h1><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0516-最长回文子序列"><a href="#0516-最长回文子序列" class="headerlink" title="0516 最长回文子序列"></a>0516 最长回文子序列</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p>“bbbab”<br>Output:<br>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划： dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) </span></span><br><span class="line"><span class="comment">otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.size();</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mat(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; i++)</span><br><span class="line">            mat[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; s.size(); k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt; s.size(); i++)&#123;</span><br><span class="line">                mat[i][i+k] = max(s[i] == s[i+k]? <span class="number">2</span> + mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>] : mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>], max(mat[i][i+k<span class="number">-1</span>], mat[i+<span class="number">1</span>][i+k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][s.size()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0151-翻转单词"><a href="#0151-翻转单词" class="headerlink" title="0151 翻转单词"></a>0151 翻转单词</h2><p>Given an input string, reverse the string word by word.</p>
<p>Example 1:</p>
<p>Input: “the sky is blue”<br>Output: “blue is sky the”</p>
<p>Example 2:</p>
<p>Input: “  hello world!  “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p>
<p>Example 3:</p>
<p>Input: “a good   example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一：使用 stringstream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is &gt;&gt; temp)&#123;</span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">int</span>(vec.size())<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            os&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=os.str();</span><br><span class="line">        ans.resize(ans.size()<span class="number">-1</span>);    <span class="comment">// 小技巧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：保证不开辟额外的 vector 来保存各个 word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以先把 leading, trailing 的零和中间过多的 0 给去除掉</span></span><br><span class="line"><span class="comment">然后 resize</span></span><br><span class="line"><span class="comment">然后左右翻转，这个容易，但是这时候每个单词本身也左右翻转了。</span></span><br><span class="line"><span class="comment">需要对每个单词本身左右翻转一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之后呢</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="字符替换和复制"><a href="#字符替换和复制" class="headerlink" title="字符替换和复制"></a>字符替换和复制</h2><p>删除一个字符串所有的 a, 并且复制所有的 b. 注意，字符数组足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析：先删除 a, 可以利用原来字符串的空间。</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[i] != <span class="string">'a'</span>)&#123;</span><br><span class="line">		s[n++] = s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)&#123;</span><br><span class="line">		++numb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再复制 b, 注意字符串要加长。</span></span><br><span class="line"><span class="comment">//     先计算字符串里有几个 b，得到复制后的长度。</span></span><br><span class="line"><span class="comment">//     然后“倒着”复制 --- 管用技巧。</span></span><br><span class="line"><span class="keyword">int</span> newLength = n + numb;</span><br><span class="line">s[newLength] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = newLength - <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">	s[i--] = s[j];</span><br><span class="line">	<span class="keyword">if</span>(s[j] == <span class="string">'b'</span>)&#123;</span><br><span class="line">		s[i--] = <span class="string">'b'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0796-rotate-string"><a href="#0796-rotate-string" class="headerlink" title="0796 rotate string"></a>0796 rotate string</h2><p>We are given two strings, A and B.</p>
<p>A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是个巧妙地解法。避免了尝试去分析到底字符串 A 平移了多少个位置才得到 B.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rotateString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (A+A).find(B) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>剑指offer: 表示数值的字符串<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0010-regular-expression-matching-正则表达式"><a href="#0010-regular-expression-matching-正则表达式" class="headerlink" title="0010 regular expression matching 正则表达式"></a>0010 regular expression matching 正则表达式</h2><h2 id="0044-wildcard-matching-通配符匹配"><a href="#0044-wildcard-matching-通配符匹配" class="headerlink" title="0044 wildcard matching 通配符匹配"></a>0044 wildcard matching 通配符匹配</h2><h2 id="字符串全排列-permutation"><a href="#字符串全排列-permutation" class="headerlink" title="字符串全排列 permutation"></a>字符串全排列 permutation</h2><p>[题目]<br>给定字符串 S, 设计算法，枚举 S 的全排列。</p>
<p>[代码]<br>当字符串里面的字符互不相等的时候。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == size<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++)&#123;    <span class="comment">// 依次拿 n 之后每个字符与 n 位置交换</span></span><br><span class="line">		swap(a[i], a[n]);    <span class="comment">// 把后面 i 位置上的字符与当前 n 位置字符交换。</span></span><br><span class="line">		Permutation(a, size, n+<span class="number">1</span>);</span><br><span class="line">		swap(a[i], a[n]);    <span class="comment">// 恢复回来。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> S = <span class="string">"abcde"</span>;</span><br><span class="line">	Permutation(S, S.size(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有重复字符的时候的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDuplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(n &lt; t)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S[n] == S[t]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; S, <span class="keyword">int</span> size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == size<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isDuplicate(S, n, i)) <span class="keyword">continue</span>;  <span class="comment">// 检查范围 [n,i) 中是否有元素与 S[i] 一样。</span></span><br><span class="line">		swap(a[i], a[n]);</span><br><span class="line">		Permutation(a, size, n+<span class="number">1</span>);</span><br><span class="line">		swap(a[i], a[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> S = <span class="string">"abbccde"</span>;</span><br><span class="line">	Permutation(S, S.size(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>非递归算法</mark><br>参考 leetcode O(n) time complexity 一文中介绍的 next permutation 题目</p>
<p>[思路]<br>将给定的字符串 S 首先升序排序，然后依次调用 std::next_permutation 直到返回 false, 即完成了非递归的全排列算法。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>【目的】字符串查找！给定文本串 text 和模式串 pattern, 从文本串 text 中找到模式串 pattern 第一次出现的位置。</li>
<li>【复杂度】KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。</li>
<li>【解释】因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</li>
</ul>
<h3 id="BF与KMP区别"><a href="#BF与KMP区别" class="headerlink" title="BF与KMP区别"></a>BF与KMP区别</h3><ul>
<li>假设当前文本串 text 匹配到 i 位置，模式串 pattern 匹配到 j 位置（模式串的开头与 text 串的 i 位置对齐）。</li>
<li>BF算法做法<ul>
<li>如果当前字符匹配成功，即 text[i+j] == pattern[j]，另 i++, j++, 继续匹配下一个字符；</li>
<li>如果字符匹配失败，即 text[i+j] != pattern[j], 另 i++, j=0, 即失败的情况下，模式串 pattern 相对于文本串 text 向右移动了一位。</li>
</ul>
</li>
<li>KMP 算法做法<ul>
<li>如果当前字符匹配成功，同上，i++, j++, 继续匹配下一个字符</li>
<li>如果匹配失败，另 i 不变，j=next<a href="此处 next[j]&lt;=j-1">j</a>, 即模式串 pattern 相对于文本串 text 向右移动了至少一位(移动的实际位数 j-next[j]&gt;=1)</li>
</ul>
</li>
</ul>
<h3 id="字符串比较机制"><a href="#字符串比较机制" class="headerlink" title="字符串比较机制"></a>字符串比较机制</h3><p>我们的想法是：不要出现回溯！如果已经匹配到了 text 串的 i+j 位置，即使没有匹配成功，接下来也要继续从当前位置匹配下去，不能回溯到 i+1 位置重新开始匹配！</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg" alt="Screen Shot 2019-12-22 at 11.22.19.png"></p>
<p><mark>如上图所示，pattern 串的绿色位置和 text 串的黄色字符不匹配，这个时候我们把 pattern 串往右移动，让 C 那个位置去和 text 串的黄色(就是上面提到的 i+j 位置)去比较！而这么比较的前提是，B 方块与 A 方块一样！这就是说 pattern 串在 d 之前的那一部分的 前缀串A 与 后缀串B 相同！</mark></p>
<h3 id="最大k前缀与k后缀"><a href="#最大k前缀与k后缀" class="headerlink" title="最大k前缀与k后缀"></a>最大k前缀与k后缀</h3><p>因此，问题就转化为如下问题</p>
<ul>
<li>对于模式串 pattern 的位置 j，考察 <mark>p[0]p[1]…p[j-2]p[j-1]</mark>，查找其<mark>最大相等的 k前缀 和 k后缀</mark>。<ul>
<li>注意！计算 next[j] 的时候，考察的字符串是模式串的前 j-1 个字符，与 p[j] 无关。</li>
</ul>
</li>
<li>即：查找满足条件的最大的 k，使得 <mark>p[0]p[1]…p[k-1] = p[j-k]p[j-k+1]…p[j-1]</mark></li>
</ul>
<p>[一个具体的例子如下]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg" alt="Screen Shot 2019-12-22 at 11.45.00.png"></p>
<h3 id="next的递推关系"><a href="#next的递推关系" class="headerlink" title="next的递推关系"></a>next的递推关系</h3><ul>
<li>对于模式串的位置 j, 有 next[j]=k, 即 p[0]p[1]…p[k-1]=p[j-k]p[j-k+1]p[j-1]</li>
<li>则，对于模式串的位置 j+1, 考察 p[j]</li>
<li>若 p[k]==p[j]<ul>
<li>则 next[j+1] = next[j]+1</li>
</ul>
</li>
<li>反之若 p[k]!=p[j]<ul>
<li>记 h=next[k]; 如果 p[h]==p[j], 则 next[j+1]=h+1, 否则重复此过程</li>
</ul>
</li>
</ul>
<p>[相等时候]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg" alt="Screen Shot 2019-12-22 at 11.58.12.png"></p>
<p>[不相等时候的递推]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg" alt="Screen Shot 2019-12-22 at 11.59.13.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 Next 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = p.size();</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">		<span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">			++j;</span><br><span class="line">			++k;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = pattern.size();</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j == <span class="number">-1</span> || text[i] == pattern[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">			ans = i - n;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步分析-next"><a href="#进一步分析-next" class="headerlink" title="进一步分析 next"></a>进一步分析 next</h3><ul>
<li>文本串匹配到 i，模式串匹配到 j，此刻若 text[i] != pattern[j]，即失败的情况</li>
<li>若 next[j]=k, 说明模式串应该从 j 滑动到 k 位置；</li>
<li>若此时满足 pattern[j] == pattern[k], 因为 text[i] != pattern[j], 所以 text[i] != pattern[k]<ul>
<li>即 i 和 k 没有匹配，应该继续滑动到 next[k]</li>
<li>换句话，在原始的 next 数组中，若 next[j]=k 并且 pattern[j] == pattern[k], next[j] 可以直接等于 next[k].</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg" alt="Screen Shot 2019-12-22 at 12.37.22.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext2</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = p.size();</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">		<span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">			++j;</span><br><span class="line">			++k;</span><br><span class="line">			<span class="keyword">if</span>(p[j] == p[k])&#123;</span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			    next[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[例子]</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<h3 id="KMP-时间复杂度"><a href="#KMP-时间复杂度" class="headerlink" title="KMP 时间复杂度"></a>KMP 时间复杂度</h3><ul>
<li>考察模式串的”串头”和主串的对应位置，也就是暴力算法中的 i</li>
<li>不匹配：串头后移，保证尽快结束算法</li>
<li>匹配：串头保持不动，i++, j++, 但一旦发现不匹配，会跳过匹配过的字符(next[j])</li>
<li>最坏的情况，当串头位于 N-M 的位置时候算法才结束</li>
<li>因此，匹配的时间复杂度为 O(N)，算上计算 next 的O(M) 时间，整体时间复杂度 O(M+N)，其实一般就认为是 O(N) 了。</li>
<li>最好情况：当模式串的首字符和其他字符都不相等时，模式串不存在相等的 k前缀和 k后缀，next 数组全为 -1<ul>
<li>一旦匹配失败，模式串直接跳过已经比较的字符。比较次数为 N</li>
</ul>
</li>
<li>最差情况：当模式串的首字符和其他字符全都相等时候，模式串存在最长的 k 前缀和 k后缀，next 数组呈现递增样式: -1, 0, 1, 2, …<ul>
<li>每个周期中 m 1 1 1 …</li>
<li>周期 n/m</li>
<li>总次数：(2 - 1/M) * N &lt; 2N</li>
<li><mark>此时变种KMP 的运行情况比较总次数依然为 N.</mark></li>
</ul>
</li>
</ul>
<h3 id="一个应用-PowerString-问题"><a href="#一个应用-PowerString-问题" class="headerlink" title="一个应用 PowerString 问题"></a>一个应用 PowerString 问题</h3><p>[题目]<br>给定一个长度为 n 的字符串 S，如果存在一个字符串 T，重复若干次 T 能够得到 S，那么，S 叫做周期串，T 叫做 S 的一个周期。请设计一个算法，计算 S 的最小周期。如果不存在周期，返回空串。</p>
<p>[Examples]<br>字符串 abababab 是周期串，abab 和 ab 都是它的周期，其中 ab 是它的最小周期。</p>
<p>[思路]<br>使用 next，限行时间解决问题</p>
<ul>
<li>计算 S 的 next 数组<ul>
<li>记 k = next[length], p = length - k</li>
<li>若 len%p==0，则 p 为最小周期长度，前 p 个字符就是最小周期。</li>
</ul>
</li>
<li>说明<ul>
<li>使用的是经典 KMP 的 next 算法，不是变种的 next 算法</li>
<li>要”多”计算到 length, 即 next[length]</li>
</ul>
</li>
<li>思考：如何证明？<ul>
<li>考察字符串 S 的 k前缀 head 和 k后缀 tail</li>
<li>head 和 tail 的前 p 个字符</li>
<li>head 和 tail 的前 2p 个字符</li>
<li>head 和 tail 的前 3p 个字符</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg" alt="Screen Shot 2019-12-22 at 13.14.24.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPeriod</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);  <span class="comment">// 仿照KMP 求伪 next, next[0] = -1 是哨兵，串首标志</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(k==<span class="number">-1</span> || p[j+<span class="number">1</span>] == p[k])&#123;</span><br><span class="line">    		++k;</span><br><span class="line">    		++j;</span><br><span class="line">    		next[j] = k;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		k = next[k];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 恢复成逻辑上的 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLast = next[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n % (n-nLast) == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> n-nLast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><ul>
<li>KMP 的 next，实际上是建立了 DFA</li>
<li>DFA: Deterministic Finite Automaton</li>
<li>以当前位置为 DFA 的状态，以模式串的字符为 DFA 的转移条件，建立确定有穷自动机。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg" alt="Screen Shot 2019-12-22 at 13.00.57.png"></p>
<p>具体算法细节请参考：</p>
<p><a href="http://note.youdao.com/noteshare?id=dda1246716d3e1f321ee1b637ad2b413" target="_blank" rel="external">KMP算法</a><br><a href="http://note.youdao.com/noteshare?id=13fe90f9adddde21b0d5f8f7880ebc1f" target="_blank" rel="external">史上最清楚的 KMP 算法介绍</a></p>
<h2 id="Boyer-Moore-算法-了解"><a href="#Boyer-Moore-算法-了解" class="headerlink" title="Boyer Moore 算法 (了解)"></a>Boyer Moore 算法 (了解)</h2><p>1977年由德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明的字符串匹配算法。BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</p>
<p>效率很高，构思巧妙，拥有在最坏情况下 O(N) 的时间复杂度。实践中比 KMP 算法的实际效能高。</p>
<h2 id="Manacher-算法-了解"><a href="#Manacher-算法-了解" class="headerlink" title="Manacher 算法 (了解)"></a>Manacher 算法 (了解)</h2><h3 id="重心扩展算法"><a href="#重心扩展算法" class="headerlink" title="重心扩展算法"></a>重心扩展算法</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg" alt="Palindrom"></p>
<p>不过要注意，因为字符串可能是奇数长度或者偶数长度，所以我们要考虑的字符串重心有 n+n-1 个。</p>
<h3 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h3><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg" alt="undefined"></p>
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg" alt="undefined"></p>
<h3 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h3><p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p>
<p>例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p>
<h3 id="求每个-P-i"><a href="#求每个-P-i" class="headerlink" title="求每个 P[i]"></a>求每个 P[i]</h3><p>接下来是算法的关键了，它充分利用了回文串的对称性。</p>
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p>
<p>让我们考虑求 P [ i ] 的时候，如下图。</p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg" alt="undefined"></p>
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p>
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p>
<h4 id="超出了-R"><a href="#超出了-R" class="headerlink" title="超出了 R"></a>超出了 R</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg" alt="undefined"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<h4 id="P-i-mirror-遇到了原字符串的左边界"><a href="#P-i-mirror-遇到了原字符串的左边界" class="headerlink" title="P[i_mirror] 遇到了原字符串的左边界"></a>P[i_mirror] 遇到了原字符串的左边界</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<h4 id="i-等于-R"><a href="#i-等于-R" class="headerlink" title="i 等于 R"></a>i 等于 R</h4><p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p>
<h3 id="考虑-C-和-R-的更新"><a href="#考虑-C-和-R-的更新" class="headerlink" title="考虑 C 和 R 的更新"></a>考虑 C 和 R 的更新</h3><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 P 的最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = P[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">//最开始讲的求原字符串下标</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><ul>
<li>另有两个孩子，1 个孩子，0 个孩子的节点个数分别为 n2, n1, n0</li>
<li>所有节点的出度为 2<em>n2+1</em>n1+0*n0</li>
<li>除了根节点，其他所有节点的入度都是 1，从而所有节点的入度为 (n0+n1+n2)-1</li>
<li>总入度等于总出度，2<em>n2+1</em>n1+0*n0 = n2+n1+n0-1</li>
<li>化简得到 n0 - n2 = 1</li>
<li>也就是说二叉树叶子节点数目比拥有两个孩子的节点数目多 1</li>
</ul>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><ul>
<li>无损压缩编码方案</li>
<li>概率高的字符使用较短的编码，概率低的使用较长的编码，从而使得编码后的字符串长度期望最小</li>
<li>Huffman 编码是一种贪心算法：每次总选择两个最小概率的字符节点合并<ul>
<li>称字符出现的次数为频数，则概率约等于频数除以字符总长；因此概率可以用频数代替</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg" alt="Screen Shot 2019-12-22 at 15.13.26.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用数组来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(<span class="keyword">int</span> *pWeight, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; code)</span></span>&#123;</span><br><span class="line">    <span class="comment">// code 传进来时候是空的 vector&lt;vector&lt;char&gt;&gt; 引用，后面会修改。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (N&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">2</span> * N - <span class="number">1</span>;  <span class="comment">// N个节点的 Huffman 树需要 2N-1 个节点</span></span><br><span class="line">	HuffmanNode* pHuffmanTree = <span class="keyword">new</span> HuffmanNode[m];  <span class="comment">// 在动态内存空间里建立这个 vector</span></span><br><span class="line">	<span class="keyword">int</span> s1, s2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 建立叶子节点</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		pHuffmanTree[i].nWeight = pWeight[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次选择权值最小的两个节点，建树</span></span><br><span class="line">	<span class="keyword">for</span>(i = N; i &lt; m; i++)&#123;</span><br><span class="line">		SelectNode(pHuffmanTree, i, s1, s2);  <span class="comment">// 在前 i 个 nodes 里面找到权值最小的两个节点。用过的节点不会被再用。因为用过的节点有 nParent 信息了。</span></span><br><span class="line">		pHuffmanTree[s1].nParent = pHuffmanTree[s2].nParent = i;  <span class="comment">// s1 和 s2 的父节点是 i 节点</span></span><br><span class="line">		pHuffmanTree[i].nLeft = s1;</span><br><span class="line">		pHuffmanTree[i].nRight = s2;</span><br><span class="line">		pHuffmanTree[i].nWeight = pHuffmanTree[s1].nWeight + pHuffmanTree[s2].nWeight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据建好的 Huffman 树从叶子到根计算每个叶节点的编码</span></span><br><span class="line">	<span class="keyword">int</span> node, nParent;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="comment">// code[i] 就是 node i 的编码！</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; cur = code[i];    <span class="comment">// 此时还是空的 vector</span></span><br><span class="line">		node = i;</span><br><span class="line">		nParent = pHuffmanTree[node].nParent;</span><br><span class="line">		<span class="keyword">while</span>(nParent != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pHuffmanTree[nParent].nLeft == node)&#123;</span><br><span class="line">				cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			node = nParent;</span><br><span class="line">			nParent = pHuffmanTree[node].nParent;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(cur.begin(), cur.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用指针来实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to allocate a new tree node</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node* left, Node* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">	node-&gt;ch = ch;</span><br><span class="line">	node-&gt;freq = freq;</span><br><span class="line">	node-&gt;left = left;</span><br><span class="line">	node-&gt;right = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparison object to be used to order the heap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* l, Node* r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// highest priority item has lowest frequency</span></span><br><span class="line">		<span class="keyword">return</span> l-&gt;freq &gt; r-&gt;freq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line"><span class="comment">// in a map.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node* root, <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;huffmanCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// found a leaf node</span></span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">		huffmanCode[root-&gt;ch] = str;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	encode(root-&gt;left, str + <span class="string">"0"</span>, huffmanCode);</span><br><span class="line">	encode(root-&gt;right, str + <span class="string">"1"</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and decode the encoded string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root, <span class="keyword">int</span> &amp;index, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// found a leaf node</span></span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;ch;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	index++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (str[index] ==<span class="string">'0'</span>)</span><br><span class="line">		decode(root-&gt;left, index, str);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		decode(root-&gt;right, index, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builds Huffman Tree and decode given input text</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHuffmanTree</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// count frequency of appearance of each character</span></span><br><span class="line">	<span class="comment">// and store it in a map</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch: text) &#123;</span><br><span class="line">		freq[ch]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a priority queue to store live nodes of</span></span><br><span class="line">	<span class="comment">// Huffman tree;</span></span><br><span class="line">	priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a leaf node for each character and add it</span></span><br><span class="line">	<span class="comment">// to the priority queue.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pair: freq) &#123;</span><br><span class="line">		pq.push(getNode(pair.first, pair.second, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do till there is more than one node in the queue</span></span><br><span class="line">	<span class="keyword">while</span> (pq.size() != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Remove the two nodes of highest priority</span></span><br><span class="line">		<span class="comment">// (lowest frequency) from the queue</span></span><br><span class="line">		Node *left = pq.top(); pq.pop();</span><br><span class="line">		Node *right = pq.top();	pq.pop();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a new internal node with these two nodes</span></span><br><span class="line">		<span class="comment">// as children and with frequency equal to the sum</span></span><br><span class="line">		<span class="comment">// of the two nodes' frequencies. Add the new node</span></span><br><span class="line">		<span class="comment">// to the priority queue.</span></span><br><span class="line">		<span class="keyword">int</span> sum = left-&gt;freq + right-&gt;freq;</span><br><span class="line">		pq.push(getNode(<span class="string">'\0'</span>, sum, left, right));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// root stores pointer to root of Huffman Tree</span></span><br><span class="line">	Node* root = pq.top();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line">	<span class="comment">// in a map. Also prints them</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; huffmanCode;</span><br><span class="line">	encode(root, <span class="string">""</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pair: huffmanCode) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nOriginal string was :\n"</span> &lt;&lt; text &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print encoded string</span></span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch: text) &#123;</span><br><span class="line">		str += huffmanCode[ch];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traverse the Huffman Tree again and this time</span></span><br><span class="line">	<span class="comment">// decode the encoded string</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDecoded string is: \n"</span>;</span><br><span class="line">	<span class="keyword">while</span> (index &lt; (<span class="keyword">int</span>)str.size() - <span class="number">2</span>) &#123;</span><br><span class="line">		decode(root, index, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huffman coding algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> text = <span class="string">"Huffman coding is a data compression algorithm."</span>;</span><br><span class="line"></span><br><span class="line">	buildHuffmanTree(text);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Huffman总结：前缀编码"><a href="#Huffman总结：前缀编码" class="headerlink" title="Huffman总结：前缀编码"></a>Huffman总结：前缀编码</h3><ul>
<li>Huffman编码是<mark>不等长编码</mark><ul>
<li>字符的编码长度不完全相等</li>
</ul>
</li>
<li>不等长编码如果需要译码，必须满足<mark>前缀编码</mark>的条件<ul>
<li>任何一个字符的编码都不是另外一个字符编码的前缀</li>
</ul>
</li>
<li>从Huffman树的角度考虑，就是<mark>所有的待编码元素都位于叶子节点上</mark>！</li>
</ul>
<p>[思考]</p>
<ul>
<li>Huffman 编码是如何解决前缀编码问题的？</li>
<li>实际算法是由多个”小算法”堆砌而成<ul>
<li>空格压缩问题</li>
<li>取数组最大/小的两个数</li>
</ul>
</li>
<li>代码实现中并非直接使用指针形成的二叉树节点，而是实现开辟足够大的缓冲空间(2n+1)，每次从缓冲区获取一个节点，使用数组代替二叉树<ul>
<li>在堆排序，双数组 Trie 树结构等问题中会再次遇到</li>
</ul>
</li>
<li>最后，由于 Huffman 树的节点权值（频数）可能相等，因此对某些文本，Huffman 编码不唯一。<ul>
<li>左赋 1，右赋 0 或者 左赋 0，右赋 1 都可以。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/算法leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/算法leetcode/" itemprop="url">算法leetcode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-25T17:40:02-08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/25/算法leetcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/25/算法leetcode/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h1><h2 id="按数据结构"><a href="#按数据结构" class="headerlink" title="按数据结构"></a>按数据结构</h2><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h3><p><a href="https://zheng-xing.github.io/2019/11/30/leetcode-string/" target="_blank" rel="external">https://zheng-xing.github.io/2019/11/30/leetcode-string/</a></p>
<h3 id="vector-数组"><a href="#vector-数组" class="headerlink" title="vector 数组"></a>vector 数组</h3><h3 id="stack-amp-heap-栈和队列"><a href="#stack-amp-heap-栈和队列" class="headerlink" title="stack &amp; heap 栈和队列"></a>stack &amp; heap 栈和队列</h3><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><h3 id="tree-amp-graph-树和图"><a href="#tree-amp-graph-树和图" class="headerlink" title="tree &amp; graph 树和图"></a>tree &amp; graph 树和图</h3><h2 id="按算法"><a href="#按算法" class="headerlink" title="按算法"></a>按算法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h3 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h3><h3 id="bfs-amp-dfs"><a href="#bfs-amp-dfs" class="headerlink" title="bfs &amp; dfs"></a>bfs &amp; dfs</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h2 id="misc-杂"><a href="#misc-杂" class="headerlink" title="misc 杂"></a>misc 杂</h2><h3 id="bit-操作"><a href="#bit-操作" class="headerlink" title="bit 操作"></a>bit 操作</h3><h3 id="O-N-时间"><a href="#O-N-时间" class="headerlink" title="O(N) 时间"></a>O(N) 时间</h3><h3 id="O-1-空间"><a href="#O-1-空间" class="headerlink" title="O(1) 空间"></a>O(1) 空间</h3><h1 id="按题目"><a href="#按题目" class="headerlink" title="按题目"></a>按题目</h1><table>
<thead>
<tr>
<th>题目序号</th>
<th>tag</th>
<th>link</th>
</tr>
</thead>
<tbody>
<tr>
<td>0005</td>
<td>string</td>
<td><a href="https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9" target="_blank" rel="external">https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9</a></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0516</td>
<td>string, dp</td>
<td>???</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-02T16:40:40-07:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/02/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/08/02/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Deal-with-formula"><a href="#Deal-with-formula" class="headerlink" title="Deal with formula"></a>Deal with formula</h3><ol>
<li>For centered formulae, use \\[ and \\] </li>
<li>For inline formular, use \\( and \\).</li>
</ol>
<p>For example, \\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \\] gives: </p>
<p>\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \]</p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Some-useful-sites"><a href="#Some-useful-sites" class="headerlink" title="Some useful sites"></a>Some useful sites</h3><ol>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">Start Instruction 1</a></li>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">Start Instruction 2</a></li>
<li><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="external">Additional Functionalities</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">Additional Functionalities 2</a></li>
<li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">Theme Yelee</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Theme next</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
