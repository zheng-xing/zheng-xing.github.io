<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="//page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zheng Xing">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com///page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url">leetcode-dp-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T13:35:23+08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/leetcode-dp-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/leetcode-dp-动态规划/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="找零钱-coin-change-2-lc0518"><a href="#找零钱-coin-change-2-lc0518" class="headerlink" title="找零钱 coin change 2 lc0518"></a>找零钱 coin change 2 lc0518</h2><p>[题目]<br>给定不超过 100 万元的现金总额，兑换成数量不限的 100, 50, 20, 10, 5, 2, 1 的组合，共有多少种组合呢？</p>
<p>[思路一]<br>这个是视频里讲得思路</p>
<ul>
<li>定义 dp[i][j]: 使用面额小于等于 i 的钱币，凑成 j 元钱，共有多少种组合方法。</li>
<li>dp[100][500] = dp[50][500] + dp[100][400]</li>
<li>dp[i][j] = dp[i_small][j] + dp[i][j-1]<ul>
<li>不考虑下界溢出的情况</li>
</ul>
</li>
</ul>
<p>[思路二！错误！！！]</p>
<ul>
<li>我觉得把，用个一维的数组来做 dp 就可以了。<ul>
<li>DP[target] 表示用给定的钱币凑出来 target 的组合数量，那么</li>
<li>DP[target] 显然等于 DP[target-1] + DP[target-2] + DP[target-5] + … + DP[target-100]</li>
</ul>
</li>
<li>就跟走楼梯的方法一模一样啊！！！</li>
<li><mark>我擦！！！这个方法是错误的！！！因为会出现同样的组合，但是因为加入的顺序不同而重复计算了！！！</mark><ul>
<li>比如用 {1, 2} 来组合成 3元。</li>
<li>按照这里的计算方法 dp[1] = 1, dp[2] = 2, dp[3] = 1 + 2 = 3</li>
<li>但是事实上，组合成 3 只有 {1, 1, 1} 和 {1, 2} 两种方式，上面的算法里面把 {2, 1} 也算进来了。</li>
</ul>
</li>
</ul>
<p>[思路三]</p>
<ul>
<li>这个是类似于 combination sum (leetcode 0039) 的思路！</li>
<li>这个肯定是可以做出来的，但是超时了！！！</li>
</ul>
<h2 id="最小编辑距离"><a href="#最小编辑距离" class="headerlink" title="最小编辑距离"></a>最小编辑距离</h2><p>[题目]<br>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p>[分析]<br>直接使用 DP 的话因为要考虑删除字符，有点不好理解，这里先转化成一个对齐的问题！</p>
<table>
<thead>
<tr>
<th>S</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>D</td>
<td>B</td>
<td>-</td>
<td>F</td>
<td>G</td>
</tr>
</tbody></table>
<ol>
<li>S = “ABCF”, T = “DBFG”</li>
<li>对应位置相同时候不扣分，不同则扣一分（修改了）</li>
<li>两个特殊字符”-“ 不会对应</li>
<li>S 位置 “-“ 代表增加字符</li>
<li>T 位置 “-“ 代表删掉字符</li>
<li>目标是使得扣分最少</li>
</ol>
<p>这个问题的 DP 思路就很好想到了</p>
<ol>
<li>假定 DP[i][j] 表示 S[0…i-1] 和 T[0…j-1] 对齐了</li>
<li>现在需要看 S[i] == T[j] ?<ol>
<li>如果相等, 说明 DP[i+1][j+1] = DP[i][j]</li>
<li>如果不相等，则有三种操作方式<ol>
<li>S[i] 替换成 T[j], DP[i+1][j+1] = DP[i][j] + 1</li>
<li>删掉 S[i], DP[i+1][j+1] = DP[i][j+1] + 1</li>
<li>删掉 T[j], DP[i+1][j+1] = DP[i+1][j] + 1</li>
</ol>
</li>
</ol>
</li>
<li>初值<ol>
<li>DP[0][j] = j, DP[i][0] = i</li>
</ol>
</li>
<li>同样，空间可以优化一下，稍微需要点技巧。</li>
</ol>
<h2 id="两次走棋盘"><a href="#两次走棋盘" class="headerlink" title="两次走棋盘"></a>两次走棋盘</h2><p>[题目]</p>
<ul>
<li>Maximum points from top left of matrix to bottom right and return back</li>
<li>给定 MxN 的矩阵，每个位置是一个非负的权值，从左上角开始，每次只能朝右和下走，走到右下角；然后，从右下角开始，每次只能超左和上走，走到左上角。求权值总和最大的路径。若相同格子走过两次，则该位置的权值只算一次。</li>
</ul>
<p>[思路]</p>
<ol>
<li>错误的思路一：贪心，先从左上到右下，再从右下到左上！这样子做选的路径两条路将会一模一样，因为重复的结点权值只算一次，这样子肯定不行。</li>
<li>错误的思路二：接错误一，如果你第一次走的时候把走过的结点权值改成 0，然后第二次走再选最大的路径。这样子也是不对的！</li>
<li>正确的思路：这题的一个技巧是把第二个图翻转过来，跟第一条路放到一起，二者同时走，即从左上角同时出发有两条路，终点都是右下角！</li>
<li>有了这个转换之后，显然，就可以用 row1, col1, row2, row4 来表示状态了！注意在任何时刻都满足条件： row1 + col1 = row2 + col2. 因此可以只用三个变量 row1, col1, row2 来表示状态。</li>
<li>在任意时刻，如果两条路汇合到同一个位置，那么这个位置的权值只计算一次，如果在两个不同的位置，那么两个权值都计算上！</li>
</ol>
<p>[代码]<br>这里的代码是自上而下的一个 DP.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; goldMatrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col2 = row1 + col1 - row2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>(), n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if they reach bottom right location</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == m<span class="number">-1</span> &amp;&amp; row1 == row2 &amp;&amp; col1 == n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> goldMatrix[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(row1 == m || row2 == m || col1 == n || col2 == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The same state has been calculated previously</span></span><br><span class="line">    <span class="keyword">if</span>(dp[row1][col1][row2] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[row1][col1][row2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// They are at the same spot</span></span><br><span class="line">    <span class="keyword">if</span>(row1 == row2)&#123; </span><br><span class="line">        res += goldMatrix[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += (goldMatrix[row1][col1] + goldMatrix[row2][col2]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move right</span></span><br><span class="line">    dp1 = helper(row1, col1+<span class="number">1</span>, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move right, second move down</span></span><br><span class="line">    dp2 = helper(row1, col1+<span class="number">1</span>, row2+<span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move right</span></span><br><span class="line">    dp3 = helper(row1+<span class="number">1</span>, col, row2, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first move down, second move down</span></span><br><span class="line">    dp4 = helper(row1 + <span class="number">1</span>, col, row2 + <span class="number">1</span>, goldMatrix, dp);</span><br><span class="line"></span><br><span class="line">    res += <span class="built_in">max</span>(dp1, <span class="built_in">max</span>(dp2, <span class="built_in">max</span>(dp3, dp4)));</span><br><span class="line"></span><br><span class="line">    dp[row1][col1][row2] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">collectGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; goldMatrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = goldMatrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = goldMatrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, goldMatrix, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 错位排列</span><br><span class="line">[问题]</span><br><span class="line"><span class="number">1.</span> 把数字 <span class="number">1</span> 到 n 做个排列，要求数字 i 不能位于第 i 个位置。问：这样的排列一共有多少种?</span><br><span class="line"><span class="number">2.</span> 这个问题最早是由 Danial Bernoulli （著名的伯努利家族成员）提出的。</span><br><span class="line"></span><br><span class="line">[思路]</span><br><span class="line"><span class="number">1.</span> (n<span class="number">-1</span>)! 这个结果是不对的，不能排除掉重复的结果！</span><br><span class="line"><span class="number">2.</span> 先考虑 n</span><br><span class="line">    <span class="number">1.</span> n 可以放置在 <span class="number">1</span> 到 n<span class="number">-1</span> 一共 n<span class="number">-1</span> 种可能。假设放在了 k 位置</span><br><span class="line"><span class="number">3.</span> 现在考虑数字 k，有两种情况</span><br><span class="line">    <span class="number">1.</span> 第一种情况，数字 k 放到了 位置 n，那么剩下的可能就是 DP(n<span class="number">-2</span>) 了。</span><br><span class="line">    <span class="number">2.</span> 第二种情况下，数字 k 不能放到位置 n，这时候把数字 k 想象成数字 n（数字 n 本来已经用掉了，可以用 k 替代它继续做问题），而剩下的 n<span class="number">-2</span> 个数字也各有一个位置不能放！其实这就是 DP(n<span class="number">-1</span>) 啊！</span><br><span class="line"><span class="number">4.</span> 所以 DP 的转移公式是</span><br><span class="line">    <span class="number">1.</span> DP[n] = (n<span class="number">-1</span>)(DP[n<span class="number">-1</span>] + DP[n<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">![Screen Shot <span class="number">2020</span><span class="number">-01</span><span class="number">-01</span> at <span class="number">17.16</span><span class="number">.10</span>.png](https:<span class="comment">//ws1.sinaimg.cn/large/6a607485gy1gahya0ozdgj20l20c043w.jpg)</span></span><br></pre></td></tr></table></figure>

<h2 id="Dungeon-Game-lc0174"><a href="#Dungeon-Game-lc0174" class="headerlink" title="Dungeon Game lc0174"></a>Dungeon Game lc0174</h2><p>[题目]</p>
<ol>
<li>也是走棋盘的题目的变种。</li>
<li>一个骑士从棋盘的左上角开始走，公主在棋盘的右下角。</li>
<li>每个棋盘的位置有一个数字，可正可负，代表骑士走到这个位置其血量会发生的变化。</li>
<li>骑士在任何时候，其血量如果降到 0 或者 负数就会立刻死亡。</li>
<li>请问骑士最开始的时候最低需要多少血量，才能保证救到公主后还活着？</li>
</ol>
<p>[分析]</p>
<ol>
<li>说一下我最开始的思路。看到题目就知道是 dp 问题，然后就想着去模拟骑士的走法了！<ol>
<li>我想的是维护两个 dp 矩阵</li>
<li>一个是走到当前位置需要的初始最低血量</li>
<li>另外还需要维护的是在这个最低的初始血量下，走到当前位置时候拥有多少血量！</li>
<li>不过在推导递推公式时候遇到了麻烦。</li>
<li>虽然我知道每个位置只能从上面或者左边的位置过来</li>
<li>但是我不知道在 (low_min_hp, high_cur_hp) 和 (high_min_hp, low_cur_hp) 里面该如何选！</li>
<li>纠结半天还是没有考虑清楚。</li>
</ol>
</li>
<li>后来参考答案才发现从左上到右下这个步骤是搞不定的，正确的思路应该是倒着考虑，从公主那里往前推<ol>
<li>此时就只需要维护一个最低血量的 dp 矩阵就可以了，其中 <code>dp[i][j]</code> 表示从这个位置走到公主那里需要的最低血量，可以保证走到公主那里后剩的血量至少为 1.</li>
<li>为啥不需要维护当前的血量了呢，因为如果这个当前血量大于 1，那么我们就把它设成 1 就可以了啊</li>
</ol>
</li>
</ol>
<p>[代码如下]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use hp[i][j] to store the min hp needed at position (i, j), </span></span><br><span class="line"><span class="comment">// then do the calculation from right-bottom to left-up.</span></span><br><span class="line"><span class="comment">// Note: adding dummy row and column would make the code cleaner.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = dungeon.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> N = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// hp[i][j] represents the min hp needed at position (i, j)</span></span><br><span class="line">        <span class="comment">// Add dummy row and column at bottom and right side</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">hp</span><span class="params">(M + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">        hp[M][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        hp[M - <span class="number">1</span>][N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> need = <span class="built_in">min</span>(hp[i + <span class="number">1</span>][j], hp[i][j + <span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">                hp[i][j] = need &lt;= <span class="number">0</span> ? <span class="number">1</span> : need;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三字符字符串组合"><a href="#三字符字符串组合" class="headerlink" title="三字符字符串组合"></a>三字符字符串组合</h2><p>[题目]<br>仅由三个字符 A, B, C 构成字符串，且字符串任意三个相邻元素不能完全相同。如 “ACCCAB” 不合法，”ABBCBCA” 合法。求满足条件的长度为 n 的字符串个数。note: 假定不考虑整数溢出，并且要求时间和空间复杂度不高于 O(N)。</p>
<p>[分析]</p>
<ol>
<li>若当前已经有了所有长度为 n-1 的合法字符串，如何在末端增加一个字符，形成长度为 n 的字符串呢？</li>
<li>将长度为 n-1 字符串分成”末尾两个字符不相等“和”末尾两个字符相等“两种情况，各自数目记做 dp[n-1][0], dp[n-1][1]:<ol>
<li>dp[n][0] = 2 * dp[n-1][0] + 2 * dp[n-1][1]</li>
<li>dp[n][1] = dp[n-1][0]</li>
<li>初始条件是 dp[1][0] = 3, dp[1][1] = 0</li>
</ol>
</li>
</ol>
<h3 id="改进空间复杂度"><a href="#改进空间复杂度" class="headerlink" title="改进空间复杂度"></a>改进空间复杂度</h3><ol start="3">
<li><mark>状态转移方程总结与改进</mark><ol>
<li>滚动数组法</li>
<li>dp[0] = 2 * dp[0] + 2 * dp[1]</li>
<li>dp[1] = dp[0]</li>
<li>此法将空间复杂度由 O(N) 降到 O(1)</li>
</ol>
</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t = nNonRepeat;</span><br><span class="line">        nNonRepeat = <span class="number">2</span> * (nNonRepeat + nRepeat);</span><br><span class="line">        nRepeat = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nNonRepeat + nRepeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进时间复杂度"><a href="#改进时间复杂度" class="headerlink" title="改进时间复杂度"></a>改进时间复杂度</h3><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/2020-01-04-at-15-36-26.png" alt=""></p>
<p>而一个矩阵的 n 次幂可以用递归方法来做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix2x2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line"></span><br><span class="line">    Matrix2x2(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd) : a(aa), b(bb), c(cc), d(dd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb, <span class="keyword">int</span> cc, <span class="keyword">int</span> dd)</span></span>&#123;</span><br><span class="line">        a = aa;</span><br><span class="line">        b = bb;</span><br><span class="line">        c = cc;</span><br><span class="line">        d = dd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixMultiply</span><span class="params">(Matrix2x2 &amp; m, Matrix2x2 &amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = m.a * n.a + m.b * n.c;</span><br><span class="line">    <span class="keyword">int</span> b = m.a * n.b + m.b * n.d;</span><br><span class="line">    <span class="keyword">int</span> c = m.c * n.a + m.d * n.c;</span><br><span class="line">    <span class="keyword">int</span> d = m.c * n.b + m.d * n.d;</span><br><span class="line">    m.Set(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixN</span><span class="params">(Matrix2x2 &amp; m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        m.Set(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 单位阵</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 偶数</span></span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           <span class="comment">// 奇数</span></span><br><span class="line">        Matrix2x2 x = m;</span><br><span class="line">        MatrixN(m, n/<span class="number">2</span>);</span><br><span class="line">        MatrixMultiply(m, m);</span><br><span class="line">        MatrixMultiply(m, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CalcCount2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nNonRepeat = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> nRepeat = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Matrix2x2 <span class="title">m</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    MatrixN(m, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * (m.a + m.c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打气球-leetcode-312"><a href="#打气球-leetcode-312" class="headerlink" title="打气球 leetcode 312"></a>打气球 leetcode 312</h2><p>[题目]<br>给定一串气球，要全部打坏。每个气球上有一个整数，打坏它的得分等于它和左右邻居上的一共三个整数的乘积。<br>如果没有左右邻居，那么视为 1，求最大总得分。</p>
<p>[分析]</p>
<ol>
<li>这个题目拿到手一看就是用 DP</li>
<li>可以先假定用 <code>DP[i][j]</code> 表示气球 i 到气球 j 这一串气球都打完的得分是多少。</li>
<li>问题的难点在于？<ol>
<li>DP 的递推式该怎么样写？</li>
<li>打完一个气球后，本来不相邻的邻居现在变成邻居了，怎么办？</li>
</ol>
</li>
<li>关键思路在于: <mark>总有最后一个消灭的气球</mark></li>
<li>假定 <code>DP[i][j]</code> 里面气球 k 最后一个打破<ol>
<li>那么 <code>DP[i][k-1]</code> 是一个子问题，要最大得分</li>
<li><code>DP[k+1][j]</code> 也是一个子问题，要最大得分</li>
<li>两个字问题被气球 k 隔离，“边界”的气球不会变</li>
</ol>
</li>
<li>因此递推关系式如下<ol>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[k-1] * nums[k] * nums[k+1])\)</li>
<li><mark>上面的式子是错误的！</mark></li>
<li>\(DP[i][j] = max_{k} (DP[i][k-1] + DP[k+1][j] + nums[i-1] * nums[k] * nums[j+1])\)</li>
<li>要注意如果 k-1 &lt; i, 那么 <code>DP[i][k-1]</code> 要理解成 0</li>
</ol>
</li>
<li>最终结果是 <code>DP[0][n-1]</code></li>
<li>更新顺序是: (j-i) 从小到大</li>
<li>时间复杂度 O(N^3)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">DP</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i+len) &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                DP[i][j] = <span class="built_in">max</span>(dp[i][j], ((i &lt;= k<span class="number">-1</span>) ? DP[i][k<span class="number">-1</span>] : <span class="number">0</span>) + ((k + <span class="number">1</span> &lt;= j) ? DP[k+<span class="number">1</span>][j] : <span class="number">0</span>)</span><br><span class="line">                + ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? nums[i<span class="number">-1</span>] : <span class="number">1</span>) * nums[k] * ((j + <span class="number">1</span> &lt; n) ? nums[j + <span class="number">1</span>] : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Count-Square-Submatrices-with-All-Ones-lc1277"><a href="#Count-Square-Submatrices-with-All-Ones-lc1277" class="headerlink" title="Count Square Submatrices with All Ones lc1277"></a>Count Square Submatrices with All Ones lc1277</h2><p>[题目]</p>
<ul>
<li>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</li>
<li>1 x 1 的方阵也算进来</li>
</ul>
<p>[思路一]</p>
<ul>
<li>这一题特别像找 largest square matrix with all ones 那道题</li>
<li>当时我用了辅助矩阵去记录行里面最长的连续 1 个数，列里面最长的连续 1 的个数。</li>
<li>这里也可以用类似的，代码如下</li>
</ul>
<p>[代码一]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> rowContinuousOnes[m][n];</span><br><span class="line">    <span class="keyword">int</span> colContinuousOnes[m][n];</span><br><span class="line">    <span class="keyword">int</span> largestSquare[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            rowContinuousOnes[i][j] = j == <span class="number">0</span> ? matrix[i][j] : (matrix[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> + rowContinuousOnes[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            colContinuousOnes[i][j] = i == <span class="number">0</span> ? matrix[i][j] : (matrix[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> + colContinuousOnes[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                largestSquare[i][j] = matrix[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largestSquare[i][j] = <span class="built_in">min</span>(&#123;largestSquare[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>, rowContinuousOnes[i][j], colContinuousOnes[i][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += largestSquare[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路二]</p>
<ul>
<li>实际上，我们不需要使用这两个辅助的矩阵就可以完成 dp 矩阵的递归！</li>
<li>只需要利用 dp 本身就可以了。</li>
<li>递推关系如下<ul>
<li>dp[i][j] means the size of biggest square with A[i][j] as bottom-right corner.</li>
<li>dp[i][j] also means the number of squares with A[i][j] as bottom-right corner.</li>
<li>If A[i][j] == 0, no possible square.</li>
<li>If A[i][j] == 1,<ul>
<li>we compare the size of square dp[i-1][j-1], dp[i-1][j] and dp[i][j-1].</li>
<li>min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 is the maximum size of square that we can find.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); res += A[i][j++])</span><br><span class="line">            <span class="keyword">if</span> (A[i][j] &amp;&amp; i &amp;&amp; j)</span><br><span class="line">                A[i][j] += <span class="built_in">min</span>(&#123;A[i - <span class="number">1</span>][j - <span class="number">1</span>], A[i - <span class="number">1</span>][j], A[i][j - <span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uncrossed-lines-lc1035"><a href="#uncrossed-lines-lc1035" class="headerlink" title="uncrossed lines lc1035"></a>uncrossed lines lc1035</h2><p>[题目]</p>
<ul>
<li>We write the integers of A and B (in the order they are given) on two separate horizontal lines.</li>
<li>Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:<ul>
<li>A[i] == B[j];</li>
</ul>
</li>
<li>The line we draw does not intersect any other connecting (non-horizontal) line.</li>
<li>Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</li>
<li>Return the maximum number of connecting lines we can draw in this way.</li>
<li><a href="https://leetcode.com/problems/uncrossed-lines/" target="_blank" rel="noopener">题目在这里</a></li>
</ul>
<p>[分析]</p>
<ul>
<li>很典型的动归题目</li>
<li><mark>这里主要是比较一下几种解法的代码优化策略。</mark></li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一：我的写法</span></span><br><span class="line"><span class="comment">// 完成了任务，但是写法不够简洁，体现在两个地方</span></span><br><span class="line"><span class="comment">// 单独拉出来处理 dp 数组的第一行和第一列，不够优美</span></span><br><span class="line"><span class="comment">// 可以一步对 dp 进行赋值，使用 memset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>] == B[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = A[i] == B[<span class="number">0</span>] ? <span class="number">1</span> : dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = A[<span class="number">0</span>] == B[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二：解决了上面两个问题。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>(), dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[i][j] = A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/leetcode-greedy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/leetcode-greedy/" itemprop="url">leetcode-greedy</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-01T13:10:37+08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/01/leetcode-greedy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/01/01/leetcode-greedy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="稳定匹配问题"><a href="#稳定匹配问题" class="headerlink" title="稳定匹配问题"></a>稳定匹配问题</h2><p>[题目]<br>假如你是一个媒人，有若干个单身男子登门求助，还有同样多的单身女子也前来征婚。如果你已经知道这些女孩在每个男人心目中的排名，以及男孩们在每个女孩心中的排名(1)，你应该怎样为他们牵线配对呢？</p>
<p>这个匹配要稳定：<br>如果男 1 号和女 1 号各自有各自的对象，但男 1 号觉得，比起自己现在的对象，女 1 号更好一些；女 1 号也发现，在自己心目中，男 1 号的排名比现男友更靠前一些。这样一来，这两人就可能会发生外遇，最后扔下各自现在的对象，一起私奔了——因为这个结果对他们两人都更好一些。在一种男女配对的方案中，如果出现了这种情况，我们就说婚姻搭配是不稳定的。</p>
<p>[思路]</p>
<ol>
<li>1962 年，美国数学家 David Gale 和 Lloyd Shapley 发明了一种寻找稳定婚姻的策略。不管男女各有多少人，不管他们各自的偏好如何，应用这种策略后总能得到一个稳定的婚姻搭配。换句话说，他们证明了稳定的婚姻搭配总是存在的。有趣的是，这种策略反映了现实生活中的很多真实情况。</li>
<li>在这种策略中，男人将一轮一轮地去追求他中意的女子，女子可以选择接受或者拒绝她的追求者。第一轮，每个男人都选择自己名单上排在首位的女人，并向她表白。此时，一个女孩儿可能面对的情况有三种：没有人跟她表白，只有一个人跟她表白，有不止一个人跟她表白。在第一种情况下，这个女孩儿什么都不用做，只需要继续等待；在第二种情况下，接受那个人的表白，答应暂时和他做男女朋友；在第三种情况下，从所有追求者中选择自己最中意的那一位，答应和他暂时做男女朋友，并拒绝其他所有的追求者。</li>
<li>第一轮结束后，有些男人已经有女朋友了，有些男人仍然是单身。在第二轮追女行动中，每个单身男都从所有还没拒绝过他的女孩中选出自己最中意的那一个，并向她表白，不管她现在是否是单身。和第一轮一样，女孩儿们需要从表白者中选择最中意的一位，拒绝其他追求者。注意，如果这个女孩儿已经有男朋友了，当她遇到了更好的追求者时，她必须拒绝掉现在的男友，投向新的追求者的怀抱。这样，一些单身男人将会得到女友，那些已经有了女友的人也可能会被甩掉，重新变成光棍。在以后的每一轮中，单身的男人继续追求列表中的下一个女孩儿，女孩儿则从包括现男友在内的所有追求者中选择最好的一个，并对其他人说不。这样一轮一轮地进行下去，直到某个时候所有人都不再单身，下一轮将不会有任何新的表白发生，整个过程自动结束。此时的婚姻搭配就一定是稳定的了。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1gahqf5s50kj207w071wei.jpg" alt="StableMatching"></p>
<p>[思考和应用]</p>
<ol>
<li>[历史应用] 历史上，这样的“配对游戏”还真有过实际应用，并且更有意思的是，这个算法的应用居然比算法本身的提出还早 10 年。早在 1952 年，美国就开始用这种办法给医学院的学生安排工作，这被称之为“全国住院医师配对项目”。配对的基本流程就是，各医院从尚未拒绝这一职位的医学院学生中选出最佳人选并发送聘用通知，当学生收到来自各医院的聘用通知后，系统会根据他所填写的意愿表自动将其分配到意愿最高的职位，并拒绝掉其它的职位。如此反复，直到每个学生都分配到了工作。当然，那时人们并不知道这样的流程可以保证工作分配的稳定性，只是凭直觉认为这是很合理的。直到 10 年之后， Gale 和 Shapley 才系统地研究了这个流程，提出了稳定婚姻问题，并证明了这个算法的正确性。</li>
<li>[男女公平吗]<ol>
<li>对男生是 optimal 的，对女生是 pesimal 的。</li>
<li>如果换一下顺序，让女生去追男的，那么结果对女生就是 optimal，对男生就是 pesimal 的。</li>
<li>注意！！！有一些简单的例子你换个顺序做会发现结果一样，这并不名说明上面的 optimal-pesimal 结论有错误，而是因为这个简单的例子只有一种可能的 stable matching. 所以两种方法都会得到这唯一的结果。</li>
<li>只有当有多个 stable solution 存在的时候（每一个solution 里面男 A 都有一个配偶），你会发现，如果是男追女，那么男A 最后的配偶一定是这些 solution 里面的配偶中男A 最喜欢的那个！而女人的配偶一定是这些solution 里面最差的那个。</li>
</ol>
</li>
<li><mark>[现实联系]</mark><ol>
<li><mark>想想生活中，一般都是男追女</mark></li>
<li><mark>那么男生先从自己最喜欢的女生追起来是很符合逻辑的</mark></li>
<li><mark>然后女生呢，只要有男生追自己，那么就先答应着！如果后面碰到更好的，就把男友踹了跟新来者谈恋爱</mark></li>
</ol>
</li>
</ol>
<p>[算法分析]</p>
<ol>
<li>贪心法<ol>
<li>我们希望第 k 个任务的计算占用空间加上前面 k-1 个任务的存储空间占用量之和，越小越好。</li>
<li>O_1 + O_2 + … + O_j + … + O_{k-1} + R_k &lt;=  O_1 + O_2 + … + O_k + … + O_{k-1} + R_j</li>
<li>上面公式的右边是假定从左边拿了任务 j 与 最后的任务 k 交换了</li>
<li>化简上面不等式，得到 O_j + R_k &lt;= O_k + R_j，得到 R_k - O_k &lt;= R_j - O_j</li>
<li>也就是说，只需要把 {R_i - O_i} 降序排列就可以了！</li>
</ol>
</li>
</ol>
<h2 id="Interval-Scheduling-区间调度问题"><a href="#Interval-Scheduling-区间调度问题" class="headerlink" title="Interval Scheduling 区间调度问题"></a>Interval Scheduling 区间调度问题</h2><p>[题目]</p>
<ul>
<li>给你很多形如 [starg, end] 的闭区间，</li>
<li>请设计一个算法，算出这些区间中最多有几个互不相交的区间。</li>
</ul>
<p>[例子]</p>
<ul>
<li>输入 [[1,3], [2,4], [3,6]]</li>
<li>分析 [[1,3], [3,6]]</li>
<li>输出 2</li>
<li>注意！[1,3] 和 [3,6] 边界相同，但是不算相交。</li>
</ul>
<p>[分析]</p>
<ul>
<li>正确的思路其实很简单，可以分为以下三步：<ul>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ul>
</li>
</ul>
<p>[代码]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.sort(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-435-无重叠区间"><a href="#leetcode-435-无重叠区间" class="headerlink" title="leetcode 435 无重叠区间"></a>leetcode 435 无重叠区间</h2><p>[题目]</p>
<ul>
<li>给定一个区间的集合，找到需要移除区间的最小数量，使得剩余区间互不重叠。</li>
<li>注意<ul>
<li>可以认为区间的终点总是大于它的起点</li>
<li>两个区间的边界相互接触不算重叠。</li>
</ul>
</li>
</ul>
<p>[分析]</p>
<ul>
<li>我们已经会求最多有几个区间不会重叠 了，那么剩下的不就是需要去除的区间吗？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">return</span> n - intervalSchedule(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-452-最少的箭射爆气球"><a href="#leetcode-452-最少的箭射爆气球" class="headerlink" title="leetcode 452 最少的箭射爆气球"></a>leetcode 452 最少的箭射爆气球</h2><p>[题目]</p>
<ul>
<li>在二维空间里有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。</li>
<li>由于它是水平的，所以 y 坐标并不重要。只需要知道开始和结束的 x 坐标就足够了。</li>
<li>开始坐标总是小于结束坐标。</li>
<li>平面内最多存在 10^4 个气球。</li>
<li>一支箭可以沿着 x 轴从不同点完全垂直地射出。</li>
<li>在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x_start, x_end, 且满足 x_start &lt;= x &lt;= x_end, 则该气球会被引爆</li>
<li>弓箭可以无限前进</li>
<li>我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</li>
</ul>
<p>[分析]</p>
<ul>
<li>这个问题和区间调度算法一模一样！如果最多有n个不重叠的区间，那么就至少需要n个箭头穿透所有区间：</li>
<li>只是有一点不一样，在intervalSchedule算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</li>
<li>所以只要将之前的算法稍作修改，就是这道题目的答案</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 把 &gt;= 改成 &gt; 就行了</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Remove-K-digits-lc-0402"><a href="#Remove-K-digits-lc-0402" class="headerlink" title="Remove K digits lc-0402"></a>Remove K digits lc-0402</h2><p>[题目]</p>
<ol>
<li>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</li>
<li>Note:<ol>
<li>The length of num is less than 10002 and will be ≥ k.</li>
<li>The given num does not contain any leading zero.</li>
</ol>
</li>
</ol>
<p>[Example 1]</p>
<ol>
<li>Input: num = “1432219”, k = 3</li>
<li>Output: “1219”</li>
<li>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</li>
</ol>
<p>[Example 2]</p>
<ol>
<li>Input: num = “10200”, k = 1</li>
<li>Output: “200”</li>
<li>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</li>
</ol>
<p>[思路]</p>
<ul>
<li>这里是贪心算法的思想</li>
<li>从左往右依次考虑 num 的每一个 digit</li>
<li>先加到结果里面，如果后面碰到的 digit 比之前的小，则依次扔掉前面比当前 digit 小的数字。</li>
<li>贪心的思想就是让最左边的数字尽可能的小！！！</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digits = (<span class="keyword">int</span>)num.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(num.<span class="built_in">size</span>(), <span class="string">'0'</span>)</span></span>;                      <span class="comment">// 这里不能是 res(digits, '0'),不然如果 num 的所有char 都一样，</span></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;                                      <span class="comment">// 程序会把所有的 char 都先放到 res 中，这是放不下的！！！</span></span><br><span class="line">        <span class="comment">// k keeps track of how many characters we can remove</span></span><br><span class="line">        <span class="comment">// if the previous character in stk is larger than the current one</span></span><br><span class="line">        <span class="comment">// then removing it will get a smaller number</span></span><br><span class="line">        <span class="comment">// but we can only do so when k is larger than 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; res[top<span class="number">-1</span>] &gt; num[i] &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                top -= <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[top++] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find the index of first non-zero digit</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; digits &amp;&amp; res[idx] == <span class="string">'0'</span>) idx++;     <span class="comment">// 只返回 digits 长度部分！</span></span><br><span class="line">        <span class="keyword">return</span> idx == digits? <span class="string">"0"</span>: res.substr(idx, digits - idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/leetcode-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/leetcode-graph/" itemprop="url">leetcode-graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-29T09:44:02+08:00">
                2019-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/29/leetcode-graph/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/29/leetcode-graph/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><ul>
<li>图的遍历和搜索</li>
<li>（隐式）图的搜索（连通性）<ul>
<li>重点</li>
<li>8皇后</li>
</ul>
</li>
<li>最短路径<ul>
<li>单源图 (Dijkstra)</li>
<li>任意两点 (floyd)</li>
<li>有负边</li>
</ul>
</li>
<li>最小生成树 (MST)<ul>
<li>Prim</li>
<li>Krusal</li>
</ul>
</li>
<li>拓扑排序 (Topological Sort)</li>
</ul>
<h2 id="图的表示和搜索"><a href="#图的表示和搜索" class="headerlink" title="图的表示和搜索"></a>图的表示和搜索</h2><ul>
<li>图的表示<ul>
<li>邻接矩阵<ul>
<li>NxN 的矩阵，有边是 1，无边是 0</li>
</ul>
</li>
<li>邻接表<ul>
<li>为每个点建立一个链表（数组）存放与之连接的点</li>
</ul>
</li>
</ul>
</li>
<li>搜索<ul>
<li>BFS</li>
<li>DFS</li>
</ul>
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="所有括号匹配的字符串-leetcode-0022"><a href="#所有括号匹配的字符串-leetcode-0022" class="headerlink" title="所有括号匹配的字符串  leetcode 0022"></a>所有括号匹配的字符串  leetcode 0022</h2><p>[题目]<br>N 对括号能够得到的有效括号序列有哪些？</p>
<p>[例子]<br>N = 3, 有效括号串共 5 个，分别为：</p>
<ol>
<li>()()()</li>
<li>()(())</li>
<li>(())()</li>
<li>(()())</li>
<li>((()))</li>
</ol>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>[分析]</p>
<ul>
<li>关键的思路是：当前位置左括号不少于右括号</li>
<li>图是什么？<ul>
<li>节点：目前位置左括号和右括号数 (x, y) (x &gt;= y)</li>
<li>边: 从 (x,y) 到 (x+1, y) 和 (x, y+1)</li>
<li>当 x == y 时，没有到 (x, y+1) 这条边</li>
</ul>
</li>
<li>解是什么？<ul>
<li>从 (0,0) 出发到 (n,n) 的全部路径</li>
</ul>
</li>
<li>DFS 方法<ul>
<li>记录什么？<ul>
<li>左右括号的个数</li>
<li>当前的部分解</li>
</ul>
</li>
</ul>
</li>
<li>BFS 方法<ul>
<li>记录什么？<ul>
<li>方法一 当前的“部分解” —- 浪费空间</li>
<li>方法二 每个节点记录能到达它之前的节点集合 —- 麻烦，最后要还原路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>先看一下 DFS 如何实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param x: number of left parenthesis</span></span><br><span class="line"><span class="comment">@param y: number of right parenthesis</span></span><br><span class="line"><span class="comment">@param now: current solution</span></span><br><span class="line"><span class="comment">@param answer: return object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> now, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; answer)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意在递归调用时，我们始终保证 x &gt;= y 并且 x &lt;= n</span></span><br><span class="line">    <span class="keyword">if</span> (y == n) &#123;    <span class="comment">// 此时 x 一定也等于 n</span></span><br><span class="line">        answer.push_back(now);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; n) &#123;    <span class="comment">// 从 (x, y) 到 (x + 1, y) 的路径</span></span><br><span class="line">        dfs(n, x + <span class="number">1</span>, y, now + <span class="string">"("</span>, answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;    <span class="comment">// 从 (x, y) 到 (x, y + 1) 的路径</span></span><br><span class="line">        dfs(n, x, y + <span class="number">1</span>, now + <span class="string">")"</span>, answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">    dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看 BFS 的第一种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param x: number of left parenthesis</span></span><br><span class="line"><span class="comment">@param y: number of right parenthesis</span></span><br><span class="line"><span class="comment">@param now: current solution</span></span><br><span class="line"><span class="comment">@param answer: return object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">string</span> now;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; answer)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        answer.push_back(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.x = temp.y = <span class="number">0</span>;</span><br><span class="line">    temp.now = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(q.push(temp); !q.empty(); q.pop())&#123;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        node other;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.x &lt; n)&#123;    <span class="comment">// 从 (x, y) 到 (x + 1, y) 的路径</span></span><br><span class="line">            other.x = temp.x + <span class="number">1</span>;</span><br><span class="line">            other.y = temp.y;</span><br><span class="line">            other.now = temp.now + <span class="string">"("</span>;</span><br><span class="line">            q.push(other);       <span class="comment">// 这里因为是加的左括号，因此一定不可能是最后的一个解，可以直接放到 q</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(temp.x &gt; temp.y) &#123;    <span class="comment">// 从 (x, y) 到 (x, y+1) 的路径</span></span><br><span class="line">            other.x = temp.x;</span><br><span class="line">            other.y = temp.y + <span class="number">1</span>;</span><br><span class="line">            other.now = temp.now + <span class="string">")"</span>;</span><br><span class="line">            <span class="keyword">if</span> (other.y == n)&#123;</span><br><span class="line">                answer.push_back(other.now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.push(other);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">    bfs(n, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>[问题分析]</p>
<ul>
<li>任何一个括号序列，都可以写成形式 (A)B<ul>
<li>A 和 B 都是若干括号对形成的合法串（可以是空串）</li>
<li>若 N=0, 括号序列为空</li>
<li>若 N=1, 括号序列只能是 () 这一种。</li>
</ul>
</li>
<li>算法描述: i 属于 [0, N-1]<ul>
<li>计算 i 对括号的可行序列 A</li>
<li>计算 N-i-1 对括号的可行序列 B</li>
<li>组合得到 (A)B</li>
<li>注：加上额外一对括号 (), 总括号数量是 N 对</li>
</ul>
</li>
</ul>
<p><mark>注意下面算法有直接修改数组最后一个元素! 使用了返回引用的方法！！！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">AllParentheses</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"()"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; prefix, suffix, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        prefix = AllParentheses(i);</span><br><span class="line">        suffix = AllParentheses(n-i<span class="number">-1</span>);</span><br><span class="line">        Unit(result, prefix, suffix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prefix, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; suffix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ip = prefix.<span class="built_in">begin</span>(); ip != prefix.<span class="built_in">end</span>(); ip++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> is = suffix.<span class="built_in">begin</span>(); is != suffix.<span class="built_in">end</span>(); is++)&#123;</span><br><span class="line">            result.push_back(<span class="string">""</span>);</span><br><span class="line">            <span class="built_in">string</span>&amp; r = result.back();    <span class="comment">// 这里返回的是引用！技巧啊！！</span></span><br><span class="line">            r += <span class="string">"("</span>;</span><br><span class="line">            r += *ip;</span><br><span class="line">            r += <span class="string">")"</span>;</span><br><span class="line">            r += *is;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思考]</p>
<ul>
<li>可以通过增加缓存的方式，对已经计算得到的字串直接获取，以空间换时间，降低时间复杂度。</li>
<li>如果只是计算可行括号串的数目，如何计算？<ul>
<li>事实上，数组 A[i] 表示长度为 i 的括号串的可行数目，即著名的 Catalan 数！</li>
</ul>
</li>
<li>Calalan 数（从 0 开始数）<ul>
<li>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, …</li>
</ul>
</li>
</ul>
<h2 id="最小平方划分"><a href="#最小平方划分" class="headerlink" title="最小平方划分"></a>最小平方划分</h2><p>[题目]<br>一个正整数可以由若干个正整数的平方和表示，求整数 201314 最小的平方划分数目。</p>
<p>[我的本来思路]<br>用DP的方法！</p>
<p>假设已知 1, …, n-1 的最小划分保存在数组 split[i] 中。求数 n 最小划分。</p>
<p>只需要遍历 1, …, n/2，然后看哪一个 split[i] + split[n-i] 最小，即是 n 的最小划分。</p>
<p>[优化的思路]<br>我的思路时间复杂度是 O(n^2), 因为对于每一个 n, 我都要考虑到 n/2 种情况。</p>
<p>事实上，这个题目可以优化到 O(n sqrt(n)) 的时间复杂度。具体做法就是考虑 n = a + K^2。<br>也就是说，只需要考虑 1 … K 这么多数字，其中 K = sqrt(n).<br>若 split[n - k^2] + 1 &lt; x (x 是当前的 n 的最小划分数目), 则将 x 更新为 split[n - k^2] + 1</p>
<p><mark>[如何求平方根]</mark><br>可以使用牛顿法。<br>牛顿法就是求一个方程的解的方法。</p>
<p>[题外话]<br>四平方和定理</p>
<ul>
<li>每个正整数均可表示为最多4个整数的平方和。</li>
<li>证明<ul>
<li>首先欧拉发现：如果正整数 m 和 n 能表示成 4 个整数的平方和，则其乘积 mn 也能表示成 4 个整数的平方和。</li>
<li>而由于每个正整数要么是质数，要么是合数，而合数都可以表达成质数的乘积形式。</li>
<li>因此只需要证明每个质数可以表示成四个整数的平方和即可！</li>
<li>拉格朗日和欧拉分别在 1770 和 1773 年做出证明。</li>
</ul>
</li>
</ul>
<h2 id="Palindrome-Partitioning-所有划分"><a href="#Palindrome-Partitioning-所有划分" class="headerlink" title="Palindrome Partitioning 所有划分"></a>Palindrome Partitioning 所有划分</h2><p>[题目]<br>给定一个字符串 str, 将 str 划分成若干子串，使得每一个子串都是回文串。计算 str 的所有可能的划分。</p>
<p>note: 因为单个字符一定是回文串，所以一定有解！</p>
<p>[思路一]</p>
<ul>
<li>若当前计算得到了 str[0 … i-1] 的所有划分，可否添加 str[i … j], 得到更大的划分呢？<ul>
<li>显然，若 str[i…j] 是回文串，则可以添加。</li>
</ul>
</li>
<li>剪枝: 在每一步都可以判断中间结果是否为合法结果<ul>
<li>回溯 + 剪枝：如果某一次发现划分不合法，立刻对该分支限界</li>
</ul>
</li>
</ul>
<p>[思路一的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindSolution</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; oneSolution, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= n)&#123;</span><br><span class="line">        res.push_back(oneSolution);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindrome[start][i])&#123;</span><br><span class="line">            oneSolution.push_back(str.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">            FindSolution(str, n, res, i + <span class="number">1</span>, oneSolution, isPalindrome);</span><br><span class="line">            oneSolution.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用二维 DP 来构建 isPalindrome 矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        p[i][i] = True;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                isPalindrome[i][j] = True;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">PalindromePartitioning</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPalindrome</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;str&gt; oneSolution;    <span class="comment">// 记录一个解！！！</span></span><br><span class="line">    FindSolution(str, n, res, start, oneSolution, isPalindrome);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>[思路二：动态规划]</p>
<ul>
<li>如果已知 str[0 … i-1] 的所有回文划分结果 res(i)</li>
<li>如何求 str[0 … i] 的所有划分呢？<ul>
<li>如果子串 str[j … i] 是回文串，则将该字串和 res(j) 共同添加到 res(i+1) 中。</li>
</ul>
</li>
<li>算法<ul>
<li>将集合 res 置空</li>
<li>遍历 j(0 &lt;= j &lt; i), 若 str[j … i] 是回文串，则将 {str[j…i], res(j)} 添加到 res(i+1) 中</li>
<li>i 从 0 到 n，一次调用上面两步骤，最终返回 res(n) 即为所求。</li>
</ul>
</li>
</ul>
<p>[思路二的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">res = &#123;</span></span><br><span class="line"><span class="comment">    &#123;&#123;&#125;&#125;,</span></span><br><span class="line"><span class="comment">    &#123;&#123;"a"&#125;&#125;,</span></span><br><span class="line"><span class="comment">    &#123;&#123;"a","a"&#125;, &#123;"aa"&#125;&#125;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstructIsPalindromeMatrix</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalindrome)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        p[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        isPalindrome[i][i+<span class="number">1</span>] = (str[i] == str[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">2</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((str[i] == str[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                isPalindrome[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">PalindromePartitioning</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPalindrome</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">    ConstructIsPalindromeMatrix(str, isPalindrome);</span><br><span class="line">    </span><br><span class="line">    res.push_back(&#123;&#123;&#125;&#125;);</span><br><span class="line">    res.push_back(&#123;&#123;str.substr(<span class="number">0</span>,<span class="number">1</span>)&#125;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[j][i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it: res[j])&#123;    <span class="comment">// "it" is a vector of strings</span></span><br><span class="line">                    it.push_back(str.substr(j, i-j));</span><br><span class="line">                &#125;</span><br><span class="line">                temp.push_back(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS-与-DP-的思考"><a href="#DFS-与-DP-的思考" class="headerlink" title="DFS 与 DP 的思考"></a>DFS 与 DP 的思考</h3><ol>
<li>DFS 的过程，是计算完成了 str[0…i] 的切分，然后递归调用，继续计算 str[i+1, i+2, … n-1] 的过程；</li>
<li>而 DP 中，假定得到了 str[0 … i-1] 的所有可能切分方案，如何扩展得到 str[0…i] 的切分</li>
<li>从本质上说，二者是等价的：最终都是搜索一颗隐式树<ol>
<li>DFS 显然是深度优先搜索，DP 有点类似于层序遍历的思想。</li>
</ol>
</li>
</ol>
<h3 id="归纳推理的理解"><a href="#归纳推理的理解" class="headerlink" title="归纳推理的理解"></a>归纳推理的理解</h3><ol>
<li>第一数学归纳法，类似于马尔科夫模型，有状态 i 推理得到状态 i+1</li>
<li>第二数学归纳法，则是有状态 0 到 i 一起推理得到状态 i+1.</li>
</ol>
<h2 id="Word-break-leetcode-0139"><a href="#Word-break-leetcode-0139" class="headerlink" title="Word break leetcode 0139"></a>Word break leetcode 0139</h2><p>[题目]<br>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ol>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ol>
<p>[我的思路]</p>
<ol>
<li>用 DP 来记录各个长度的从头开始的子串是否满足条件。</li>
<li>如果 DP[i] 为 true, 则遍历字典中所有字符串 temp<ol>
<li>如果目标字符串 <code>s.substr(i, temp.size()) == temp</code> </li>
<li>那么可以更新 DP[i + temp.size()] 也为真</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(s.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(res[i])&#123;                    <span class="comment">// 截止到前i个字符，都是可以的</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> ss: wordDict)&#123;</span><br><span class="line">                    <span class="comment">// 注意这里的技巧，如果 res[i + ss.size()] 已经为真就不必要取子串判断了</span></span><br><span class="line">                    <span class="keyword">if</span>(i + ss.<span class="built_in">size</span>() &lt;= s.<span class="built_in">size</span>() &amp;&amp; (res[i + ss.<span class="built_in">size</span>()] || (ss.compare(s.substr(i, ss.<span class="built_in">size</span>())) == <span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; ss &lt;&lt; " " &lt;&lt; s.substr(i, ss.size()) &lt;&lt; endl;</span></span><br><span class="line">                        res[i + ss.<span class="built_in">size</span>()] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i+ss.<span class="built_in">size</span>() == s.<span class="built_in">size</span>())</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.<span class="built_in">size</span>()];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Word-break-2-leetcode-0140"><a href="#Word-break-2-leetcode-0140" class="headerlink" title="Word break 2 leetcode 0140"></a>Word break 2 leetcode 0140</h2><h2 id="Word-Search-II-lc0212"><a href="#Word-Search-II-lc0212" class="headerlink" title="Word Search II lc0212"></a>Word Search II lc0212</h2><p>[题目]</p>
<ol>
<li>Given a 2D board and a list of words from the dictionary, find all words in the board.</li>
<li>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</li>
</ol>
<p>[分析]</p>
<ol>
<li>难点<ol>
<li>对于词典里的一个单词，如何看是否在矩阵里？</li>
<li>以上动作需要重复 N 次嘛？N 是词典包含的单词数量。</li>
</ol>
</li>
</ol>
<p>[简洁的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_end;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; children;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        is_end=<span class="literal">false</span>;</span><br><span class="line">        children=<span class="built_in">vector</span>&lt;TrieNode*&gt;(<span class="number">26</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TrieNode* <span class="title">getRoot</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line">    Trie(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            addWord(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">word</span>)</span></span>&#123;</span><br><span class="line">        TrieNode* cur=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=<span class="keyword">word</span>[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;children[index]==<span class="literal">NULL</span>)   </span><br><span class="line">               cur-&gt;children[index]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            cur=cur-&gt;children[index];    </span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;is_end=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie* trie = <span class="keyword">new</span> Trie(words);</span><br><span class="line">        TrieNode* root=trie-&gt;getRoot();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; result_set;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;board.<span class="built_in">size</span>(); ++x)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;board[<span class="number">0</span>].<span class="built_in">size</span>(); ++y)</span><br><span class="line">                findWords(board, x, y, root, <span class="string">""</span>, result_set);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:result_set)    result.push_back(it);</span><br><span class="line">        <span class="keyword">return</span> result;        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, TrieNode* root, <span class="built_in">string</span> <span class="keyword">word</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;=board.<span class="built_in">size</span>()||y&lt;<span class="number">0</span>||y&gt;=board[<span class="number">0</span>].<span class="built_in">size</span>() || board[x][y]==<span class="string">' '</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;children[board[x][y]-<span class="string">'a'</span>] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">word</span>=<span class="keyword">word</span>+board[x][y];</span><br><span class="line">            root=root-&gt;children[board[x][y]-<span class="string">'a'</span>]; </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;is_end) result.insert(<span class="keyword">word</span>);</span><br><span class="line">            <span class="keyword">char</span> c=board[x][y];</span><br><span class="line">            board[x][y]=<span class="string">' '</span>;</span><br><span class="line">            findWords(board, x+<span class="number">1</span>, y, root, <span class="keyword">word</span>, result);</span><br><span class="line">            findWords(board, x<span class="number">-1</span>, y, root, <span class="keyword">word</span>, result);</span><br><span class="line">            findWords(board, x, y+<span class="number">1</span>, root, <span class="keyword">word</span>, result);</span><br><span class="line">            findWords(board, x, y<span class="number">-1</span>, root, <span class="keyword">word</span>, result);</span><br><span class="line">            board[x][y]=c;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[运行速度较快的代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Trie *children[<span class="number">26</span>]; <span class="comment">// pointers to its substrings starting with 'a' to 'z'</span></span><br><span class="line">        <span class="keyword">bool</span> leaf; <span class="comment">// if the node is a leaf, or if there is a word stopping at here</span></span><br><span class="line">        <span class="keyword">int</span> idx; <span class="comment">// if it is a leaf, the string index of the array words</span></span><br><span class="line">        Trie()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;leaf = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;idx = <span class="number">0</span>;</span><br><span class="line">            fill_n(<span class="keyword">this</span>-&gt;children, <span class="number">26</span>, <span class="literal">nullptr</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertWords</span><span class="params">(Trie *root, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, len = words[idx].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">nullptr</span> == root-&gt;children[words[idx][pos]-<span class="string">'a'</span>]) root-&gt;children[words[idx][pos]-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            root = root-&gt;children[words[idx][pos++]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;leaf = <span class="literal">true</span>;</span><br><span class="line">        root-&gt;idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Trie *<span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> Trie(); </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;words.<span class="built_in">size</span>();i++) insertWords(root, words, i);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, Trie *root, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="string">'X'</span>) <span class="keyword">return</span>; <span class="comment">// visited before;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == root-&gt;children[board[i][j]-<span class="string">'a'</span>]) <span class="keyword">return</span> ; <span class="comment">// no string with such prefix</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = board[i][j];</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;children[temp-<span class="string">'a'</span>]-&gt;leaf)  <span class="comment">// if it is a leaf</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(words[root-&gt;children[temp-<span class="string">'a'</span>]-&gt;idx]);</span><br><span class="line">                root-&gt;children[temp-<span class="string">'a'</span>]-&gt;leaf = <span class="literal">false</span>; <span class="comment">// set to false to indicate that we found it already</span></span><br><span class="line">            &#125;</span><br><span class="line">            board[i][j]=<span class="string">'X'</span>; <span class="comment">//mark the current position as visited</span></span><br><span class="line"><span class="comment">// check all the possible neighbors</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) checkWords(board, i<span class="number">-1</span>, j, row, col, root-&gt;children[temp-<span class="string">'a'</span>], res, words);</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)&lt;row) checkWords(board, i+<span class="number">1</span>, j, row, col,  root-&gt;children[temp-<span class="string">'a'</span>], res, words);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">0</span>) checkWords(board, i, j<span class="number">-1</span>,  row, col, root-&gt;children[temp-<span class="string">'a'</span>], res, words);</span><br><span class="line">            <span class="keyword">if</span>((j+<span class="number">1</span>)&lt;col)  checkWords(board, i, j+<span class="number">1</span>,  row, col, root-&gt;children[temp-<span class="string">'a'</span>], res, words);</span><br><span class="line">            board[i][j] = temp; <span class="comment">// recover the current position</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">       <span class="keyword">int</span> row = board.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">0</span>==row) <span class="keyword">return</span> res;</span><br><span class="line">       <span class="keyword">int</span> col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">0</span>==col) <span class="keyword">return</span> res;</span><br><span class="line">       <span class="keyword">int</span> wordCount = words.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(<span class="number">0</span>==wordCount) <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">       Trie *root = buildTrie(words);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> i,j;</span><br><span class="line">       <span class="keyword">for</span>(i =<span class="number">0</span> ; i&lt;row; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;col &amp;&amp; wordCount &gt; res.<span class="built_in">size</span>(); j++)</span><br><span class="line">           &#123;</span><br><span class="line">               checkWords(board, i, j, row, col, root, res, words);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="几个-backtracking-题目"><a href="#几个-backtracking-题目" class="headerlink" title="几个 backtracking 题目"></a>几个 backtracking 题目</h2><h3 id="Combination-Sum-lc0039"><a href="#Combination-Sum-lc0039" class="headerlink" title="Combination Sum lc0039"></a>Combination Sum lc0039</h3><p>[题目]</p>
<ol>
<li>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</li>
<li>The same repeated number may be chosen from candidates unlimited number of times.</li>
<li>Note:<ol>
<li>All numbers (including target) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ol>
</li>
<li>Example 1:<ol>
<li>Input: candidates = [2,3,6,7], target = 7,</li>
<li>A solution set is: [ [7], [2,2,3] ]</li>
</ol>
</li>
<li>Example 2:<ol>
<li>Input: candidates = [2,3,5], target = 8,</li>
<li>A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ]</li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ul>
<li>先排序<ul>
<li>可以降低搜索次数，因为是从小到大搜，一旦有一个元素已经超过剩下的数值了，后面的元素也就不用看了</li>
</ul>
</li>
<li>如何才能使得数字重复利用<ul>
<li>当前从 i 位置开始搜索的，</li>
<li>把 candidates[i] 放到 combination 里面后</li>
<li>递归调用时候还是传递 begin = i，这样子还可以把 candidates[i] 接着放进去</li>
</ul>
</li>
<li>如何避免产生重复的 combinations<ul>
<li>从第 begin 个位置往下递归的调用不能进入小于 begin 的位置</li>
<li>即加入当前加入 3 了，那么剩下的结果你不要又从头开始看加个 1， 加个2， 加个 3；你只能看加个 3，加个 4，etc</li>
<li>否则你有一个递归是先加入 2，再加入的 3；而另外可能有一个递归是先加入了 3，再加入的 2.</li>
</ul>
</li>
</ul>
<p><mark>这个代码非常简洁优美！</mark> 来自<a href="https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c%2B%2B-solution-use-backtracking-easy-understand." target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        combinationSum(candidates, target, res, combination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != candidates.<span class="built_in">size</span>() &amp;&amp; target &gt;= candidates[i]; ++i) &#123;   <span class="comment">// target &gt;= candidates[i] 相当于剪枝了！</span></span><br><span class="line">            combination.push_back(candidates[i]);</span><br><span class="line">            combinationSum(candidates, target - candidates[i], res, combination, i);    <span class="comment">// 把 i 当做 begin, 既保证元素可以重复，</span></span><br><span class="line">            combination.pop_back();                                                     <span class="comment">// 又保证结果中不会出现重复的 combination</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Combination-Sum-II-leetcode-0040"><a href="#Combination-Sum-II-leetcode-0040" class="headerlink" title="Combination Sum II leetcode 0040"></a>Combination Sum II leetcode 0040</h3><p>[题目]</p>
<ul>
<li>参考上面 Combination Sum 的题目</li>
<li>这里的区别在于<font color="red">candidates元素只能用一次</font></li>
</ul>
<p>[思路]</p>
<ul>
<li>代码跟上面的 leetcode 0039 很类似</li>
<li>要注意的是如何保证 candidates 元素只能用一次</li>
<li>不能简单地这么做：递归调用时候传递 <code>begin</code> 为 <code>i+1</code> (上一题是 <code>begin = i</code>)<ul>
<li>这么做会导致重复</li>
<li>假设搜到某个步骤时候 target 变成 5 了</li>
<li>而此时 candidates 里面有 4 个 5</li>
<li>那么上面的做法会使得结果里面有 4 个一样的 combinations</li>
</ul>
</li>
<li>正确的方法是：<ul>
<li>加一个判断语句, 参见代码，真是优美！</li>
<li><code>if(i == begin || candidates[i] != candidates[i-1]) {...}</code></li>
<li><code>i == begin</code> 保证了只会连续得看，不会跳着看</li>
<li>即如果有 k 个 5，那么递归的时候只会考虑第一个 5 ，剩下的 5 就都跳过了</li>
<li>注意这里并没有说相同的 5 只考虑一个</li>
<li>因为 k 个 5 的时候考虑了第一个 5，此时递归下去后，下一次函数调用看到了 k-1 个连续的 5，它只会考虑第一个 5</li>
<li><mark>这样子就保证了如果某个 combination 里面有 m 个 5，那么它一定来自于 candidates 中连续的 k 个 5 中最左边 m 个！！！</mark></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        combinationSum2(candidates, target, res, combination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;candidates, <span class="keyword">int</span> target, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">            res.push_back(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i != candidates.<span class="built_in">size</span>() &amp;&amp; target &gt;= candidates[i]; ++i)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="built_in">begin</span> || candidates[i] != candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                combination.push_back(candidates[i]);</span><br><span class="line">                combinationSum2(candidates, target - candidates[i], res, combination, i + <span class="number">1</span>);</span><br><span class="line">                combination.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Combination-Sum-III-leetcode-0216"><a href="#Combination-Sum-III-leetcode-0216" class="headerlink" title="Combination Sum III leetcode 0216"></a>Combination Sum III leetcode 0216</h3><p>[题目]</p>
<ul>
<li>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</li>
<li>Note:<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
</li>
<li>Example 1:<ul>
<li>Input: k = 3, n = 7</li>
<li>Output: [[1,2,4]]</li>
</ul>
</li>
<li>Example 2:<ul>
<li>Input: k = 3, n = 9</li>
<li>Output: [[1,2,6], [1,3,5], [2,3,4]]</li>
</ul>
</li>
</ul>
<p>[思路]</p>
<ul>
<li>这一题比前两题都简单我觉得，因为你搜索的数字是 1-9，它们没有重复元素啊！！！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(combination);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt;= <span class="number">9</span> &amp;&amp; i &lt;= target; i++)&#123;</span><br><span class="line">            combination.push_back(i);</span><br><span class="line">            helper(k<span class="number">-1</span>, target - i, ans, combination, i+<span class="number">1</span>);</span><br><span class="line">            combination.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</span><br><span class="line">        helper(k, n, ans, combination, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="subsets-leetcode-0078"><a href="#subsets-leetcode-0078" class="headerlink" title="subsets leetcode 0078"></a>subsets leetcode 0078</h3><p>[题目]</p>
<ul>
<li>Given a set of distinct integers, nums, return all possible subsets (the power set).</li>
<li>Note: The solution set must not contain duplicate subsets.</li>
<li>Example:<ul>
<li>Input: nums = [1,2,3]</li>
<li>Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]</li>
</ul>
</li>
</ul>
<p>[解法一：DFS 代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, ans, temp, <span class="built_in">begin</span>+<span class="number">1</span>);    <span class="comment">// 不放当前字母，递归看下一个位置</span></span><br><span class="line">            </span><br><span class="line">        temp.push_back(nums[<span class="built_in">begin</span>]);</span><br><span class="line">        dfs(nums, ans, temp, <span class="built_in">begin</span>+<span class="number">1</span>);    <span class="comment">// 放当前字母，然后递归看下一个位置。</span></span><br><span class="line">        temp.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        dfs(nums, ans, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种 dfs 实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;    <span class="comment">// 在这里声明也可以，不过不太好我觉得</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        dfs(<span class="number">0</span>, ans, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        res.push_back(ans);                            <span class="comment">// 开头第一句这个 很精髓！！！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">            dfs(i + <span class="number">1</span>, ans, nums);</span><br><span class="line">            ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[解法二: BFS]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：</span></span><br><span class="line"><span class="comment">组合|非递归实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 最外层循环逐一从 nums 数组中取出每个元素 num</span></span><br><span class="line"><span class="comment">2. 内层循环从原来的结果集中取出每个中间结果集，并向每个中间结果集中添加该 num 元素</span></span><br><span class="line"><span class="comment">3. 往每个中间结果集中加入 num</span></span><br><span class="line"><span class="comment">4. 将新的中间结果集加入结果集中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">邢政：这个非递归的我没有想出来最开始，主要还是我是从排列组合的角度去思考，先考虑空集合，</span></span><br><span class="line"><span class="comment">接着考虑只有一个元素的集合，再下来只有两个元素的subsets，这样子很不好弄。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而如下的算法非常巧妙，外层 for 循环一共执行 n 次 (n 是有多少个数字)，</span></span><br><span class="line"><span class="comment">内层for 循环是每次去看 result 里面已经有多少个集合了，然后每个集合取出来添加一个相同的当前数字，</span></span><br><span class="line"><span class="comment">形成的新集合放到 result 里面！！</span></span><br><span class="line"><span class="comment">非常巧妙！ 以 1，2，3 为例：</span></span><br><span class="line"><span class="comment">循环之前：res = &#123;&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment">第一次循环，取出空集合，加入数字“1”并放回result中，res = &#123;&#123;&#125; &#123;1&#125;&#125;</span></span><br><span class="line"><span class="comment">第二次循环，取出集合 &#123;&#125; 和 &#123;1&#125;，分别加入数字“2”，新的两个集合放到 result中， res = &#123;&#123;&#125; &#123;1&#125; &#123;2&#125; &#123;1,2&#125;&#125;</span></span><br><span class="line"><span class="comment">第三次循环，取出result中的四个集合，加入数字“3”，新的4个集合放回result中，res= &#123;&#123;&#125; &#123;1&#125; &#123;2&#125; &#123;1,2&#125; &#123;3&#125; &#123;1,3&#125; &#123;2,3&#125; &#123;1,2,3&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        res.push_back(ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ss = res.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ss; j++)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = res[j];</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>[解法三: 集合论]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">解法三：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">利用我们的集合论的知识，我们知道对于一个集合来说，若其元素个数为 n ，则其子集的个数为 2^n 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于其中元素来说，就是在当前子集和不在当前子集两种状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于任意一个子集，我们用一个长度为 n 的01串来表示在不在的状态。其中1表示在，0表示不在。比如：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">| 6 | 5 | 4 | 3 | 2 | 1 |    第i个元素</span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">| 1 | 0 | 0 | 1 | 0 | 1 |    是否在集合</span></span><br><span class="line"><span class="comment">+---+---+---+---+---+---+</span></span><br><span class="line"><span class="comment">该01串也可以表示成二进制数(100101)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对于一个集合来说，其子集若都采用这样的01串来表示，恰好覆盖了从 0 ~ 2^n-1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因此我们同样可以利用这个性质，枚举从0到2^n-1，然后依次还原这个子集。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">具体实现请参考下面的代码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line">        <span class="keyword">int</span> limit = (<span class="number">1</span> &lt;&lt; nums.<span class="built_in">size</span>()) - <span class="number">1</span>; <span class="comment">// 2^n-1</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());     <span class="comment">// 排序，保证子集的是由小到大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= limit; ++i) &#123;  <span class="comment">// 枚举 0 ~ 2^n-1</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp;</span><br><span class="line">            <span class="keyword">int</span> p = i, now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                <span class="comment">// 若该位为1，则表示该位需要存入子集</span></span><br><span class="line">                <span class="keyword">if</span> (p &amp; <span class="number">1</span> == <span class="number">1</span>) tp.push_back( nums[now] );</span><br><span class="line">                p &gt;&gt;= <span class="number">1</span>, ++now;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(tp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="subsets-II-leetcode"><a href="#subsets-II-leetcode" class="headerlink" title="subsets II leetcode"></a>subsets II leetcode</h3><p>[题目]</p>
<p>[解法 DFS 代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        ans.push_back(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;            </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="built_in">begin</span> || nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                temp.push_back(nums[i]);</span><br><span class="line">                dfs(nums, ans, temp, i+<span class="number">1</span>);    <span class="comment">// 放当前字母</span></span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        dfs(nums, ans, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树要求从一个带权无相连通图中选择 n-1 条边并使这个图仍然联通（即得到了一棵生成树），同时还要求树的权重最小。<br>解决这个问题有两个很著名的算法：Prim 和 Kruskal。它们都是<mark>贪心算法</mark>。</p>
<ol>
<li>Prim 算法<ol>
<li>从某个（任意一个）结点出发，选择与该结点邻接的权重最小的边；随着结点的不断加入，每次都选择这些结点发出的边中<mark>权值最小</mark>的：重复 n-1 次。</li>
</ol>
</li>
<li>Kruskal 算法<ol>
<li>将边按照权值递增排序，每次选择权值最小并且不构成环的边，重复 n-1 次。</li>
</ol>
</li>
</ol>
<h2 id="course-schedule"><a href="#course-schedule" class="headerlink" title="course schedule"></a>course schedule</h2><p>[题目]</p>
<ul>
<li>There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.</li>
<li>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</li>
<li>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</li>
</ul>
<p>[分析一]</p>
<ul>
<li>这是一个 topological sort 的问题啊，我们只需要把这个排序步骤给搞一遍就行了。</li>
<li>求每个节点的入度，每多一个 dependency 就入度加一</li>
<li>先把入度为 0 的点找出来，然后把它们对其他节点的入度贡献去掉</li>
<li>其他节点的入度减少到 0 的时候也放入 queue</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numCourses;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;    <span class="comment">// 记录对当前节点有以来的那些节点们</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n, <span class="number">0</span>)</span></span>;    <span class="comment">// 记录每个节点的入度，先都初始化为 0 。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: prerequisites) &#123;</span><br><span class="line">            adj[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">            degree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front(); q.pop(); n--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next: adj[curr])</span><br><span class="line">                <span class="keyword">if</span> (--degree[next] == <span class="number">0</span>) q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[分析二]</p>
<ul>
<li>上面的代码在 n 比较小的时候没问题，但是如果 n 很大，而那些依赖项又相对来说很少的时候，可以使用 map 来优化空间存储。</li>
<li>只考虑 prerequisites 里面出现过的节点！</li>
</ul>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; degree;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p: prerequisites) &#123;</span><br><span class="line">            adj[p[<span class="number">1</span>]].push_back(p[<span class="number">0</span>]);</span><br><span class="line">            degree[p[<span class="number">0</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(degree.<span class="built_in">find</span>(p[<span class="number">1</span>]) == degree.<span class="built_in">end</span>()) degree[p[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = degree.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; it: degree)</span><br><span class="line">            <span class="keyword">if</span> (it.second == <span class="number">0</span>) q.push(it.first);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front(); q.pop(); n--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next: adj[curr])</span><br><span class="line">                <span class="keyword">if</span> (--degree[next] == <span class="number">0</span>) q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Possible-Bipartition"><a href="#Possible-Bipartition" class="headerlink" title="Possible Bipartition"></a>Possible Bipartition</h2><p>[题目]</p>
<ol>
<li>Given a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size.</li>
<li>Each person may dislike some other people, and they should not go into the same group. </li>
<li>Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.</li>
<li>Return true if and only if it is possible to split everyone into two groups in this way.</li>
</ol>
<p>[分析]</p>
<ol>
<li>这个题目理解起来并不困难，就是有一群人，互相之间可能会讨厌，然后呢，需要把他们分成两组人，组内的人不能互相讨厌，只能讨厌另一组的人！</li>
<li>只不过代码要写的比较简洁有一定难度。</li>
<li>这里把一个 leetcode discussion 的答案放在这里<ol>
<li>逐个染色就行了，即不需要用两个 unordered_map 来记录 setA, setB</li>
<li>只需要用一个 <code>vector&lt;int&gt;</code> 来记录颜色就可以了啊</li>
<li>然后也只需要用一个 <code>unordered_map&lt;int, vector&lt;int&gt;&gt; adj</code> 来记录排斥关系就行</li>
<li>不需要用两个来记录 dislike, being_disliked，因为他们作用相同！！！ </li>
</ol>
</li>
</ol>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> COLOR&#123;BLUE, RED, WHITE&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;                        <span class="comment">// used for BFS</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : adj[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[x] == WHITE)</span><br><span class="line">                &#123;</span><br><span class="line">                    colors[x] = <span class="number">1</span> - colors[u];</span><br><span class="line">                    q.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(colors[x] == colors[u])  <span class="comment">//if visited &amp; color same as that of its parent, then its not valid</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dislikes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        colors.assign(N+<span class="number">1</span>, WHITE);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj[dislikes[i][<span class="number">0</span>]].push_back(dislikes[i][<span class="number">1</span>]);</span><br><span class="line">            adj[dislikes[i][<span class="number">1</span>]].push_back(dislikes[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : adj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[x.first] == WHITE)        <span class="comment">//unvisited</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(x.first);</span><br><span class="line">                colors[x.first] = BLUE;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isValid</span>())                <span class="comment">// 执行一次 isValid 就会标记好一群 nodes</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/12/leecode-O-n-time-complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/12/leecode-O-n-time-complexity/" itemprop="url">leecode O(n) time complexity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-12T11:36:14+08:00">
                2019-12-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/12/leecode-O-n-time-complexity/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/12/leecode-O-n-time-complexity/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>O(n) 是什么<ul>
<li>注意 n 是什么？图的节点？边？</li>
<li>扫一遍</li>
<li>两头扫</li>
<li>双重循环，但是内循环变量不减</li>
<li>单调性<ul>
<li>队列</li>
<li>堆栈</li>
</ul>
</li>
<li>组合数学<ul>
<li>下一个排列（上一个排列）</li>
<li>巧妙地证明</li>
<li>计数 != 枚举</li>
</ul>
</li>
<li>动态规划</li>
</ul>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-名人问题"><a href="#1-名人问题" class="headerlink" title="1. 名人问题"></a>1. 名人问题</h2><p>[题目]<br>有 n 个人他们之间认识与否用邻接矩阵表示（1 表示认识，0 表示不认识），并且A认识 B 并不意味着 B 认识 A。<br>名人定义为他不认识任何人且所有人都认识他的人。请求出所有名人。</p>
<p>[分析]<br>最多有几个名人？1 个！</p>
<p>O(n) 的方法：<br>对于两个人 i 和 j，如果 i 认识 j，则 i 显然不是名人，排除掉；<br>如果 i 不认识 j，则 j 显然不是名人，排除掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一：一头扫</span></span><br><span class="line"><span class="comment">// i &lt; j, [0...i-1]没有名人，[i...j-1] 没有名人</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现二：两头扫</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(known[i][j])&#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i != j) &amp;&amp; (known[i][j] || !known[j][i]))&#123;  <span class="comment">// i认识j或者j不认识i</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure>


<h2 id="Trapping-in-Rain-Water-leetcode-0042"><a href="#Trapping-in-Rain-Water-leetcode-0042" class="headerlink" title="Trapping in Rain Water leetcode 0042"></a>Trapping in Rain Water leetcode 0042</h2><h2 id="Container-With-Most-Water"><a href="#Container-With-Most-Water" class="headerlink" title="Container With Most Water"></a>Container With Most Water</h2><p>[题目]<br>a[i] 表示横坐标为 i 出有一个高度为 a[i] 的竖线。把两个竖线当做一个容器左右边的高度，<br>横轴当做底，问哪两条线段组成的容器容量最大？</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            best = <span class="built_in">max</span>(best, <span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大间隔问题"><a href="#最大间隔问题" class="headerlink" title="最大间隔问题"></a><strong>最大间隔问题</strong></h2><p>[题目]<br>给定数组 a，求下标对 i，j 满足 a[i]&lt;=a[j]，并且 j-i 最大。</p>
<p>[分析]</p>
<ul>
<li>假设目前最优解是 d，对于 j，至少要检查 i = j - d - 1 才可能更优。</li>
<li>记录前缀最小值 p[x] = min{p[0…x]}</li>
<li>倒着循环 j，对于每个 j 看一下 p[j-d-1] 是否 &lt;= a[j]，用 p 引导。</li>
<li>如果前面都比 a[j] 大，则这个 j 得不到更优的解。</li>
</ul>
<p><mark>这一题我实在没有想到这个巧妙地思路，我始终局限在两个 pointer 指到元素上面。<br>但是它其实是有一个 “pointer” 是 d！参考下面的代码。</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        p[i] = ((i ==<span class="number">0</span>) || (a[i] &lt; p[i<span class="number">-1</span>])) ? a[i] : p[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; best; --j)&#123;</span><br><span class="line">        <span class="keyword">while</span>((j &gt; best) &amp;&amp; (a[j] &gt;= p[j - best <span class="number">-1</span>]))&#123;</span><br><span class="line">            ++best;</span><br><span class="line">        &#125;  <span class="comment">// 对于每一个 j, 内层循环都试图找到这个 j 所能允许的最大的 gap.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01-相等的串"><a href="#01-相等的串" class="headerlink" title="01 相等的串"></a>01 相等的串</h2><p>[题目]<br>给定一个 01 串，求它的一个最长的子串满足 0 和 1 的个数相等。</p>
<p>[分析]</p>
<ul>
<li><mark>把 0 看成 -1，1 当做 +1</mark>，还是使用“前缀和”的技巧<ul>
<li><font color="orange">这个把 0 看成 -1 的操作绝了！本来这一段区间内即使 0 1 的数量相等，区间和也有很多种数值可能，现在把 0 当成 -1 以后，这么多的可能都塌缩到一种可能: 0!!</font></li>
</ul>
</li>
<li>如果有两个前缀和相等，则这两个前缀和之间的子串满足 0，1 的个数相等。</li>
<li>需要对前缀和排序吗？那就是 O(nlogn) 的时间复杂度了</li>
<li>优化！不需要排序<ul>
<li>前缀和的范围是[-n…n]，我们加上 n 之后就是 [0…2n]，只要记录<mark>第一次出现</mark>的位置。</li>
<li>本质！用 hash 代替排序。当 hash 值是比较小的非负整数时，可以用做数组下标。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">have</span><span class="params">((n &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">// 擦，括号里面就是 2n+1 的意思。</span></span><br><span class="line">    have[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        sum += (s[i] == <span class="string">'0'</span>) ? (<span class="number">-1</span>) : (+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(have[sum] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            best = <span class="built_in">max</span>(best, i - have[sum] + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            have[sum] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制矩阵中-1-的个数"><a href="#二进制矩阵中-1-的个数" class="headerlink" title="二进制矩阵中 1 的个数"></a>二进制矩阵中 1 的个数</h2><p>[题目]<br>给定 n * n 的 01 方阵，每一行都是降序的（即先连续的一段 1，再连续的一段 0），求 1 最多的那行中 1 的个数？</p>
<p>[分析]</p>
<ul>
<li>思路一：数出每一行的 1 … 复杂度O(n^2)</li>
<li>思路二：二分法找到每一行 0 和 1 的分界线，复杂度 O(nlogn)</li>
<li>思路三：从左上角开始，如果某个位置是 1，就向右走，如果是 0 则向下走！（我们只需要找到比本行更多的 1 才有意义！）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (best &lt; n) &amp;&amp; (i &lt; n); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>((best &lt; n) &amp;&amp; (a[i][best] == <span class="string">'1'</span>))&#123;</span><br><span class="line">            ++best;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><ul>
<li>最大子数组和</li>
<li>KMP</li>
<li>Manacher</li>
<li>最大直方图（单调堆栈）</li>
<li>滑动窗口最大值（单调队列）</li>
<li>快排 partition 过程</li>
<li>杨氏矩阵查找<ul>
<li>荷兰国旗问题</li>
<li>First Missing Positive</li>
</ul>
</li>
<li>排列组合相关<ul>
<li>Next/Previous permutation</li>
</ul>
</li>
<li>树相关<ul>
<li>二叉树遍历，（最大、最小）深度，同构，镜像判断，平衡判断</li>
</ul>
</li>
</ul>
<h2 id="下一个排列-leetcode-0031-STL亦如此实现"><a href="#下一个排列-leetcode-0031-STL亦如此实现" class="headerlink" title="下一个排列 leetcode 0031 (STL亦如此实现)"></a>下一个排列 leetcode 0031 (STL亦如此实现)</h2><p>[题目]<br>Next Permutation 找到字典序里的下一个排列。12345 的下一个是 12354，而54321 的下一个是 12345.</p>
<p>[分析]</p>
<ul>
<li>a[0], a[1], …, a[n-1], 下一个排列是字典序比它大，最小的</li>
<li>找到尽可能大的 m, b[0] = a[0], b[1] = a[1], …, b[m-1] = a[m-1], 而 b[m] &gt; a[m], b[m+1 … n-1] 是按照升序排列的。</li>
</ul>
<p>[形象点的分析]</p>
<ul>
<li>目前的排列是: (A)a<a href="B">x</a></li>
<li>下一个排列是: (A)a<a href="B'">y</a><ul>
<li>A 是相同的，A 尽可能长</li>
<li>a[y] &gt; a[x]</li>
<li>B’ 几乎是 B 里面的数排好顺序的结果</li>
</ul>
</li>
<li>如何确定 x？<ul>
<li>一个位置只要右边有数比它大就是候选的 x</li>
<li>a[x] 是最后一个这样的数（最右边）<ul>
<li>a[x] 右边的数，没个数的右边没有比它大的</li>
<li>所以 a[x] 右边的数是按照降序（不升序）排列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>[算法 (二找、一交换、一翻转)]</p>
<ul>
<li>找到最后一个严格升序的首位 (a[i] &lt; a[i+1])，定义为 x<ul>
<li>(A) = a[0…x-1], (B) = a[x+1…n-1]</li>
</ul>
</li>
<li>找到 y&gt;x, a[y] &gt; a[x], 且 a[y] 最小<ul>
<li>一定存在，因为 x+1 就是一个候选</li>
<li>a[x] 后面的数都是降序，所以从后往前找到第一个大于 a[x] 的位置就是 y 了</li>
<li>可以二分找到 y，但不影响总体时间复杂度</li>
</ul>
</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转<ul>
<li>交换后 a[x+1…n-1] 仍然是降序（不升）</li>
<li>逆转等于排序</li>
</ul>
</li>
</ul>
<p><mark>这个解法要熟记！</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(x = n<span class="number">-2</span>; (x&gt;=<span class="number">0</span>) &amp;&amp; (nums[x] &gt;= nums[x+<span class="number">1</span>]); --x)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        reverse(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">for</span>(y = n - <span class="number">1</span>; nums[y] &lt;= nums[x]; --y)</span><br><span class="line">    ;</span><br><span class="line">    swap(nums[x], nums[y]);</span><br><span class="line">    reverse(nums.<span class="built_in">begin</span>() + x + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考题：上一个排列？"><a href="#思考题：上一个排列？" class="headerlink" title="思考题：上一个排列？"></a>思考题：上一个排列？</h3><p>类似的思路</p>
<ul>
<li>找到最后一个严格降序的首位(a[i] &gt; a[i+1])，定义为 x</li>
<li>找到 y&gt;x, a[y] &lt; a[x], 且 a[y] 最大</li>
<li>交换 a[x], a[y]</li>
<li>对 (x+1) 位后进行逆转</li>
</ul>
<h2 id="均分01"><a href="#均分01" class="headerlink" title="均分01"></a>均分01</h2><p>[题目]<br>给定一个01串，签好包含 2n 个 0 和 2n 个 1，你可以把它切成若干段，再把它们任意拼接，要求拼接出两部分，每部分恰好包含 n 个 0，n 个 1，如何使得切得段数最少？</p>
<p>[示例]<br>举例一：0101，从中间切一刀形成(01)(01)，分别作为两部分<br>举例二：0011，切成 3 段 (0)(01)(1), 把中间 (01) 单独作为一部分，生育的 (0)(1) 作为另外一部分。</p>
<p>[思路]<br>这一题其实都不算是算法题我觉得。<br>先考虑前面 2n 个数字，如果里面 1 的个数超过 0，那么把这个长度为 2n 的窗口向右挪，中间肯定在某个位置使得 1 和 0 的个数相等？为啥呢？因为不可能在所有的位置都有 2n 窗口内 1 的个数大于 0 的个数，这与题目的条件 4n 窗口内有 2n 个 1 和 2n 个 0 相冲突！</p>
<p>[答案]<br>如果最前面 2n 个数满足 1 和 0 个数相等，那么就分成两段就可以了；<br>如果不是，那么就分成三部分。</p>
<h2 id="X-的个数"><a href="#X-的个数" class="headerlink" title="X 的个数"></a>X 的个数</h2><p>[题目]<br>给定一个长度为 n 的整数数组 a，下标从 0 开始，再给定一个元素 X，求一个位置 m，满足 0&lt;=m&lt;=n，且 a[0…m-1] 中 X 的个数（如果m=0表示空数组）和 a[m…n-1] 中非 X 的个数（如果 m==n，表示空数组）相等。</p>
<p>[分析]</p>
<ul>
<li>假设 a 中一共有 x 个 X，给定 m，假设 a[0…m-1] 中有 y 个 X，则 a[m…n-1] 中非 X 的个数是 (n-m)-(x-y) = n-m-x+y == y</li>
<li>化简可得 m = n - x</li>
<li>解存在且唯一！</li>
</ul>
<p>[解法]</p>
<ul>
<li>直接统计下有多少个 X 就可以了</li>
<li>O(n) 时间，O(1) 空间</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>[题目]<br>10个硬币，有四个是正面的，在不开灯的情况下，把他们分成两组，如果做可以使得正面的个数相等？（可以手动改变某些硬币的正反面）</p>
<p>[答案]<br>分成两组，一组 6 个，一组 4 个，然后把 4 个的那组所有硬币都翻个面。</p>
<h2 id="PAT-的个数"><a href="#PAT-的个数" class="headerlink" title="PAT 的个数"></a>PAT 的个数</h2><p>[题目]<br>给定一个只包含 P, A, T 的串，求一共出现多少个 “PAT” 子序列？</p>
<p>[分析：计数和枚举不同]</p>
<ul>
<li>p, pa, pat 表示之前出现的 “P”, “PA”, “PAT” 的个数</li>
<li>s[i] == “P”, ++p</li>
<li>s[i] == “A”, pa += p</li>
<li>s[i] == ‘T’, pat += pa</li>
<li>时间复杂度 O(n)，空间复杂度 O(1)</li>
</ul>
<h3 id="思考题-distinct-subsequences-leetcode-115"><a href="#思考题-distinct-subsequences-leetcode-115" class="headerlink" title="思考题 distinct subsequences leetcode 115"></a>思考题 distinct subsequences leetcode 115</h3><p>[题目]<br>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意内层的 for 循环是倒着来算的，这样子可以排除掉出现相同字母的情形。</span></span><br><span class="line"><span class="comment">比如 S = "rabbbit", T = "rabbit"</span></span><br><span class="line"><span class="comment">T 的第三第四个位置都是 'b'</span></span><br><span class="line"><span class="comment">如果你从左往右看 T, 第三个 'b' 那里你把 dp[2]更新了，</span></span><br><span class="line"><span class="comment">这会导致第四个 'b' 那里你用 dp[2] 来计算 dp[3] 出现错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(t.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = t.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">                    dp[j] += j ? dp[j<span class="number">-1</span>] : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小平均值子数组-codility"><a href="#最小平均值子数组-codility" class="headerlink" title="最小平均值子数组 codility"></a>最小平均值子数组 codility</h2><p>[题目]<br>给定一个数组，求一个至少包含两个元素的子数组，满足平均值最小。<br>输出子数组的起点，多个的时候输出最小的。</p>
<p>[分析]</p>
<ul>
<li>如果最优解长度为偶数，把它拆成长度为 2 的若干段</li>
<li>如果最优解长度为奇数 (&gt;2), 我们把它柴承长度为 2 的若干段，和一段长度为 3 的段</li>
<li>最优解中每一段的平均值都相等<ul>
<li>如果某一段平均值比最优解小，至少有一段平均值比最优解大，矛盾。</li>
</ul>
</li>
<li>！！！ 一次，只需要考虑长度为 2 和 3 的段计算就可以了。</li>
</ul>
<h2 id="环形最大子数组和-from-itint5-com-Q9"><a href="#环形最大子数组和-from-itint5-com-Q9" class="headerlink" title="环形最大子数组和 from itint5.com Q9"></a>环形最大子数组和 from itint5.com Q9</h2><p>[题目]<br>给定一个数组，是环形的，最后一个元素和第一个元素相接，求最大子数组和。</p>
<p>[分析]</p>
<ul>
<li>环形最大子数组和<ul>
<li>普通最大子数组和，例如 1 2 -4 <mark> 5 6 -9 </mark></li>
<li>开头和结尾的一部分，例如 <mark>1 2 </mark> -4 -5 -6 <mark> 9 </mark></li>
</ul>
</li>
<li>算法<ul>
<li>求普通最大子数组的和</li>
<li>总和减去普通的最小子数组和<ul>
<li>可以考虑对原始数组取相反数，调用最大子数组和模块。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="允许交换一次的最大子数组和"><a href="#允许交换一次的最大子数组和" class="headerlink" title="允许交换一次的最大子数组和"></a>允许交换一次的最大子数组和</h2><p><mark> 这一题非常难！要好好琢磨其 DP 思路 </mark></p>
<p>[题目]<br>给定一个数组，在允许交换两个数的前提下（只允许交换一次，可以不换），求最大子数组的和。</p>
<p>[分析]</p>
<ul>
<li>定义 f[i] 为两部分之和<ul>
<li>以 a[i] 结尾的最大子数组的和（可以为空）</li>
<li>与任意 a[0…i] 里面单独一个元素</li>
<li>以上两部分没有交集</li>
<li>递推式 f[i] = max(f[i-1] + a[i], max(a[0…i]))</li>
</ul>
</li>
<li>定义 g[i]<ul>
<li>以 a[i] 开头的最大子数组和（非空）</li>
<li>递推式 g[i] = max(g[i+1], 0) + a[i]</li>
</ul>
</li>
<li>如果 a[i] 和 a[j] 交换 (j &lt; i), 原来包含 a[i] 的最大子数组和变为<ul>
<li>g[i] - a[i] + f[i-1]</li>
<li>（即要换掉的元素在 f[i-1] 里, <mark>单独存在的那一个</mark>）</li>
</ul>
</li>
<li>如果不交换，答案就是 max{g[i]}</li>
<li>我们只考虑 j &lt; i 的情况，对于 j &gt; i, 把 a 翻转再做一次就可以了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f, g;</span><br><span class="line">    f.resize(n);</span><br><span class="line">    f[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> now = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        now = <span class="built_in">max</span>(now, a[i]);</span><br><span class="line">        f[i] = <span class="built_in">max</span>(a[i] + f[i<span class="number">-1</span>], now);</span><br><span class="line">    &#125;</span><br><span class="line">    g.resize(n);</span><br><span class="line">    g[n<span class="number">-1</span>] = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        g[i] = <span class="built_in">max</span>(g[i+<span class="number">1</span>], <span class="number">0</span>) + a[i];</span><br><span class="line">        answer = <span class="built_in">max</span>(answer, g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        answer = <span class="built_in">max</span>(answer, g[i] - a[i] + f[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = help(A);</span><br><span class="line">    reverse(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    answer = <span class="built_in">max</span>(answer, help(A));</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>计数 != 枚举</li>
<li>没有讲到的问题<ul>
<li>O(n^3) 优化到 O(n^2)</li>
<li>序列相关的问题<ul>
<li>给定一个 1-n 的排列，每次只能把一个数放到序列开头，至少几次能排好循序？</li>
<li>给定一个 1-n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序？</li>
</ul>
</li>
<li>更多前缀、后缀的利用</li>
</ul>
</li>
</ul>
<h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><h3 id="leetcode-53-最大连续子数组和"><a href="#leetcode-53-最大连续子数组和" class="headerlink" title="leetcode 53 最大连续子数组和"></a>leetcode 53 最大连续子数组和</h3><p>[题目]<br>给定一个数组，求最大的连续子数组和。</p>
<p>[分析]</p>
<ul>
<li>方法一 记录最小前缀和（两个前缀和的差就是一段连续的子数组）</li>
<li>方法二 动态规划，记录以每个位置结束的最大子数组的和。</li>
</ul>
<h3 id="leetcode-152-求最大的连续子数组乘积"><a href="#leetcode-152-求最大的连续子数组乘积" class="headerlink" title="leetcode 152 求最大的连续子数组乘积"></a>leetcode 152 求最大的连续子数组乘积</h3><p>[分析]</p>
<ul>
<li>首先要考虑一下是否会溢出</li>
<li>到当前项乘积最大要考虑之前乘积的绝对值，因此要记录<ul>
<li>之前最小乘积</li>
<li>之前最大乘积</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mini = nums[<span class="number">0</span>], maxi = nums[<span class="number">0</span>], ansmin = nums[<span class="number">0</span>], ansmax = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempmin = <span class="built_in">min</span>(nums[i], <span class="built_in">min</span>(mini * nums[i], maxi * nums[i]));</span><br><span class="line">            <span class="keyword">int</span> tempmax = <span class="built_in">max</span>(nums[i], <span class="built_in">max</span>(mini * nums[i], maxi * nums[i]));</span><br><span class="line">            mini = tempmin;</span><br><span class="line">            maxi = tempmax;</span><br><span class="line">            ansmin = <span class="built_in">min</span>(mini, ansmin);</span><br><span class="line">            ansmax = <span class="built_in">max</span>(maxi, ansmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansmax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p>[题目]<br>一个数组，比如 {1,2,3,4,5} 循环移动一位就是 {2,3,4,5,1}，再移动一位就是 {3,4,5,1,2}.</p>
<p>[分析]</p>
<ul>
<li>长度为 n，把它移动 m 位，和移动 m % n 位是一样的。</li>
<li>翻转前 m 位</li>
<li>翻转后 (n-m) 位</li>
<li>总体再翻转</li>
<li>翻转可以O(n)做到：<ul>
<li>for(int i = from, j = to; i &lt; j; swap(a[i++], a[j–]));</li>
</ul>
</li>
</ul>
<h3 id="单词翻转"><a href="#单词翻转" class="headerlink" title="单词翻转"></a>单词翻转</h3><h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><h2 id="快排-partition"><a href="#快排-partition" class="headerlink" title="快排 partition"></a>快排 partition</h2><ul>
<li>荷兰国旗问题 leetcode 75</li>
<li>奇偶数分开，正负数分开</li>
<li>01 交换排序</li>
<li>交换星号</li>
<li>第一个缺失的整数 leetcode 41</li>
<li>中位数、第k大（小）的书、最大（小）的k个数<ul>
<li>找第 k 大的数关键<ul>
<li>5 数取中做 pivot (3 数取中会退化)</li>
<li>Partition 过程分三段（分两段有相同数会退化）<ul>
<li>算法导论“偷懒”了（它假设了没有相同的数做了分析）</li>
</ul>
</li>
</ul>
</li>
<li>找到最小的 k 个数<ul>
<li>基于 partition 的方法找到的数是无序的</li>
<li>如果要有序建议用堆 O(nlogk)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>[思路一]</p>
<ul>
<li>直接两次快排</li>
<li>第一次把 0 和非 0 分开</li>
<li>第二次把 1 和 2 分开</li>
</ul>
<p>[思路2]<br>循环不变式的应用</p>
<ul>
<li>三个变量 begin, cur, end 把数组分成四个区域<ul>
<li>[0, begin): 所有数据都是 0</li>
<li>[begin, current): 所有数据都是 1</li>
<li>(end, size-1]: 所有数据都是 2</li>
<li>[current, end): 未知</li>
</ul>
</li>
<li>循环不变式<ul>
<li>初值 begin=current=0, end=size-1, 前三个区间都为空集，满足以上四个条件</li>
<li>遍历 current, 根据arr[current] 的值作相应处理，直到区间 [current, end) 为空，即 current==end 时退出。</li>
<li>代码如下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Holland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = <span class="keyword">int</span>(arr.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[current] == <span class="number">2</span>)&#123;</span><br><span class="line">            swap(arr[<span class="built_in">end</span>], arr[current]);</span><br><span class="line">            <span class="built_in">end</span>--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[current] == <span class="number">1</span>)&#123;</span><br><span class="line">            current++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// if(a[current] == 0)</span></span><br><span class="line">            <span class="keyword">if</span>(current != <span class="built_in">begin</span>)&#123;</span><br><span class="line">                swap(arr[current], arr[<span class="built_in">begin</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">begin</span>++;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>[荷兰国旗与快排的优化]</mark></p>
<p>传统的快排每次选取 pivot，然后把元素分成 &lt;=pivot 和 &gt;pivot 两部分。<br>在有相同元素的时候，每次分割递归的时候还是把 pivot 左边的，pivot 右边的递归。</p>
<p>而使用荷兰国旗思想，则可以优化有大量重复数字的情况。</p>
<p>假设选取的 pivot 呢，有很多相同元素，荷兰国旗的思想就是把元素分成三段！<br>第一段小于 pivot, 第二段等于 pivot, 第三段大于 pivot.</p>
<p>然后递归的时候，中间等于 pivot 的那一段就不需要在处理了！！！<br>因此有很多优化。</p>
<p><mark>快排的最坏情况</mark></p>
<ol>
<li>本来已经是顺序排好了</li>
<li>本来已经是逆序排好了</li>
<li>所有元素都一样！(这个可以用荷兰国旗思想来优化！)</li>
</ol>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><ul>
<li>找出出现次数超过一半的数</li>
<li>推广：找出出现次数大于 1/k 的数，用 (k-1) 个 map，复杂度 O(n * k)，注意 k 是常数的时候就是 O(n).</li>
</ul>
<h2 id="单调堆栈"><a href="#单调堆栈" class="headerlink" title="单调堆栈"></a>单调堆栈</h2><p>[题目]<br>最大直方图</p>
<p>[思路]</p>
<ul>
<li>入栈时左边界确定</li>
<li>出栈时右边界确定</li>
<li>每块只出入栈一次<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="滑动窗口最值-栈和队列-例6"><a href="#滑动窗口最值-栈和队列-例6" class="headerlink" title="滑动窗口最值 (栈和队列 例6)"></a>滑动窗口最值 (栈和队列 例6)</h3><h3 id="codility-题目"><a href="#codility-题目" class="headerlink" title="codility 题目"></a>codility 题目</h3><p>[题目]<br>给定一个数组 A 和整数 K，问有多少对下标 i&lt;=j 满足 max(A[i…j]) - min(A[i…j]) &lt;= K</p>
<p>[分析]</p>
<ul>
<li>如果(i,j)满足条件，则(i+1,j), (i+2,j)…都满足条件。</li>
<li>对每个 i, 找到第一个不满足条件的 j</li>
<li>如何求 [i…j] 的最大最小值<ul>
<li>单调队列</li>
<li>滑动窗口（两个边界都只增大不减）<ul>
<li>滑动出去的不会进来</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> K, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; qmin, qmax;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; A.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>((!qmin.empty()) &amp;&amp; (A[qmin.back()] &gt;= A[j]))&#123;</span><br><span class="line">                qmin.pop_back();</span><br><span class="line">            &#125; <span class="comment">// qmin 里面的元素是单调递增的！</span></span><br><span class="line">            qmin.push_back(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((!qmax.empty()) &amp;&amp; (A[qmax.back()] &lt;= A[j]))&#123;</span><br><span class="line">                qmax.pop_back();</span><br><span class="line">            &#125; <span class="comment">// qmax 里面的元素是单调递减的！</span></span><br><span class="line">            qmax.push_back(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(A[qmax.front()] - A[qmin.front()] &lt;= K)&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// 这个 while 循环找到最远的 j。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(qmin.front() == i)&#123;</span><br><span class="line">            qmin.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qmax.front() == i)&#123;</span><br><span class="line">            qmax.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        answer += j - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><ul>
<li>树的高度</li>
<li>二叉树对称判断</li>
<li>二叉树平衡判断</li>
<li>二叉树的最小深度</li>
<li>指定和的路径</li>
<li>二叉树双向链表转换</li>
<li>前中后序遍历</li>
</ul>
<h3 id="距离最远的点"><a href="#距离最远的点" class="headerlink" title="距离最远的点"></a>距离最远的点</h3><p>[题目]<br>给定一个无根的树（无向<mark>无环图</mark>），求距离最远的两个点（树的直径）。</p>
<p>[易忽略]</p>
<ul>
<li>对于一个自由树的直径，《算法导论》上的说明是“树中所有最短路径的最大值即为树的直径。”</li>
<li>记住，“无环图”这个概念很重要。</li>
<li>最笨的方法<ul>
<li>就是对每一个节点进行 BFS, 找到最远的点。这个方法时间复杂度是 O(n^2).</li>
</ul>
</li>
<li>简单巧妙的贪心<ul>
<li>以任意一点为根、找到距离它最远的节点 x</li>
<li>以 x 为根找到距离 x 最远的点 y</li>
<li>(x, y) 就是一条直径</li>
</ul>
</li>
<li>如何找最远的点？dfs 求深度</li>
<li>思考：算法证明？</li>
</ul>
<p>[证明]<br>但是在证明定义之前，先证明一个引理：</p>
<p>引理：在一个连通无向无环图中，x、y 和 z 是三个不同的结点。当 x 到 y 的最短路与 y 到 z 的最短路不重合时，x 到 z 的最短路就是这两条最短路的拼接。</p>
<p>证明：假设 x 到 z 有一条不经过 y 的更短路δ(x,z)，则该路与δ(x,y)、δ(y,z)形成一个环，与前提矛盾。</p>
<p>定理：在一个连通无向无环图中，以任意结点出发所能到达的最远结点，一定是该图直径的端点之一。</p>
<p>证明：假设这条直径是δ(s,t)。分两种情况：</p>
<ul>
<li>当出发结点 y 在δ(s,t)时，假设到达的最远结点 z 不是 s,t 中的任一个。这时将δ(y,z)与不与之重合的δ(y,s)拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的直径，与前提矛盾。</li>
<li>当出发结点 y 不在δ(s,t)上时，分两种情况：<ul>
<li>1). 当 y 到达的最远结点 z 横穿δ(s,t)时，记与之相交的结点为 x。此时有δ(y,z)=δ(y,x)+δ(x,z)。而此时δ(y,z)&gt;δ(y,t)，故可得δ(x,z)&gt;δ(x,t)。由1的结论可知该假设不成立。<br>2). 当 y 到达的最远结点 z 与δ(s,t)不相交时，记 y 到 t 的最短路首先与δ(s,t)相交的结点是 x。由假设δ(y,z)&gt;δ(y,x)+δ(x,t)。而δ(y,z)+δ(y,x)+δ(x,s)又可以形成δ(z,s)，而δ(z,s)&gt;δ(x,s)+δ(x,t)+2δ(y,x)=δ(s,t)+2δ(y,x)，显然与题意矛盾。</li>
</ul>
</li>
</ul>
<p>因此定理成立。</p>
<h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><p>[题目]<br>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two end nodes</p>
<p>[分析]<br>The diameter of a tree T is the largest of the following quantities:</p>
<ul>
<li>the diameter of T’s left subtree</li>
<li>the diameter of T’s right subtree</li>
<li>the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xz注：这个代码是用 C 实现的，函数的调用需要记录两个变量，</span></span><br><span class="line"><span class="comment">tree height &amp; tree diameter，它这里采用的是通过传递</span></span><br><span class="line"><span class="comment">指针过去来计算得到 height, 然后函数返回的是 tree diameter.</span></span><br><span class="line"><span class="comment">如果使用 C++ 的话，可以让函数返回 vector&lt;int&gt; = &#123;tree_height, tree_diameter&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The second parameter is to store the height of tree. </span></span><br><span class="line"><span class="comment">   Initially, we need to pass a pointer to a location with value </span></span><br><span class="line"><span class="comment">   as 0. So, function should be used as follows: </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">   int height = 0; </span></span><br><span class="line"><span class="comment">   struct node *root = SomeFunctionToMakeTree(); </span></span><br><span class="line"><span class="comment">   int diameter = diameterOpt(root, &amp;height); */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOpt</span><span class="params">(struct node *root, <span class="keyword">int</span>* <span class="built_in">height</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">/* lh --&gt; Height of left subtree </span></span><br><span class="line"><span class="comment">     rh --&gt; Height of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* ldiameter  --&gt; diameter of left subtree </span></span><br><span class="line"><span class="comment">     rdiameter  --&gt; Diameter of right subtree */</span></span><br><span class="line">  <span class="keyword">int</span> ldiameter = <span class="number">0</span>, rdiameter = <span class="number">0</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    *<span class="built_in">height</span> = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* diameter is also 0 */</span></span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Get the heights of left and right subtrees in lh and rh </span></span><br><span class="line"><span class="comment">    And store the returned values in ldiameter and ldiameter */</span></span><br><span class="line">  ldiameter = diameterOpt(root-&gt;left, &amp;lh); </span><br><span class="line">  rdiameter = diameterOpt(root-&gt;right, &amp;rh); </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/* Height of current node is max of heights of left and </span></span><br><span class="line"><span class="comment">     right subtrees plus 1*/</span></span><br><span class="line">  *<span class="built_in">height</span> = <span class="built_in">max</span>(lh, rh) + <span class="number">1</span>; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span>(lh + rh + <span class="number">1</span>, <span class="built_in">max</span>(ldiameter, rdiameter)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口相关"><a href="#滑动窗口相关" class="headerlink" title="滑动窗口相关"></a>滑动窗口相关</h2><h3 id="leetcode-209"><a href="#leetcode-209" class="headerlink" title="leetcode 209"></a>leetcode 209</h3><p>[题目]<br>给定一个数组，里面全是正整数，再给一个正整数 s, 求数组里面最少多少个连续的数，满足总和不小于 s.</p>
<p>[分析]</p>
<ul>
<li>核心：大窗口不满足条件，它的任意子窗口也不满足条件。</li>
<li>窗口 [i…j]<ul>
<li>过小，++j</li>
<li>过大, ++i</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> answer = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>; j &lt; n; )&#123;</span><br><span class="line">            <span class="keyword">while</span>((sum &lt; s) &amp;&amp; (j &lt; n))&#123;</span><br><span class="line">                sum += nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                <span class="keyword">for</span>(; sum &gt;= s; sum -= nums[i++])</span><br><span class="line">                ;</span><br><span class="line">                answer = <span class="built_in">min</span>(answer, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (answer &gt;= n) ? <span class="number">0</span> : answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子串变位词"><a href="#子串变位词" class="headerlink" title="子串变位词"></a>子串变位词</h3><p>easy TODO</p>
<h3 id="leetcode-76-最短子串包含全部子母"><a href="#leetcode-76-最短子串包含全部子母" class="headerlink" title="leetcode 76 最短子串包含全部子母"></a>leetcode 76 最短子串包含全部子母</h3><p>easy TODO</p>
<h3 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3 无重复字符的最长子串"></a>leetcode 3 无重复字符的最长子串</h3><p>easy TODO</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>长度</li>
<li>（K 个一组）翻转 leetcode 206, 92, 25</li>
<li>插入 leetcode 147</li>
<li>删除 leetcode 203, 82, 83</li>
<li>复制 leetcode 138</li>
<li>求交 leetcode 160</li>
<li>找环 leetcode 141, 142</li>
<li>（倒数）第 k 个元素 leetcode 19</li>
<li>链表判断是否回文</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="2-SUM"><a href="#2-SUM" class="headerlink" title="2-SUM"></a>2-SUM</h3><p>使用hash easy</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>[题目]<br>给定一个 1-n 的排列，每次只能把一个数放到序列末尾，至少几次能排好顺序。</p>
<p>[分析]</p>
<ul>
<li>需要移动 1 吗？不，其他都排好了，1 自然就好了。</li>
<li>如果要移动 x，则我们必须把 (x+1), (x+2), …, n 都移动了</li>
<li>从 1 到 (x-1) 是有序的<ul>
<li>x 有多大？</li>
</ul>
</li>
</ul>
<p><font color="red">注意这一题跟下面两个题目不一样的地方是：这一题只能把数字移动到末尾。因此我们必须找从数字 1 开始的子序列，看看能达到多大。</p>
<p>假设可以达到 x，那么说明 x+1, x+2, …, n 都在 x 的前面出现了，那么为了让数组有序，需要依次把 x+1, x+2, …, n 放到数组最后。<br></font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), want = <span class="number">1</span>;  <span class="comment">// 从 1 开始的子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == want)&#123;  <span class="comment">// 每次找到 want 以后，就加 1.</span></span><br><span class="line">            ++want;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 这个找的实际上是有多少个数字出现在了比它小的数字的前面。。。</span></span><br><span class="line">    <span class="comment">// want ... n must be moved</span></span><br><span class="line">    <span class="keyword">return</span> n - want + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序2"><a href="#数组排序2" class="headerlink" title="数组排序2"></a>数组排序2</h3><p>题目<br>给定一个 1 到 n 的排列，每次可以把一个数放到序列开头，也可以放到结尾，至少几次能排好序。</p>
<p>分析</p>
<ul>
<li><font color="red">这一题跟上一题不一样，数字可以移动到开头，所以不需要限制从 1 开始找，只需要找到 y 到 x 最长的就可以。</font></li>
<li>把数字 1 到数字 y 移动到开头，把数字 x 到 数字 n 移动到末尾</li>
<li>[y+1…x-1] 必须按顺序出现</li>
<li>所以目的就是要找到最小的 y 和 最大的 x，这样子 移动的数字才最少。</li>
<li>dp[x] 表示从 x 开始在原数组中往后按顺序出现的最长长度<ul>
<li>即 x, x+1, …, x+dp[x]-1 按顺序出现</li>
<li>倒着循环 i, dp[a[i]] = dp[a[i]+1] + 1</li>
</ul>
</li>
</ul>
<p><font color="orange">我其实觉得很奇怪，这个 dp 序列在更新的时候，不是按照一定的顺序来逐个得到的。而是来回跳。。。（取决于数组 a 里面的数字从右往左出现的顺序）。</font></p>
<p><font color="red">想了一个多小时，从上一题的思路到这一题，终于想明白。<br>首先要清楚，之所以 for 循环里面 i 从大到小，意味着数组是从右往左扫。<br>这样子如果扫到了比如 a[5] = 8, 那么 dp[8] 就可以计算出来了。<br>往左走如果 a[4]=7，那么 dp[7] 就可以用 dp[8] 的结果加上 1 得到。<br>为啥呢？因为是从右往左扫的，后遇见 dp[7] 说明 7 比 8 晚遇见，7 在 8 的左边嘛！满足排序的顺序。</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>(), m = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 使用 1...n+1 注意下标范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m, dp[a[i]] = dp[a[i]+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序3-NOIP，很难"><a href="#数组排序3-NOIP，很难" class="headerlink" title="数组排序3 NOIP，很难"></a>数组排序3 NOIP，很难</h3><p>[题目描述]<br>给定一个长度为N的数列Ai。<br>你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。<br>求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。</p>
<p>[输入格式]<br>第一行是一个正整数N。<br>第二行是N个正整数Ai。</p>
<p>[输出格式]<br>输出一个整数，表示最少需要的操作次数。</p>
<p>[样例输入]<br>5<br>6 3 7 8 6</p>
<p>[样例输出]<br>2</p>
<p>[题解]<br><font color="red">这一题跟上一题不一样的地方在于这一题的数字不一定是 1 到 n，并且数字还可以允许出现重复数字。</font></p>
<p>经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：</p>
<ul>
<li>子序列单调递增；</li>
<li>若子序列中最小数是L，最大数是R，则子序列必须包含[L+1,R−1]中的数列中的所有数。</li>
</ul>
<p>用单调队列求出满足这两个条件的子序列的最大长度，用n减去就是答案。<br>即这个子序列保持不动，其余数向前或后移动一次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE], q[SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"change.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"change.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        b[a[i]].push_back(i);</span><br><span class="line">        m = <span class="built_in">max</span>(m, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        reverse(b[i].<span class="built_in">begin</span>(), b[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = b[i][j];</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">2</span> + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            q[++r] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-11T15:34:42+08:00">
                2019-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/11/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<h1 id="几个重要的排序法讲解"><a href="#几个重要的排序法讲解" class="headerlink" title="几个重要的排序法讲解"></a>几个重要的排序法讲解</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于<mark>排序效率在同为O(N * logN)的几种排序方法中效率较高</mark>，因此经常被采用，再加上快速排序思想<mark>分治法</mark>也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。</p>
<p>总的说来，要直接默写出快速排序还是有一定难度的，因为本人就自己的理解对快速排序作了下白话解释，希望对大家理解有帮助，达到快速排序，快速搞定.</p>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先从数列中取出一个数作为基准数。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<h3 id="填坑法"><a href="#填坑法" class="headerlink" title="填坑法"></a>填坑法</h3><p>对挖坑填数进行总结</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-sorting-quick-sort-1.png" alt=""></p>
<p><mark>注意，这里的图画的有点问题。最后数字 11 应该在 12 的左边。</mark></p>
<p>步骤如下<br>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。<br>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = a[start];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[<span class="built_in">end</span>] &gt;= p &amp;&amp; start &lt; <span class="built_in">end</span>) <span class="built_in">end</span>--;</span><br><span class="line">        a[start] = a[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span>(a[start] &lt; p &amp;&amp; start &lt; <span class="built_in">end</span>) start++;</span><br><span class="line">        a[<span class="built_in">end</span>] = a[start];</span><br><span class="line">    &#125;</span><br><span class="line">    a[start] = p;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(a, start, <span class="built_in">end</span>);</span><br><span class="line">    qs(a, start, mid<span class="number">-1</span>);</span><br><span class="line">    qs(a, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h3><p>交换法，顾名思义就是要对两边的元素进行交换，再代码形式中用到swap函数。其流程如下:</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-sorting-quick-sort-2.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[start];</span><br><span class="line">    <span class="keyword">int</span> p = start+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= q)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[p] &lt; pivot &amp;&amp; p &lt;= q) p++;</span><br><span class="line">        <span class="keyword">while</span>(a[q] &gt;= pivot &amp;&amp; p &lt;= q) q--;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; q)&#123;</span><br><span class="line">            swap(&amp;a[p], &amp;a[q]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;a[start], &amp;a[q]);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(a, start, <span class="built_in">end</span>);</span><br><span class="line">    qs(a, start, mid<span class="number">-1</span>);</span><br><span class="line">    qs(a, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序遍历法"><a href="#顺序遍历法" class="headerlink" title="顺序遍历法"></a>顺序遍历法</h3><p>上面两种方法是维护了一个start,一个end指针，逐步向中间趋近的过程。而顺序遍历用一次遍历完成对数据的分段。</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-sorting-quick-sort-3.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[<span class="built_in">end</span>];</span><br><span class="line">    <span class="keyword">int</span> storeIndex = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; <span class="built_in">end</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; pivot)&#123;</span><br><span class="line">            swap(&amp;a[storeIndex], &amp;a[i]);</span><br><span class="line">            storeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;a[storeIndex], &amp;a[<span class="built_in">end</span>]);</span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(a, start, <span class="built_in">end</span>);</span><br><span class="line">    qs(a, start, mid<span class="number">-1</span>);</span><br><span class="line">    qs(a, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另类交换法"><a href="#另类交换法" class="headerlink" title="另类交换法"></a>另类交换法</h3><p>这个方法和之前的交换法的思路相同，但是它不返回mid值，所以索性称之为另类交换法吧。运作的流程就不做解释，直接上代码，各位客官姑且一看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[start];</span><br><span class="line">    <span class="keyword">int</span> p = start;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[p] &lt; pivot) p++;</span><br><span class="line">        <span class="keyword">while</span>(a[q] &gt; pivot) q--;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= q)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;a[p], &amp;a[q]);</span><br><span class="line">        p++;</span><br><span class="line">        q--;</span><br><span class="line">    &#125;</span><br><span class="line">    qs(a, start, p<span class="number">-1</span>);</span><br><span class="line">    qs(a, q+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h2><p><img src="http://bubkoo.qiniudn.com/shell-sort-animation.gif" alt=""></p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ol>
<p>算法思路：</p>
<ol>
<li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d2(d2 &lt; d1)</li>
<li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</li>
</ol>
<p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="http://bubkoo.qiniudn.com/shell-sort-step1.1.png" alt=""><br>然后分别对 4 个小组进行插入排序，排序后的结果为：</p>
<p>然后，取 d2 = 2，将原数组分为 2 小组，如下图：</p>
<p>然后分别对 2 个小组进行插入排序，排序后的结果为：</p>
<p>最后，取 d3 = 1，进行插入排序后得到最终结果：</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆概念"><a href="#堆概念" class="headerlink" title="堆概念"></a>堆概念</h3><ol>
<li>堆：满足堆有序的完全二叉树</li>
<li>堆有序：一棵二叉树的所有父节点大于等于（最大堆）或者小于等于（最小堆）其全部子节点</li>
<li>堆的高度：假设有 n 个节点，那么树的高度为 h = floor(log n)</li>
</ol>
<h3 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a>堆排序的过程</h3><p>用数组存储堆，这里以最大堆为例。如果数组从下标 0 开始算，那么节点 k 的父节点为 floor((k-1) / 2)，节点 k 的左右子节点为 2k+1 和 2k+2.</p>
<p>对于一个未排序的初始化数组，</p>
<ol>
<li>第一步是建堆：从其<mark>最后一个父节点</mark>开始往前进行堆调整，即可建立最大堆。</li>
<li>第二步：建好最大堆之后，每次取其根节点作为最大值，把最后一个节点作为新的根节点对堆进行调整，反复进行上述操作直到堆只有一个根节点。</li>
</ol>
<h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><p>这个代码做的操作就是把 index 位置的节点调整，然后被变动的子节点再向下调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heapArr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heapArr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> largest = index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑左孩子</span></span><br><span class="line">    <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &amp;&amp; heapArr[index * <span class="number">2</span> + <span class="number">1</span>] &gt; heapArr[largest])&#123;</span><br><span class="line">        largest = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑右孩子</span></span><br><span class="line">    <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span> &lt;= n<span class="number">-1</span>) &amp;&amp; heapArr[index * <span class="number">2</span> + <span class="number">2</span>] &gt; heapArr[largest])&#123;</span><br><span class="line">        largest = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(largest != index)&#123;</span><br><span class="line">        swap(heapArr[largest], heapArr[index]);</span><br><span class="line">        maxHeapify(heapArr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立最大堆"><a href="#建立最大堆" class="headerlink" title="建立最大堆"></a>建立最大堆</h3><p>建立最大堆就是从一个完全二叉树的最后一个父节点开始往前进行堆调整。<br>若最后一个节点为 n - 1，那么其父节点，也就是最后一个父节点，为 floor(((n-1)-1)/2).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; maxHeap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = maxHeap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lastFatherIndex = (n<span class="number">-1</span><span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lastFatherIndex; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        maxHeapify(maxHeap, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[时间复杂度]<br><mark>这里要注意时间复杂度不是 O(NlogN)的，而是 O(N).<br>因为倒数第二层的父节点只需要往下沉一层，倒数第三层的节点需要往下沉两层，以此类推。</mark></p>
<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>所谓堆排序就是每次取堆的根节点为最大值，然后将最后一个节点作为根节点，进行堆调整。<br>堆排序的时间等于建堆和进行堆调整的时间，所以堆排序的时间复杂度是 O(N logN + N) = O(N logN)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; maxHeap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = maxHeap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(maxHeap[<span class="number">0</span>], maxHeap[i]);    <span class="comment">// 根节点和最后一个节点交换</span></span><br><span class="line">        maxHeapify(maxHeap, <span class="number">0</span>);    <span class="comment">// ”根“位置的元素是错的，需要把它从”根“位置往下沉！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="各种排序算法的C-代码"><a href="#各种排序算法的C-代码" class="headerlink" title="各种排序算法的C++代码"></a>各种排序算法的C++代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"><span class="comment">//                    Author: qianghaohao(Xqiang)</span></span><br><span class="line"><span class="comment">//                    Mail: qiang.timothy@qq.com</span></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  直接插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 stl 里面的函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = start; i != <span class="built_in">end</span>; ++i)</span><br><span class="line">    <span class="built_in">std</span>::rotate(<span class="built_in">std</span>::upper_bound(start, i, *i), i, <span class="built_in">std</span>::next(i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  折半插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  二分法找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  希尔排序:</span></span><br><span class="line"><span class="comment">//  a:数组  d:分组间距 n:元素个数</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(2^1.5)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> d, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d; i &lt; n; i++) &#123;</span><br><span class="line">            key = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span>; j -= d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; a[j]) &#123;</span><br><span class="line">                    a[j+d] = a[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+d] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        d -= <span class="number">2</span>;   <span class="comment">//最终要保证d为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 选择排序 selectionSort</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">std</span>::min_element(a.<span class="built_in">begin</span>() + i, a.<span class="built_in">end</span>());  <span class="comment">//选最小值</span></span><br><span class="line">      swap(a[i], a[it - a.<span class="built_in">begin</span>()]);  <span class="comment">//最小值和a[i]交换</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//// 快速排序</span></span><br><span class="line"><span class="comment">//// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//// 稳定性:不稳定</span></span><br><span class="line"><span class="comment">//void QuickSort(vector&lt;int&gt; &amp;a, int low, int high) &#123;</span></span><br><span class="line"><span class="comment">//    int i = low;</span></span><br><span class="line"><span class="comment">//    int j = high;</span></span><br><span class="line"><span class="comment">//    if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//        while (i &lt; j) &#123;   //i == j跳出循环</span></span><br><span class="line"><span class="comment">//            //支点为i</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //支点为j</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//       QuickSort(a, low, i-1);</span></span><br><span class="line"><span class="comment">//     QuickSort(a, i+1, high);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 快速排序(改进版--避免了交换支点的开销)</span></span><br><span class="line"><span class="comment">/* 时间复杂度:平均是 O(nlogn)，最坏情况和插入排序相同，也是O(n^2)。</span></span><br><span class="line"><span class="comment">比如一个序列5,4,3,2,1，要排为1,2,3,4,5。</span></span><br><span class="line"><span class="comment">或者是序列1，2，3，4，5，虽然已经是排好顺序的了。</span></span><br><span class="line"><span class="comment">但是，按照快速排序方法，每次只会有一个数据进入正确顺序，</span></span><br><span class="line"><span class="comment">不能把数据分成大小相当的两份。</span></span><br><span class="line"><span class="comment">很明显，排序的过程就成了一个歪脖子树，树的深度为n，那时间复杂度就成了O(n^2)。</span></span><br><span class="line"><span class="comment">尽管如此，需要排序的情况几乎都是乱序的，自然性能就保证了。</span></span><br><span class="line"><span class="comment">据书上的测试图来看，在数据量小于20的时候，插入排序具有最好的性能。</span></span><br><span class="line"><span class="comment">当大于20时，快速排序具有最好的性能，归并(merge sort)和堆排序(heap sort)也望尘莫及，</span></span><br><span class="line"><span class="comment">尽管复杂度都为nlog2(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[i];  <span class="comment">//保存支点(最左边的数字)</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;   <span class="comment">//只可能在 i == j 时跳出循环，不会出现 i&gt;j</span></span><br><span class="line">            <span class="comment">//支点为i, 从右边开始找一个小于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pivot &lt;= a[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个数字填到 i 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//支点为j，再从左边开始找一个大于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个大于 pivot 的数字填到 j 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// while 里面的复杂度是 O(n)</span></span><br><span class="line">        <span class="comment">// 循环结束后，说明 i==j，此时左边的值都小于pivot，右边的值都大于pivot</span></span><br><span class="line">        <span class="comment">// 这个时候把 pivot 填写到 i==j 处</span></span><br><span class="line">        <span class="comment">// 之后对左右两边都分别递归做 quicksort</span></span><br><span class="line">       a[i] = pivot;  <span class="comment">//i==j时填入支点</span></span><br><span class="line">       QuickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">       QuickSort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意，while 里面的复杂度固定是 O(n)，</span></span><br><span class="line"><span class="comment">因为每次比较都会把左指针右移一位或者右指针左移一位。</span></span><br><span class="line"><span class="comment">因此快速排序算法的关键就是减少 while 循环的次数。</span></span><br><span class="line"><span class="comment">那就必须使得每一次while 循环都能保证 pivot 跑到了中间位置。</span></span><br><span class="line"><span class="comment">这个数组被大致等分。</span></span><br><span class="line"><span class="comment">这样子整个算法复杂度就是经典的 divide and conqure 的复杂度 O(nlogn).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用这个代码，更有 C++ 范儿</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(FwdIt first, FwdIt last, Compare cmp = Compare&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> N = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> pivot = <span class="built_in">std</span>::next(first, N/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::nth_element(first, pivot, last, cmp);</span><br><span class="line">    quickSort(first, pivot, cmp);</span><br><span class="line">    quickSort(pivot, last, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  堆排 heapsort</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="comment">//  不适合在元素个数太少的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  调整堆为最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">//(n-1)/2:最后一个有孩子节点的编号</span></span><br><span class="line">        j = <span class="number">2</span>*i;  <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &#123;  <span class="comment">//左右孩子都有</span></span><br><span class="line">            <span class="keyword">if</span> (a[j+<span class="number">1</span>] &gt; a[j]) &#123;  <span class="comment">//选取左右孩子中较大的</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="comment">// 交换--较大的元素调整到根节点</span></span><br><span class="line">        <span class="comment">// 在此也可以用a[0]当作中间变量来交换</span></span><br><span class="line">        <span class="comment">// 相当于temp,因为a[0]在整个排序过程中</span></span><br><span class="line">        <span class="comment">// 没有使用</span></span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用AdjustHeap进行堆排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        AdjustHeap(a, n - i);</span><br><span class="line">        swap(a[<span class="number">1</span>], a[n<span class="number">-1</span>-i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(n)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src中low-mid 和 mid-high两部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid;  <span class="comment">//前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = mid + <span class="number">1</span>;  <span class="comment">//后半部分</span></span><br><span class="line">    <span class="keyword">int</span> n = high;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; m &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src[i] &lt; src[m]) &#123;</span><br><span class="line">            des[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            des[k++] = src[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  合并可能剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        des[k++] = src[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n) &#123;</span><br><span class="line">        des[k++] = src[m++];</span><br><span class="line">    &#125;</span><br><span class="line">    swap_ranges(src.<span class="built_in">begin</span>() + low, src.<span class="built_in">begin</span>() + high + <span class="number">1</span>, des.<span class="built_in">begin</span>());  <span class="comment">//  合并后放回原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  temp:临时向量,保存合并后的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">      mid = first + ((last - first) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      MergeSort(a, first, mid, temp);</span><br><span class="line">      MergeSort(a, mid + <span class="number">1</span>, last, temp);</span><br><span class="line">      MergeArray(a, first, mid, last, temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="comment">//  测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(arr.<span class="built_in">size</span>())</span></span>;  <span class="comment">//merge sort test</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; arr = &#123;0, 9, 8, 7, 6, 5, 4, 4, 4, 6, 6, 6&#125;;  //heap sort test</span></span><br><span class="line"><span class="comment">// InsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// BinaryInsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// ShellSort(arr, 5, arr.size());</span></span><br><span class="line"><span class="comment">// BubbleSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// SelectSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// QuickSort(arr, 0, arr.size()-1);</span></span><br><span class="line"><span class="comment">// HeapSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// copy(arr.begin() + 1, arr.end(), ostream_iterator&lt;int&gt;(cout, " "));  //heap sort test</span></span><br><span class="line">   MergeSort(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>, temp);</span><br><span class="line">   copy(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快排为什么快"><a href="#快排为什么快" class="headerlink" title="快排为什么快"></a>快排为什么快</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="noopener">http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/</a></li>
<li><a href="https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ</a></li>
<li><a href="http://www.inference.org.uk/mackay/sorting/sorting.html" target="_blank" rel="noopener">http://www.inference.org.uk/mackay/sorting/sorting.html</a></li>
</ul>
<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>我们先来玩一个猜数字游戏：我心里默念一个1<del>64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1</del>32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。</p>
<p>我们再来回顾一下这个游戏所蕴含的本质：为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1<del>10之间，那么一旦发现不是在1</del>10之间的话就会剩下比N/2更多的可能性需要去考察了。</p>
<p>徐宥在讨论中提到，这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。</p>
<h2 id="称球"><a href="#称球" class="headerlink" title="称球"></a>称球</h2><p>12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。</p>
<p>这个问题是一道流传已久的智力题。网络上也有很多讲解，还有泛化到N个球的情况下的严格证明。也有零星的一些地方提到从信息论的角度来看待最优解法。本来我一直认为这道题目除了试错之外没有其它高妙的思路了，只能一个个方法试，并尽量从结果中寻找信息，然后看看哪种方案最少。</p>
<p>然而，实际上它的确有其它的思路，一个更本质的思路，而且根本用不着信息论这么拗口的知识。</p>
<p>我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。</p>
<p>如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。</p>
<p>为了更清楚的看待这个问题，我们不妨假设有6个球，来考虑一下3、3称和2、2称的区别：</p>
<p>在未称之前，一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后，不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）：1重、2重、3重、4轻、5轻、6轻。即这种称法能排除一半可能性。</p>
<p>现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！我们充分利用了“天平的结果状态可能有三种”这个条件来三等分所有可能性，而不是二等分。</p>
<p>说到这里，剩下的事情就实在很简单了：第二步称法，只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。</p>
<p>MacKay在他的书《Information Theory: Inference and Learning Algorithms》（作者开放免费电子书）里面4.1节专门讲了这个称球问题，还画了一张不错的图，我就照抄了：</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6qe45peoj20d40d875m.jpg" alt="23131201.jpg"></p>
<p>图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现a&lt;b的话剩下的排列可能性就变成N!/2，如果发现a&gt;b也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持a&lt;b的排列一共有N!/2个，支持a&gt;b的也是N!/2个，换言之，a&lt;b的概率等于a&gt;b的概率。</p>
<p>我们希望每次在比较a和b的时候，a&lt;b和a&gt;b的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。</p>
<p>一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。</p>
<h3 id="为什么堆排比快排慢"><a href="#为什么堆排比快排慢" class="headerlink" title="为什么堆排比快排慢"></a>为什么堆排比快排慢</h3><p>回顾一下堆排的过程：</p>
<ol>
<li><p>建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子… 以此类推）</p>
</li>
<li><p>将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。</p>
</li>
<li><p>重复第2步。</p>
</li>
</ol>
<p>这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到——原本剩下多少可能性还是剩下多少可能性。</p>
<p>在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p>
<p>这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。</p>
<p>MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了。具体参考这里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/leetcode-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/leetcode-tree/" itemprop="url">leetcode tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-10T12:20:05+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/10/leetcode-tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h1><p>数的基本操作有</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    tagSTreeNode* left;</span><br><span class="line">    tagSTreeNode* right;</span><br><span class="line"></span><br><span class="line">    tagSTreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; STreeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STreeNode* m_root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(STreeNode* root)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> _Insert(STreeNode* root, <span class="keyword">int</span> val);    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">bool</span> _Insert2(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> _PreOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">void</span> _PreOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder3(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _PostOrder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于任何的树，算法复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Iterative 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* BinaryTree::Find(int v) const &#123;</span><br><span class="line">    if(!m_root) return nullptr;</span><br><span class="line"></span><br><span class="line">    TreeNode* res &#x3D; m_root;</span><br><span class="line">    while(res)&#123;</span><br><span class="line">        if(v &lt; res-&gt;val)&#123;</span><br><span class="line">            res &#x3D; res-&gt;left;</span><br><span class="line">        &#125; else if (v &gt; res-&gt;val) &#123;</span><br><span class="line">            res &#x3D; res-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加一个节点"><a href="#添加一个节点" class="headerlink" title="添加一个节点"></a>添加一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Insert: BST的插入过程是一个递归过程，如果插入结点值比插入位置结点值小，则插入到左子树。反之则插入到右子树中。若插入位置结点的左子树或者右子树为空，则直接插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTree::Insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Insert(m_root, val);    <span class="comment">// 递归算法</span></span><br><span class="line">    <span class="comment">// return _Insert2(val);        // 非递归算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert(TreeNode* root, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// val 已经在 tree 里面了，插入失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert2(<span class="keyword">int</span> val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root)&#123;</span><br><span class="line">        m_root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* pnode = m_root, pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exhausively 找到待插入的位置(nullptr)</span></span><br><span class="line">    <span class="comment">// 此时 pnode 就是那个 nullptr, pcur 是此节点的父节点。</span></span><br><span class="line">    <span class="keyword">while</span>(pnode)&#123;</span><br><span class="line">        pcur = pnode;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// while 执行完后 pnode = nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; pcur-&gt;val)&#123;</span><br><span class="line">        pcur-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pcur-&gt;val) &#123;</span><br><span class="line">        pcur-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除一个节点</span><br><span class="line"></span><br><span class="line">思想就是：</span><br><span class="line">    递归寻找待删除的 node</span><br><span class="line">    找到以后</span><br><span class="line">    如果node 没有左子树，就把右子树提上来</span><br><span class="line">    如果node 没有右子树，就把左子树提上来</span><br><span class="line">    如果node 既有左子树，又有右子树，这个情况比较复杂</span><br><span class="line">        可以把左子树最大的数字拿过来，也可以把右子树最小的拿过来！</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    /*<br>    方法一：左子树的最右边的 node 替换上来！！！<br>    */</p>
<pre><code>TreeNode* deleteNode(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* maxNode = findMax(root-&gt;left);
        root-&gt;val = maxNode-&gt;val;
        root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
    }

    return root;
}

TreeNode* findMax(TreeNode* node){
    while(node-&gt;right)
        node = node-&gt;right;
    return node;
}


/* 
方法二：右子树的最左边的 node 替换上来
*/

TreeNode* deleteNode_way2(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* minNode = findMin(root-&gt;right);
        root-&gt;val = minNode-&gt;val;
        root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
    }

    return root;
}

TreeNode* findMin(TreeNode* node){
    while(node-&gt;left)
        node = node-&gt;left;
    return node;
}
*/</code></pre><p>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的3种遍历(include iterative and recursive)</span><br><span class="line">1. 下面四种情况中，只有 2 和 3 能唯一决定一棵树。More generally, if a node has only one child, preorder and postorder do not contain enough information to determine whether that child is a left child or a right child.</span><br><span class="line">    1. preorder and postorder</span><br><span class="line">    2. inorder and postorder</span><br><span class="line">    3. preorder and inorder</span><br><span class="line">    4. level order and postorder</span><br><span class="line"></span><br><span class="line">技巧</span><br><span class="line">1. 二叉搜索树的 in-order traversal 输出一个 sorted array</span><br><span class="line">2. 二叉搜索树的 pre-order traversal 输出一个 array，这个 array 不是 sorted，但是它有个特点就是，右子树的值肯定都大于当前节点。(leetcode-255, verify pre-order sequence of Binary Search Tree)</span><br><span class="line"></span><br><span class="line">### 前序遍历</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">void BinaryTree::PreOrder(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    _PreOrder(m_root, visited);</span><br><span class="line">    &#x2F;&#x2F;_PreOrder2(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归思想去做前序遍历</span><br><span class="line">void BinaryTree::_PreOrder(TreeNode* root, vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!root) return;</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _PreOrder(root-&gt;left, visited);</span><br><span class="line">    _PreOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归方法的前序遍历</span><br><span class="line">void BinaryTree::_PreOrder2(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!m_root) return;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(m_root);</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        pcur &#x3D; s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        visited.push_back(pcur-&gt;val);</span><br><span class="line">        if(pcur-&gt;right) s.push(pcur-&gt;right);</span><br><span class="line">        if(pcur-&gt;left) s.push(pcur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二插查找树中序遍历的结果是升序的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::InOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _InOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _InOrder2(visited);</span></span><br><span class="line">    <span class="comment">// _InOrder3(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _InOrder(root-&gt;left, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _InOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历</span></span><br><span class="line"><span class="comment">  注意，这一个不是按照上面的思路！每次拿出一个节点，把右放进去，再放自己，再放左。</span></span><br><span class="line"><span class="comment">  这样子需要额外记录一下节点是不是第一次访问的信息，写起来麻烦！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的解决思路是每次弹出一个节点，需要一直找左子树，</span></span><br><span class="line"><span class="comment">  走到头，把过程中碰到的节点都压入栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pcur || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(pcur)&#123;        <span class="comment">// 找最左孩子</span></span><br><span class="line">            s.push(pcur);</span><br><span class="line">            pcur = pcur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            pcur = s.top();    <span class="comment">// 访问左海子为空的节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">            pcur = pcur-&gt;right;    <span class="comment">// 转向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历 第二种思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放自己，再放左子树节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::PostOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _PostOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _PostOrder2(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_PostOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _PostOrder(root-&gt;left, visited);</span><br><span class="line">    _PostOrder(root-&gt;right, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的后序遍历（与中序遍历的第三个方法代码区别就只有一行！）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放左子树节点，再放自己。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据前序中序，计算后续"><a href="#根据前序中序，计算后续" class="headerlink" title="根据前序中序，计算后续"></a>根据前序中序，计算后续</h3><p>[例如]<br>前序遍历: GDAFEMHZ<br>中序遍历: ADEFGHMZ</p>
<p>[思路]<br>两个步骤</p>
<ul>
<li>根据前序中序，构造二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InPre2Post</span><span class="params">(<span class="built_in">string</span> InOrder, <span class="built_in">string</span> PreOrder)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> n1 = InOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n2 = PreOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> helper(InOrder, <span class="number">0</span>, n1 - <span class="number">1</span>, PreOrder, <span class="number">0</span>, n2 - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; InOrder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; PreOrder, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        res.push_back(InOrder[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">while</span>(InOrder[k] != PreOrder[p])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(InOrder, i, k<span class="number">-1</span>, PreOrder, p+<span class="number">1</span>, p+k-i, res);</span><br><span class="line">    helper(InOrder, k+<span class="number">1</span>, j, PreOrder, p+<span class="number">1</span>+k-i, q, res);</span><br><span class="line">    res.push_back(PreOrder[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据后续和中序，计算前序"><a href="#根据后续和中序，计算前序" class="headerlink" title="根据后续和中序，计算前序"></a>根据后续和中序，计算前序</h3><p>思路跟上面的 InPre2Post 基本一模一样。只不过：</p>
<ul>
<li>一个是 InOrder 的第一个元素作为根节点，</li>
<li>一个是 PostOrder 的末尾元素作为根节点。</li>
</ul>
<h3 id="前序遍历是否合法-leetcode-331"><a href="#前序遍历是否合法-leetcode-331" class="headerlink" title="前序遍历是否合法 leetcode 331"></a>前序遍历是否合法 leetcode 331</h3><p>[题目]</p>
<p>[分析]</p>
<ul>
<li>如何还原这个树？</li>
<li>建立每个节点<ul>
<li>顺着树往“左”走</li>
<li>遇到叶子(#)就回退，往右走</li>
</ul>
</li>
<li>维护每个节点的孩子</li>
<li>更巧的方法<ul>
<li>不需要知道“父子关系”</li>
<li>当前节点插入空位</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> space = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[i] == <span class="string">','</span>) preorder[i] = <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--space &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="string">"#"</span>)&#123;</span><br><span class="line">                space += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (space == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的写法有问题，一定要先减去一，再考虑是否要加上2</span></span><br><span class="line">    <span class="comment">/*bool isValidSerialization(string preorder) &#123;</span></span><br><span class="line"><span class="comment">        int space = 1;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 0) return true;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 1) return (preorder[0] == '#');</span></span><br><span class="line"><span class="comment">        if(preorder[0] == '#') return false;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; preorder.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">            if(preorder[i] == ',') preorder[i] = ' ';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        stringstream s(preorder);</span></span><br><span class="line"><span class="comment">        string temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        while(s &gt;&gt; temp)&#123;</span></span><br><span class="line"><span class="comment">            if(temp == "#")&#123;</span></span><br><span class="line"><span class="comment">                space--;</span></span><br><span class="line"><span class="comment">                if(space &lt; 0) return false;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                space++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; space;</span></span><br><span class="line"><span class="comment">        return (space == 0);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="复杂的树结构"><a href="#复杂的树结构" class="headerlink" title="复杂的树结构"></a>复杂的树结构</h2><ul>
<li>AVL 树：最早的平衡二叉树之一。应用相对其他数据结构比较少。Windows 对进程地址空间的管理使用到了 AVL 树。</li>
<li>红黑树：平衡二叉树，广泛用在 C++ 的 STL 中。如 map 和 set 都是用红黑树实现的。</li>
<li>B/B+ 树：用在磁盘文件组织，数据索引，和数据库索引。</li>
<li>Trie树（字典树）：用在统计和排序大量字符串，如自动机。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ol>
<li>Trie 树是一种哈希多叉树，又称字典树、单词查找树、或者前缀树，用于在大量字符串中快速检索。<ol>
<li>英文字母的字典树是一个 26 叉树。</li>
<li>数字的字典树是一个 10 叉树。</li>
</ol>
</li>
<li>典型应用<ol>
<li>统计和排序大量的字符串（但不仅限于字符串），经常被文字处理系统用于文本词频统计。</li>
<li>优点：利用字符串的公共前缀来节约存储空间，最大限度地减少无畏的字符串比较，查询效率比哈希表高。</li>
<li>缺点：如果存在大量字符串且这些字符串基本没有公共前缀，则相应的 Trie 树将非常消耗内存。</li>
</ol>
</li>
<li>基本性质<ol>
<li>根节点不包含字符。除根节点以外每一个节点都只包含一个字符。每个节点有 26 个指针指向子节点，同时自身还有个 bool 变量用来记录当前位置是否可以作为一个字符串的结束位置！</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该根节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
</li>
</ol>
<p>[题目]<br>给定一棵边的权值都是正整数的数，求某两个节点间的路径，使得该路径所包含的所有边权的异或值最大。</p>
<p>[例子]<br>中心点 B 有三个无向边指向 A, C, D，权值分别为 3, 4, 6<br>那么最优的答案就是路径 A-B-D，结果就是 3^4 = 7</p>
<p>[思路]</p>
<ol>
<li>思路一：朴素解法<ol>
<li>枚举所有节点对，求得所有路径异或权。时间复杂度O(n^2).</li>
</ol>
</li>
<li>思路二：<ol>
<li>问题分析<ol>
<li>异或的性质: a^b = (a^c)^(b^c)</li>
<li>因此可以选择一个点作为根节点建立一个数。然后任意两个节点之间的路径的权重的异或值，等于两个节点分别到跟节点的路径的权重异或值，这两个结果再异或一下就可以了。</li>
<li>从根节点到每个节点的异或值可以通过一次深度优先搜索解决，时间复杂度 O(n)</li>
<li><mark>问题转化为求 n 个数中异或值最大的两个数字。</mark></li>
</ol>
</li>
<li>利用 Trie 树的解法<ol>
<li>将数字看成二进制的 0/1 串，先将所有数字从最高位起放入一个二叉 Trie 数中 (这里如果数字的长度不一样，可以使用最大的数字的有效长度，比如最大的数字是 100，那么用 7 个 bit 位就可以表示了。其他的数字也都用 7 个 bit 位表示，不到的话左边补 0)</li>
<li>枚举每个数字 a，从最高位开始，寻找尽量与 a 对应位不同的数字；时间复杂度 O(len)</li>
<li>总体时间复杂度 O(N * len)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png" alt=""></p>
<p>[总结]</p>
<ol>
<li>Trie 树逻辑结构清晰简练，在海量数据中查找某数据，和海量数据规模无关，只和待查找数据长度本身有关，时间复杂度为 O(len)，常认为是 O(1)。<ol>
<li>可以看做是以数据元素为关键字的多 Hash 结构</li>
<li>海量数据的复杂度分析未考虑内存调度问题。</li>
</ol>
</li>
<li>双数组的存储结构比较难，增删困难。实践中，往往离线将海量数据建立 Trie 树双数组结构，少量删除时可以继续使用。若大量删除，则离线建立新的 Trie 树双数组结构，适时替换。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="0117 Populating Next Right Pointers in Each Node II"></a>0117 Populating Next Right Pointers in Each Node II</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一题实际上就是 level order traversal</span></span><br><span class="line"><span class="comment">使用 queue 就很好做了</span></span><br><span class="line"><span class="comment">但是 queue 的空间复杂度是 O(n)</span></span><br><span class="line"><span class="comment">而题目要求是 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决的关键就在于 每一个 node 里都有一个 next pointer</span></span><br><span class="line"><span class="comment">它的存在使得我们没有必要用queue 记录一层所有的 nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法关键：</span></span><br><span class="line"><span class="comment">    在扫描当前level的节点的 children nodes 时候</span></span><br><span class="line"><span class="comment">    更新这些 children nodes 的 next 指针</span></span><br><span class="line"><span class="comment">    这样子，在扫描下一个 level的时候，</span></span><br><span class="line"><span class="comment">    就可以使用这些 next pointer 了！！！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">二刷关键：</span></span><br><span class="line"><span class="comment">    引入一个 dummy node 可以使得代码更简洁！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode *cur; <span class="comment">// cur 指针扫描下一层 的节点;</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;                          <span class="comment">// root 指针用于扫描当前 level</span></span><br><span class="line">            cur = dummy;                        <span class="comment">// cur 指针扫描下一层 的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root) &#123;                       <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;left;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;right;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            root = dummy-&gt;next;                <span class="comment">// root 指针跳到下一层的 dummy 后面第一个有效节点</span></span><br><span class="line">            dummy-&gt;next = <span class="literal">nullptr</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 一刷的代码，不够简洁</span></span><br><span class="line"><span class="comment">    void connect(TreeLinkNode *root) &#123;</span></span><br><span class="line"><span class="comment">        TreeLinkNode *cur = root;         //current node of current level</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while (cur) &#123;</span></span><br><span class="line"><span class="comment">            TreeLinkNode *head = NULL;   // head of the next level</span></span><br><span class="line"><span class="comment">            TreeLinkNode *prev = NULL;   //the leading node on the next level</span></span><br><span class="line"><span class="comment">            while(cur) &#123;       //iterate on the current level</span></span><br><span class="line"><span class="comment">                if (cur-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev  = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                if (cur-&gt;right) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //move to next node           </span></span><br><span class="line"><span class="comment">                cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //move to next level</span></span><br><span class="line"><span class="comment">            cur = head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Find-k-th-smallest-number-of-binary-search-tree"><a href="#Find-k-th-smallest-number-of-binary-search-tree" class="headerlink" title="Find k-th smallest number of binary search tree"></a>Find k-th smallest number of binary search tree</h2><p>==适用于binary search tree 的递归的方法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements;</span><br><span class="line">        recurse(root, elements, k);</span><br><span class="line">        <span class="keyword">return</span> elements[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; elements, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(elements.<span class="built_in">size</span>() == k) <span class="keyword">return</span>;        <span class="comment">// 技巧，提前停止</span></span><br><span class="line">        recurse(root-&gt;left, elements, k);</span><br><span class="line">        elements.push_back(root-&gt;val);</span><br><span class="line">        recurse(root-&gt;right, elements, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==适用于BST的非递归，使用stack的方法！！！（这个非常棒！！！）==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = mystack.top();</span><br><span class="line">                mystack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE BEGIN</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE END</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                </span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>==适用于任何的二叉树(binary tree, not necessarily BST)：先输出所有点(iterative 或 recursive)到array，然后找第 k 个==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 iterative 的方法，输出所有点到 array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    dq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">        TreeNode* temp = dq.front();</span><br><span class="line">        myvec.push_back(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left) dq.push_back(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right) dq.push_back(temp-&gt;right);</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 recursive 的方法，输出所有点到array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    helper(root, myvec);</span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.push_back(root-&gt;<span class="keyword">int</span>);</span><br><span class="line">    helper(root-&gt;left, vec);</span><br><span class="line">    helper(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Common-Ancester-总结"><a href="#Common-Ancester-总结" class="headerlink" title="Common Ancester 总结"></a>Common Ancester 总结</h2><p>注意</p>
<ol>
<li>这些题目的有些解法对问题的定义实际上是做了修改的！但是却巧妙地得到了正确答案。</li>
<li>注意经常犯的把问题复杂化的一个习惯是分别对如下情况考虑<ol>
<li>root 的左右子树分别含有 p 和 q</li>
<li>p 是 root, 子节点立面有 q</li>
<li>q 为根的子树里面有 p</li>
</ol>
</li>
</ol>
<h3 id="leetcode-0235"><a href="#leetcode-0235" class="headerlink" title="leetcode 0235"></a>leetcode 0235</h3><p>[题目]</p>
<ol>
<li>p 和 q 节点不相同，且一定存在！</li>
<li>BST 节点里的数值互不相同。</li>
</ol>
<p>[思路]</p>
<ol>
<li>[不好的思路]<ol>
<li>如上所述，对几种情况分别考虑，代码很长，时间也不低。</li>
</ol>
</li>
<li>好的思路，充分利用 BST 树的性质来做。<ol>
<li>其 LCA 节点的值一定在给定的两个节点的值中间。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; maxVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; minVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterative 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; maxVal)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; minVal)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;    <span class="comment">// 这一句不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-0236"><a href="#leetcode-0236" class="headerlink" title="leetcode 0236"></a>leetcode 0236</h3><p>[题目]</p>
<ol>
<li>本题的变化是树不再是 BST 了</li>
<li>同样的，仍然有<ol>
<li>所有节点的值都不相同</li>
<li>p 和 q 不同，且一定存在</li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ol>
<li>递归解法一个核心的思想是: <mark>我们找到一个节点 p 后，就不需要再递归找另一个 q 了，直接返回这个 p 就行！因为如果节点 q 在下面的话，那么二者的 LCA 一定是 p</mark>.</li>
<li>在这个前提条件下，我们的判断条件是，左子树上找到了一个点，右子树上找到了一个点，那么当前 root 就是 LCA.</li>
<li>为啥说这个解法对题目做了修改呢，因为我们没有去直接找两个点，而是找到一个就返回了！但是判断条件决定了我们可以找到正确的答案。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncester</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lintcode-578"><a href="#lintcode-578" class="headerlink" title="lintcode 578"></a>lintcode 578</h3><p>[题目]</p>
<ol>
<li>主要区别是两个节点有可能不在这个树上！！</li>
</ol>
<p>[思路一]</p>
<ol>
<li>可以先遍历一遍看看两个节点是否在树上啊！！！</li>
<li>然后就可以使用上面的代码了哎！</li>
</ol>
<p>[思路一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasNode</span><span class="params">(TreeNode* root, TreeNode* p, <span class="keyword">bool</span>&amp; flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hasNode(root-&gt;left, p, flag);</span><br><span class="line">    hasNode(root-&gt;right, p, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasP = <span class="literal">false</span>, hasQ = <span class="literal">false</span>;</span><br><span class="line">    hasNode(root, p, hasP);</span><br><span class="line">    hasNode(root, q, hasQ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个节点至少有一个不存在</span></span><br><span class="line">    <span class="keyword">if</span>( !hasP || !hasQ ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明两个节点一定存在了</span></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestorHelper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncestorHelper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestorHelper(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：</p>
<ol>
<li>我这个代码算是一个非常好的代码！时间复杂度不高，空间复杂度 leetcode 上显示，小于百分百提交的代码！</li>
<li>我这个代码看似是遍历了三遍树，实际上每次都没有遍历完！<ol>
<li>我定义的辅助函数 hasNode 在找到节点后就停止递归了！网上有不好的实现方法是递归同时找两个节点！这样子你找到一个后不可以停止，导致必须遍历完全部的树节点才可以！</li>
<li>由于知道两个节点后才调用 lowestCommonAncestorHelper，这个函数找到一个节点后也会停止递归！</li>
<li>空间复杂度这么好是因为没有递归遍历所有的节点，导致使用的 stack memory 较少所致！</li>
</ol>
</li>
</ol>
<p>[思路二]</p>
<ol>
<li>因为可能有无效的节点，所以上面的那个解法就不 work 了，我们需要真得去找到 p 和 q 才行！</li>
</ol>
<p>[思路二代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> a_exist, b_exist;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    ResultType(<span class="keyword">bool</span> a, <span class="keyword">bool</span> b, TreeNode* n) &#123;</span><br><span class="line">        a_exist = a;</span><br><span class="line">        b_exist = b;</span><br><span class="line">        node = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ResultType rt = helper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rt.a_exist &amp;&amp; rt.b_exist)</span><br><span class="line">            <span class="keyword">return</span> rt.node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ResultType <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root 不存在，则 p, q 一定不在树里面。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ResultType(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        ResultType left_rt = helper(root-&gt;left, p, q);</span><br><span class="line">        ResultType right_rt = helper(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> a_exist = left_rt.a_exist || right_rt.a_exist || root == p;</span><br><span class="line">        <span class="keyword">bool</span> b_exist = left_rt.b_exist || right_rt.b_exist || root == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四种情况</span></span><br><span class="line">        <span class="comment">// 一：p, q 至少有一个等于 root</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二：</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span> &amp;&amp; right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 三：p, q 同属 root 的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, left_rt.node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四：p, q 同属 root 的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, right_rt.node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultType(a_exist, b_exist, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="节点含有父节点指针"><a href="#节点含有父节点指针" class="headerlink" title="节点含有父节点指针"></a>节点含有父节点指针</h3><p>[思路]</p>
<ol>
<li>面试中，面试者一般不直接告诉你树的节点是否含有父节点的指针，能否自定义树的 node，因此需要主动询问。</li>
<li>如果有指向父节点的指针的话，这道题就类似于 Y 链表那道题目。<ol>
<li>先分别求出 p 和 q 到 root 的距离，假定 p 到 root 距离是 q 到 root 距离多 N steps.<ol>
<li>当然如果 p 和 q 可能不属于同一棵树的话</li>
<li>这里可以判断两个 root 是否相等，如果不相等说明 p 和 q 来自不同的树！</li>
</ol>
</li>
<li>让 p 向上走 N steps</li>
<li>p 和 q 同时向上走，直到相遇！</li>
</ol>
</li>
</ol>
<h2 id="complete-tree-完全二叉树"><a href="#complete-tree-完全二叉树" class="headerlink" title="complete tree 完全二叉树"></a>complete tree 完全二叉树</h2><p>这里讨论两道题，比较类似</p>
<h3 id="Count-Complete-Tree-Nodes-lc0222"><a href="#Count-Complete-Tree-Nodes-lc0222" class="headerlink" title="Count Complete Tree Nodes lc0222"></a>Count Complete Tree Nodes lc0222</h3><p>[题目]</p>
<ol>
<li>Given a complete binary tree, count the number of nodes.</li>
</ol>
<p>[分析]</p>
<ol>
<li>肯定不能用 layer by layer traversal</li>
<li>要充分考虑到完全二叉树的性质</li>
</ol>
<p>[思路一]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归的思想</span></span><br><span class="line"><span class="comment">对于一个完全complete的 tree，node总数是 2^h - 1, where h is number of layers</span></span><br><span class="line"><span class="comment">判断条件也很简单，一直往左下走和一直往右下走的距离一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果不是完全complete 的tree，</span></span><br><span class="line"><span class="comment">则递归观察其子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, rc = <span class="number">0</span>;               <span class="comment">// 根节点到最左边节点的总层数</span></span><br><span class="line">        <span class="keyword">while</span>(temp) &#123; lc++; temp = temp-&gt;left;&#125;</span><br><span class="line">        temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp) &#123; rc++; temp = temp-&gt;right;&#125;</span><br><span class="line">        <span class="keyword">if</span>(lc == rc) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, lc) - <span class="number">1</span>;                  <span class="comment">// 此处不要用 pow(2, lc) - 1，会慢很多！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[思路二]</p>
<ol>
<li>其实可以直接看右子树的最左边的节点是否存在，如果存在，那么左子树肯定是满的</li>
<li>只需要计算右边的就可以了！</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">            h++;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root, h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(h == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(h == <span class="number">2</span>) <span class="keyword">return</span> root-&gt;right ? <span class="number">3</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// h is at least 3</span></span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        temp = temp-&gt;right;</span><br><span class="line">        <span class="keyword">int</span> h2 = h<span class="number">-2</span>;        <span class="comment">// 往左下继续移动这么多次，检查是不是 nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(h2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">            h2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, h<span class="number">-1</span>) + helper(root-&gt;right, h<span class="number">-1</span>);    <span class="comment">// temp 存在说明 root 左子树是满的！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, h<span class="number">-1</span>) + <span class="built_in">pow</span>(<span class="number">2</span>, h<span class="number">-2</span>);    <span class="comment">// temp 不存在说明 root 右子树是满的！只不过其高度只有 h - 2</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树最后一层的最右节点"><a href="#完全二叉树最后一层的最右节点" class="headerlink" title="完全二叉树最后一层的最右节点"></a>完全二叉树最后一层的最右节点</h3><p>[tag]</p>
<ul>
<li>剑指 offer, </li>
</ul>
<p>[思路]</p>
<ol>
<li>层次遍历，用一个last变量记录每次出队列的值，遍历结束之后last变量记录的就是所求节点。时间、空间复杂度都是O(N)。</li>
<li>递归，求子树的高度<ol>
<li>如果当前根节点为叶子节点，则返回；</li>
<li>如果左子树高度&gt;右子树高度，则在左子树继续递归过程；</li>
<li>否则在右子树继续递归。</li>
<li>由于是完全二叉树，求高度时只需一直往左遍历即可。每次递归都下降一层，每次都求树的高度，时间复杂度为O(lgN * lgN)。</li>
</ol>
</li>
</ol>
<p>[递归版本代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> * 求子树高度：如果当前根节点为叶子节点，则返回</span></span><br><span class="line"><span class="comment"> * 如果左子树高度&gt;右子树高度，则在左子树递归</span></span><br><span class="line"><span class="comment"> * 否则在右子树递归</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(logN * logN) （求高度 * 遍历层数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getLastNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="number">0</span>;     <span class="comment">// 左子树高度</span></span><br><span class="line">        TreeNode *node = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">            ++ leftHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="number">0</span>;    <span class="comment">// 右子树高度</span></span><br><span class="line">        node = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(node)&#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">            ++ rightHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftHeight &gt; rightHeight)</span><br><span class="line">            <span class="keyword">return</span> getLastNode(root-&gt;left);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getLastNode(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[迭代版本代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 迭代</span></span><br><span class="line"><span class="comment"> * O(log N * log N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionI</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getLastNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">0</span>;     <span class="comment">// 树高度</span></span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">            ++ <span class="built_in">height</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *last = root;  <span class="comment">// 当前比较的左子树和右子树的根节点</span></span><br><span class="line">        <span class="keyword">while</span> (last-&gt;left != <span class="literal">nullptr</span>)&#123;  <span class="comment">// 指向叶子节点时退出</span></span><br><span class="line">            <span class="keyword">int</span> lh = --<span class="built_in">height</span>;</span><br><span class="line">            <span class="keyword">int</span> rh = <span class="number">0</span>;</span><br><span class="line">            node = last-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (node)&#123;</span><br><span class="line">                ++ rh;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lh &gt; rh)</span><br><span class="line">                last = last-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = last-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树是最重要的数据结构，没有之一！</li>
<li>从根节点到叶子的过程，是逐渐细化精确的过程，所以，实践中往往作为海量数据索引。</li>
<li>数只是数据结构，非存储结构。实践中，可以使用数组来存储树。<ul>
<li>思考实例 Huffman 编码、堆排序、并查集等。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/leetcode-linked-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/leetcode-linked-list/" itemprop="url">leetcode linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T03:16:04+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/leetcode-linked-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/leetcode-linked-list/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目总体分析"><a href="#题目总体分析" class="headerlink" title="题目总体分析"></a>题目总体分析</h1><p>哎感觉链表的题目基本上都是考你指针操作的细节的。。。<br>算法上都没有特别难的。。</p>
<h1 id="C-相关操作语法"><a href="#C-相关操作语法" class="headerlink" title="C++ 相关操作语法"></a>C++ 相关操作语法</h1><p>TODO</p>
<h1 id="Python-相关操作语法"><a href="#Python-相关操作语法" class="headerlink" title="Python 相关操作语法"></a>Python 相关操作语法</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="翻转单链表"><a href="#翻转单链表" class="headerlink" title="翻转单链表"></a>翻转单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头开始翻</span></span><br><span class="line">ListNode *result = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line">    temp = head-&gt;next;</span><br><span class="line">    head-&gt;next = result;</span><br><span class="line">    result = head;</span><br><span class="line">    head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### TODO 思考：翻转部分链表 leetcode <span class="number">92</span></span><br><span class="line">- 如何找到第 m 个元素和第 n 个元素</span><br><span class="line">- 如何处理前面和后面</span><br><span class="line">    - 保存前面部分最后一个元素</span><br><span class="line">    - 保存后面部分第一个元素</span><br><span class="line">    - 特殊情况？</span><br><span class="line"></span><br><span class="line">### TODO 思考： 每 k 个元素翻转一次 leetcode <span class="number">25</span></span><br><span class="line">- 前面翻好的部分（小链表）</span><br><span class="line">- 要翻转的部分（K 个）</span><br><span class="line">- 后面没处理的部分（小链表）</span><br><span class="line">- 不足 k 个怎么办？</span><br><span class="line"></span><br><span class="line">## 单链表含有环 leetcode <span class="number">0141</span>, <span class="number">0142</span></span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line">- 假设链表起点到圈起点距离是 a，相遇点到圈起点距离是 b</span><br><span class="line">- 那么有</span><br><span class="line">    - slow pointer 走了 a + b</span><br><span class="line">    - fast pointer 走了 a + b + k * n == <span class="number">2</span> * (a+b)</span><br><span class="line">    - 从而 a + b = k * n</span><br><span class="line">- 如何找圈的起点</span><br><span class="line">    - 相遇后，把 slow pointer 拉回链表起点，fast pointer 从相遇点继续走。</span><br><span class="line">    - 注意这个时候两个指针都一步一步的走</span><br><span class="line">    - 这个时候二者会在圈起点相遇！！！</span><br><span class="line">- 如何找圈长</span><br><span class="line">    - 相遇后，slow pointer 再走一圈并统计长度就是圈长。</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head)&#123;</span><br><span class="line">        ListNode *p1 = head, *p2 = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((!p2) || (p2-&gt;next == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span>(p1 != p2);</span><br><span class="line">        <span class="keyword">for</span>(p1 = head; p1 != p2; p1 = p1-&gt;next, p2 = p2-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个单链表是否相交-leetcode-160"><a href="#两个单链表是否相交-leetcode-160" class="headerlink" title="两个单链表是否相交 leetcode 160"></a>两个单链表是否相交 leetcode 160</h2><p>就是检测是否是 Y 型结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tempA = headA, *tempB = headB;</span><br><span class="line">        <span class="keyword">int</span> lenA, lenB;</span><br><span class="line">        <span class="keyword">for</span>(lenA = <span class="number">0</span>; tempA; tempA = tempA-&gt;next) lenA++;</span><br><span class="line">        <span class="keyword">for</span>(lenB = <span class="number">0</span>; tempB; tempB = tempB-&gt;next) lenB++;</span><br><span class="line">        tempA = headA;</span><br><span class="line">        tempB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; i++) tempA = tempA-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; i++) tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tempA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempA == tempB) <span class="keyword">return</span> tempA;</span><br><span class="line">            tempA = tempA-&gt;next;</span><br><span class="line">            tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复制带随机指针的链表-leetcode-138"><a href="#复制带随机指针的链表-leetcode-138" class="headerlink" title="复制带随机指针的链表 leetcode 138"></a>复制带随机指针的链表 leetcode 138</h2><p>方法一：使用 map&lt;旧地址，新地址&gt;</p>
<p>方法二：不用 map</p>
<ul>
<li>插入：每个旧节点后面插入一个自身的“复本”</li>
<li>复制 random 指针<ul>
<li>一个旧节点 a 的复本是 a-&gt;next</li>
<li>a-&gt;ranom 的复本是 a-&gt;random-&gt;next</li>
<li>新节点的random 指针 a-&gt;next-&gt;random = a-&gt;random-&gt;next (空值单独判断)</li>
</ul>
</li>
<li>拆分<ul>
<li>旧节点链表是奇数项</li>
<li>新节点链表是偶数项<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(RandomListNode *now = head; now; )&#123;</span><br><span class="line">            RandomListNode *copy = <span class="keyword">new</span> RandomListNode(now-&gt;label);</span><br><span class="line">            copy-&gt;next = now-&gt;next;</span><br><span class="line">            now-&gt;next = copy;</span><br><span class="line">            now = copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(RandomListNode *now = head; now; now = now-&gt;next-&gt;next)&#123;</span><br><span class="line">            now-&gt;next-&gt;<span class="built_in">random</span> = (now-&gt;<span class="built_in">random</span> == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : now-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode *h = head-&gt;next, *t = h, *tail = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            tail = tail-&gt;next = t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!tail)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            t = t-&gt;next = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="链表-partition-leetcode-86"><a href="#链表-partition-leetcode-86" class="headerlink" title="链表 partition leetcode 86"></a>链表 partition leetcode 86</h2><p>链表里存放整数，给定 x 把比 x 小的节点放到比 x 大的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        ListNode *h1 = <span class="literal">nullptr</span>, *t1 = <span class="literal">nullptr</span>, *h2 = <span class="literal">nullptr</span>, *t2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( ; head; head = head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t1)&#123;    <span class="comment">// 需要看一下是不是 nullptr</span></span><br><span class="line">                    t1 = t1-&gt;next = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    h1 = t1 = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2)&#123;</span><br><span class="line">                t2 = t2-&gt;next = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h2 = t2 = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t2) t2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1) t1-&gt;next = h2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h1? h1 : h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>[题目]<br>给定一个链表，返回排序后的结果。</p>
<p>[分析]</p>
<ul>
<li>思路就是 merge sort</li>
<li>但是注意 merge sort 的空间复杂度严格上来说并不是 O(1)，而是 O(logN) 的，</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//divide the list into two parts </span></span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(sortList(head), sortList(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dump</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* cur = &amp;dump;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除重复元素-leetcode-0082"><a href="#删除重复元素-leetcode-0082" class="headerlink" title="删除重复元素 leetcode 0082"></a>删除重复元素 leetcode 0082</h2><p>[题目]<br>删除出现两次或以上的元素，只保留只出现过一次的元素。</p>
<p>[代码]<br>使用辅助函数真的方便了很多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        head = nextSingleElementPointer(head);</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* head2 = nextSingleElementPointer(head-&gt;next);</span><br><span class="line">        <span class="keyword">while</span>(head2)&#123;</span><br><span class="line">            cur-&gt;next = head2;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            head2 = nextSingleElementPointer(cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">nextSingleElementPointer</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;    <span class="comment">// if has duplicate</span></span><br><span class="line">            <span class="keyword">int</span> temp = head-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == temp)                           <span class="comment">// , then skip all the current values</span></span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LRU-cache"><a href="#LRU-cache" class="headerlink" title="LRU cache"></a>LRU cache</h2><p>[题目]<br>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a positive capacity.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<p>[例子]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure>

<p>[分析]</p>
<ol>
<li>要实现 O(1) 的时间复杂度，核心就是使用 list</li>
<li>这里使用 stl list 库极大地减少了代码量！</li>
</ol>
<p>[代码如下]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : <span class="built_in">size</span>(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kv.count(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        updateLRU(key);</span><br><span class="line">        <span class="keyword">return</span> kv[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kv.<span class="built_in">size</span>() == <span class="built_in">size</span> &amp;&amp; kv.count(key) == <span class="number">0</span>)</span><br><span class="line">            evict();</span><br><span class="line">        updateLRU(key);</span><br><span class="line">        kv[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateLRU</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kv.count(key)) </span><br><span class="line">            lru.erase(mp[key]);</span><br><span class="line">        lru.push_front(key);</span><br><span class="line">        mp[key] = lru.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mp.erase(lru.back());</span><br><span class="line">        kv.erase(lru.back());</span><br><span class="line">        lru.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lru;                              <span class="comment">// MRU ... LRU</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; mp; <span class="comment">// key -&gt; iterator</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv;                 <span class="comment">// key -&gt; value</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/leetcode-stack-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/08/leetcode-stack-queue/" itemprop="url">leetcode stack queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-08T09:23:44+08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/leetcode-stack-queue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/08/leetcode-stack-queue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><p>TODO</p>
<h1 id="C-相关语法操作"><a href="#C-相关语法操作" class="headerlink" title="C++ 相关语法操作"></a>C++ 相关语法操作</h1><p>TODO</p>
<p>用自定义 greater 决定最大堆，最小堆。</p>
<h1 id="python-相关语法操作"><a href="#python-相关语法操作" class="headerlink" title="python 相关语法操作"></a>python 相关语法操作</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="用两个队列实现一个栈"><a href="#用两个队列实现一个栈" class="headerlink" title="用两个队列实现一个栈"></a>用两个队列实现一个栈</h2><p>思路：用两个队列来回倒，保证一个队列是空的。<br>用空队列临时存储除队尾外所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入栈：维护一个队列是空的。时间复杂度: O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) q1.push(x)</span><br><span class="line">    <span class="keyword">else</span> q2.push(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">出栈：用一个队列临时存放元素。时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pop():</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(q1.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类似操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用两个堆栈实现一个队列"><a href="#用两个堆栈实现一个队列" class="headerlink" title="用两个堆栈实现一个队列"></a>用两个堆栈实现一个队列</h2><p>思路：使用两个堆栈。s1 负责 push, s2 负责 pop.<br>注意这个跟上一个题目不一样，因为不是每次 pop 都需要重新翻一次数据。<br>如果负责 pop 的 s2 里面还有数据的话，可以直接 pop.<br>这样子最终的 amotized complexity is O(1).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push(x): <span class="comment">//O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// 均摊O(1) 每个元素出入两个栈各一次。</span></span><br><span class="line">    <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();</span><br></pre></td></tr></table></figure>

<h2 id="支持查找最小值的栈"><a href="#支持查找最小值的栈" class="headerlink" title="支持查找最小值的栈"></a>支持查找最小值的栈</h2><p>题目：一个堆栈除了支持 push, pop 外还要支持一个操作: getMin 得到当前堆栈里所有元素的最小值。</p>
<p>思路一：用两个堆栈，s1 正常使用，s2 在 getMin 的时候使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：用两个堆栈，s1 维护原来的值，s2 维护最小值，他们元素个数一样多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):  <span class="comment">// O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line">    <span class="keyword">if</span>(!s2.empty() &amp;&amp; s2.top() &lt; x) s2.push(s2.top())</span><br><span class="line">    <span class="keyword">else</span> s2.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// O(1)</span></span><br><span class="line">    s1.pop()</span><br><span class="line">    s2.pop()</span><br><span class="line"></span><br><span class="line">getMin:  <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> s2.top()</span><br></pre></td></tr></table></figure>

<h3 id="变型：维护最小值的-queue"><a href="#变型：维护最小值的-queue" class="headerlink" title="变型：维护最小值的 queue"></a>变型：维护最小值的 queue</h3><p>==维护队列单调性！！！==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用两个双端队里，记录最大值的双端队列保持单调递减性，记录最小值的双端队列保持单调递增性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minque;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxque;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.push(val);</span><br><span class="line">    <span class="keyword">while</span> ((!minque.empty()) &amp;&amp; (minque.back() &gt; val))</span><br><span class="line">        minque.pop_back();</span><br><span class="line">    minque.push_back(val);</span><br><span class="line">    <span class="keyword">while</span> ((!maxque.empty()) &amp;&amp; (maxque.back() &lt; val))</span><br><span class="line">        maxque.pop_back();</span><br><span class="line">    maxque.push_back(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">if</span> (minque.front() == value)</span><br><span class="line">        minque.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (maxque.front() == value)</span><br><span class="line">        maxque.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minque.front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxque.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直方图中最大面积矩形-leetcode-84"><a href="#直方图中最大面积矩形-leetcode-84" class="headerlink" title="直方图中最大面积矩形 leetcode 84"></a>直方图中最大面积矩形 leetcode 84</h2><p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想还是维持一个单调的栈。</span></span><br><span class="line"><span class="comment">这里栈内元素大小是递增的。一旦来了一个小的元素，那么会把栈顶比此元素大的一个一个 pop 出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">height</span>.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>(), area = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexes.empty() &amp;&amp; <span class="built_in">height</span>[indexes.top()] &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">height</span>[indexes.top()];   <span class="comment">// 以当前栈顶值为高度的矩形，此时右边界已经确定，就是刚扫描到的 height[i]。</span></span><br><span class="line">                indexes.pop();    <span class="comment">// 而左边界就是栈里下面压着的那一个 index. 因为下面压着的 index 那个高度小于它。</span></span><br><span class="line">                <span class="keyword">int</span> l = indexes.empty() ? <span class="number">-1</span> : indexes.top();  </span><br><span class="line">                area = <span class="built_in">max</span>(area, h * (i - l - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            indexes.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="sliding-window-maximum"><a href="#sliding-window-maximum" class="headerlink" title="sliding window maximum"></a>sliding window maximum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque 只需要保存 k 个内容就可以，这里是保存 index，</span></span><br><span class="line"><span class="comment">此处关键是 dq 保存所有的 k 个 index 吗？</span></span><br><span class="line"><span class="comment">显然不是，它只会保存有用的信息。</span></span><br><span class="line"><span class="comment">什么才是有用的信息？是那些有可能成为 maximum 的点。</span></span><br><span class="line"><span class="comment">这里的操作和之前 0456 - 132 Pattern 解法中的操作类似。</span></span><br><span class="line"><span class="comment">在考虑 num[i] 的时候，把 num[i] 跟 dequeue 的最后一个值(实际是index对应位置的值)比较</span></span><br><span class="line"><span class="comment">如果小于 nums[i]，那么就 pop_back()，直到遇到比 nums[i] 大的</span></span><br><span class="line"><span class="comment">这个操作保证了 dequeue 中的数值一定是递减数列</span></span><br><span class="line"><span class="comment">此时 de.front() 对应的值就是位置 i(含) 之前 k 个值中最大的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">dq 中保存的是 index，所以第8行和第10行用 nums[dq.back()], nums[dq.front()].</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">心得体会</span></span><br><span class="line"><span class="comment">我发现这个用 stack(0456) 或者queue存储 maximum/minimum 的技巧，</span></span><br><span class="line"><span class="comment">对于比较大小或者 max/min 的题目很有效啊。</span></span><br><span class="line"><span class="comment">主要就是 stack/queue 的“两端”是对应的是 current maximum/minimum</span></span><br><span class="line"><span class="comment">可以用O(1)直接找到并作比较。</span></span><br><span class="line"><span class="comment">如果直接在一个范围内找 max 作比较，那就需要 O(n) 去找了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">答案里分析 time complexity 的时候都提到了 amotized O(n)，</span></span><br><span class="line"><span class="comment">这个是因为 for loop 里面那个 while 的次数是变得，可能为 O(1) ，也可能为 O(n).</span></span><br><span class="line"><span class="comment">换个角度，每个元素最多被添加一次pop一次，因此算法复杂度是 amotized O(n).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/leetcode-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/05/leetcode-%E6%95%B0%E7%BB%84/" itemprop="url">leetcode 数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-05T13:39:38+08:00">
                2019-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/05/leetcode-%E6%95%B0%E7%BB%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/05/leetcode-数组/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><pre><code>查找和排序
    二分查找: 貌似都可以使用或者不使用递归！
    元素交换
    排序，中位数
    归并
    位运算
    前缀和的应用
动态规划
排列组合</code></pre><h1 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h1><h1 id="python-list"><a href="#python-list" class="headerlink" title="python list"></a>python list</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse()</span></span><br><span class="line"><span class="comment"># list_a[::-1]    # 二者都可以让列表反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list_a.sort()    # 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于字典，字符串等数据结构，必须用 sorted 函数</span></span><br><span class="line"><span class="comment"># sorted(iterable[, cmp[, key[, reverse]]])</span></span><br><span class="line">dict_a = &#123;<span class="string">'a'</span> : <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line">sorted(dict_a, key = <span class="keyword">lambda</span> d: d[<span class="number">0</span>])    <span class="comment"># 按照 key 排序，换成 d[1] 就按照 value 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 1D list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1d = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2d = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>


<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="局部极小值-leetcode-162"><a href="#局部极小值-leetcode-162" class="headerlink" title="局部极小值 leetcode 162"></a>局部极小值 leetcode 162</h2><p>一个给定的不包含相同元素的整数数组，每个局部极小值的定义是一个值比左右相邻的（如果存在）都小的值。求它的一个局部极小值。</p>
<pre><code>分析：首先要问清楚边界条件如何处理，在这里假定边界条件是比它大的。

这里规定用数组下标 a[1, ..., n]表示那 n 个整数，定义 a[0] = a[n+1] = 无穷大。

递归的思路是，如果子数组 a[p, q] 满足条件 a[p] &lt; a[p-1], a[q] &lt; a[q+1]，则它包含一个局部极小值。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：不使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：使用递归思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[m+<span class="number">1</span>]) <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, m+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数值等于下标的元素"><a href="#数值等于下标的元素" class="headerlink" title="数值等于下标的元素"></a>数值等于下标的元素</h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<p>样例<br>输入：[-3, -1, 1, 3, 5]<br>输出：3</p>
<p>注意:如果不存在，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="循环有序数组查找元素-leetcode-153"><a href="#循环有序数组查找元素-leetcode-153" class="headerlink" title="循环有序数组查找元素 leetcode 153"></a>循环有序数组查找元素 leetcode 153</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1</p>
<p>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：二分法</span></span><br><span class="line"><span class="comment">找中间一个元素，因为数组有 shift，所以中间元素只有两种可能：</span></span><br><span class="line"><span class="comment">要么在左半段，中间元素数值大于两端的数值；</span></span><br><span class="line"><span class="comment">要么在右半段，中间元素数值小于两端的数值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，有个特殊情况就是如果 shift=0，那么只有一个左半段存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == j) <span class="keyword">return</span> <span class="built_in">min</span>(nums[i], nums[j]);</span><br><span class="line">        <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, m, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="循环有序数组查找元素-leetcode-154"><a href="#循环有序数组查找元素-leetcode-154" class="headerlink" title="循环有序数组查找元素 leetcode 154"></a>循环有序数组查找元素 leetcode 154</h2><p>TODO</p>
<h2 id="Search-Insert-Position-lc0035"><a href="#Search-Insert-Position-lc0035" class="headerlink" title="Search Insert Position lc0035"></a>Search Insert Position lc0035</h2><p>【题目】</p>
<ul>
<li>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</li>
<li>You may assume no duplicates in the array.</li>
<li>Example 1:<ul>
<li>Input: [1,3,5,6], 5</li>
<li>Output: 2</li>
</ul>
</li>
<li>Example 2:<ul>
<li>Input: [1,3,5,6], 2</li>
<li>Output: 1</li>
</ul>
</li>
<li>Example 3:<ul>
<li>Input: [1,3,5,6], 7</li>
<li>Output: 4</li>
</ul>
</li>
<li>Example 4:<ul>
<li>Input: [1,3,5,6], 0</li>
<li>Output: 0</li>
</ul>
</li>
</ul>
<p>【分析】</p>
<ul>
<li>这一题本身是个 easy 的题目，但是我写的代码不够简洁，这里摘录几个特别简洁的思路放在这里。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ############ 我的版本  ################################ */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target &lt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[r]) <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">// size equals 1 considered here</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target)&#123;</span><br><span class="line">                l = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; target)&#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// here we have l + 1 == r and nums[l] &lt;= target &lt;= nums[r]</span></span><br><span class="line">        <span class="keyword">if</span>(target == nums[l]) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ############ 不考虑重复元素时候版本  ################################ */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; target) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ############ 我的版本  ################################ */</span></span><br><span class="line"><span class="comment">// If there are duplicate elements equal to target, my code will always return the one with smallest index.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: the desired index is between [low, high+1]</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) At this point, low &gt; high. That is, low &gt;= high+1</span></span><br><span class="line">        <span class="comment">// (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1.</span></span><br><span class="line">        <span class="comment">// (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index</span></span><br><span class="line">        <span class="comment">//     Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>【思路】<br>就是动态规划！注意空间复杂度可以不用建立二维数组，只使用两个一维向量就可以了。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>largest increasing subsequence (LIS)</p>
<p>【思路】</p>
<ul>
<li>方法一：其实这一题可以转换为最长公共子序列的问题<ul>
<li>先对数组进行排序</li>
<li>计算排序后数组和原来数组的最长公共子序列，这个就是最长递增的子序列</li>
<li>复杂度为排序的复杂度 = O(nlogn)</li>
</ul>
</li>
<li>方法二：直接用动态规划<ul>
<li>方法很直接</li>
<li>时间复杂度是 O(n^2)</li>
</ul>
</li>
</ul>
<p>[方法三 贪心的算法]<br>这个方法比较难想出来，也难以表达清楚。这里先给出过程如下。</p>
<p>假设原来的序列是 3 4 5 1 2 3 4</p>
<p>逐个考察这些数</p>
<ul>
<li>考察 3 得到 [3]</li>
<li>考察 4 比 3 大，放到后面，得到 [3, 4]</li>
<li>考察 5 比 4 大，放到后面，得到 [3, 4, 5]</li>
<li>考察 1 比 3 还小，替换掉 3, 得到 [1, 4, 5]</li>
<li>考察 2 比 4 还小，替换掉 4， 得到 [1, 2, 5]</li>
<li>考察 3 比 5 还小，替换掉 5， 得到 [1, 2, 3]</li>
<li>考察 4 比 3 大，放到后面，得到 [1, 2, 3, 4]</li>
<li>最终得到的数组长度为 4，那么就代表最长的递增子序列长度为 4.</li>
</ul>
<p><mark>[上面构造的数组的意义]</mark><br>数组 temp 中第 i 个位置的数组 temp[i] 代表原数组中当前能够找到的，长度为 i 的递增子序列中末尾数子最小的是 temp[i].</p>
<p>比如考虑到上面考察到 2 的时候，得到的 temp 数组是 [1, 2, 5].</p>
<ul>
<li>这个 temp 数组中数字 1 表示长度为 1 的递增子序列中末尾数字最小的是 1</li>
<li>这个 temp 数组中数字 2 表示长度为 2 的递增子序列中末尾数字最小的是 2</li>
<li>这个 temp 数组中数字 5 表示长度为 3 的递增子序列中末尾数字最小的是 5</li>
</ul>
<h2 id="Largest-Divisible-Subset-lc0368"><a href="#Largest-Divisible-Subset-lc0368" class="headerlink" title="Largest Divisible Subset lc0368"></a>Largest Divisible Subset lc0368</h2><p>[题目]</p>
<ul>
<li>给定一些不重复的正整数集合，找出一个子集合满足：<ul>
<li>子集合内的元素两两之间一定可以整除</li>
<li>这个子集合是所有满足第一个条件的子集合中含有元素最多的那个子集合</li>
<li>如果有两个子集合都含有相同的最多的元素，那么只需要返回任意一个就行。</li>
</ul>
</li>
</ul>
<p>[错误的思路]</p>
<ul>
<li>使用生成式的思路去构造一个集合出来</li>
<li>没有什么好的贪心的思想去这么做</li>
<li>如果是全部考虑的话，那么复杂度太大了，是 O(N!)。</li>
</ul>
<p>[正确思路]</p>
<ul>
<li>DP 思想，类似于 LIS</li>
<li>有个思想：<mark>只要新添加的元素可以整除当前某个集合里面最大的那个元素，那么它一定可以整除集合内剩下的所有元素</mark></li>
<li>因此先给元素排序，假设我们知道了第 i 个位置上的元素的最大的集合元素数是 dp[i]</li>
<li>那么只要 <code>nums[j] % nums[i] == 0</code>，我们一定知道 nums[i] 可以整除那个集合里所有元素。</li>
<li>对于任意一个 nums[i]，我们可以遍历它前面的所有元素，找到 <code>dp[j]</code> 最大的那个满足 <code>nums[i] % nums[j] == 0</code> 的 j, 此时有 <code>dp[i] = dp[j] + 1</code>.</li>
</ul>
<p>[代码如下]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prev</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i] % nums[j] == <span class="number">0</span>) &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i]))&#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    prev[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> largest_ind, largest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; largest)&#123;</span><br><span class="line">                largest_ind = i;</span><br><span class="line">                largest = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(largest_ind &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            ans.push_back(nums[largest_ind]);</span><br><span class="line">            largest_ind = prev[largest_ind];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第一个缺失的正整数-leetcode-41"><a href="#第一个缺失的正整数-leetcode-41" class="headerlink" title="第一个缺失的正整数 leetcode 41"></a>第一个缺失的正整数 leetcode 41</h2><p>[题目]<br>给一个数组，找到从 1 开始第一个不在里面的正整数。</p>
<p>[例如]<br>输入：[3, 4, -1, 1]<br>输出：2.</p>
<p><mark>循环不变式</mark></p>
<ul>
<li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则该元素即为所求。</li>
<li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li>
</ul>
<p><mark>利用循环不变式设计算法</mark><br>假定前 i-1 个数已经找到，并且依次存放在 A[1,2,…,i-1]中，继续考察 A[i]:</p>
<ul>
<li>若 A[i]&lt;i 且 A[i]&gt;=1, 则 A[i] 在 A[1,2,…,i-1] 中已经出现过，可以直接丢弃。<ul>
<li>若 A[i] 为负，则更应该丢弃它</li>
</ul>
</li>
<li>若 A[i]&gt;i 且 A[i] &lt;= N, 则 A[i] 应该位于后面的位置上，则将 A[A[i]] 和 A[i] 交换。<ul>
<li>若 A[i]&gt;=N, 由于缺失数据一定小于 N, 则 A[i] 丢弃</li>
</ul>
</li>
<li>若 A[i]=i, 则 A[i] 位于正确的位置上，则 i 加 1，循环不变式扩大，继续比较后面的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：数组下标从 0 开始，</span><br><span class="line">我们得目的是让 a[i] &#x3D;&#x3D; i + 1</span><br><span class="line">每次循环</span><br><span class="line">    1. 要么 i+1</span><br><span class="line">    2. 要么 n-1</span><br><span class="line">    3. 要么有一个数被放到正确的位置</span><br><span class="line"></span><br><span class="line">有一点要记住！一旦一个元素被放到正确的位置以后，那么它的位置就不会改变了！</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt; A, int n)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; )&#123;</span><br><span class="line">            if(A[i] &#x3D;&#x3D; i + 1)&#123;  &#x2F;&#x2F; A[i]刚好位置正确</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; else if ((A[i] &lt;&#x3D; i) || (A[i] &gt; n) || (A[A[i] - 1] &#x3D;&#x3D; A[i]))&#123;  &#x2F;&#x2F; 当前元素可以丢掉了！</span><br><span class="line">                A[i] &#x3D; A[--n];  &#x2F;&#x2F; 快速丢弃 A[i]，就是把最后一个元素移过来，同时长度减去一。</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                swap(A[i], A[A[i] - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素最大间距-leetcode-164-“maximum-Gap”"><a href="#元素最大间距-leetcode-164-“maximum-Gap”" class="headerlink" title="元素最大间距 leetcode 164 “maximum Gap”"></a>元素最大间距 leetcode 164 “maximum Gap”</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:<br>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.</p>
<p>Example 2:<br>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.</p>
<p>Note:<br>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值x, 最小值y，如果 x==y 答案是0.</span></span><br><span class="line"><span class="comment">把数放进 n+1 个桶。</span></span><br><span class="line"><span class="comment">    每个桶大小是 d = (x-y)/(n+1) 浮点数</span></span><br><span class="line"><span class="comment">    每个桶区间是 [y + i*d, y + (i+1) * d) (i=0, 1, 2, ..., n)</span></span><br><span class="line"><span class="comment">        注意是左闭右开的区间，最后一个桶是双闭区间。</span></span><br><span class="line"><span class="comment">        最小的数在 0 号桶里，最大的数在 n 号桶里。</span></span><br><span class="line"><span class="comment">        第一个桶非空，最后一个桶非空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    【鸽笼原理】中间有空桶，空桶左右两侧肯定有元素。</span></span><br><span class="line"><span class="comment">    最大间隙出现在一个非空桶的最大值和下一个非空桶的最小值之间。</span></span><br><span class="line"><span class="comment">    如何判断数 r 出现在哪个桶里</span></span><br><span class="line"><span class="comment">        (r-y)*(n+1)/(x-y) （整数运算，注意 r==x 时候，答案取 n）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">code is from: https://leetcode.com/problems/maximum-gap/discuss/50644/Pigeon-hole-principle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxE = *max_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> minE = *min_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxA</span><span class="params">(n,INT_MIN)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minA</span><span class="params">(n,INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">        maxA[index] = <span class="built_in">max</span>(maxA[index],nums[i]);</span><br><span class="line">        minA[index] = <span class="built_in">min</span>(minA[index],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        gap = <span class="built_in">max</span>(gap,minA[i]-prev);</span><br><span class="line">        prev = maxA[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Top-K-问题的两种解法"><a href="#Top-K-问题的两种解法" class="headerlink" title="Top K 问题的两种解法"></a>Top K 问题的两种解法</h2><p>[题目]</p>
<ol>
<li>输入整数数组 arr，找出其中最小的 k 个数。</li>
<li>例如，输入 [4,5,1,6,2,7,3,8]</li>
<li>输出：4 个最小的数字是 [1,2,3,4]</li>
</ol>
<p>[思路]</p>
<ol>
<li>这是个经典的面试题，也叫做”Top K 问题”。解决这个问题有两种常用的方法：堆方法和分治法。</li>
<li>其中分治法的思想和快速排序相同。</li>
</ol>
<h3 id="堆方法"><a href="#堆方法" class="headerlink" title="堆方法"></a>堆方法</h3><p>这个思路比较简单。</p>
<ol>
<li>就是构建一个最大堆。</li>
<li>然后从左往右扫描数组元素<ol>
<li>如果扫到的元素比堆顶元素小，则加入到堆中。</li>
<li>如果堆含有的元素为 k + 1 个，则把堆顶元素删掉。</li>
</ol>
</li>
<li>复杂度分析<ol>
<li>因为使用了一个大小为 k 的堆，空间复杂度为 O(k)</li>
<li>入堆和出堆操作的时间复杂度都是 O(log k)，每个元素都要进行一次入堆操作，算法整体时间复杂度为 O(n log k).</li>
</ol>
</li>
</ol>
<h3 id="快排变形"><a href="#快排变形" class="headerlink" title="快排变形"></a>快排变形</h3><p>Top K 问题的另一个解法就比较难想到，需要在平时有算法的积累。<br>实际上，“查找第 k 大的元素”是一类算法问题，称为选择问题。<br>找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。<br>这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>让我们回顾快速排序的思路。快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边。</p>
<p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，<mark>快速排序</mark>会递归地排序左右两侧的数组。<br>而<mark>快速选择（quick select）</mark>算法的不同之处在于，接下来只需要递归地选择一侧的数组。<br><mark>快速选择算法想当于一个“不完全”的快速排序</mark>，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p>
<p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，<br>也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ol>
<li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k &lt; m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 partition 即可；</li>
<li>若 k &gt; m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li>
</ol>
<p>[代码如下]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.length &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原地不断划分数组</span></span><br><span class="line">    partitionArray(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次 partition 操作</span></span><br><span class="line">    <span class="keyword">int</span> m = partition(arr, lo, hi);</span><br><span class="line">    <span class="comment">// 此时数组前 m 个数，就是最小的 m 个数</span></span><br><span class="line">    <span class="keyword">if</span> (k == m) &#123;</span><br><span class="line">        <span class="comment">// 正好找到最小的 k(m) 个数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; m) &#123;</span><br><span class="line">        <span class="comment">// 最小的 k 个数一定在前 m 个数中，递归划分</span></span><br><span class="line">        partitionArray(arr, lo, m-<span class="number">1</span>, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在右侧数组中寻找最小的 k-m 个数</span></span><br><span class="line">        partitionArray(arr, m+<span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition 函数和快速排序中相同，具体可参考快速排序相关的资料</span></span><br><span class="line"><span class="comment">// 代码参考 Sedgewick 的《算法4》</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>partitionArray 函数中，两次递归调用传入的参数为什么都是 k？特别是第二个调用，我们在右侧数组中寻找最小的 k-m 个数，但是对于整个数组而言，这是最小的 k 个数。所以说，函数调用传入的参数应该为 k。</li>
<li>算法的复杂度分析<ol>
<li>空间复杂度是 O(1)，不需要额外空间。</li>
<li>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序。期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2).</li>
</ol>
</li>
</ol>
<p>###两种方法比较<br>在面试中，另一个常常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p>
<ol>
<li>第一，<mark>算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li>
<li>第二，算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。</mark></li>
</ol>
<p>所以当数据量大的时候还是用基于堆的方法比较好。</p>
<h2 id="出现一次的数"><a href="#出现一次的数" class="headerlink" title="出现一次的数"></a>出现一次的数</h2><h2 id="出现-3-次的数-leetcode-137"><a href="#出现-3-次的数-leetcode-137" class="headerlink" title="出现 3 次的数 leetcode 137"></a>出现 3 次的数 leetcode 137</h2><p>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,3,2]<br>Output: 3<br>Example 2:</p>
<p>Input: [0,1,0,1,0,1,99]<br>Output: 99</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个思路是最直接，最清晰的！就是把每一个 bit 位分开来看。</span></span><br><span class="line"><span class="comment">把当前 bit 位出现的 1 的总次数除以 3，如果可以整除，</span></span><br><span class="line"><span class="comment">那么最终结果在这个 bit 位上就是 0，如果不能整除，最终结果在这个 bit 位上就是 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To solve this problem using only constant space, you have to rethink how the numbers are being represented in computers -- using bits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you sum the ith bit of all numbers and mod 3, it must be either 0 or 1 due to the constraint of this problem where each number must appear either three times or once. This will be the ith bit of that "single number".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We can improve this based on the previous solution using three bitmask variables:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. ones as a bitmask to represent the ith bit had appeared once.</span></span><br><span class="line"><span class="comment">2. twos as a bitmask to represent the ith bit had appeared twice.</span></span><br><span class="line"><span class="comment">3. threes as a bitmask to represent the ith bit had appeared three times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">When the ith bit had appeared for the third time, clear the ith bit of both ones and twos to 0. The final answer will be the value of ones.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];</span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举一反三的思考"><a href="#举一反三的思考" class="headerlink" title="举一反三的思考"></a>举一反三的思考</h3><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers" target="_blank" rel="noopener">这里</a> 对于这类题目做了一个 generalization 的总结。</p>
<p>generalization 后题目变成：一个数组里面除了一个数字出现了 p 次，其他所有数字都出现了 k 次，那么请找出这个出现了 p 次的数字。</p>
<p>其思想也是对于每个 bit 位单独考虑，看看 1 出现了多少次保存在 count 中。并且保证 1 在出现了 k 次之后，count 会归零。</p>
<p>对于单独的一个 bit 位置来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 32-bit 的数字来说<br><img src="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png" alt="haha"></p>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 2, p = 1</span></span><br><span class="line"><span class="comment">k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 3, p = 1</span></span><br><span class="line"><span class="comment">k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = '11', then k1 = 1, k2 = 1, so we have mask = ~(x1 &amp; x2). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; x2);</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. </span></span><br><span class="line">                    <span class="comment">// If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 5, p = 3</span></span><br><span class="line"><span class="comment">k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = '101', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, x3  = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x3 ^= x2 &amp; x1 &amp; i;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">            x3 &amp;= mask;</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. </span></span><br><span class="line">                    <span class="comment">// If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2 | x3).</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-100-缺少的两个数"><a href="#1-100-缺少的两个数" class="headerlink" title="1-100 缺少的两个数"></a>1-100 缺少的两个数</h2><p>解方程？ 位运算？</p>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>找出超过一半的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：众数出现的次数大于其他所有数出现次数之和。</span><br><span class="line">    每次扔掉两个不同的数，众数不变</span><br><span class="line">        如果扔掉一个众数，和一个非众数</span><br><span class="line">        如果扔掉两个非众数</span><br><span class="line">    如何实现？和 x 不同就扔掉</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">int count &#x3D; 0, x;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">    if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        x &#x3D; a[i];</span><br><span class="line">        count &#x3D; 1;</span><br><span class="line">    &#125; else if (x &#x3D;&#x3D; a[i]) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意有的题目要数一下 x 出现次数是否确实超过一半（众数可能不存在）。</span><br></pre></td></tr></table></figure>

<p>TODO:<br>思考题：如何找到所有出现次数严格大于总数 1/k 的数？<br>提示：保存(k - 1)个数。<br>如何查找？hash? map?</p>
<h2 id="几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><a href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240" class="headerlink" title="几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240"></a>几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</h2><h3 id="leetcode-0011"><a href="#leetcode-0011" class="headerlink" title="leetcode 0011"></a>leetcode 0011</h3><p>题目：<br>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>
<p>分析：<br>这一题的解法比较巧妙，想通了后就特别简单。</p>
<p>绝妙的思路：<br>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.<br>In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.<br>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by —).</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p><mark>注意：上面划线部分没有细说，但是你必须要搞懂。<br>事实上，如果 2 3 4 5 的高度超过 1，那么由于 1 的高度的限制，水桶的整体高度不会超过 1 的高度。<br>同时又由于 2 3 4 5 距离 1 相对于 6 距离 1 更近，<br>所以<br>(1,2) (1,3) (1,4) (1,5) 肯定小于 (1,6)<br>另一种情形，如果 2 3 4 5 的高度小于 1，那么<br>(1,2) (1,3) (1,4) (1,5) 更小于 (1,6) 了。<br>因此这四种情形都不用计算了！！！！</mark></p>
<p> we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<h3 id="leetcode-0167-Two-Sum-2-Input-array-is-sorted"><a href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted" class="headerlink" title="leetcode 0167 Two Sum 2 Input array is sorted"></a>leetcode 0167 Two Sum 2 Input array is sorted</h3><p>题目：<br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>思路分析：<br>For those of you who are wondering how this works, here is a quick explanation:<br>Each sum is characterized by two indices (i, j), where 0 &lt;= i &lt; j &lt; n with n the length of the input array. If we were to compute them explicitly, we end up with an n-by-n matrix.<br>If the input array is not sorted, to search for the target, there is no good way but comparing it with elements from the above matrix one by one. This is the naive O(n^2) solution. Of course you can use a HashMap to memorize visited elements and cut down the time to O(n) so we have the classic space-time tradeoff.<br>Now if the input array is sorted, the n-by-n summation matrix will have the following properties:<br>Integers in each row are sorted in ascending order from left to right.<br>Integers in each column are sorted in ascending order from top to bottom.<br>To find the target, we do not have to scan the whole matrix now since it exhibits some partial order. We may start from the top-right (or bottom-left) corner, then proceed to the next row or previous column depending on the relationship between the matrix element and the target until either it is found or all rows and columns are exhausted. The key here is that we can get rid of a whole row or column due to the two properties of the matrix specified above.<br>If you have finished leetcode problem “240. Search a 2D Matrix II”, you will find that this is exactly the same problem, except now of the two indices, the first has to be smaller than the second. Time complexity for “leetcode 240” is O(m + n), while for this problem we have m = n, plus the indices constraint so the time complexity will be O(n). Also we do not need the HashMap now so space complexity will be O(1).</p>
<h3 id="leetcode-240-Search-a-2D-Matrix-II"><a href="#leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="leetcode 240 Search a 2D Matrix II"></a>leetcode 240 Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,<br>Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>Given target = 5, return true.<br>Given target = 20, return false.</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We start search the matrix from top right corner, initialize the current position to top right corner, </span></span><br><span class="line"><span class="comment">if the target is greater than the value in current position, then the target can not be in entire row </span></span><br><span class="line"><span class="comment">of current position because the row is sorted, if the target is less than the value in current position, </span></span><br><span class="line"><span class="comment">then the target can not in the entire column because the column is sorted too. </span></span><br><span class="line"><span class="comment">We can rule out one row or one column each time, so the time complexity is O(m+n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; matrix.<span class="built_in">size</span>() &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[m][n])&#123;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[m][n])&#123;</span><br><span class="line">                --n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p>其实对于二维的也可以分治啊！二维矩阵的中心点把矩阵分成了：左上 A, 右上 B，左下 C，右下 D 这四个小矩阵。</p>
<ol>
<li>根据中心元素 m 和 target 的比较情况<ol>
<li>如果 m &lt; target, 则 target 不可能在 A</li>
<li>如果 m &gt; target, 则 target 不可能在 B</li>
</ol>
</li>
<li>时间复杂度<ol>
<li>T(N) = T(N/2) + T(N/4) +O(1)</li>
<li>不好分析，可能在O(N^0.5) - O(N) 之间，这里 N 是全部的数组元素</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x1 &gt; x2) || (y1 &gt; y2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midx = (x1 + x2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midy = (y1 + y2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[midx][midy] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (target &lt; a[midx][midy]) ?</span><br><span class="line">        (<span class="built_in">find</span>(a, x1, y1, midx - <span class="number">1</span>, y2, target) || <span class="built_in">find</span>(a, midx, y1, x2, midy - <span class="number">1</span>, target)) :</span><br><span class="line">        (<span class="built_in">find</span>(a, x1, midy + <span class="number">1</span>, x2, y2, target) || <span class="built_in">find</span>(a, midx + <span class="number">1</span>, y1, x2, midy, target)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(matrix, <span class="number">0</span>, <span class="number">0</span>, m<span class="number">-1</span>, n<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些题目的 算法复杂度优化 都是转化为矩阵分析。<br>本来要考虑的情况是矩阵的所有元素 O(m * n)，<br>但是每次计算其中一个元素，并做了比较以后，<br>可以排除一整行或者一整列的元素，<br>因此变成了 O(m + n) 的算法。</p>
<h2 id="Ugly-Number-II-lc0264"><a href="#Ugly-Number-II-lc0264" class="headerlink" title="Ugly Number II lc0264"></a>Ugly Number II lc0264</h2><p>[题目]</p>
<ol>
<li>Write a program to find the n-th ugly number.</li>
<li>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. </li>
<li>Example:<ol>
<li>Input: n = 10</li>
<li>Output: 12</li>
<li>Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</li>
</ol>
</li>
<li>Note:  <ol>
<li>1 is typically treated as an ugly number.</li>
<li>n does not exceed 1690.</li>
</ol>
</li>
</ol>
<p>[思路一]</p>
<ol>
<li>大致的思路很清楚，ugly number 一定是由较小的 ugly number 乘以 2, 3, 5 形成的</li>
<li>因此可以遍历之前的数，找到一个最小的。</li>
</ol>
<p>[思路一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; <span class="title">ans</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j] * <span class="number">2</span> &gt; ans[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    ans[i] = <span class="built_in">min</span>(ans[i], ans[j] * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j] * <span class="number">3</span> &gt; ans[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    ans[i] = <span class="built_in">min</span>(ans[i], ans[j] * <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j] * <span class="number">5</span> &gt; ans[i - <span class="number">1</span>])&#123;</span><br><span class="line">                    ans[i] = <span class="built_in">min</span>(ans[i], ans[j] * <span class="number">5</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这里面之所以用了三个内层 for 循环，是为了及时终止寻找，因为找到的最小的那个超过已有 ugly number 就可以了。</li>
<li>这个代码勉强在 leetcode 上 AC 了。</li>
</ol>
<p>[思路二]</p>
<ol>
<li>注意上面的思路，内部的三个 for 循环实际上终止的时候都各自只找到了一个数字！</li>
<li>也就是说，对于外面的 for loop 的每一次循环，我们只需要 generate 三个数字，然后从里面找出最小的就行了！</li>
<li>想办法记住位置！</li>
</ol>
<p>[思路二代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/ugly-number-ii/discuss/69364/My-16ms-C%2B%2B-DP-solution-with-short-explanation</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We have an array k of first n ugly number. We only know, at the beginning, the first one, which is 1. Then</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k[1] = min( k[0]x2, k[0]x3, k[0]x5). The answer is k[0]x2. So we move 2's pointer to 1. Then we test:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">k[2] = min( k[1]x2, k[0]x3, k[0]x5). And so on. Be careful about the cases such as 6, in which we need to forward both pointers of 2 and 3.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">x here is multiplication.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// get rid of corner cases </span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>; <span class="comment">//pointers for 2, 3, 5</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">k</span><span class="params">(n)</span></span>;</span><br><span class="line">        k[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; n ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            k[i] = <span class="built_in">min</span>(k[t2]*<span class="number">2</span>,<span class="built_in">min</span>(k[t3]*<span class="number">3</span>,k[t5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(k[i] == k[t2]*<span class="number">2</span>) t2++; </span><br><span class="line">            <span class="keyword">if</span>(k[i] == k[t3]*<span class="number">3</span>) t3++;</span><br><span class="line">            <span class="keyword">if</span>(k[i] == k[t5]*<span class="number">5</span>) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Trapping-Rain-Water-leetcode-0042"><a href="#Trapping-Rain-Water-leetcode-0042" class="headerlink" title="Trapping Rain Water leetcode 0042"></a>Trapping Rain Water leetcode 0042</h2><p>题目：<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water"></p>
<p>分析：<br>我本来想的是这些水只能 trap 在两个“峰”中间，<br>所以我们可以从左到右找这些峰，<br>然后分别计算中间trap了多少水。<br>这个算法的复杂度也算是O(n),<br>但是实现起来应该比较复杂，<br>主要是在于山峰的寻找上。<br>比如说山峰的判断可以是当前高度大于左右两边，<br>但是如果有当前高度等于左边或者右边怎么办？<br>如果山峰在边界怎么办？<br>都不太好处理。</p>
<p>discuss forum 里面有个好算法<br>没有通过寻找山峰<br>就是分别看每个 bin<br>计算每个 bin 能存储的水量<br>为了达到这个目的<br>算法需要两个变量来记录 maxleft 和 maxright。<br>在保证右边有更高的 bin 的时候，<br>左边每个 bin 保存的水量等于 maxleft 减去 当前高度。<br>同理，<br>在保证左边有更高的 bin 的时候，<br>右边每个 bin 保存的水量等于 maxright 减去当前高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>, res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[left] &lt;= <span class="built_in">height</span>[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[left] &gt;= maxleft)&#123;</span><br><span class="line">                    maxleft = <span class="built_in">height</span>[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxleft - <span class="built_in">height</span>[left];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[right] &gt;= maxright)&#123;</span><br><span class="line">                    maxright = <span class="built_in">height</span>[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxright - <span class="built_in">height</span>[right];</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中第 10 行和第 17 行对 res 做了改变。</span></span><br><span class="line"><span class="comment">我好奇的是第 10 行用 maxleft 减，</span></span><br><span class="line"><span class="comment">如果 maxleft 大于 maxright的话，不应该拿 maxright 来减吗？？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事实上，maxleft 大于 maxright 的话，</span></span><br><span class="line"><span class="comment">left pointer 肯定指向了 maxleft，</span></span><br><span class="line"><span class="comment">这个时候程序按照逻辑，</span></span><br><span class="line"><span class="comment">会进入到 else 语句（14到19行），</span></span><br><span class="line"><span class="comment">所以达到目的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<mark>
第 10 行运行的时候 maxleft 一定是小于 maxright，准确说是小于 right pointer 指向的位置的高度 ,
第 17 行运行的时候 maxright 一定小于 maxleft，准确说是小于 left pointer 指向的位置的高度。
left 或者 right pointer 有一个肯定位于目前浏览到的所有 bin 的最高的那一个，然后保持不动，另外一个 pointer 移动.
</mark>


<h2 id="数组中连续一段和，绝对值最小"><a href="#数组中连续一段和，绝对值最小" class="headerlink" title="数组中连续一段和，绝对值最小"></a>数组中连续一段和，绝对值最小</h2><p>思路：先计算前缀和，然后排序。整体复杂度就是排序的复杂度 O(nlogn).</p>
<h2 id="subarray-sum-equals-k-leetcode-0560"><a href="#subarray-sum-equals-k-leetcode-0560" class="headerlink" title="subarray sum equals k leetcode 0560"></a>subarray sum equals k leetcode 0560</h2><p>[题目]</p>
<ol>
<li>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</li>
</ol>
<p>[错误分析]</p>
<ol>
<li>先过一遍数组，把所有前缀和都放到 hash map 里面，记录出现的次数</li>
<li>然后对所有的 key, 看 map 中是否存在 (key + k) 或者 (key - k), 若存在就把那个对应的次数加到 res 中。</li>
<li>！！！这个思路是错的。因为不能对所有的 key 都考虑 +- k. 我们必须拿较长的前缀和 减去 较短的前缀和才行。</li>
</ol>
<p>[正确思路]</p>
<ol>
<li>必须一边求前缀和更新 map，一边更新 res</li>
</ol>
<p>[正确代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cumsum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        mymap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            cumsum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mymap.<span class="built_in">find</span>(cumsum - k) != mymap.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res += mymap[cumsum-k];</span><br><span class="line">            &#125;</span><br><span class="line">            mymap[cumsum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子数组和-leetcode-53"><a href="#最大子数组和-leetcode-53" class="headerlink" title="最大子数组和 leetcode 53"></a>最大子数组和 leetcode 53</h2><p>[题目]<br>一个整数数组，一个非空的子数组（连续一段数），使得它的和最大。</p>
<p>[思路一]<br>暴利枚举。枚举子数组的起点 i，终点 j，计算 [i…j] 的和，时间复杂度为 O(N^3)。</p>
<p>[思路二]<br>聪明枚举。对于每一个起点 i，让 j 从 i+1 开始枚举，一遍枚举一边求和，时间复杂度为 O(N^2)。</p>
<p>[思路三]<br>分治</p>
<ol>
<li>Divide the given array in two halves</li>
<li>Return the maximum of following three<ol>
<li>Maximum subarray sum in left half (Make a recursive call)</li>
<li>Maximum subarray sum in right half (Make a recursive call)</li>
<li>Maximum subarray sum such that the subarray crosses the midpoint</li>
</ol>
</li>
</ol>
<p>The lines 2.1 and 2.2 are simple recursive calls. How to find maximum subarray sum such that the subarray crosses the midpoint? We can easily find the crossing sum in linear time.<br>Suppose the current range is [l, r] and the mid point is “m”.<br>The idea is simple, find the maximum sum starting from mid point “m” and ending at some point on left of mid, then find the maximum sum starting from “m + 1” and ending with sum point on right of “m + 1”. Finally, combine the two and return.</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">max</span>(helper(arr, l, m), helper(arr, m+<span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">int</span> now = arr[m], may = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">        may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now = may + arr[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">2</span>; i &lt; r; i++)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">        may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans, may);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路四-DP]</p>
<ol>
<li>dp[i] 表示以 a[i] 结尾的最大子数组的和</li>
<li>dp[i] = max(dp[i-1] + a[i], a[i])</li>
<li>初值 dp[0] = a[0]</li>
<li>答案是 dp 数组里面最大的那个</li>
<li>时间复杂度 O(n)，空间复杂度 O(n)</li>
<li>空间优化：不需要把 dp 数组存储下来<ol>
<li>endHere = max(endHere + a[i], a[i])</li>
<li>answer = max(endHere, answer)</li>
</ol>
</li>
</ol>
<p>[思路五：前缀和]</p>
<ol>
<li>计算前缀和 preSum</li>
<li>i 从 0 遍历到 n-1，保存 preSum[0…i-1] 这 i 个数的最小值 currentMin，当前的 preSum[i] - currentMin</li>
<li>整体的思想就类似于买卖股票一次，求最大的 gain 那道题</li>
<li>时间复杂度跟 DP 一样，都是 O(n).</li>
<li>空间优化：也可以一边求 preSum 一边做第二步，这样子就不需要保存 preSum 这个数组了。</li>
</ol>
<h2 id="最大子数组和-环形数组-lc-0918"><a href="#最大子数组和-环形数组-lc-0918" class="headerlink" title="最大子数组和 环形数组 lc-0918"></a>最大子数组和 环形数组 lc-0918</h2><p>[题目]</p>
<ul>
<li>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</li>
</ul>
<p>[Example 2]</p>
<ol>
<li>Input: [5,-3,5]</li>
<li>Output: 10</li>
<li>Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</li>
</ol>
<p>[Example 3]</p>
<ol>
<li>Input: [3,-1,2,-1]</li>
<li>Output: 4</li>
<li>Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</li>
</ol>
<p>[思路]</p>
<ul>
<li>最主要的就是注意到，如果最大值是尾巴连到头部的一个 subarray 的话</li>
<li>那就相当于从中间挖了一块 minimum subarray</li>
<li>参加下图</li>
</ul>
<p><img src="https://assets.leetcode.com/users/motorix/image_1538888300.png" alt=""></p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, maxSum = <span class="number">-30000</span>, curMax = <span class="number">0</span>, minSum = <span class="number">30000</span>, curMin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">        curMax = <span class="built_in">max</span>(curMax + a, a);</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, curMax);</span><br><span class="line">        curMin = <span class="built_in">min</span>(curMin + a, a);</span><br><span class="line">        minSum = <span class="built_in">min</span>(minSum, curMin);</span><br><span class="line">        total += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum &gt; <span class="number">0</span> ? <span class="built_in">max</span>(maxSum, total - minSum) : maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cantor-数组"><a href="#Cantor-数组" class="headerlink" title="Cantor 数组"></a>Cantor 数组</h2><p>[题目]</p>
<p>[思路]</p>
<ul>
<li>观察第一个元素，你就能知道思路了</li>
<li>第一个元素是 3，说明后面的元素中有三个小于这个元素，那么第一个元素只可能是 4 啊！！！</li>
<li>然后依次找到第二个，三个，。。。元素就可以了</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">CantorRecovery</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        temp.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[j] &gt; <span class="number">0</span>) k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(temp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue-Reconstruction-by-Height"><a href="#Queue-Reconstruction-by-Height" class="headerlink" title="Queue Reconstruction by Height"></a>Queue Reconstruction by Height</h2><p>[题目]</p>
<ul>
<li>Suppose you have a random list of people standing in a queue. </li>
<li>Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. </li>
<li>Write an algorithm to reconstruct the queue.</li>
</ul>
<p>[例子]</p>
<ul>
<li>Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</li>
<li>Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</li>
</ul>
<p>[分析]</p>
<ul>
<li>这道题跟上面的 Cantor 数组一样啊，神马 queue height 实际就是比较数字的大小嘛！</li>
<li>思路就是先考虑最小的数字，假设它前面有 4 个比它大的，那它就在 arr[4] 啊！（这里注意数组下标从 0 开始）</li>
</ul>
<p>[代码]<br>注意！这个代码的复杂度我最开始做的时候想错了，我以为是 <code>O(NlogN) * O(N)</code> 也就是 <code>O(N^2 logN)</code>。而其实应该是 <code>O(N) * O(logN + N)</code>  也就是 <code>O(N^2)</code>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">reconstructQueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: people)&#123;</span><br><span class="line">            mymap.insert(make_pair(v[<span class="number">0</span>], v[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = people.<span class="built_in">size</span>(), ind, i;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!mymap.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">            ind = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i][<span class="number">1</span>] == <span class="number">-1</span> || ans[i][<span class="number">0</span>] == iter-&gt;first) ind++;</span><br><span class="line">                <span class="keyword">if</span>(ind == iter-&gt;second + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i][<span class="number">0</span>] = iter-&gt;first;</span><br><span class="line">            ans[i][<span class="number">1</span>] = iter-&gt;second;</span><br><span class="line">            mymap.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="subset-sum"><a href="#subset-sum" class="headerlink" title="subset sum"></a>subset sum</h2><p>[题目]<br>Given a set of positive integers and an integer s, is there any non-empty subset whose sum is s.</p>
<p>[ref]<br><a href="https://www.techiedelight.com/subset-sum-problem/" target="_blank" rel="noopener">https://www.techiedelight.com/subset-sum-problem/</a></p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">    <span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">    <span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">    <span class="comment">// remaining items (n - 1)</span></span><br><span class="line">    <span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return true if we can get subset by including or excluding the</span></span><br><span class="line">    <span class="comment">// current item</span></span><br><span class="line">    <span class="keyword">return</span> include || exclude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Input: set of items and a sum</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of items</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>带记忆的算法代码</mark></p>
<ul>
<li>这里记忆的是：前面 n 个数里面能不能凑出来一个 sum.</li>
<li>算法是从右往前逐个看是否包括每个元素的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a map to store solutions of subproblems</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a unique map key from dynamic elements of the input</span></span><br><span class="line">    <span class="built_in">string</span> key = to_string(n) + <span class="string">"|"</span> + to_string(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sub-problem is seen for the first time, solve it and</span></span><br><span class="line">    <span class="comment">// store its result in a map</span></span><br><span class="line">    <span class="keyword">if</span> (lookup.<span class="built_in">find</span>(key) == lookup.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">        <span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">        <span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">        <span class="comment">// remaining items (n - 1)</span></span><br><span class="line">        <span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign true if we can get subset by including or excluding the</span></span><br><span class="line">        <span class="comment">// current item</span></span><br><span class="line">        lookup[key] = include || exclude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return solution to current sub-problem</span></span><br><span class="line">    <span class="keyword">return</span> lookup[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Input: set of items and a sum</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of items</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆序数有关"><a href="#逆序数有关" class="headerlink" title="逆序数有关"></a>逆序数有关</h2><h3 id="Count-of-Smaller-Number-After-Self-leetcode-0315"><a href="#Count-of-Smaller-Number-After-Self-leetcode-0315" class="headerlink" title="Count of Smaller Number After Self leetcode 0315"></a>Count of Smaller Number After Self leetcode 0315</h3><p>[题目]<br>给定一个数组，返回一个同样长度的数组，里面的数字表示原数组这个位置后面有多少个数字小于它。</p>
<p>[例子]</p>
<ul>
<li>Input: [5,2,6,1]</li>
<li>Output: [2, 1, 1, 0]</li>
</ul>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><ul>
<li>对每一个元素，逐个检查右边所有元素，看是否比它小</li>
<li>时间复杂度 O(N^2)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(numsSize, <span class="number">0</span>)</span></span>;<span class="comment">//用于储存nums[i]右边比它小的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">            <span class="comment">//寻找[i + 1, numsSize - 1]中小于nums[i]的元素个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    result[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改进暴力解法"><a href="#改进暴力解法" class="headerlink" title="改进暴力解法"></a>改进暴力解法</h4><ul>
<li>思路一的问题是，每次我们都要遍历右边所有的元素</li>
<li>如果我们从右往左看，看过的元素都排好序，那么可以使用二分查找来迅速找到小于每个数字的元素个数了</li>
<li>不过因为对 vector 进行插入复杂度是 O(N)，导致整体复杂度仍为 O(N^2)，但是不会出现 TLE.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s_num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(s_num.<span class="built_in">begin</span>(), s_num.<span class="built_in">end</span>(), nums[i]);  <span class="comment">// 二分查找比 nums[i] 小的数</span></span><br><span class="line">            <span class="keyword">int</span> pos = iter - s_num.<span class="built_in">begin</span>();</span><br><span class="line">            res.push_back(pos);             <span class="comment">// pos 就是小于 nums[i] 的元素个数</span></span><br><span class="line">            s_num.insert(iter, nums[i]);    <span class="comment">// 插入后要保持sorted_num排序，所以nums[i]插入到iter位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul>
<li>思路二的一个问题是：虽然查找有多少元素小于 nums[i] 的时候速度很快，但是把 nums[i] 插入到当前的已经排好序的数组里这一步骤耗时间。</li>
<li>因为 <code>vector&lt;int&gt;</code> 在中间位置插入元素需要把插入位置后面的元素都整体往后移动一位以获得一个空。</li>
<li>而解决这个问题就是使用 BST，它查找时间复杂度同样是 <code>log(N)</code>，然而插入步骤只是简单地 <code>O(1)</code> 复杂度。</li>
<li>BST 有个很好的性质：左子树所有节点都比根节点小，右子树所有节点都比根节点大</li>
<li>这个方法的最坏时间复杂度是 O(n^2). 也就是给定数组是递增，或者递减序列的时候，此时 BST 长得就是一根直线。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> val, smallerCnt;</span><br><span class="line">        TreeNode* left, *right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> v, <span class="keyword">int</span> s) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), val(v), smallerCnt(s)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(len, <span class="number">0</span>)</span></span>; </span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            root = insert(ret, nums[i], i, <span class="number">0</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把 val 插入到 node 为根节点的树中；</span></span><br><span class="line"><span class="comment">    preSum 是当前已经找到的比 val 小的数字的个数了；</span></span><br><span class="line"><span class="comment">    递归终止的条件是 val 放到了正确的位置，也就是第一个 if else 条件，此时会把最终的结果放到 ret[idx];</span></span><br><span class="line"><span class="comment">    val, idx 在递归调用中保持不变；</span></span><br><span class="line"><span class="comment">    递归调用中改变的东西只有 preSum 和 *node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, <span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="keyword">int</span> preSum, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(val, <span class="number">0</span>);</span><br><span class="line">            ret[idx] = preSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val &gt; val) &#123;</span><br><span class="line">            node-&gt;smallerCnt++;</span><br><span class="line">            node-&gt;left = insert(ret, val, idx, preSum, node-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;right = insert(ret, val, idx, preSum + node-&gt;smallerCnt + ((node-&gt;val &lt; val)? <span class="number">1</span>: <span class="number">0</span>), node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="平衡-BST"><a href="#平衡-BST" class="headerlink" title="平衡 BST"></a>平衡 BST</h4><ul>
<li>这个思路是对思路二的改进，为了让最坏情况下时间复杂度仍然是 O(NlogN)</li>
<li>需要时刻让 BST 保持平衡，也就是使用 AVL tree, RB-Tree 等数据结构。</li>
<li>此处每个节点包含以此节点为根的树的大小。</li>
<li>使用 AVL 树。</li>
<li>We traverse the array from right to left and insert all elements one by one in an AVL tree. </li>
<li>While inserting a new key in an AVL tree, we first compare the key with root. <ul>
<li>If key is greater than root, then it is greater than all the nodes in left subtree of root. </li>
<li>So we add the size of left subtree to the count of smaller element for the key being inserted. </li>
<li>We recursively follow the same approach for all nodes down the root.</li>
</ul>
</li>
</ul>
<p>代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, <span class="built_in">height</span>, <span class="built_in">size</span>, freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="keyword">this</span>-&gt;<span class="built_in">size</span> = <span class="keyword">this</span>-&gt;freq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateNode</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;<span class="built_in">size</span> = getSize(root-&gt;left) + getSize(root-&gt;right) + root-&gt;freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateLeft</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node *B = A-&gt;right;</span><br><span class="line">    Node *T2 = B-&gt;left;</span><br><span class="line">    A-&gt;right = T2;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateRight</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node* B = A-&gt;left;</span><br><span class="line">    Node* T2 = B-&gt;right;</span><br><span class="line">    A-&gt;left = T2;</span><br><span class="line">    B-&gt;right = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">balance</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    updateNode(root);</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;left) &gt;= <span class="number">0</span>) root = rotateRight(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;left = rotateLeft(root-&gt;left);</span><br><span class="line">            root = rotateRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;right) &lt;= <span class="number">0</span>) root = rotateLeft(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;right = rotateRight(root-&gt;right);</span><br><span class="line">            root = rotateLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node* root, <span class="keyword">int</span> data, <span class="keyword">int</span>&amp; count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == data)&#123;</span><br><span class="line">        root-&gt;freq++;</span><br><span class="line">        count += getSize(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; data)  root-&gt;left = insert(root-&gt;left, data, count);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        count += getSize(root-&gt;left) + root-&gt;freq;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, data, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        Node *root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) root = insert(root, nums[i], count[i]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>[这段代码来自 geeksforgeeks]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// An AVL tree node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> key; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>; </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// size of the tree rooted with this node </span></span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get height of the tree rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to size of the tree of rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">size</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &gt; b)? a : b; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Helper function that allocates a new node with the given key and </span></span><br><span class="line"><span class="comment">    NULL left and right pointers. */</span></span><br><span class="line"><span class="function">struct node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">node</span>*) </span></span><br><span class="line"><span class="class">                        <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span> </span><br><span class="line">    node-&gt;key   = key; </span><br><span class="line">    node-&gt;left   = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;right  = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;  <span class="comment">// new node is initially added at leaf </span></span><br><span class="line">    node-&gt;<span class="built_in">size</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span>(node); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to right rotate subtree rooted with y </span></span><br><span class="line"><span class="function">struct node *<span class="title">rightRotate</span><span class="params">(struct node *y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">x</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    x-&gt;right = y; </span><br><span class="line">    y-&gt;left = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update heights </span></span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to left rotate subtree rooted with x </span></span><br><span class="line"><span class="function">struct node *<span class="title">leftRotate</span><span class="params">(struct node *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">y</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    y-&gt;left = x; </span><br><span class="line">    x-&gt;right = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  Update heights </span></span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Get Balance factor of node N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Inserts a new key to the tree rotted with node. Also, updates *count </span></span><br><span class="line"><span class="comment">// to contain count of smaller elements for the new key </span></span><br><span class="line"><span class="function">struct node* <span class="title">insert</span><span class="params">(struct node* node, <span class="keyword">int</span> key, <span class="keyword">int</span> *count)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/* 1.  Perform the normal BST rotation */</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>(newNode(key)); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key) </span><br><span class="line">        node-&gt;left  = insert(node-&gt;left, key, count); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key, count); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// UPDATE COUNT OF SMALLER ELEMENTS FOR KEY </span></span><br><span class="line">        *count = *count + <span class="built_in">size</span>(node-&gt;left) + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 2. Update height and size of this ancestor node */</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>; </span><br><span class="line">    node-&gt;<span class="built_in">size</span>   = <span class="built_in">size</span>(node-&gt;left) + <span class="built_in">size</span>(node-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 3. Get the balance factor of this ancestor node to check whether </span></span><br><span class="line"><span class="comment">       this node became unbalanced */</span></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If this node becomes unbalanced, then there are 4 cases </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;left =  leftRotate(node-&gt;left); </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right); </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* return the (unchanged) node pointer */</span></span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The following function updates the countSmaller array to contain count of </span></span><br><span class="line"><span class="comment">// smaller elements on right side. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructLowerArray</span> <span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> countSmaller[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i, j; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">root</span> = <span class="title">NULL</span>;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize all the counts in countSmaller array as 0 </span></span><br><span class="line">  <span class="keyword">for</span>  (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">     countSmaller[i] = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Starting from rightmost element, insert all elements one by one in </span></span><br><span class="line">  <span class="comment">// an AVL tree and get the count of smaller elements </span></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">  &#123; </span><br><span class="line">     root = insert(root, arr[i], &amp;countSmaller[i]); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Utility function that prints out an array on a line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; </span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *low = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); </span><br><span class="line">  </span><br><span class="line">  constructLowerArray(arr, low, n); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Following is the constructed smaller count array"</span>); </span><br><span class="line">  printArray(low, n); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，有人提议可以使用 set (如果没有重复元素)，或者 multiset (有重复元素) 来做。set 的底层实现用的就是平衡二叉树。</p>
<ol>
<li>averse the array element from i=len-1 to 0 and insert every element in a set.</li>
<li>Find the first element that is lower than A[i] using lower_bound function.</li>
<li>Find the distance between above found element and the beginning of the set using distance function.</li>
<li>Store the distance in another array Lets say CountSmaller.</li>
<li>Print that array .</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSmallerRight</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="keyword">int</span> countSmaller[len]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        s.insert(A[i]); </span><br><span class="line">        <span class="keyword">auto</span> it = s.lower_bound(A[i]); </span><br><span class="line">        countSmaller[i] = distance(s.<span class="built_in">begin</span>(), it); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; countSmaller[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">    countSmallerRight(A, len); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>但是，这里跟上面的解法不一样的是：这里使用的 <code>std::distance()</code> 函数的时间复杂度为 O(size)，因此整体的复杂度是 O(N^2)，虽然 set 底层也用得平衡二叉树。</li>
<li>不过这个解法让我们学习了 STL algrorithm 的用法，而且写得很简洁，不错！</li>
<li>如果存在重复元素，只需要改成 multiset 就可以了！</li>
</ol>
<h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><ul>
<li>在 merge sort 的过程中多记录一些额外的东西。</li>
<li>例如考虑这个数组: <code>6 4 1 8 7 5 2 9</code></li>
<li>因为是递归调用，所以两个子数组是 <code>6 4 1 8</code> 和 <code>7 5 2 9</code></li>
<li>假定两个子数组分别处理好了<ul>
<li>第一个子数组处理结果是 <code>1(0) 4(1) 6(2) 8(0)</code></li>
<li>第二个子数组处理结果是 <code>2(0) 5(1) 7(2) 9(0)</code></li>
<li>括号里的数字表示当前子数组里面，排序前位置在右边的并且小于自己的数字有多少个。</li>
<li>比如 <code>4(1)</code> 就表示原来的第一个子数组中位置在 <code>4</code> 右边，并且值小于 <code>4</code> 的数字有 <code>1</code> 个。</li>
</ul>
</li>
<li>现在需要合并两个子数组了, 用 rightcount 来记录右边的子数组中拿出来多少个数字了，并初始化为 0.<ul>
<li>先从左边子数组中拿出 1(0 + rightcount) = 1(0)</li>
<li>再从右边子数组中拿出 2(0)，同时 rightcount = 0 + 1 = 1</li>
<li>再从左边子数组中拿出 4(1 + rightcount) = 4(1+1) = 4(2)</li>
<li>再从右边子数组中拿出 5(1), 同时 rightcount = 1 + 1 = 2</li>
<li>再从左边子数组中拿出 6(2+rightcount) = 6(2+2) = 6(4)</li>
<li>再从右边子数组中拿出 7(2), 同时 rightcount = 2 + 1 = 3</li>
<li>再从左边子数组中拿出 8(0 + rightcount) = 8(0+3) = 8(3)</li>
<li>再从右边子数组中拿出 9(0)</li>
</ul>
</li>
<li>可以看出来，我们只需要更新左边子数组中括号里面的个数记录</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Pii;</span><br><span class="line">    <span class="keyword">typedef</span> Pii::iterator Pit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">Pii <span class="title">nums_</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            nums_[i] = &#123;nums[i], i&#125;;</span><br><span class="line">        merge(nums_.<span class="built_in">begin</span>(), nums_.<span class="built_in">end</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Pit <span class="built_in">begin</span>, Pit <span class="built_in">end</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span> - <span class="built_in">begin</span> &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        merge(<span class="built_in">begin</span>, mid, res);</span><br><span class="line">        merge(mid, <span class="built_in">end</span>, res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="built_in">begin</span>, j = mid; i != mid; ++i)&#123; <span class="comment">// 对于每一个 i</span></span><br><span class="line">            <span class="keyword">while</span>(j != <span class="built_in">end</span> &amp;&amp; i-&gt;first &gt; j-&gt;first)   <span class="comment">// 把 j 往右移动到最后一个满足条件: i-&gt;first 大于 j-&gt;first</span></span><br><span class="line">                ++j;                                 <span class="comment">// 此时相当于 merge 时候把右边的子数组中到 j 位置的所有元素</span></span><br><span class="line">            res[i-&gt;second] += j - mid;               <span class="comment">// 都移动到汇总数组里面了，下一个就是把 i 位置元素放到汇总数组里。</span></span><br><span class="line">        &#125;</span><br><span class="line">        inplace_merge(<span class="built_in">begin</span>, mid, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="离散化-分桶"><a href="#离散化-分桶" class="headerlink" title="离散化 分桶"></a>离散化 分桶</h4><ul>
<li>离散化：数字绝对大小没有意义，转化为 0 - (n-1) 之间, 这一步骤复杂度 O(NlogN)</li>
<li>如何分桶<ol>
<li>桶大小 bucketSize = sqrt(n)</li>
<li>桶个数 (n + bucketSize - 1) / bucketSize</li>
<li>例如 n = 11<ol>
<li>分成 4 个桶 [0,1,2], [3,4,5], [6,7,8], [9,10]</li>
</ol>
</li>
<li>数 x 所在桶的编号为 <code>x / bucketSize</code></li>
<li>把所有数 倒着 放入桶里<ol>
<li>统计每个数出现的次数</li>
<li>每个桶包含的数的个数</li>
</ol>
</li>
<li>桶自然有序（区间）</li>
<li>如何计数<ol>
<li>和 x 在同一个桶里的数，暴力循环 O(sqrt(N))</li>
<li>x 之前桶里的数通过每个桶里数的个数累加 O(sqrt(N))</li>
</ol>
</li>
<li>总复杂度 O(N^1.5)</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ++save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t = save.<span class="built_in">begin</span>(); t != save.<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">            t-&gt;second = m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bucketSize = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(m);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bucket</span><span class="params">((n + bucketSize - <span class="number">1</span>) / bucketSize)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">have</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = save[nums[i]];</span><br><span class="line">            <span class="keyword">int</span> id = x / bucketSize;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = id - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                answer[i] += bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = id * bucketSize; j &lt; x; ++j)&#123;</span><br><span class="line">                answer[i] += have[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ++have[x];</span><br><span class="line">            ++bucket[id];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="离散化方法二"><a href="#离散化方法二" class="headerlink" title="离散化方法二"></a>离散化方法二</h4><ol>
<li>从二进制入手</li>
<li>比如 x = 10110</li>
<li>比 x 小的数 (类似字典序，前缀) — 3 个集合不想交<ol>
<li>0xxxx, 100xx, 1010x</li>
</ol>
</li>
<li>枚举每一位，倒着循环，计算每个”前缀”出现的次数，如果 nums[i] 在该位为 1，累加在它右边，前缀相同，在该位为 0 的所有数的个数。</li>
<li>每个比它小的数只会被累加一次(在最高不同位时)</li>
<li>技巧：位运算，右移位，异或</li>
<li>时间复杂度 O(NlogN)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ++save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t = save.<span class="built_in">begin</span>(); t != save.<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">            t-&gt;second = m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一直到这里，上面全是预处理！把 nums 数组变成 rank 数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">bool</span> next = <span class="literal">true</span>; next; )&#123;    <span class="comment">// 总循环次数为数字个数用二进制表示的位数，相当于循环看每一个 bit 位了。</span></span><br><span class="line">            next = <span class="literal">false</span>;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cal</span><span class="params">(m, <span class="number">0</span>)</span></span>;    <span class="comment">// m 是最大的 rank + 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;    <span class="comment">// 对每个 bit 位都扫描一遍全部的数组元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                    next = <span class="literal">true</span>;    <span class="comment">// 只要数组里面有一个数字不是 0，next 就被改成 true</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &amp; <span class="number">1</span>)&#123;    <span class="comment">// nums[i] 最后一位是 1，那么看最后一位是 0 的数字出现了多少次，它们都小于当前元素。</span></span><br><span class="line">                        answer[i] += cal[nums[i] ^ <span class="number">1</span>];  <span class="comment">// 每次循环只找出来既小于它，还满足一定条件的数！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++cal[nums[i]];</span><br><span class="line">                nums[i] &gt;&gt;= <span class="number">1</span>;    <span class="comment">// 外层循环每执行一次，rank 数组所有元素都右移一位！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="Binary-Index-Tree"><a href="#Binary-Index-Tree" class="headerlink" title="Binary Index Tree"></a>Binary Index Tree</h4><ul>
<li>也叫做 Fenwick Tree，中文是“树状数组”</li>
<li>BIT 的介绍参考<ul>
<li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">这里</a></li>
<li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees" target="_blank" rel="noopener">这里</a></li>
</ul>
</li>
<li>BIT 方法与下面的 Segment tree 方法相比，都是 log n 时间复杂度，然后需要的空间更小，更容易写代码。</li>
</ul>
<h5 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h5><p>[问题背景]</p>
<ol>
<li>树状数组的提出主要是为了较好的平衡计算前缀和，以及修改某项的值这两个操作。<ol>
<li>如果你使用普通的数组保存每项的值，那么计算前缀和的复杂度就是 O(N), 而修改某项的值这个操作复杂度是 O(1)；</li>
<li>如果你使用的数组里面保存得是前缀和，那么计算前缀和复杂度为 O(1), 修改值变成了 O(N).</li>
<li>而 binary index tree 可以使得这两个操作的复杂度都是 O(logN).</li>
</ol>
</li>
</ol>
<p>[初始化]</p>
<ol>
<li>\(nums[i] = arr[i]\)</li>
<li>\(BIT[i] = \sum_{k = i - lowestbit(i) + 1}^{i} arr[k]\)</li>
<li>注意，上面的 <code>lowestbit(i)</code> 是指将 <code>i</code> 转为二进制后，最后一个 <code>1</code> 的位置所代表的数值。如 <code>lowestbit(1) = 1</code>, <code>lowestbit(6) = 2</code>, 具体的实现可以通过 <code>(i &amp; -i)</code> 获取。</li>
<li>代码可以参考本文例题 Leetcode 0307 里面的 Python 代码。</li>
</ol>
<p>[一个好图胜过千言万语！！！]<br><mark>下图即为初始化后的情况，横轴为数组的下标（记为 i）,纵轴为下表数值对应的 <code>lowestbit (i &amp; -i)</code>, 长方形表示 <code>BIT[i]</code> 涵盖的求和范围。</mark></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp_fenwick_tree_binary_index_tree.jpg" alt="Binary Index Tree"></p>
<p>从图中可以看到:</p>
<ol>
<li>每一个 <code>BIT[i]</code> 覆盖的范围都是 2 的指数！即要么只覆盖自身，要么覆盖两个，四个，8个元素！</li>
<li>图中描黑的那些节点在形态上构成了一棵树的形状，这也是为什么这个算法被叫做 Binary Index Tree 的原因。</li>
<li>对于每个下表的 lowestbit 表示成的 tree node 有以下特性<ol>
<li><mark>假如 i 是左子节点，那么其父节点下标为 <code>i + lowestbit(i)</code></mark></li>
<li><mark>假如 i 是右子节点，那么其父节点下标为 <code>i - lowestbit(i)</code></mark></li>
</ol>
</li>
<li>算法思想<ol>
<li><mark>update i 的过程就是从 i 一直找 <code>i + lowestbit(i)</code> 去更新；</mark></li>
<li><mark>getSum(i) 的过程就是从 i 一直找 <code>i - lowestbit(i)</code> 去求和！</mark></li>
</ol>
</li>
</ol>
<p>[更新一个数值]<br>假如要修改原始数组中下标为 i 的值，那么需要修改 <code>nums</code> 数组中对应下标的值。除此之外还要修改 <code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值。结合上图可以知道，<code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值为下标 i 及其所有的父节点（它在父节点的左边）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    BIT[i] = BIT[i] + new_value</span><br><span class="line">    i = i + (i &amp; -i)</span><br></pre></td></tr></table></figure>

<p>[求前缀和]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    count = count + BIT[i]</span><br><span class="line">    i = i - (i &amp; -i)</span><br></pre></td></tr></table></figure>


<p>[理解]</p>
<ol>
<li>树状数组的构造过程是这样的<ol>
<li>对于一段序列 A[1…n]，把所有奇数项偶数项分开得到数组 P Q，</li>
<li>偶数项每项加上其左边的奇数项得到 (P + Q)，偶数项求一遍树状数组得到 T(P + Q)，</li>
<li>最后把 P 和 T(P + Q) 交替排列出来。</li>
</ol>
</li>
<li>举例：<ol>
<li>1 3 5 6 8</li>
<li>3   6    分离偶数项</li>
<li>4   11   每个偶数项加上其左边的奇数项</li>
<li>4   15   递归求树状数组</li>
<li>1 4 5 15 8 把奇数项交替排列回去</li>
</ol>
</li>
<li>树状数组一个数 n 能当偶数项 k 次，进入 k 次递归中，那么 n 的二进制最后有 k 个 0，因为每“当”一次偶数项，它所管辖的区间就会加倍，所以它的值就是原数组里以 n 结尾长度为 2^k 的一段区间。注意到 lowbit(n) = 2^k。如果区间写成左开右闭的，那么树状数组里第 n 项就是原数组 (n - lowbit(n), n] 的和。</li>
<li>举例。要查询前 10 个数的前缀和，二进制是 1010，我们可以将其拆成如下两个区间：(8, 10] 和 (0, 8]。</li>
<li>（2017-01-21 接近半夜，修改了修改操作的解释）</li>
<li>修改的话，观察构造树状数组的过程，观察原数组的某下标上如果被加上了一个变化量 d，那么这个 d 会怎样传播。</li>
<li>在某一层，如果这个下标 n 是偶数项，那么它左边的奇数项被加过来，这两项原本应该是 a 和 a + b 的，变成了 a 和 a + b + d，恰好就是第 n 位被改了；但是如果是奇数项的话，a 和 a + b 要变成 a + d 和 a + d + b，也就是说 d 被传播到了 n 右边的偶数项。当然影响是要传递的。所以我们修改的下标 n 在某一层作为奇数项的时候，它影响到了它在这一层右边的偶数项 n’，n’ 又会影响到 n’’，以此类推。</li>
<li>举例：10 在第 2 层的时候，它在这层的编号是 5，很不幸地影响到了这层编号是 6，即原编号 12 的元素。</li>
<li>我们来看一下二进制表示。10 = 1010 在第 2 层是 5 = 101，影响到的是 5 + 1 = 6 = 110。（此处感谢 UOJ 用户 rabbit_lb 提醒修改）在第 2 层，加的这个1，应该对应原数组上的 1 * 2^1 = 2，就是 lowbit(10)！</li>
<li>这是为什么呢？因为一个二进制最后有 k 个 0 的下标 n 会在第 k + 1 层，作为 n / 2^k 影响到 1 + n / 2^k，在原数组上的下标就是 n 影响到 2^k + n = lowbit(n) + n。</li>
<li>当然影响是要传递的，所以修改的时候就是不停加 lowbit 改就行了</li>
</ol>
<h5 id="本题的代码"><a href="#本题的代码" class="headerlink" title="本题的代码"></a>本题的代码</h5><p>为什么一个用来快速计算 range sum 的数据结构可以用来解决目前的这个问题呢？</p>
<p>主要是因为一个巧妙地转换：</p>
<ol>
<li>第一步先把数组中数字转换成 rank <ol>
<li>比如 [2, 5, -3, 6, 2, 4] 变成 rank 就变成了 [2, 4, 1, 5, 2, 3]</li>
<li>原数组里面 2 出现了两次，在 rank 数组里面它们的 rank 都是 2 (-3 是最小的数字)</li>
</ol>
</li>
<li>接下来就是关键的了，新定义一个数组 freq (长度为 n+1, 所有元素初始化为 0) 用来记录每个 rank 出现的数字的次数，然后从右到左扫描 rank 数组<ol>
<li>最先碰到的是 3, 此时我们把 freq[3]++，代表 rank=3 的数字碰到了一个, 而此时 freq[1] = freq[2] == 0，因此 freq[3] 左边的数字求和为 0， 代表原数组中 4 右边有 0 个数字比它值小。</li>
<li>接下来碰到 2，此时把 freq[2]++，而 freq[1] == 0，所以原数组中倒数第二个数字 2 后面有 0 个元素比它小。</li>
<li>接下来碰到 5，此时把 freq[5]++, 而 freq 数组中 freq[5] 前面有 freq[2] = freq[3] = 1, 因此说明原数组的 6 右边有两个元素比它小。</li>
</ol>
</li>
<li>思路还是很清晰的<ol>
<li>因为我们是从右往左遍历 rank 数组</li>
<li>如果右边数字的 rank 小于左边某个数字的 rank，也就是说原来的数组中右边的数字小于左边的数字了。</li>
<li>同时！右边先被遍历，也保证了如果右边有 rank 小的数字，freq[右边数字的 rank] 会更新，这样子再扫到左边的数字的时候，我们就可以直接把 freq[左边数字的 rank] 左边的数字全部加起来，这个和就是左边数字有多少个小于它的数字在右边！</li>
</ol>
</li>
</ol>
<p>下图也有个例子<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-leetcode-315-binary-index-tree.png.png" alt=""></p>
<p>代码参考<a href="https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">这里</a></p>
<p>注意这里的 Fenwick Tree 不是用原来的数组构建的，也不是用 rank 数组构建的。因此可以初始化为 0 数组。<br>然后只需要实现 update 和 query 两个函数就行！<br>之后再随着从右往左扫描 rank 数组，不停地 update 数组并 query 结果！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> &#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n): sums_(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sums_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sums_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sums_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Sort the unique numbers</span></span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sorted</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Map the number to its rank</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ranks;</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> num : sorted)</span><br><span class="line">            ranks[num] = ++rank;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="function">FenwickTree <span class="title">tree</span><span class="params">(ranks.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Scan the numbers in reversed order</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// Chechk how many numbers are smaller than the current number.</span></span><br><span class="line">            ans.push_back(tree.query(ranks[nums[i]] - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// Increse the count of the rank of current number.</span></span><br><span class="line">            tree.update(ranks[nums[i]], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>下面的代码来自 geeksforgeeks，可以得到右边小的数字个数或者左边大的数字个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ implementation of the approach </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to return the sum of arr[0..index] </span></span><br><span class="line"><span class="comment">// This function assumes that the array is preprocessed </span></span><br><span class="line"><span class="comment">// and partial sums of array elements are stored in BITree[] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// Initialize result </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse ancestors of BITree[index] </span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// Add current element of BITree to sum </span></span><br><span class="line">        sum += BITree[index]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move index to parent node in getSum View </span></span><br><span class="line">        index -= index &amp; (-index); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Updates a node in Binary Index Tree (BITree) at given index </span></span><br><span class="line"><span class="comment">// in BITree. The given value 'val' is added to BITree[i] and </span></span><br><span class="line"><span class="comment">// all of its ancestors in tree. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBIT</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Traverse all ancestors and add 'val' </span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= n) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add 'val' to current node of BI Tree </span></span><br><span class="line">        BITree[index] += val; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update index to that of parent in update View </span></span><br><span class="line">        index += index &amp; (-index); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Converts an array to an array with values from 1 to n </span></span><br><span class="line"><span class="comment">// and relative order of smaller and greater elements remains </span></span><br><span class="line"><span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line"><span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Create a copy of arrp[] in temp and sort the temp array </span></span><br><span class="line">    <span class="comment">// in increasing order </span></span><br><span class="line">    <span class="keyword">int</span> temp[n]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        temp[i] = arr[i]; </span><br><span class="line">    sort(temp, temp + n); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse all array elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="comment">// lower_bound() Returns pointer to the first element </span></span><br><span class="line">        <span class="comment">// greater than or equal to arr[i] </span></span><br><span class="line">        arr[i] = lower_bound(temp, temp + n, arr[i]) - temp + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to find smaller_right array </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findElements</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Convert arr[] to an array with values from 1 to n and </span></span><br><span class="line">    <span class="comment">// relative order of smaller and greater elements remains </span></span><br><span class="line">    <span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line">    <span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line">    convert(arr, n); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a BIT with size equal to maxElement+1 (Extra </span></span><br><span class="line">    <span class="comment">// one is used so that elements can be directly be </span></span><br><span class="line">    <span class="comment">// used as index) </span></span><br><span class="line">    <span class="keyword">int</span> BIT[n + <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// To store smaller elements in right side </span></span><br><span class="line">    <span class="comment">// and greater elements on left side </span></span><br><span class="line">    <span class="keyword">int</span> smaller_right[n], greater_left[n]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse all elements from right. </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get count of elements smaller than arr[i] </span></span><br><span class="line">        smaller_right[i] = getSum(BIT, arr[i] - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add current element to BIT </span></span><br><span class="line">        updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Smaller right: "</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print smaller_right array </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; smaller_right[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all left side greater elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get count of elements greater than arr[i] </span></span><br><span class="line">        greater_left[i] = i - getSum(BIT, arr[i]); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add current element to BIT </span></span><br><span class="line">        updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Greater left: "</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print greater_left array </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; greater_left[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span> &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function call </span></span><br><span class="line">    findElements(arr, n); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">Smaller right: 6 1 1 1 0 1 0 </span></span><br><span class="line"><span class="comment">Greater left: 0 1 1 1 4 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="Segment-Tree-线段树"><a href="#Segment-Tree-线段树" class="headerlink" title="Segment Tree 线段树"></a>Segment Tree 线段树</h4><h5 id="线段树定义"><a href="#线段树定义" class="headerlink" title="线段树定义"></a>线段树定义</h5><ol>
<li>线段树（segment tree），顾名思义，是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。</li>
<li>与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。</li>
<li>与树状数组不同的是，线段树不止可以用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。</li>
<li>对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。</li>
</ol>
<p>从数据结构的角度来说，就是用一个完全二叉树来存储对应于其每一个区间(segment)的数据</p>
<h5 id="自下而上的线段树"><a href="#自下而上的线段树" class="headerlink" title="自下而上的线段树"></a>自下而上的线段树</h5><p><mark>这种自下而上的线段树不仅写起来简单，而且运行速度还快得飞起！！！<br>比 naive 自上而下的递归写法高明多了！！！</mark></p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><ol>
<li>自底向上进行：从每一个叶子节点开始，也就是原数组中的每一个元素。沿从叶子节点到根节点的路径向上按层构建。</li>
<li>在构建的每一步中，对应两个子节点的数据将被用来构建应当存储于它们父节点中的值。</li>
<li>每一个中间节点代表它的左右两个子节点对应区间融合过后的大区间所对应的值。</li>
<li>这个融合信息的过程可能依所需要处理的问题不同而不同<ol>
<li>对于保存区间最小值的线段树来说，merge 的过程应为 <code>min()</code> 函数</li>
</ol>
</li>
<li>注意此处我们对于 <code>segTree</code> 数组的索引从 1 开始算起。这样子做，对于数组中的任意节点 <code>i</code>, 其左子节点为 <code>2*i</code>, 右子节点为 <code>2*i + 1</code>, 其父节点为 <code>i/2</code>.</li>
</ol>
<p>算法描述如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">construct(arr):</span><br><span class="line">    n &#x3D; length(arr)</span><br><span class="line">    segTree &#x3D; new int[2*n]     # 新建数组长度为 2*N, 其中第一个位置不会被使用。</span><br><span class="line">    for i from n to 2*n-1:     # 先把原数组放到最后的 N 个位置上。</span><br><span class="line">        segTree[i] &#x3D; arr[i - n]</span><br><span class="line">    for i from n-1 to 1:       # 注意这里 i 最小到 1，因为整个树的根节点的 index 为 1.</span><br><span class="line">        segTree[i] &#x3D; merge(segTree[2*i], segTree[2*i+1])</span><br></pre></td></tr></table></figure>

<p>例如给定一个输入数组 <code>[1, 5, 3, 7, 3, 2, 5, 7]</code>，其对应的最小值线段树如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-1.png" alt=""></p>
<p>上图所示线段树每一个节点代表的区间如下图所示:<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-2.png" alt=""></p>
<p>用数组表示来说，数组 <code>segTree</code> 中每一个位置代表的区间如下:</p>
<blockquote>
<p>segmentTree[1] = arr[0:8)<br>segmentTree[2] = arr[0:4)<br>segmentTree[3] = arr[4:8)<br>segmentTree[4] = arr[0:2)<br>segmentTree[5] = arr[2:4)<br>segmentTree[6] = arr[4:6)<br>segmentTree[7] = arr[6:8)<br>segmentTree[8] = arr[0]<br>segmentTree[9] = arr[1]<br>segmentTree[10] = arr[2]<br>segmentTree[11] = arr[3]<br>segmentTree[12] = arr[4]<br>segmentTree[13] = arr[5]<br>segmentTree[14] = arr[6]<br>segmentTree[15] = arr[7]</p>
</blockquote>
<h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><p>更新一个线段树的过程与上述构造线段树的过程相同。当输入数组中位于i位置的元素被更新时，我们只需从这一元素对应的叶子结点开始，沿二叉树的路径向上更新至更结点即可。显然，这一过程是一个O(logn)的操作。其算法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update(i, value):</span><br><span class="line">    i &#x3D; i + n</span><br><span class="line">    segTree[i] &#x3D; value</span><br><span class="line">    while(i &gt; 1):</span><br><span class="line">        i &#x3D; i &#x2F; 2</span><br><span class="line">        segTree[i] &#x3D; merge(segTree[2 * i], segTree[2 * i + 1])</span><br></pre></td></tr></table></figure>

<h6 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h6><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-1.png" alt=""></p>
<p>对照着上面的图来思考。<br>假设查询的范围是 <code>[left, right]</code> 区间：</p>
<ol>
<li>先把 <code>left</code> 和 <code>right</code> 各自加上 <code>n</code> 变成数组 <code>segTree</code> 的 index.</li>
<li>考虑 <code>left</code> 节点<ol>
<li>如果 <code>left</code> 是奇数，就意味着 <code>left</code> 是其父节点的右子节点，那么我们只能考虑 <code>left</code> 的信息，不能继续查看 <code>left</code> 父节点，因其父节点的左子节点不在范围内。故考虑完 <code>left</code> 信息后可将 <code>left++</code>。</li>
<li>如果 <code>left</code> 是其父节点的左子节点，那么我们不用考虑 <code>left</code> 的信息了，直接查看其父节点信息即可。</li>
</ol>
</li>
<li>考虑 <code>right</code> 节点<ol>
<li>如果 <code>right</code> 是偶数，就意味着 <code>right</code> 是其父节点的左子节点，我们只能考虑 <code>right</code> 的信息，不能继续查看 <code>right</code> 父节点，因其父节点的右子节点不在范围内。故考虑完 <code>right</code> 信息后可将 <code>right--</code>.</li>
</ol>
</li>
<li>上面两部考察完以后，让 <code>left</code> 和 <code>right</code> 分别指向其父节点。然后迭代这三步！</li>
</ol>
<p>以求最小值为例，算法如下，注意这里的区间是双闭区间，即 <code>left</code> 和 <code>right</code> 节点都在范围内，要考虑进去！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">minimum(left, right):</span><br><span class="line">    left &#x3D; left + n</span><br><span class="line">    right &#x3D; right + n</span><br><span class="line">    minimum &#x3D; Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">    while left &lt;&#x3D; right:</span><br><span class="line">        if left is odd:</span><br><span class="line">            minimum &#x3D; min(minimum, segTree[left])</span><br><span class="line">            left &#x3D; left + 1</span><br><span class="line">        if right is even:</span><br><span class="line">            minimum &#x3D; min(minimum, segTree[right])</span><br><span class="line">            right &#x3D; right - 1</span><br><span class="line">        &#x2F;&#x2F; move left and right one level up</span><br><span class="line">        left &#x3D; left &#x2F; 2</span><br><span class="line">        right &#x3D; right &#x2F; 2</span><br></pre></td></tr></table></figure>

<h6 id="n不是2的指数次怎么办"><a href="#n不是2的指数次怎么办" class="headerlink" title="n不是2的指数次怎么办"></a>n不是2的指数次怎么办</h6><p>上面举的例子中 <code>n = 8 = 2^3</code>，形成的二叉树刚好是一个满二叉树。那么当 n 不是 2 的次方时，该如何处理呢？</p>
<p>事实上：</p>
<ol>
<li>这个算法思路适用于所有的 n</li>
<li>当 n 不是 2 的 次方时候，造成的后果仅仅是对应原来数组元素的那些节点不在同一高度而已</li>
<li>而放置原来数组元素的那些节点仍然是叶子节点！</li>
<li>整个树也是一个<mark>完全二叉树</mark>, 注意！不是<mark>满二叉树</mark>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-3.png" alt=""></p>
<p>在上图的例子中，你可以自己计算一下 <code>sum(nums[0,1,2,3,4])</code> 和 <code>sum(nums[1,2,3,4])</code> 就可以发现，上面的算法也可以用于这种情况！</p>
<h5 id="自上而下的线段树"><a href="#自上而下的线段树" class="headerlink" title="自上而下的线段树"></a>自上而下的线段树</h5><p>这个方法介绍来自<a href="https://www.acwing.com/blog/content/372/" target="_blank" rel="noopener">这里</a>.</p>
<p>这个时候仍然是使用数组来存储，这个写法跟自下而上的线段树比起来，写起来复杂一点，运行稍慢。</p>
<p>注意这里我们把根节点的 index 当做 0，而之前是从 1 开始 (index=0 的点没用)。这就导致了</p>
<ol>
<li>left = 2 * node + 1</li>
<li>right = 2 * node + 2</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-4.png" alt=""></p>
<h6 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立范围为a[start]~a[end] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node<span class="comment">/*当前节点*/</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界(即遇到叶子节点时) </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="comment">//直接存储a数组中的值 </span></span><br><span class="line">        tree[node] = a[start];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将建立的区间分成两半 </span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;<span class="comment">//左子节点的下标 </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;<span class="comment">//右子节点的下标 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出左子节点的值(即从节点left开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, left,  start, mid);</span><br><span class="line">        <span class="comment">//求出右子节点的值(即从节点right开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点的职位左子节点的值加上右子节点的值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//从根节点(即节点0)开始建树,建树范围为a[0]~a[size-1]</span></span><br><span class="line">    build(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-5.png" alt=""></p>
<h6 id="update-操作"><a href="#update-操作" class="headerlink" title="update 操作"></a>update 操作</h6><ul>
<li>确定需要改的分支，向下寻找需要修改的节点，再向上修改节点值。</li>
<li>与建树的函数相比，update 函数增加了两个参数 x，val，即把 a[x] 改为 val。</li>
</ul>
<p>例：把a[x]改为 6（代码实现）</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-6.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找到a[x],修改值 </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        a[x] = val;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= start &amp;&amp; x &lt;= mid) &#123;<span class="comment">//如果x在左分支 </span></span><br><span class="line">            update(a, tree, start, mid, x, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果x在右分支 </span></span><br><span class="line">            update(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, x, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上更新值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在主函数中调用：</span><br><span class="line"><span class="comment">//把a[x]改成6</span></span><br><span class="line">update(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-7.png" alt=""></p>
<h6 id="query-操作"><a href="#query-操作" class="headerlink" title="query 操作"></a>query 操作</h6><ul>
<li>向下依次寻找包含在目标区间中的区间，并累加。</li>
<li>与建树的函数相比，queryquery函数增加了两个参数 L，R 即把求 a 的区间 [L,R] 的和。</li>
</ul>
<p>例：求 a[2] + a[3] + … + a[5] 的值（代码实现）</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-8.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若目标区间与当时区间没有重叠,结束递归返回0 </span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; R || <span class="built_in">end</span> &lt; L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标区间包含当时区间,直接返回节点值 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;=start &amp;&amp; <span class="built_in">end</span> &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_left  = query(a, tree, left,  start, mid, L, R);</span><br><span class="line">        <span class="comment">//计算右边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_right = query(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相加即为答案 </span></span><br><span class="line">        <span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在主函数中调用：</span><br><span class="line"><span class="comment">//求区间[2,5]的和</span></span><br><span class="line"><span class="keyword">int</span> ans = query(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ans = %d"</span>, ans);</span><br></pre></td></tr></table></figure>

<p>运行结果是:<br>ans = 29</p>
<h6 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立范围为a[start]~a[end] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node<span class="comment">/*当前节点*/</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界(即遇到叶子节点时) </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="comment">//直接存储a数组中的值 </span></span><br><span class="line">        tree[node] = a[start];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将建立的区间分成两半 </span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;<span class="comment">//左子节点的下标 </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;<span class="comment">//右子节点的下标 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出左子节点的值(即从节点left开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, left,  start, mid);</span><br><span class="line">        <span class="comment">//求出右子节点的值(即从节点right开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点的职位左子节点的值加上右子节点的值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找到a[x],修改值 </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        a[x] = val;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= start &amp;&amp; x &lt;= mid) &#123;<span class="comment">//如果x在左分支 </span></span><br><span class="line">            update(a, tree, left, start, mid, x, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果x在右分支 </span></span><br><span class="line">            update(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, x, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上更新值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求a[L]~a[R]的区间和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若目标区间与当时区间没有重叠,结束递归返回0 </span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; R || <span class="built_in">end</span> &lt; L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标区间包含当时区间,直接返回节点值 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;=start &amp;&amp; <span class="built_in">end</span> &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_left  = query(a, tree, left,  start, mid, L, R);</span><br><span class="line">        <span class="comment">//计算右边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_right = query(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相加即为答案 </span></span><br><span class="line">        <span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//从根节点(即节点0)开始建树,建树范围为a[0]~a[size-1]</span></span><br><span class="line">    build(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把a[x]改成6</span></span><br><span class="line">    update(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">4</span>, <span class="number">6</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间[2,5]的和</span></span><br><span class="line">    <span class="keyword">int</span> ans = query(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ans = %d"</span>, ans); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="本题的线段树解法"><a href="#本题的线段树解法" class="headerlink" title="本题的线段树解法"></a>本题的线段树解法</h5><p>代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        idx += n;</span><br><span class="line">        tree[idx] += val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=idx; i&gt;<span class="number">1</span>; i&gt;&gt;=<span class="number">1</span>) tree[i&gt;&gt;<span class="number">1</span>] = tree[i] + tree[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (l+=n, r+=n+<span class="number">1</span>; l&lt;r; l&gt;&gt;=<span class="number">1</span>, r&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) sum += tree[l++];</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) sum += tree[--r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) temp[i] = a[i];</span><br><span class="line">        sort(temp, temp+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i] = lower_bound(temp, temp+n, a[i]) - temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), N = n+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> result;</span><br><span class="line">        compress(nums);</span><br><span class="line">        <span class="keyword">int</span> tree[N&lt;&lt;<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = query(tree, <span class="number">0</span>, nums[i]<span class="number">-1</span>, N);</span><br><span class="line">            update(tree, nums[i], <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>note:</p>
<ol>
<li>这里的 <code>compress</code> 算法跟之前树状数组的解法那里处理不太一样，这里相同的元素会占用多个 rank, 比如第二名有两个元素，那么下一个就是第四名。而树状数组那里的处理是，相同的元素只会占用一个 rank。</li>
<li></li>
</ol>
<h4 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h4><ul>
<li>TODO: 参考<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76630/Evolve-from-brute-force-to-optimal-a-review-of-all-solutions" target="_blank" rel="noopener">这里</a>的解法6，和<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76729/onlogn-divide-and-conquer-java-solution-based-on-bit-by-bit-comparison" target="_blank" rel="noopener">这里</a>的思路解释</li>
</ul>
<h3 id="Reverse-Pairs-Leetcode-0493"><a href="#Reverse-Pairs-Leetcode-0493" class="headerlink" title="Reverse Pairs Leetcode 0493"></a>Reverse Pairs Leetcode 0493</h3><h3 id="Count-of-Range-Sum-Leetcode-0327"><a href="#Count-of-Range-Sum-Leetcode-0327" class="headerlink" title="Count of Range Sum Leetcode 0327"></a>Count of Range Sum Leetcode 0327</h3><p>[使用 Binary Index Tree 方法]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums[:]</span><br><span class="line">        self.count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            self.initialize(i, nums[i])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(self.nums)+<span class="number">1</span>:</span><br><span class="line">            self.count[i] += val</span><br><span class="line">            i += (i &amp; -i)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diff = val - self.nums[i]</span><br><span class="line">        self.nums[i] = val</span><br><span class="line">        self.initialize(i, diff)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_sum</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            total += self.count[i]</span><br><span class="line">            i -= (i &amp; -i)</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        sum of elements nums[i..j], inclusive.</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.left_sum(j) - self.left_sum(i<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># numArray = NumArray(nums)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(0, 1)</span></span><br><span class="line"><span class="comment"># numArray.update(1, 10)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(1, 2)</span></span><br></pre></td></tr></table></figure>

<p>[C++ using Binary Index Tree]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">bit</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">lower_bit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=<span class="built_in">bit</span>[i];</span><br><span class="line">                i-=lower_bit(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="built_in">bit</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">bit</span>[i]+=val;</span><br><span class="line">                i+=lower_bit(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) : _nums(nums) &#123;</span><br><span class="line">            <span class="built_in">bit</span>.resize(nums.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                add(i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val!=_nums[i])&#123;</span><br><span class="line">                add(i, val-_nums[i]);</span><br><span class="line">                _nums[i]=val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> query(j)-query(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>[使用 Segment Tree C++]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        _segTree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span>*n; i++)&#123;    # 把 nums 数组的 n 个元素依次放到 _segTree 数组的后面 n 个位置</span><br><span class="line">            _segTree[i] = nums[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;    # 自下而上依次填满前面的 n<span class="number">-1</span> 个位置。</span><br><span class="line">            _segTree[i] = _segTree[<span class="number">2</span> * i] + _segTree[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i = i + n;</span><br><span class="line">        <span class="keyword">int</span> dif = val - _segTree[i];</span><br><span class="line">        _segTree[i] = val;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            _segTree[i] += dif;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        j += n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;    <span class="meta"># i 是奇数</span></span><br><span class="line">                res += _segTree[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;    <span class="meta"># j 是偶数</span></span><br><span class="line">                res += _segTree[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            j = j&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _segTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/30/leetcode-string/" itemprop="url">leetcode string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T16:29:46+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/30/leetcode-string/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/30/leetcode-string/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-string-用法"><a href="#C-string-用法" class="headerlink" title="C++ string 用法"></a>C++ string 用法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br></pre></td></tr></table></figure>

<h2 id="特性描述"><a href="#特性描述" class="headerlink" title="特性描述"></a>特性描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;    <span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">s.substr(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// "bcd"</span></span><br><span class="line"></span><br><span class="line">s.append(<span class="string">"h"</span>);    <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">"cd"</span>);    <span class="comment">// 返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br><span class="line"></span><br><span class="line">s.rfind(<span class="string">"cd"</span>);    <span class="comment">// 从后往前找，还是返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)    <span class="comment">// val 转换成 string</span></span><br><span class="line"></span><br><span class="line">stoi(s,p,b)    <span class="comment">// 把字符串s从p开始转换成b进制的int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">os &lt;&lt; i;    <span class="comment">// 把 int 类型传递给 output string stream</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the data is "</span> + os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(<span class="string">"12"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">is &gt;&gt; i;    <span class="comment">// 把 input string steam 传递给 int 类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Python-string-用法"><a href="#Python-string-用法" class="headerlink" title="Python string 用法"></a>Python string 用法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str()    # 数字转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int()    # 浮点数转 int 或者整数字符串转 int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0xA1'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isalpha()    # 判断字符串是否全为字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdigit()    # 判断字符串是否全是数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is_integer()    # 判断浮点数是否为整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># join()    # separator.join(str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.count(substr, start, end)    # 计算 substr 在范围内出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.upper()    # 转大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.lower()    # 转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str[::-1]    # 以让列表反转</span></span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0516-最长回文子序列"><a href="#0516-最长回文子序列" class="headerlink" title="0516 最长回文子序列"></a>0516 最长回文子序列</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p>“bbbab”<br>Output:<br>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划： dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) </span></span><br><span class="line"><span class="comment">otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mat</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            mat[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; s.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                mat[i][i+k] = <span class="built_in">max</span>(s[i] == s[i+k]? <span class="number">2</span> + mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>] : mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>], <span class="built_in">max</span>(mat[i][i+k<span class="number">-1</span>], mat[i+<span class="number">1</span>][i+k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0151-翻转单词"><a href="#0151-翻转单词" class="headerlink" title="0151 翻转单词"></a>0151 翻转单词</h2><p>Given an input string, reverse the string word by word.</p>
<p>Example 1:</p>
<p>Input: “the sky is blue”<br>Output: “blue is sky the”</p>
<p>Example 2:</p>
<p>Input: “  hello world!  “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p>
<p>Example 3:</p>
<p>Input: “a good   example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一：使用 stringstream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is &gt;&gt; temp)&#123;</span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">int</span>(vec.<span class="built_in">size</span>())<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            os&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=os.str();</span><br><span class="line">        ans.resize(ans.<span class="built_in">size</span>()<span class="number">-1</span>);    <span class="comment">// 小技巧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：保证不开辟额外的 vector 来保存各个 word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以先把 leading, trailing 的零和中间过多的 0 给去除掉</span></span><br><span class="line"><span class="comment">然后 resize</span></span><br><span class="line"><span class="comment">然后左右翻转，这个容易，但是这时候每个单词本身也左右翻转了。</span></span><br><span class="line"><span class="comment">需要对每个单词本身左右翻转一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之后呢</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符替换和复制"><a href="#字符替换和复制" class="headerlink" title="字符替换和复制"></a>字符替换和复制</h2><p>删除一个字符串所有的 a, 并且复制所有的 b. 注意，字符数组足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析：先删除 a, 可以利用原来字符串的空间。</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] != <span class="string">'a'</span>)&#123;</span><br><span class="line">        s[n++] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        ++numb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再复制 b, 注意字符串要加长。</span></span><br><span class="line"><span class="comment">//     先计算字符串里有几个 b，得到复制后的长度。</span></span><br><span class="line"><span class="comment">//     然后“倒着”复制 --- 管用技巧。</span></span><br><span class="line"><span class="keyword">int</span> newLength = n + numb;</span><br><span class="line">s[newLength] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = newLength - <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">    s[i--] = s[j];</span><br><span class="line">    <span class="keyword">if</span>(s[j] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        s[i--] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0796-rotate-string"><a href="#0796-rotate-string" class="headerlink" title="0796 rotate string"></a>0796 rotate string</h2><p>We are given two strings, A and B.</p>
<p>A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是个巧妙地解法。避免了尝试去分析到底字符串 A 平移了多少个位置才得到 B.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rotateString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (A+A).<span class="built_in">find</span>(B) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>剑指offer: 表示数值的字符串<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0316-删除重复字符"><a href="#0316-删除重复字符" class="headerlink" title="0316 删除重复字符"></a>0316 删除重复字符</h2><p>[题目]</p>
<ul>
<li>给定一个仅有小写字母的字符串，只能删除一些字符而不能修改字符顺序；</li>
<li>任务是最终的字符串中原先的每种字符只出现一次，并且结果字典序最小。</li>
</ul>
<p>[分析]</p>
<ul>
<li>如果有 ‘a’, 但是 ‘a’ 的左右两边都存在 ‘b’，那么为了字典序较小，我们肯定是保留 ‘a’ 右侧的 ‘a’</li>
<li>但是如果只有 ‘a’ 的左侧有 ‘b’，那么没办法，只能保留左侧的 ‘b’</li>
</ul>
<p>[解法一：贪心法]</p>
<ul>
<li>延缓决定每种字符的位置，让每个位置字符尽可能小<ul>
<li>某字符在原始字符串中最后出现在位置 p, 它必须出现在结果中了</li>
<li>p 位置及其左边有“更小”的字符，则优先选取它们！</li>
</ul>
</li>
<li>细节<ul>
<li>有多个“最小值”，取最左边的，这样子给右边足够的空间</li>
<li>时间复杂度，大于 O(n)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>;    <span class="comment">// 记录每个字符在不在结果中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ) &#123;    <span class="comment">// 没有自动 i++, 需要在函数体里执行这一句</span></span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>( (num[c] == <span class="number">1</span>) &amp;&amp; (!in[c]) )&#123;    <span class="comment">// 这是字符 s[i] 最后一次出现了！并且它还不在 answer 中</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找到双闭区间 s[last...i] 中最小的那个字符，如果有多个，则是最左边那个</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = last; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( (!in[s[j] - <span class="string">'a'</span>]) &amp;&amp; ((x &lt; <span class="number">0</span>) || (s[j] &lt; s[x])) )&#123;</span><br><span class="line">                        x = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                answer += s[x];</span><br><span class="line">                in[s[x] - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[x] == s[i])&#123;    <span class="comment">// 只有当 s[i] 前面所有的不大于它的字符(包括自己喽)都加进去后，才会 i++</span></span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                last = x + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --num[c];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二：优化？]</p>
<ul>
<li>反思<ul>
<li>我们之所以不敢加一个字符，是怕后面出现了比它还小的字符，并且那个小字符的后面还有这个字符</li>
<li>但是如果我们不加，后面没有这个字符了咋办</li>
</ul>
</li>
<li>可以引入“后悔”</li>
<li>用一个“堆栈”临时保存结果字符串<ul>
<li>从栈底到栈顶 对应从左到右</li>
<li>一个字符如果右边还有，可以自由弹出堆栈</li>
<li>一个字符如果右边没有，<mark>卡住堆栈，它以及被它压住的那些元素均不能弹出</mark></li>
<li>字符 x 入栈前，把堆栈里可以弹出的比它大的字符弹出</li>
</ul>
</li>
<li>时间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>; </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            --num[c];</span><br><span class="line">            <span class="keyword">if</span>(!in[c])&#123;</span><br><span class="line">                <span class="keyword">while</span>( (!st.empty()) &amp;&amp; (st.top() &gt; s[i]) &amp;&amp; (num[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>) )&#123;</span><br><span class="line">                    in[st.top() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">                in[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; !st.empty(); st.pop())&#123;</span><br><span class="line">            answer = st.top() + answer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号系列"><a href="#括号系列" class="headerlink" title="括号系列"></a>括号系列</h2><h3 id="0032-最长有效括号"><a href="#0032-最长有效括号" class="headerlink" title="0032 最长有效括号"></a>0032 最长有效括号</h3><p>[题目]</p>
<ul>
<li>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</li>
<li>Example 1<ul>
<li>输入：”(()”</li>
<li>输出：2</li>
</ul>
</li>
<li>Example 2<ul>
<li>输入：”)()())”</li>
<li>输出：4 , 因为最长的子串为 “()()”</li>
</ul>
</li>
</ul>
<p>[方法一：使用 stack]</p>
<ul>
<li>这个题目相当于是 LeetCode 第 20 题 有效的括号 的升级版。</li>
<li>于是可以尝试借助 栈 这个数据结构去解决。</li>
<li>括号相关的问题首先可以尝试使用 栈 这个数据结构去解决，至于原因，想一想应该不难理解，如果进来一个右括号，也就是 ‘)’，它会和之前 最后一次遍历到的左括号 匹配，栈的 先进后出 的特性保证了这一要求。</li>
<li>对于这道题目，因为我们要求的是子串的长度，因此<mark>我们可以考虑在栈中保存 index，这样子我们不仅可以通过 index 找到对应的括号，还可以借此来求长度</mark></li>
<li>我们的思路可以分为下面几步：<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，意味着这并不能和前面遍历过的部分组成合法答案，此时我们只需要把当前 index 入栈即可</li>
<li>如果遇到的是 ‘)’，这时我们就要看栈顶保存的元素了，这里就会有几种情况：<ol>
<li>栈顶保存的是 ‘(‘<ol>
<li>表示当前元素和栈顶元素可以配对，这个时候我们需要把栈顶元素弹出栈，</li>
<li>记录答案则记录当前 index 和弹出配对元素后的新栈顶 index 之间的距离，</li>
<li>这个地方是重点，如果不理解，你可以思考下面两个例子：</li>
<li>“((()()”</li>
<li>“((())”</li>
</ol>
</li>
<li>栈顶保存的是 ‘)’，<ol>
<li>如果是这种情况，表示前面没有可配对的  ‘(‘，我们此时还是需要把当前 index 入栈，原因是</li>
<li>我们确定距离需要知道边界，如果不理解，还是有两个例子供你参考：</li>
<li>“))(())”</li>
<li>“())()()”</li>
</ol>
</li>
<li>栈是空的<ol>
<li>当然在第一种情况中，你弹出栈顶元素后也会使得栈变空，</li>
<li>为了避免这种情况，我们可以在最开始的时候推一个 -1 入栈，这样可以节省我们的判断次数，</li>
<li>并且当栈中的没有元素的时候，我们也可以用这个 -1 来计算当前子串的长度，你可以参考下面这两个例子：</li>
<li>“()”</li>
<li>“()(())”</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>[方法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mystack;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(<span class="number">-1</span>);    <span class="comment">// -1 用于处理边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// mystack.size() &gt; 1 表示栈不为空，而且我们必须保证栈顶元素是 '('</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; mystack.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[mystack.top()] == <span class="string">'('</span>)&#123;</span><br><span class="line">            mystack.pop();    <span class="comment">// 配对的 '(' 出栈</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, i - mystack.top());  <span class="comment">// 记录长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mystack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[方法二：动态规划]<br><mark>这个方法不是很容易理解！要好好体会! 感觉思想很类似求解回文子串的马拉车算法！</mark></p>
<p>我们可以<mark>定义 dp[i] 表示以 s[i] 结尾的最长的括号子串的长度</mark>，思路如下：</p>
<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，因为有效的括号串只能以 ‘)’ 结尾，所以 dp[i] = 0</li>
<li>如果遇到的是 ‘)’，要分情况讨论：<ol>
<li>如果 str[i - 1] 是 ‘(‘，<ol>
<li>那么 dp[i] = dp[i - 2] + 2</li>
</ol>
</li>
<li>如果 str[i - 1] 是 ‘)’，<ol>
<li>则我们需要看以 str[i - 1] 结尾的最长有效括号串 (很明显，它的长度为 dp[i-1])</li>
<li>然后我们要跳过这个括号串，找到它左边那个没有被匹配的字符 s[i - dp[i - 1] - 1]<ol>
<li>如果这个没有被匹配的字符是左括号，那么 s[i] 可以与它搭配成一个左右括号对，因此 <code>dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]</code> <ol>
<li>公式里面的 <code>2</code> 来自于 s[i] 和 s[i - dp[i-1] -1] 形成的括号对</li>
<li>公式右边第三项来自于: 看看当前的序列是否可以和之前匹配的序列链接起来，也就是加上 dp[i - dp[i - 1] - 2]</li>
</ol>
</li>
<li><mark>如果这个没有被匹配的字符是右括号，那么 s[i] 不能与它搭配成一个括号对，dp[i] = 0<ol>
<li>这个结论并没有很明显，你会怀疑，那不能与它搭配就不可以在与之前的搭配吗？</li>
<li>它是个右括号呀！我们跳过以它结尾的最长有效括号串，再找到左边的字符看看是左括号不行吗？？？</li>
<li>不行！！！</li>
<li>为什么呢？因为如果有以 s[i - dp[i-1] - 1] 结尾的最长有效括号串，那么这个括号串一定会和刚才跳过的那个以 s[i-1] 结尾的有效括号串连接起来形成一个更长的有效括号串！</li>
<li>换句话说，因为 dp[i-1] 表示的是以 s[i-1] 结尾的最长的有效括号串，那么我们跳过它之后，左边如果碰到了右括号，那么以这个右括号结尾的最长有效括号串长度为 0，不存在！</li>
<li>不需要再往左边查看了，直接让 dp[i] = 0 即可</mark></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 只需要考虑右括号，左括号对应位置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (sArr[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    <span class="comment">// 前一个位置是 '('，直接配对</span></span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;                      <span class="comment">// 前一个位置是 ')'</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 需要跳过以 sArr[i-1] 结尾的最长的有效括号串找到第一个没有被匹配的位置</span></span><br><span class="line">                <span class="comment">// 如果那个位置是 '('，则可以与 sArr[i] 进行匹配</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; sArr[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    </span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;    <span class="comment">// 没有越界的话就加上</span></span><br><span class="line">                        dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者更简洁的 C++ 代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">longest</span><span class="params">(s.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; i-longest[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-longest[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                longest[i] = longest[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-longest[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?longest[i-longest[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                curMax = <span class="built_in">max</span>(longest[i],curMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>[思路三：双指针法]</p>
<ol>
<li>使用了两个变量 Left 和 Right，分别用来记录到当前位置时左括号和右括号的出现次数。</li>
<li>当遇到左括号时，Left 自增 1，右括号时 Right 自增1。</li>
<li>对于最长有效的括号的子串，一定是左括号等于右括号的情况，此时就可以更新结果 res 了，一旦右括号数量超过左括号数量了，说明当前位置不能组成合法括号子串，Left 和 Right 重置为 0。</li>
<li>但是对于这种情况 “(()” 时，在遍历结束时左右子括号数都不相等，此时没法更新结果 res，但其实正确答案是 2，怎么处理这种情况呢？</li>
<li>答案是再 反向遍历一遍 ，采取类似的机制，稍有不同的是此时若 Left 大于 Right 了，则重置 0，这样就可以涵盖所有情况。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0301-最长合法括号系列"><a href="#0301-最长合法括号系列" class="headerlink" title="0301 最长合法括号系列"></a>0301 最长合法括号系列</h3><p>[题目]<br>给定一个括号序列（可能包括非括号），删除尽可能少的括号，使得剩余括号序列合法，求所有合法最长序列。</p>
<p>[Example]</p>
<ul>
<li>Input: “()())()”</li>
<li>Output: [“()()()”, “(())()”]</li>
</ul>
<p>[解法一思路]</p>
<ul>
<li>动态规划</li>
<li>前 i 个字符，左括号个数比右括号个数多 j 个的最长合法括号序列长度定义为 <code>dp[i][j]</code><ul>
<li>这里的“合法”啥意思？</li>
<li>长度不是指左右括号匹配的长度，而是左括号比右括号多 j 个的括号序列的长度</li>
</ul>
</li>
<li>递归<ul>
<li><code>dp[i][j]</code> = <ul>
<li><code>max(dp[i-1][j], dp[i-1][j-1] + 1) if s[i] == &quot;(&quot;</code>    第二项加 1 是因为要把 s[i] 也包括进来</li>
<li><code>max(dp[i-1][j], dp[i-1][j+1] + 1) if s[i] == &quot;)&quot;</code>    同上！</li>
<li><code>dp[i-1][j] + 1  if s[i] == 其他非括号字母</code></li>
</ul>
</li>
</ul>
</li>
<li>初值<ul>
<li><code>dp[0][0] = 0</code></li>
<li><code>dp[0][x&gt;0] = -infinity</code></li>
</ul>
</li>
<li>“偷懒”记路径<ul>
<li><code>set&lt;string&gt;</code> 记录所有中间字符串</li>
<li>同一个集合里所有的串长度相同</li>
</ul>
</li>
<li>空间优化<ul>
<li><code>dp[i][.]</code> 只与 <code>dp[i-1][.]</code> 有关</li>
<li>滚动数组</li>
</ul>
</li>
</ul>
<p>[解法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">better</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; a, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(b.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> &gt; b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>())&#123;    <span class="comment">// a 元素长度 + 1 大于 b 中元素长度时候，b 被清空</span></span><br><span class="line">            b.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> == b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>();  <span class="comment">// 此时 a 和 b 要 merge 到一起, 因为答案要全部的结果！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">have</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        have[<span class="number">0</span>].insert(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j<span class="number">-1</span>], have[j])) &#123;    <span class="comment">// better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j<span class="number">-1</span>].<span class="built_in">begin</span>(); it != have[j<span class="number">-1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">"("</span>);  <span class="comment">// have[j-1]</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j + <span class="number">1</span>], have[j])) &#123;  <span class="comment">// // better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j+<span class="number">1</span>].<span class="built_in">begin</span>(); it != have[j+<span class="number">1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">")"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator t = have[j].<span class="built_in">begin</span>(); t != have[j].<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">                        temp.insert(*t + s[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    have[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[<span class="number">0</span>].<span class="built_in">begin</span>(); it != have[<span class="number">0</span>].<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            answer.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二: BFS]</p>
<ul>
<li>先把原来的字符串(长度 n)放入一个队列中</li>
<li>每一次循环，从队列中取出一个字符串(长度为 k)，检查其是否合法<ul>
<li>如果合法，则将依次检查队列中剩下的所有元素，看其是否合法</li>
<li>如果不合法，则把这个字符串每个括号位置字符删掉后的结果(一共是 k 个长度为 k-1 的字符串)加到队列中，然后看下一个字符串</li>
</ul>
</li>
<li>所以此处 BFS 的思想是扫完全部的长度为 n 的后，再扫完全部的长度为 n-1 的字符串，etc.</li>
<li><font color="red">TODO: 有一点没有想明白就是它一旦找到一个合法的字符串，就会停止加入新的字符串，并且会把队列当中剩下的所有的合法的字符串放到结果中！我的问题是，它怎么保证结果里面不会同时含有长度为 max_len 的字符串和 max_len-1 的字符串呢？</font><ul>
<li><font color="red">看了 leetcode 讨论区才意识到，确实不会出现这种情况。因为 BFS 的每一层都比上一层的字符串少一个括号！如果你找到了一个结果之后，那么就意味着当前这一层的左括号与右括号匹配，意味着括号数量是偶数！那么队列中存在的下一层的字符串含有的括号数量是奇数！绝对不可能是答案！</font></li>
<li>其实也可以找到答案的时候把长度记录下来，然后队列里的元素拿出来的时候先判断一下长度是否符合，如果不符合，就不需要调用 <code>isValid()</code> 函数了。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(t)) &#123;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] != <span class="string">'('</span> &amp;&amp; t[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">string</span> str = t.substr(<span class="number">0</span>, i) + t.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!visited.count(str)) &#123;</span><br><span class="line">                    q.push(str);</span><br><span class="line">                    visited.insert(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者是使用 <code>unordered_set</code> 的数据结构，可以解决我上面的疑问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; cur&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!cur.empty()) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(a)) res.push_back(a);</span><br><span class="line">                <span class="keyword">if</span> (!res.empty()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] != <span class="string">'('</span> &amp;&amp; a[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    next.insert(a.substr(<span class="number">0</span>, i) + a.substr(i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty()) <span class="keyword">return</span> res;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法三:递归，DFS]</p>
<ul>
<li>这种解法首先统计了<font color="red">多余的</font>半括号的数量，用 cnt1 表示多余的左括号，cnt2 表示多余的右括号。<mark>“多余的”意味着需要把它们删掉，也就是说我们的目标是: 让 cnt1 和 cnt2 降为 0.</mark></li>
<li>因为给定字符串左右括号要么一样多，要么左括号多，要么右括号多，也可能左右括号都多，比如 “)(“。</li>
<li>所以 cnt1 和 cnt2 要么都为0，要么都大于0，要么一个为0，另一个大于0。</li>
<li>好，下面进入递归函数<ul>
<li>首先判断，如果当 cnt1 和 cnt2 都为0时，说明此时左右括号个数相等了，调用 isValid 子函数来判断是否正确，正确的话加入结果 res 中并返回即可。</li>
<li>否则从 start 开始遍历<ul>
<li>这里的变量 start 表示当前递归开始的位置，不需要每次都从头开始，会有大量重复计算。</li>
<li>而且对于多个相同的半括号在一起，只删除第一个，比如 “())”，这里有两个右括号，不管删第一个还是删第二个右括号都2会得到 “()”，没有区别，所以只用算一次就行了，通过和上一个字符比较，如果不相同，说明是第一个右括号，如果相同则直接跳过。</li>
</ul>
</li>
<li>此时来看如果 cnt1 大于0，说明此时左括号多，而如果当前字符正好是左括号的时候，可以删掉当前左括号，继续调用递归，此时 cnt1 的值就应该减1，因为已经删掉了一个左括号。</li>
<li>同理，如果 cnt2 大于0，说明此时右括号多，而如果当前字符正好是右括号的时候，可以删掉当前右括号，继续调用递归，此时 cnt2 的值就应该减1，因为已经删掉了一个右括号，参见代码如下：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1 == <span class="number">0</span>) cnt2++;</span><br><span class="line">                <span class="keyword">else</span> cnt1--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, cnt1, cnt2, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt1, <span class="keyword">int</span> cnt2, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s)) res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt1 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) &#123;    <span class="comment">// 删除左括号以使得 cnt1 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1 - <span class="number">1</span>, cnt2, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt2 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 删除右括号以使得 cnt2 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1, cnt2 - <span class="number">1</span>, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我的思考：</p>
<ol>
<li>这里的思路还是很明确的，计算 cnt1, cnt2 然后想办法删除左右括号来降低 cnt1, cnt2 使得它们都变成 0.</li>
<li>这里其实有一些删除是无意义的，多做了。比如 “(())))((“ 这里 <code>cnt1 = cnt2 = 2</code>，算法会从字符串最左边开始，发现是左括号，然后此时 <code>cnt1=2&gt;0</code> 所以会进入下一层 DFS! 但是这里的 cnt1 =  2 实际上是来自于最右边的两个左括号啊！你删除最左边的没有意义！</li>
<li>所以算法里面实际上是有一些多余的操作的。不过貌似也没有什么好办法去避免这些无意义的操作。</li>
</ol>
<p>[解法四：递归 DFS]</p>
<ul>
<li>本解法跟解法三一样都是 DFS 的思想，但是上面提到，解法三里面有不少操作是没有意义的多余操作</li>
<li>而这里的解法每一步的递归都会得到一个有效的结果！不存在无意义的递归！</li>
<li>思路解析：<ul>
<li>We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter. The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.</li>
<li>To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.</li>
<li>After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.</li>
<li>For this, we keep tracking the last removal position and only remove ‘)’ after that.</li>
<li>Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?<ul>
<li>The answer is: do the same from right to left.</li>
<li>However a cleverer idea is: reverse the string and reuse the code!</li>
</ul>
</li>
</ul>
</li>
<li>我的理解：<ul>
<li>为啥这个算法每次的递归都会产生一个有意义的结果呢？你看它的思路是，从左往右扫，一旦 stack 不满足大于等于 0 的时候（也就是 stack = -1 嘛）会从左边的 prefix 里面删除一个右括号，这样子左边的 prefix 就是一个有意义的结果了啊！</li>
<li>并且它删的时候也特别注意，对于每一段连续的右括号只会删除第一个右括号，保证了不会有重复的结果产生。</li>
<li>它还有一个技巧使用了 {‘(‘, ‘)’} 也特别惊艳！并且它是在 helper 函数最后这么用的，保证了对任何一个子串都会考虑这两种情况！</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> last_i, <span class="keyword">int</span> last_j, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_i; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[<span class="number">0</span>]) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == p[<span class="number">1</span>]) --cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = last_j; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == p[<span class="number">1</span>] &amp;&amp; (j == last_j || s[j] != s[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="comment">// Recursion: last_i = i 因为 i 左边的 prefix 正好是完全匹配的了。</span></span><br><span class="line">                    <span class="comment">// last_j = j 避免产生重复的结果。</span></span><br><span class="line">                    helper(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, p, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              不要小看这个 return.</span></span><br><span class="line"><span class="comment">              能到这里，说明这个字符串 s 在从左往右扫的时候，出现了右括号多于左括号的情况。</span></span><br><span class="line"><span class="comment">              你递归后就会去处理剩下的那部分了，因此不需要再继续往后执行了。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> rev = <span class="built_in">string</span>(s.rbegin(), s.rend());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">'('</span>) helper(rev, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;, res);</span><br><span class="line">        <span class="keyword">else</span> res.push_back(rev);    <span class="comment">// 能到这一步说明这里的 s 是原来的 s 翻转得到的，而这里的 rev 是 s 的翻转，所以就是与原来的顺序相同了！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*上面的两行可以稍微优化一下*/</span></span><br><span class="line">        <span class="comment">// if(cnt == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     res.push_back(p[0] == '(' ? s : rev);</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     if(p[0] == '(') helper(rev, 0, 0, &#123;')', '('&#125;, res);</span></span><br><span class="line">        <span class="comment">//     else res.push_back(rev);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>我突然发现这个算法是最适合没有计算机的时候，如果让你拿一支笔一张纸如何得到所有的结果！我自己试验了一下，真得非常棒！</li>
<li>一个例子 “()())()”<ol>
<li>第一次调用 helper, s = “()())()”</li>
<li>上面的调用会在内层 for loop 里面产生两次调用，一个传递 s = “(())()”，一个传递 “()()()”。并且不会执行外层 for loop 下面的任何语句了。即<ol>
<li>要么不分裂,cnt一直大于等于 0，会跑到外层 for loop 后面语句执行。</li>
<li>要么分裂了，产生了几个递归后直接返回，不会执行外层 for loop 后面的任何语句。</li>
</ol>
</li>
</ol>
</li>
<li>另外我发现上面的算法有一些多余的步骤，所以我修改了一点，参见上面的代码最后。<ol>
<li>主要就是如果 s 刚好是完美匹配了，即不需要删除任何东西，此时 cnt 等于 0，可以直接返回 s 或者 rev.</li>
<li>按照作者的思路，即使完美匹配了，还是会继续对 rev 来一遍操作(虽然操作只是简单地从头到尾遍历了一下每个字符，改变了cnt 的值，但是复杂度也是 O(N) 啊！此处 N 为字符串长度。)</li>
</ol>
</li>
</ol>
<h2 id="字符串全排列-permutation"><a href="#字符串全排列-permutation" class="headerlink" title="字符串全排列 permutation"></a>字符串全排列 permutation</h2><p>[题目]ku<br>给定字符串 S, 设计算法，枚举 S 的全排列。</p>
<p>[代码]<br>当字符串里面的字符互不相等的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;    <span class="comment">// 依次拿 n 之后每个字符与 n 位置交换</span></span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 把后面 i 位置上的字符与当前 n 位置字符交换。</span></span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 恢复回来。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abcde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有重复字符的时候的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDuplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &lt; t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[n] == S[t]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isDuplicate(S, n, i)) <span class="keyword">continue</span>;  <span class="comment">// 检查范围 [n,i) 中是否有元素与 S[i] 一样。</span></span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abbccde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>非递归算法</mark><br>参考 leetcode O(n) time complexity 一文中介绍的 next permutation 题目</p>
<p>[思路]<br>将给定的字符串 S 首先升序排序，然后依次调用 std::next_permutation 直到返回 false, 即完成了非递归的全排列算法。</p>
<h2 id="Permutation-Sequence-lc0060"><a href="#Permutation-Sequence-lc0060" class="headerlink" title="Permutation Sequence lc0060"></a>Permutation Sequence lc0060</h2><p>[题目]</p>
<ol>
<li>The set [1,2,3,…,n] contains a total of n! unique permutations.</li>
<li>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
</li>
<li>Given n and k, return the kth permutation sequence.</li>
<li>Note:<ol>
<li>Given n will be between 1 and 9 inclusive.</li>
<li>Given k will be between 1 and n! inclusive.</li>
</ol>
</li>
<li>Example 1:<ol>
<li>Input: n = 3, k = 3</li>
<li>Output: “213”</li>
</ol>
</li>
<li>Example 2:<ol>
<li>Input: n = 4, k = 9</li>
<li>Output: “2314”</li>
</ol>
</li>
</ol>
<p>[分析二]</p>
<ol>
<li>这个思路是第二次看的时候想出来的，是递归的思路，逐渐找到当前字串的首字母</li>
</ol>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res += (i + <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(res, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> res, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">        sort(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());    <span class="comment">// 这里注意一定要 sort, 使剩下的子串顺序正确！否则会出现比如 "123"，把 '3' 挪到第一位后变成 "321" 的错误（应该是 "312"）。</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> fac = calFactorial(res.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = (k - <span class="number">1</span>) / fac;        <span class="comment">// 看看应该把第几个位置上的数字放到最左边！！！</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; fac &lt;&lt; " " &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        swap(res[<span class="number">0</span>],res[temp]);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] + helper(res.substr(<span class="number">1</span>), k - temp * fac);    <span class="comment">// 递归！！！</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calFactorial</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            ans *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0040-Wildcard-Matching"><a href="#0040-Wildcard-Matching" class="headerlink" title="0040 Wildcard Matching"></a>0040 Wildcard Matching</h2><p>[题目]</p>
<ul>
<li>判断字符串 s 是否与含有通配符 <code>?</code> 和 <code>*</code> 的串 p 匹配。<ul>
<li>其中 <code>?</code> 可以匹配任何的字母</li>
<li>而 <code>*</code> 可以匹配任意长的字母串（包括空串）。</li>
</ul>
</li>
</ul>
<p>[思路一: DP]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    二维DP。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态表示：</span></span><br><span class="line"><span class="comment">    res[i][j] records whether the first i characters of s can be matched by the first j characters of p.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态转移方程：</span></span><br><span class="line"><span class="comment">    res[i][j] = </span></span><br><span class="line"><span class="comment">      1) if p[j] == '?', then res[i][j] = res[i-1][j-1]</span></span><br><span class="line"><span class="comment">      2) if p[j] == '*'  then res[i][j] = true (if exist k in (0,1,...,i) for res[k][j-1]=true, 即p的前j-1个字符可以match某个长度的 s)</span></span><br><span class="line"><span class="comment">                                        = false (if no exist k ...)</span></span><br><span class="line"><span class="comment">      3) if p[j] is small letter, then res[i][j] == res[i-1][j-1] &amp;&amp; (s[i] == p[j]).</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">    优化：</span></span><br><span class="line"><span class="comment">    滚动数组方法</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[i] record whether the first i characters of s can be matched.</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个为啥置为 true 呢，因为初始的 res 数组 res[i] 代表 p 的前面 0 个字符能否 match s 的前 i 个字符。</span></span><br><span class="line">        <span class="comment">// res[0] = true 因为 p 的前面 0 个字符可以匹配 s 的前面 0 个字符。</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="literal">true</span>;                        </span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; p.<span class="built_in">size</span>(); col++)&#123;   <span class="comment">// loop the char of p, each time updates the whole res array</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); row &gt; <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[col] == <span class="string">'?'</span>)</span><br><span class="line">                    res[row] = res[row<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[col] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= row; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res[k]) &#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res[row] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    res[row] = (res[row<span class="number">-1</span>] &amp;&amp; p[col] == s[row<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要 p 当中出现了不是星号的时候，res[0] 就必须改成 false 了</span></span><br><span class="line">            <span class="comment">// 因为此时 p 的前 col+1 个字符就不能匹配上 s 的前 0 个字符了。</span></span><br><span class="line">            <span class="keyword">if</span>(p[col] != <span class="string">'*'</span>)</span><br><span class="line">                res[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个时间复杂度很慢，耗时 500ms, 超过了 5.53% 的提交</li>
<li>可以改成 int array 来实现，速度提高到耗时 160ms, 超过 11.28% 的提交。</li>
</ol>
<p>[思路二：贪心，有点 DFS 思想]</p>
<ul>
<li>这个问题的难点就在于星号的处理，它可以匹配 0 个，1 个，2 个，etc</li>
<li>此处的思路就是，我们先考虑星号匹配 0 个字符的情况，即跳过星号，接着进行匹配。如果发现不行了，就回溯检查，让星号匹配 1 个字符，以此类推。<ul>
<li>可以看出来有点 DFS 思想，和贪心的思想。</li>
</ul>
</li>
<li>代码里面 last_match 实际是表示 <code>s[last_match] == p[starj + 1]</code>, 即 last_match 指向的字符与 starj + 1 指向的字符分别作为开头进行的匹配。它们前面的 prefix 是匹配好的。<ul>
<li>如果 i 和 j 对应的字符不匹配了，就需要把 i 回溯到 last_match + 1 (last_match 同时也加一), 同时 j 也回溯到 lastj + 1</li>
</ul>
</li>
<li>平均时间复杂度可能是 O(M+N)</li>
<li>最坏的时间复杂度为 O(MN)<ul>
<li>eg. s = “aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”, p = <code>&quot;*aaaaaab&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">int</span> last_match = <span class="number">-1</span>, starj = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m)&#123;</span><br><span class="line">        <span class="comment">// 把两个指针都往前移动一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'?'</span>))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发现 '*' 则，只把 p 的指针前移一位。注意如果是多个星号连续出现，则会在这一步移动到最后一个星号。</span></span><br><span class="line">        <span class="comment">// 毕竟连续的星号作用也只相当于一个星号！因此可以只考虑最后一个！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starj = j;</span><br><span class="line">            j++;</span><br><span class="line">            last_match = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starj != <span class="number">-1</span>)&#123;</span><br><span class="line">            j = starj + <span class="number">1</span>;</span><br><span class="line">            last_match++;</span><br><span class="line">            i = last_match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 p 剩下的字符是否都是 *</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>) j++;</span><br><span class="line">    <span class="keyword">return</span> j == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>本来我有个疑问，万一有两个星号怎么办？<ol>
<li>我们只有一个 lastj 记录星号的位置，万一第一个星号我们考虑它匹配 3 个字符，然后后面匹配过程中碰到了第二个星号，我们让 lastj 指向了第二个星号。</li>
<li>这个时候我们没有办法再回到第一个星号考虑让它匹配 4 个，5 个，等字符的情况了啊？</li>
<li>万一正确答案是第一个星号匹配 6 个字符的情况咋办？</li>
</ol>
</li>
<li>举个例子<ol>
<li>s = <code>&quot;abxyzcdecdeijkmn&quot;</code></li>
<li>p = <code>&quot;ab*cde*kmn&quot;</code></li>
</ol>
</li>
<li>事实上，代码是没有问题的<ol>
<li>上面的例子中，我本来是想让第一个星号匹配 “xyzcde”, 第二个星号匹配 “ij”的。</li>
<li>但是，按照代码里面的话，第一个星号在匹配了 “xyz” 后，就走到了第二个星号了，然后把 lastj 指向第二个星号了。这个看起来会有问题，但是代码实际上还是 return true. 即得到了正确的结果！<ul>
<li>为什么呢？</li>
<li>因为这种情况下是存在多解的！</li>
<li>第一个星号可以只匹配 “xyz”，然后第二个星号匹配 “cdeij”。程序找到的就是这个解，因此返回 true.</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="0010-Regular-Expression-Matching"><a href="#0010-Regular-Expression-Matching" class="headerlink" title="0010 Regular Expression Matching"></a>0010 Regular Expression Matching</h2><p>[题目]</p>
<ul>
<li>实现正则表达式匹配<ul>
<li>支持 ‘.’: matches any single character</li>
<li>支持 <code>&#39;*&#39;</code>: matches 0 or more of the preceding element</li>
</ul>
</li>
<li>字符串 s 可能为空，并且只含有小写字母</li>
<li>模式串 p 可能为空，只含有小写字母，<code>.</code> 或者 <code>*</code></li>
<li>原理参见<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Leetcode</a></li>
</ul>
<p><font color='red'>[思路一：分治 Divide and Conquer]</font></p>
<ul>
<li>分治作为一种经典和重要的算法设计思路，是很多解题的出发点，练习分治的能力很重要！</li>
<li>考虑一般 p 和 s 都不为空的情况，从 p 和 s 的头观察：<ul>
<li>如果 p 的第二个字母不是 <code>*</code>，那么<ul>
<li>需要 (1) p[0] 和 s[0] 匹配, 此时 p[0] 可以是 <code>.</code> 或者字母</li>
<li>以及 (2) s.substr(1) 与 p.substr(1) 匹配</li>
</ul>
</li>
<li>如果 p 的第二个字符是 <code>*</code>，需要满足如下两个条件<ul>
<li>一是，p 去掉头两个字符剩下的 p.substr(2) 可以和 s 的某个后缀匹配</li>
<li>二是，p 的前两个字符能匹配 s 剩下的前缀 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 空的 p 只能匹配空字符串</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个字符为 '*'</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举所有能匹配前两个字符的前缀，剩下的部分是子问题</span></span><br><span class="line">        <span class="comment">// 这里用 do-while 而不是 while loop 是为了处理好 match empty prefix 的情况</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s.substring(k), p.substring(<span class="number">2</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k &lt; s.length() &amp;&amp; isMatch(s[k++], p[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>分治的方法不难理解，但是运行效率较慢</li>
<li>假设s的长度是n，p的长度是m，最坏情况下每一层recursion会产生O(n)个递归调用，而recursion的深度是O(m)，按照DFS的复杂度分析公式，时间复杂度高达O(n^m)</li>
</ol>
<p><font color='red'>[思路二：改进分治]</font></p>
<ol>
<li>在分治的过程中，核心的部分是 induction rule 的构建，而对于同一个分治的定义，是可以有不同的 induction rule 的，不同的 induction rule 带来的效率也是不同的。</li>
<li>对于 <code>*</code> 的情况，我们也可以只分成两种情况讨论：匹配空前缀，或者匹配非空前缀。<ol>
<li>如果 <code>*</code> 匹配空前缀，且 s 匹配 p.substr(2)，则 s 与 p 匹配。</li>
<li>如果 <code>*</code> 匹配非空前缀，且 s.substr(1) 匹配 p, 则 s 与 p 匹配。<ol>
<li>注意这种情况下没有改变 p 就传给了子问题，可以进一步匹配 s.substr(1) 的前缀（可为空）。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>改进后的分治每一层 dfs 最多可以产生两个递归调用，时间复杂度减少到了 O(2^m).</li>
</ol>
<p><font color='red'>[方法三：记忆化搜索]</font></p>
<ol>
<li>通过观察现有解决方案来找到效率不高的地方，继续利用对常见数据结构和算法的理解进行优化，是系统解决问题的过程中能够体现出的重要能力之一。</li>
<li>注意到 dfs 在搜索过程中有可能会对完全一样的参数（相同的子问题）计算多次。对于同样的参数，dfs 的计算过程和结果都是完全一致的，所以没有必要做重复的计算。避免重复的计算的方法就是把计算的结果按照 dfs 的参数存下来，这样以后遇到之前计算过得 dfs 时候可以直接放回上一次计算的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="built_in">string</span> p, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; memo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> i == s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            memo[i][j] = helper(s, i, p, j+<span class="number">2</span>, visited, memo) || (i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j, visited, memo));</span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"haha2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        memo[i][j] = i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>, visited, memo);</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  <span class="title">visited</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">memo</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>, visited, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>记忆化搜索只需要对代码做简单的改进，然而运行时间却有巨大的提升（leetcode ~12-20ms）.不同子问题的个数总共有 O(mn) 个，每个子问题只计算一遍。每个子问题的开销不包含任何循环，所以只有 O(1).</li>
<li>总的时间复杂度变成了 O(mn). 这是一个很好地空间换时间的策略。</li>
</ol>
<p><font color='red'>[思路四: 动态规划]</font></p>
<ol>
<li>上述三种方法里<ol>
<li>分治法本质上是在一个图上做一个深度优先搜索</li>
<li>而记忆化搜索本质上是按照这个图的拓扑顺序 (topological order) 的逆序填表。</li>
</ol>
</li>
<li>如果我们能用简单的循环描述出图的拓扑顺序，那么就可以用迭代的形式来完成填表的任务，这就是著名的动态规划。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(sLen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(pLen + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个代码在 leetcode oj 上有 4-8ms 的时间复杂度。</li>
<li>如果使用 C array 的话时间和空间复杂度更好。有时候 leetcode oj 给出 0ms 的运行时间。</li>
</ol>
<p>[思路五：动态规划空间优化]</p>
<ol>
<li>在上面的算法里面，我们是按照一行一行的顺序填表的，每填一行的时候只需要用到下一行的值。</li>
<li>也就是说只需要保存最近 2 行的值就能够完成填表的任务了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> dp[<span class="number">2</span>][pLen + <span class="number">1</span>] &#123;&#123;<span class="literal">false</span>&#125;&#125;;             <span class="comment">// 使用 C type array; 还进行了空间优化。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = dp[i%<span class="number">2</span>][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>[更早的思路：递归 DFS]</p>
<ul>
<li>核心就是看看第二个字符是不是 <code>*</code></li>
<li>分如下情况：<ol>
<li>p 为空<ol>
<li>如果 s 为空，则返回 true</li>
<li>如果 s 不为空，返回 false</li>
</ol>
</li>
<li>p 长度为 1<ol>
<li>若 s 长度为 1，并且 <code>p[0] == s[0] 或者 p[0] == &#39;.&#39;</code></li>
<li>否则返回 false</li>
</ol>
</li>
<li>p[1] 即第二个字符不是 <code>*</code><ol>
<li>若此时 s 为空返回 false</li>
<li>s 不为空的话则比较 s[0] 和 p[0], 并且从各自的第二个字符开始调用递归函数匹配</li>
</ol>
</li>
<li>p[1] 第二个字符为 <code>*</code>，进行下列循环，条件是若s不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配s和去掉前两个字符的p（这样做的原因是假设此时的星号的作用是让前面的字符出现0次，验证是否匹配），若匹配返回 true，否则s去掉首字母（因为此时首字母匹配了，我们可以去掉s的首字母，而p由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。</li>
<li>返回调用递归函数匹配s和去掉前两个字符的p的结果（这么做的原因是处理星号无法匹配的内容，比如 s=”ab”, p=”a<em>b”，直接进入 while 循环后，我们发现 “ab” 和 “b” 不匹配，所以s变成 “b”，那么此时跳出循环后，就到最后的 return 来比较 “b” 和 “b” 了，返回 true。再举个例子，比如 s=””, p=”a</em>“，由于s为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(s, p.substr(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s = s.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>【目的】字符串查找！给定文本串 text 和模式串 pattern, 从文本串 text 中找到模式串 pattern 第一次出现的位置。</li>
<li>【复杂度】KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。</li>
<li>【解释】因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</li>
</ul>
<h3 id="BF与KMP区别"><a href="#BF与KMP区别" class="headerlink" title="BF与KMP区别"></a>BF与KMP区别</h3><ul>
<li>假设当前文本串 text 匹配到 i 位置，模式串 pattern 匹配到 j 位置（模式串的开头与 text 串的 i 位置对齐）。</li>
<li>BF算法做法<ul>
<li>如果当前字符匹配成功，即 text[i+j] == pattern[j]，另 i++, j++, 继续匹配下一个字符；</li>
<li>如果字符匹配失败，即 text[i+j] != pattern[j], 另 i++, j=0, 即失败的情况下，模式串 pattern 相对于文本串 text 向右移动了一位。</li>
</ul>
</li>
<li>KMP 算法做法<ul>
<li>如果当前字符匹配成功，同上，i++, j++, 继续匹配下一个字符</li>
<li>如果匹配失败，另 i 不变，j=next[j](此处 next[j]&lt;=j-1), 即模式串 pattern 相对于文本串 text 向右移动了至少一位(移动的实际位数 j-next[j]&gt;=1)</li>
</ul>
</li>
</ul>
<h3 id="字符串比较机制"><a href="#字符串比较机制" class="headerlink" title="字符串比较机制"></a>字符串比较机制</h3><p>我们的想法是：不要出现回溯！如果已经匹配到了 text 串的 i+j 位置，即使没有匹配成功，接下来也要继续从当前位置匹配下去，不能回溯到 i+1 位置重新开始匹配！</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg" alt="Screen Shot 2019-12-22 at 11.22.19.png"></p>
<p><mark>如上图所示，pattern 串的绿色位置和 text 串的黄色字符不匹配，这个时候我们把 pattern 串往右移动，让 C 那个位置去和 text 串的黄色(就是上面提到的 i+j 位置)去比较！而这么比较的前提是，B 方块与 A 方块一样！这就是说 pattern 串在 d 之前的那一部分的 前缀串A 与 后缀串B 相同！</mark></p>
<h3 id="最大k前缀与k后缀"><a href="#最大k前缀与k后缀" class="headerlink" title="最大k前缀与k后缀"></a>最大k前缀与k后缀</h3><p>因此，问题就转化为如下问题</p>
<ul>
<li>对于模式串 pattern 的位置 j，考察 <mark>p[0]p[1]…p[j-2]p[j-1]</mark>，查找其<mark>最大相等的 k前缀 和 k后缀</mark>。<ul>
<li>注意！计算 next[j] 的时候，考察的字符串是模式串的前 j-1 个字符，与 p[j] 无关。</li>
</ul>
</li>
<li>即：查找满足条件的最大的 k，使得 <mark>p[0]p[1]…p[k-1] = p[j-k]p[j-k+1]…p[j-1]</mark></li>
</ul>
<p>[一个具体的例子如下]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg" alt="Screen Shot 2019-12-22 at 11.45.00.png"></p>
<h3 id="next的递推关系"><a href="#next的递推关系" class="headerlink" title="next的递推关系"></a>next的递推关系</h3><ul>
<li>对于模式串的位置 j, 有 next[j]=k, 即 p[0]p[1]…p[k-1]=p[j-k]p[j-k+1]p[j-1]</li>
<li>则，对于模式串的位置 j+1, 考察 p[j]</li>
<li>若 p[k]==p[j]<ul>
<li>则 next[j+1] = next[j]+1</li>
</ul>
</li>
<li>反之若 p[k]!=p[j]<ul>
<li>记 h=next[k]; 如果 p[h]==p[j], 则 next[j+1]=h+1, 否则重复此过程</li>
</ul>
</li>
</ul>
<p>[相等时候]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg" alt="Screen Shot 2019-12-22 at 11.58.12.png"></p>
<p>[不相等时候的递推]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg" alt="Screen Shot 2019-12-22 at 11.59.13.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 Next 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || <span class="built_in">text</span>[i] == pattern[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            ans = i - n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进一步分析-next"><a href="#进一步分析-next" class="headerlink" title="进一步分析 next"></a>进一步分析 next</h3><ul>
<li>文本串匹配到 i，模式串匹配到 j，此刻若 text[i] != pattern[j]，即失败的情况</li>
<li>若 next[j]=k, 说明模式串应该从 j 滑动到 k 位置；</li>
<li>若此时满足 pattern[j] == pattern[k], 因为 text[i] != pattern[j], 所以 text[i] != pattern[k]<ul>
<li>即 i 和 k 没有匹配，应该继续滑动到 next[k]</li>
<li>换句话，在原始的 next 数组中，若 next[j]=k 并且 pattern[j] == pattern[k], next[j] 可以直接等于 next[k].</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg" alt="Screen Shot 2019-12-22 at 12.37.22.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext2</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == p[k])&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[例子]</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="KMP-时间复杂度"><a href="#KMP-时间复杂度" class="headerlink" title="KMP 时间复杂度"></a>KMP 时间复杂度</h3><ul>
<li>考察模式串的”串头”和主串的对应位置，也就是暴力算法中的 i</li>
<li>不匹配：串头后移，保证尽快结束算法</li>
<li>匹配：串头保持不动，i++, j++, 但一旦发现不匹配，会跳过匹配过的字符(next[j])</li>
<li>最坏的情况，当串头位于 N-M 的位置时候算法才结束</li>
<li>因此，匹配的时间复杂度为 O(N)，算上计算 next 的O(M) 时间，整体时间复杂度 O(M+N)，其实一般就认为是 O(N) 了。</li>
<li>最好情况：当模式串的首字符和其他字符都不相等时，模式串不存在相等的 k前缀和 k后缀，next 数组全为 -1<ul>
<li>一旦匹配失败，模式串直接跳过已经比较的字符。比较次数为 N</li>
</ul>
</li>
<li>最差情况：当模式串的首字符和其他字符全都相等时候，模式串存在最长的 k 前缀和 k后缀，next 数组呈现递增样式: -1, 0, 1, 2, …<ul>
<li>每个周期中 m 1 1 1 …</li>
<li>周期 n/m</li>
<li>总次数：(2 - 1/M) * N &lt; 2N</li>
<li><mark>此时变种KMP 的运行情况比较总次数依然为 N.</mark></li>
</ul>
</li>
</ul>
<h3 id="一个应用-PowerString-问题"><a href="#一个应用-PowerString-问题" class="headerlink" title="一个应用 PowerString 问题"></a>一个应用 PowerString 问题</h3><p>[题目]<br>给定一个长度为 n 的字符串 S，如果存在一个字符串 T，重复若干次 T 能够得到 S，那么，S 叫做周期串，T 叫做 S 的一个周期。请设计一个算法，计算 S 的最小周期。如果不存在周期，返回空串。</p>
<p>[Examples]<br>字符串 abababab 是周期串，abab 和 ab 都是它的周期，其中 ab 是它的最小周期。</p>
<p>[思路]<br>使用 next，限行时间解决问题</p>
<ul>
<li>计算 S 的 next 数组<ul>
<li>记 k = next[length], p = length - k</li>
<li>若 len%p==0，则 p 为最小周期长度，前 p 个字符就是最小周期。</li>
</ul>
</li>
<li>说明<ul>
<li>使用的是经典 KMP 的 next 算法，不是变种的 next 算法</li>
<li>要”多”计算到 length, 即 next[length]</li>
</ul>
</li>
<li>思考：如何证明？<ul>
<li>考察字符串 S 的 k前缀 head 和 k后缀 tail</li>
<li>head 和 tail 的前 p 个字符</li>
<li>head 和 tail 的前 2p 个字符</li>
<li>head 和 tail 的前 3p 个字符</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg" alt="Screen Shot 2019-12-22 at 13.14.24.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPeriod</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;  <span class="comment">// 仿照KMP 求伪 next, next[0] = -1 是哨兵，串首标志</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || p[j+<span class="number">1</span>] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 恢复成逻辑上的 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLast = next[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n % (n-nLast) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-nLast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><ul>
<li>KMP 的 next，实际上是建立了 DFA</li>
<li>DFA: Deterministic Finite Automaton</li>
<li>以当前位置为 DFA 的状态，以模式串的字符为 DFA 的转移条件，建立确定有穷自动机。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg" alt="Screen Shot 2019-12-22 at 13.00.57.png"></p>
<p>具体算法细节请参考：</p>
<p><a href="http://note.youdao.com/noteshare?id=dda1246716d3e1f321ee1b637ad2b413" target="_blank" rel="noopener">KMP算法</a><br><a href="http://note.youdao.com/noteshare?id=13fe90f9adddde21b0d5f8f7880ebc1f" target="_blank" rel="noopener">史上最清楚的 KMP 算法介绍</a></p>
<h2 id="Robin-Karp-字符串匹配算法"><a href="#Robin-Karp-字符串匹配算法" class="headerlink" title="Robin-Karp 字符串匹配算法"></a>Robin-Karp 字符串匹配算法</h2><ul>
<li>核心思想是比较两个字符串的哈希值，而不是逐个字母进行比较。</li>
<li>需要巧妙地设计哈希函数<ul>
<li>比如使用字符串的和来做哈希值，这样就可以使用增量方法来方便计算。比如主串上右移了一位，那么就可以简单的把移调的字母值减掉，加上右移后cover到的那个字母值加上就行了！</li>
</ul>
</li>
</ul>
<h3 id="Longest-Duplicate-Substring-lc1044"><a href="#Longest-Duplicate-Substring-lc1044" class="headerlink" title="Longest Duplicate Substring lc1044"></a>Longest Duplicate Substring lc1044</h3><p>[题目]</p>
<ol>
<li>Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)</li>
<li>Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is “”.)</li>
<li>Example-1<ol>
<li>Input: “banana”</li>
<li>Output: “ana”</li>
</ol>
</li>
<li>Note:<ol>
<li>2 &lt;= S.length &lt;= 10^5</li>
<li>S consists of lowercase English letters.</li>
</ol>
</li>
</ol>
<p>[思路一]</p>
<ol>
<li>这个题目看起来很简单，找就是了！</li>
<li>可以对于长度为 1，2，3，4，… 的情况，一次对每个位置开始的子串考虑，一旦出现重复的，更新最长的子串</li>
<li>其实可以优化一下，从最长的长度往小的长度遍历，这样子第一个找到的重复子串就可以返回了。</li>
<li>！！！ 这个思路毫无疑问超时了！！！</li>
</ol>
<p>[思路二]</p>
<ol>
<li>这个问题其实就做了两个东西<ol>
<li>一个是遍历各种长度的情况</li>
<li>第二个是对于一个特定的长度，如何看这么多子串是否有重复的！</li>
</ol>
</li>
<li>对于第一个问题，上面的思路一用的是从大到小遍历的情况！其实我们可以优化一下，用二分查找啊！！！这样时间复杂度就从 <code>O(N)</code> 优化到 <code>O(logN)</code> 了。</li>
<li>！！！不过，加上这个优化后，还是超时了！！！</li>
</ol>
<p>[思路三]</p>
<ol>
<li>这个思路里面就需要深入到子字符串的比较情况了！具体就是如何设计 hash 算法来快速的比较这么多子串！</li>
<li>同时还要考虑，如何去从源字符串里面去获得这么多子串。</li>
<li>其思路的关键就是<ol>
<li><mark>不需要获得子串，只需要保存hash 值就行了啊！</mark></li>
<li><mark>使用混动的方式去计算 hash 值</mark></li>
</ol>
</li>
</ol>
<p>[思路三代码 - Python 版]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Explanation</span></span><br><span class="line"><span class="comment">#     Binary search the length of longest duplicate substring and call the help function test(L).</span></span><br><span class="line"><span class="comment">#     test(L) slide a window of length L,</span></span><br><span class="line"><span class="comment">#     rolling hash the string in this window,</span></span><br><span class="line"><span class="comment">#     record the seen string in a hashset,</span></span><br><span class="line"><span class="comment">#     and try to find duplicated string.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     I give it a big mod for rolling hash and it should be enough for this problem.</span></span><br><span class="line"><span class="comment">#     Actually there could be hash collision.</span></span><br><span class="line"><span class="comment">#     One solution is to have two different mod for hash.</span></span><br><span class="line"><span class="comment">#     Or we can use a hashmap to record the index of string.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Complexity</span></span><br><span class="line"><span class="comment">#     Binary Search in range 1 and N, so it's O(logN)</span></span><br><span class="line"><span class="comment">#     Rolling hash O(N)</span></span><br><span class="line"><span class="comment">#     Overall O(NlogN)</span></span><br><span class="line"><span class="comment">#     SpaceO(N)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        A = [ord(c) - ord(<span class="string">'a'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> S]</span><br><span class="line">        mod = <span class="number">2</span>**<span class="number">63</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(L)</span>:</span></span><br><span class="line">            p = pow(<span class="number">26</span>, L, mod)</span><br><span class="line">            cur = reduce(<span class="keyword">lambda</span> x, y: (x * <span class="number">26</span> + y) % mod, A[:L], <span class="number">0</span>)</span><br><span class="line">            seen = &#123;cur&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(L, len(S)):</span><br><span class="line">                cur = (cur * <span class="number">26</span> + A[i] - A[i - L] * p) % mod</span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">in</span> seen: <span class="keyword">return</span> i - L + <span class="number">1</span></span><br><span class="line">                seen.add(cur)</span><br><span class="line">        res, lo, hi = <span class="number">0</span>, <span class="number">0</span>, len(S)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            pos = test(mi)</span><br><span class="line">            <span class="keyword">if</span> pos:</span><br><span class="line">                lo = mi</span><br><span class="line">                res = pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> S[res:res + lo]</span><br></pre></td></tr></table></figure>


<p>[思路三的代码 - C++版]</p>
<ol>
<li>Rabin-Karp algorihm can be implemented in C++17 with <code>std::unordered_set&lt;std::string_view&gt;</code> if a custom hasher is supplied. </li>
<li>Check the second code block below for the custom hasher.</li>
<li><code>std::string_view</code> does not copy the whole string and <code>std::unordered_set</code> handles the logic of hashing and comparing <code>std::string_view</code>‘s.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">rabinFingerprint</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::string_view&amp; s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_clear)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pow = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i != s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">                    m_pow = (m_pow * base) % p;</span><br><span class="line">                m_cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">                    m_cur = ((m_cur * base) % p + (c - <span class="string">'a'</span>)) % p;</span><br><span class="line">                m_clear = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_cur = ((<span class="keyword">ssize_t</span>(m_cur) - <span class="keyword">ssize_t</span>(m_pow * (m_first - <span class="string">'a'</span>))) % <span class="keyword">ssize_t</span>(p) + p) % p;</span><br><span class="line">                m_cur = (m_cur * base + (s.back() - <span class="string">'a'</span>)) % p;</span><br><span class="line">            &#125;</span><br><span class="line">            m_first = s.front();</span><br><span class="line">            <span class="keyword">return</span> m_cur;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; m_clear = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> p = <span class="number">19260817</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> base = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> m_clear = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">size_t</span> m_cur;</span><br><span class="line">        <span class="keyword">size_t</span> m_pow;</span><br><span class="line">        <span class="keyword">char</span> m_first;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wrapper</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::string_view&amp; s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_hasher(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rabinFingerprint&amp; m_hasher;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::string_view longest;</span><br><span class="line">        rabinFingerprint hasher;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::string_view, wrapper&gt; <span class="built_in">set</span>&#123;<span class="number">10</span>, wrapper&#123;hasher&#125;&#125;;</span><br><span class="line">        <span class="keyword">size_t</span> beg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">size_t</span> <span class="built_in">end</span> = S.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (beg &lt;= <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> len = beg + (<span class="built_in">end</span> - beg) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != S.<span class="built_in">size</span>() - len + <span class="number">1</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> [it, inserted] = <span class="built_in">set</span>.emplace(S.data() + i, len);</span><br><span class="line">                <span class="keyword">if</span> (!inserted)</span><br><span class="line">                &#123;</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                    longest = *it;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (found)</span><br><span class="line">                beg = len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = len - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">clear</span>();</span><br><span class="line">            hasher.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> &#123;longest.<span class="built_in">begin</span>(), longest.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Boyer-Moore-算法-了解"><a href="#Boyer-Moore-算法-了解" class="headerlink" title="Boyer Moore 算法 (了解)"></a>Boyer Moore 算法 (了解)</h2><ol>
<li>1977年由德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明的字符串匹配算法。</li>
<li>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则<ol>
<li>即 坏字符规则 和 好后缀规则，来决定向右跳跃的距离。</li>
<li>基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</li>
</ol>
</li>
<li>效率很高，构思巧妙，拥有在最坏情况下 O(N) 的时间复杂度。实践中比 KMP 算法的实际效能高。</li>
<li>Ref:<ol>
<li><a href="https://mp.weixin.qq.com/s/7IZTuLrPSuxvFRqsv5PiXQ" target="_blank" rel="noopener">微信公众号:帅地玩编程</a></li>
</ol>
</li>
</ol>
<h2 id="Manacher-算法-了解"><a href="#Manacher-算法-了解" class="headerlink" title="Manacher 算法 (了解)"></a>Manacher 算法 (了解)</h2><h3 id="重心扩展算法"><a href="#重心扩展算法" class="headerlink" title="重心扩展算法"></a>重心扩展算法</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg" alt="Palindrom"></p>
<p>不过要注意，因为字符串可能是奇数长度或者偶数长度，所以我们要考虑的字符串重心有 n+n-1 个。</p>
<h3 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h3><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg" alt="undefined"></p>
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg" alt="undefined"></p>
<h3 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h3><p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p>
<p>例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p>
<h3 id="求每个-P-i"><a href="#求每个-P-i" class="headerlink" title="求每个 P[i]"></a>求每个 P[i]</h3><p>接下来是算法的关键了，它充分利用了回文串的对称性。</p>
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p>
<p>让我们考虑求 P [ i ] 的时候，如下图。</p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg" alt="undefined"></p>
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p>
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p>
<h4 id="超出了-R"><a href="#超出了-R" class="headerlink" title="超出了 R"></a>超出了 R</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg" alt="undefined"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<h4 id="P-i-mirror-遇到了原字符串的左边界"><a href="#P-i-mirror-遇到了原字符串的左边界" class="headerlink" title="P[i_mirror] 遇到了原字符串的左边界"></a>P[i_mirror] 遇到了原字符串的左边界</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<h4 id="i-等于-R"><a href="#i-等于-R" class="headerlink" title="i 等于 R"></a>i 等于 R</h4><p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p>
<h3 id="考虑-C-和-R-的更新"><a href="#考虑-C-和-R-的更新" class="headerlink" title="考虑 C 和 R 的更新"></a>考虑 C 和 R 的更新</h3><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 P 的最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = P[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">//最开始讲的求原字符串下标</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><ul>
<li>另有两个孩子，1 个孩子，0 个孩子的节点个数分别为 n2, n1, n0</li>
<li>所有节点的出度为 2<em>n2+1</em>n1+0*n0</li>
<li>除了根节点，其他所有节点的入度都是 1，从而所有节点的入度为 (n0+n1+n2)-1</li>
<li>总入度等于总出度，2<em>n2+1</em>n1+0*n0 = n2+n1+n0-1</li>
<li>化简得到 n0 - n2 = 1</li>
<li>也就是说二叉树叶子节点数目比拥有两个孩子的节点数目多 1</li>
</ul>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><ul>
<li>无损压缩编码方案</li>
<li>概率高的字符使用较短的编码，概率低的使用较长的编码，从而使得编码后的字符串长度期望最小</li>
<li>Huffman 编码是一种贪心算法：每次总选择两个最小概率的字符节点合并<ul>
<li>称字符出现的次数为频数，则概率约等于频数除以字符总长；因此概率可以用频数代替</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg" alt="Screen Shot 2019-12-22 at 15.13.26.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用数组来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(<span class="keyword">int</span> *pWeight, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; code)</span></span>&#123;</span><br><span class="line">    <span class="comment">// code 传进来时候是空的 vector&lt;vector&lt;char&gt;&gt; 引用，后面会修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * N - <span class="number">1</span>;  <span class="comment">// N个节点的 Huffman 树需要 2N-1 个节点</span></span><br><span class="line">    HuffmanNode* pHuffmanTree = <span class="keyword">new</span> HuffmanNode[m];  <span class="comment">// 在动态内存空间里建立这个 vector</span></span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 建立叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        pHuffmanTree[i].nWeight = pWeight[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次选择权值最小的两个节点，建树</span></span><br><span class="line">    <span class="keyword">for</span>(i = N; i &lt; m; i++)&#123;</span><br><span class="line">        SelectNode(pHuffmanTree, i, s1, s2);  <span class="comment">// 在前 i 个 nodes 里面找到权值最小的两个节点。用过的节点不会被再用。因为用过的节点有 nParent 信息了。</span></span><br><span class="line">        pHuffmanTree[s1].nParent = pHuffmanTree[s2].nParent = i;  <span class="comment">// s1 和 s2 的父节点是 i 节点</span></span><br><span class="line">        pHuffmanTree[i].nLeft = s1;</span><br><span class="line">        pHuffmanTree[i].nRight = s2;</span><br><span class="line">        pHuffmanTree[i].nWeight = pHuffmanTree[s1].nWeight + pHuffmanTree[s2].nWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据建好的 Huffman 树从叶子到根计算每个叶节点的编码</span></span><br><span class="line">    <span class="keyword">int</span> node, nParent;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">// code[i] 就是 node i 的编码！</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; cur = code[i];    <span class="comment">// 此时还是空的 vector</span></span><br><span class="line">        node = i;</span><br><span class="line">        nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        <span class="keyword">while</span>(nParent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHuffmanTree[nParent].nLeft == node)&#123;</span><br><span class="line">                cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            node = nParent;</span><br><span class="line">            nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用指针来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to allocate a new tree node</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node* left, Node* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    node-&gt;ch = ch;</span><br><span class="line">    node-&gt;freq = freq;</span><br><span class="line">    node-&gt;left = left;</span><br><span class="line">    node-&gt;right = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparison object to be used to order the heap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* l, Node* r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// highest priority item has lowest frequency</span></span><br><span class="line">        <span class="keyword">return</span> l-&gt;freq &gt; r-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line"><span class="comment">// in a map.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node* root, <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;huffmanCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        huffmanCode[root-&gt;ch] = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    encode(root-&gt;left, str + <span class="string">"0"</span>, huffmanCode);</span><br><span class="line">    encode(root-&gt;right, str + <span class="string">"1"</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and decode the encoded string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root, <span class="keyword">int</span> &amp;index, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;ch;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str[index] ==<span class="string">'0'</span>)</span><br><span class="line">        decode(root-&gt;left, index, str);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        decode(root-&gt;right, index, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builds Huffman Tree and decode given input text</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHuffmanTree</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// count frequency of appearance of each character</span></span><br><span class="line">    <span class="comment">// and store it in a map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        freq[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a priority queue to store live nodes of</span></span><br><span class="line">    <span class="comment">// Huffman tree;</span></span><br><span class="line">    priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a leaf node for each character and add it</span></span><br><span class="line">    <span class="comment">// to the priority queue.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: freq) &#123;</span><br><span class="line">        pq.push(getNode(pair.first, pair.second, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do till there is more than one node in the queue</span></span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the two nodes of highest priority</span></span><br><span class="line">        <span class="comment">// (lowest frequency) from the queue</span></span><br><span class="line">        Node *left = pq.top(); pq.pop();</span><br><span class="line">        Node *right = pq.top(); pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new internal node with these two nodes</span></span><br><span class="line">        <span class="comment">// as children and with frequency equal to the sum</span></span><br><span class="line">        <span class="comment">// of the two nodes' frequencies. Add the new node</span></span><br><span class="line">        <span class="comment">// to the priority queue.</span></span><br><span class="line">        <span class="keyword">int</span> sum = left-&gt;freq + right-&gt;freq;</span><br><span class="line">        pq.push(getNode(<span class="string">'\0'</span>, sum, left, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root stores pointer to root of Huffman Tree</span></span><br><span class="line">    Node* root = pq.top();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line">    <span class="comment">// in a map. Also prints them</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; huffmanCode;</span><br><span class="line">    encode(root, <span class="string">""</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: huffmanCode) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nOriginal string was :\n"</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print encoded string</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        str += huffmanCode[ch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree again and this time</span></span><br><span class="line">    <span class="comment">// decode the encoded string</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDecoded string is: \n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; (<span class="keyword">int</span>)str.<span class="built_in">size</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">        decode(root, index, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huffman coding algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span> = <span class="string">"Huffman coding is a data compression algorithm."</span>;</span><br><span class="line"></span><br><span class="line">    buildHuffmanTree(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Huffman总结：前缀编码"><a href="#Huffman总结：前缀编码" class="headerlink" title="Huffman总结：前缀编码"></a>Huffman总结：前缀编码</h3><ul>
<li>Huffman编码是<mark>不等长编码</mark><ul>
<li>字符的编码长度不完全相等</li>
</ul>
</li>
<li>不等长编码如果需要译码，必须满足<mark>前缀编码</mark>的条件<ul>
<li>任何一个字符的编码都不是另外一个字符编码的前缀</li>
</ul>
</li>
<li>从Huffman树的角度考虑，就是<mark>所有的待编码元素都位于叶子节点上</mark>！</li>
</ul>
<p>[思考]</p>
<ul>
<li>Huffman 编码是如何解决前缀编码问题的？</li>
<li>实际算法是由多个”小算法”堆砌而成<ul>
<li>空格压缩问题</li>
<li>取数组最大/小的两个数</li>
</ul>
</li>
<li>代码实现中并非直接使用指针形成的二叉树节点，而是实现开辟足够大的缓冲空间(2n+1)，每次从缓冲区获取一个节点，使用数组代替二叉树<ul>
<li>在堆排序，双数组 Trie 树结构等问题中会再次遇到</li>
</ul>
</li>
<li>最后，由于 Huffman 树的节点权值（频数）可能相等，因此对某些文本，Huffman 编码不唯一。<ul>
<li>左赋 1，右赋 0 或者 左赋 0，右赋 1 都可以。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/%5C/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/%5C/">1</a><span class="page-number current">2</span><a class="page-number" href="/%5C/page/3/">3</a><a class="page-number" href="/%5C/page/4/">4</a><a class="extend next" rel="next" href="/%5C/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
