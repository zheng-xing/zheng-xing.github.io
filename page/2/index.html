<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/leetcode-linked-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/08/leetcode-linked-list/" itemprop="url">leetcode linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-08T11:16:04-08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/leetcode-linked-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/08/leetcode-linked-list/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目总体分析"><a href="#题目总体分析" class="headerlink" title="题目总体分析"></a>题目总体分析</h1><p>哎感觉链表的题目基本上都是考你指针操作的细节的。。。<br>算法上都没有特别难的。。</p>
<h1 id="C-相关操作语法"><a href="#C-相关操作语法" class="headerlink" title="C++ 相关操作语法"></a>C++ 相关操作语法</h1><p>TODO</p>
<h1 id="Python-相关操作语法"><a href="#Python-相关操作语法" class="headerlink" title="Python 相关操作语法"></a>Python 相关操作语法</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="翻转单链表"><a href="#翻转单链表" class="headerlink" title="翻转单链表"></a>翻转单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头开始翻</span></span><br><span class="line">ListNode *result = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line">	temp = head-&gt;next;</span><br><span class="line">	head-&gt;next = result;</span><br><span class="line">	result = head;</span><br><span class="line">	head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### TODO 思考：翻转部分链表 leetcode <span class="number">92</span></span><br><span class="line">- 如何找到第 m 个元素和第 n 个元素</span><br><span class="line">- 如何处理前面和后面</span><br><span class="line">    - 保存前面部分最后一个元素</span><br><span class="line">    - 保存后面部分第一个元素</span><br><span class="line">    - 特殊情况？</span><br><span class="line"></span><br><span class="line">### TODO 思考： 每 k 个元素翻转一次 leetcode <span class="number">25</span></span><br><span class="line">- 前面翻好的部分（小链表）</span><br><span class="line">- 要翻转的部分（K 个）</span><br><span class="line">- 后面没处理的部分（小链表）</span><br><span class="line">- 不足 k 个怎么办？</span><br><span class="line"></span><br><span class="line">## 单链表含有环 leetcode <span class="number">0141</span>, <span class="number">0142</span></span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line">- 假设链表起点到圈起点距离是 a，相遇点到圈起点距离是 b</span><br><span class="line">- 那么有</span><br><span class="line">    - slow pointer 走了 a + b</span><br><span class="line">    - fast pointer 走了 a + b + k * n == <span class="number">2</span> * (a+b)</span><br><span class="line">    - 从而 a + b = k * n</span><br><span class="line">- 如何找圈的起点</span><br><span class="line">    - 相遇后，把 slow pointer 拉回链表起点，fast pointer 从相遇点继续走。</span><br><span class="line">    - 注意这个时候两个指针都一步一步的走</span><br><span class="line">    - 这个时候二者会在圈起点相遇！！！</span><br><span class="line">- 如何找圈长</span><br><span class="line">    - 相遇后，slow pointer 再走一圈并统计长度就是圈长。</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head)&#123;</span><br><span class="line">    	ListNode *p1 = head, *p2 = head;</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">    		<span class="keyword">if</span>((!p2) || (p2-&gt;next == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		p2 = p2-&gt;next-&gt;next;</span><br><span class="line">    		p1 = p1-&gt;next;</span><br><span class="line">    	&#125; <span class="keyword">while</span>(p1 != p2);</span><br><span class="line">    	<span class="keyword">for</span>(p1 = head; p1 != p2; p1 = p1-&gt;next, p2 = p2-&gt;next)</span><br><span class="line">    	;</span><br><span class="line">    	<span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个单链表是否相交-leetcode-160"><a href="#两个单链表是否相交-leetcode-160" class="headerlink" title="两个单链表是否相交 leetcode 160"></a>两个单链表是否相交 leetcode 160</h2><p>就是检测是否是 Y 型结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tempA = headA, *tempB = headB;</span><br><span class="line">        <span class="keyword">int</span> lenA, lenB;</span><br><span class="line">        <span class="keyword">for</span>(lenA = <span class="number">0</span>; tempA; tempA = tempA-&gt;next) lenA++;</span><br><span class="line">        <span class="keyword">for</span>(lenB = <span class="number">0</span>; tempB; tempB = tempB-&gt;next) lenB++;</span><br><span class="line">        tempA = headA;</span><br><span class="line">        tempB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; i++) tempA = tempA-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; i++) tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tempA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempA == tempB) <span class="keyword">return</span> tempA;</span><br><span class="line">            tempA = tempA-&gt;next;</span><br><span class="line">            tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复制带随机指针的链表-leetcode-138"><a href="#复制带随机指针的链表-leetcode-138" class="headerlink" title="复制带随机指针的链表 leetcode 138"></a>复制带随机指针的链表 leetcode 138</h2><p>方法一：使用 map&lt;旧地址，新地址&gt;</p>
<p>方法二：不用 map</p>
<ul>
<li>插入：每个旧节点后面插入一个自身的“复本”</li>
<li>复制 random 指针<ul>
<li>一个旧节点 a 的复本是 a-&gt;next</li>
<li>a-&gt;ranom 的复本是 a-&gt;random-&gt;next</li>
<li>新节点的random 指针 a-&gt;next-&gt;random = a-&gt;random-&gt;next (空值单独判断)</li>
</ul>
</li>
<li>拆分<ul>
<li>旧节点链表是奇数项</li>
<li>新节点链表是偶数项<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(RandomListNode *now = head; now; )&#123;</span><br><span class="line">    		RandomListNode *copy = <span class="keyword">new</span> RandomListNode(now-&gt;label);</span><br><span class="line">    		copy-&gt;next = now-&gt;next;</span><br><span class="line">    		now-&gt;next = copy;</span><br><span class="line">    		now = copy-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(RandomListNode *now = head; now; now = now-&gt;next-&gt;next)&#123;</span><br><span class="line">    		now-&gt;next-&gt;random = (now-&gt;random == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : now-&gt;random-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	RandomListNode *h = head-&gt;next, *t = h, *tail = head;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    		tail = tail-&gt;next = t-&gt;next;</span><br><span class="line">    		<span class="keyword">if</span>(!tail)</span><br><span class="line">    		    <span class="keyword">break</span>;</span><br><span class="line">    		t = t-&gt;next = tail-&gt;next;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="链表-partition-leetcode-86"><a href="#链表-partition-leetcode-86" class="headerlink" title="链表 partition leetcode 86"></a>链表 partition leetcode 86</h2><p>链表里存放整数，给定 x 把比 x 小的节点放到比 x 大的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	    ListNode *h1 = <span class="literal">nullptr</span>, *t1 = <span class="literal">nullptr</span>, *h2 = <span class="literal">nullptr</span>, *t2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">for</span>( ; head; head = head-&gt;next)&#123;</span><br><span class="line">	    	<span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">	    		<span class="keyword">if</span>(t1)&#123;    <span class="comment">// 需要看一下是不是 nullptr</span></span><br><span class="line">	    			t1 = t1-&gt;next = head;</span><br><span class="line">	    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    			h1 = t1 = head;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2)&#123;</span><br><span class="line">	    		t2 = t2-&gt;next = head;</span><br><span class="line">	    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    		h2 = t2 = head;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span>(t2) t2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	    <span class="keyword">if</span>(t1) t1-&gt;next = h2;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> h1? h1 : h2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>## </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/leetcode-stack-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/leetcode-stack-queue/" itemprop="url">leetcode stack queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-07T17:23:44-08:00">
                2019-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/leetcode-stack-queue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/07/leetcode-stack-queue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><p>TODO</p>
<h1 id="C-相关语法操作"><a href="#C-相关语法操作" class="headerlink" title="C++ 相关语法操作"></a>C++ 相关语法操作</h1><p>TODO</p>
<p>用自定义 greater 决定最大堆，最小堆。</p>
<h1 id="python-相关语法操作"><a href="#python-相关语法操作" class="headerlink" title="python 相关语法操作"></a>python 相关语法操作</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="用两个队列实现一个栈"><a href="#用两个队列实现一个栈" class="headerlink" title="用两个队列实现一个栈"></a>用两个队列实现一个栈</h2><p>思路：用两个队列来回倒，保证一个队列是空的。<br>用空队列临时存储除队尾外所有元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入栈：维护一个队列是空的。时间复杂度: O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) q1.push(x)</span><br><span class="line">    <span class="keyword">else</span> q2.push(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">出栈：用一个队列临时存放元素。时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pop():</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty())&#123;</span><br><span class="line">    	<span class="keyword">while</span>(q1.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    		q2.push(q1.front());</span><br><span class="line">    		q1.pop();</span><br><span class="line">    	&#125;</span><br><span class="line">    	q1.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 类似操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用两个堆栈实现一个队列"><a href="#用两个堆栈实现一个队列" class="headerlink" title="用两个堆栈实现一个队列"></a>用两个堆栈实现一个队列</h2><p>思路：使用两个堆栈。s1 负责 push, s2 负责 pop.<br>注意这个跟上一个题目不一样，因为不是每次 pop 都需要重新翻一次数据。<br>如果负责 pop 的 s2 里面还有数据的话，可以直接 pop.<br>这样子最终的 amotized complexity is O(1).<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push(x): <span class="comment">//O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// 均摊O(1) 每个元素出入两个栈各一次。</span></span><br><span class="line">    <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">    	<span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">    		s2.push(s1.top());</span><br><span class="line">    		s1.pop();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();</span><br></pre></td></tr></table></figure></p>
<h2 id="支持查找最小值的栈"><a href="#支持查找最小值的栈" class="headerlink" title="支持查找最小值的栈"></a>支持查找最小值的栈</h2><p>题目：一个堆栈除了支持 push, pop 外还要支持一个操作: getMin 得到当前堆栈里所有元素的最小值。</p>
<p>思路一：用两个堆栈，s1 正常使用，s2 在 getMin 的时候使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：用两个堆栈，s1 维护原来的值，s2 维护最小值，他们元素个数一样多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):  <span class="comment">// O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line">    <span class="keyword">if</span>(!s2.empty() &amp;&amp; s2.top() &lt; x) s2.push(s2.top())</span><br><span class="line">    <span class="keyword">else</span> s2.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// O(1)</span></span><br><span class="line">    s1.pop()</span><br><span class="line">    s2.pop()</span><br><span class="line"></span><br><span class="line">getMin:  <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> s2.top()</span><br></pre></td></tr></table></figure>
<h3 id="变型：维护最小值的-queue"><a href="#变型：维护最小值的-queue" class="headerlink" title="变型：维护最小值的 queue"></a>变型：维护最小值的 queue</h3><p>==维护队列单调性！！！==<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用两个双端队里，记录最大值的双端队列保持单调递减性，记录最小值的双端队列保持单调递增性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minque;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxque;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	que.push(val);</span><br><span class="line">	<span class="keyword">while</span> ((!minque.empty()) &amp;&amp; (minque.back() &gt; val))</span><br><span class="line">		minque.pop_back();</span><br><span class="line">	minque.push_back(val);</span><br><span class="line">	<span class="keyword">while</span> ((!maxque.empty()) &amp;&amp; (maxque.back() &lt; val))</span><br><span class="line">		maxque.pop_back();</span><br><span class="line">	maxque.push_back(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value = que.front();</span><br><span class="line">	que.pop();</span><br><span class="line">	<span class="keyword">if</span> (minque.front() == value)</span><br><span class="line">		minque.pop_front();</span><br><span class="line">	<span class="keyword">if</span> (maxque.front() == value)</span><br><span class="line">		maxque.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> minque.front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> maxque.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="直方图中最大面积矩形-leetcode-84"><a href="#直方图中最大面积矩形-leetcode-84" class="headerlink" title="直方图中最大面积矩形 leetcode 84"></a>直方图中最大面积矩形 leetcode 84</h2><p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想还是维持一个单调的栈。</span></span><br><span class="line"><span class="comment">这里栈内元素大小是递增的。一旦来了一个小的元素，那么会把栈顶比此元素大的一个一个 pop 出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = height.size(), area = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexes.empty() &amp;&amp; height[indexes.top()] &gt; height[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[indexes.top()];   <span class="comment">// 以当前栈顶值为高度的矩形，此时右边界已经确定，就是刚扫描到的 height[i]。</span></span><br><span class="line">                indexes.pop();    <span class="comment">// 而左边界就是栈里下面压着的那一个 index. 因为下面压着的 index 那个高度小于它。</span></span><br><span class="line">                <span class="keyword">int</span> l = indexes.empty() ? <span class="number">-1</span> : indexes.top();  </span><br><span class="line">                area = max(area, h * (i - l - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            indexes.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sliding-window-maximum"><a href="#sliding-window-maximum" class="headerlink" title="sliding window maximum"></a>sliding window maximum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dq 只需要保存 k 个内容就可以，这里是保存 index，</span></span><br><span class="line"><span class="comment">此处关键是 dq 保存所有的 k 个 index 吗？</span></span><br><span class="line"><span class="comment">显然不是，它只会保存有用的信息。</span></span><br><span class="line"><span class="comment">什么才是有用的信息？是那些有可能成为 maximum 的点。</span></span><br><span class="line"><span class="comment">这里的操作和之前 0456 - 132 Pattern 解法中的操作类似。</span></span><br><span class="line"><span class="comment">在考虑 num[i] 的时候，把 num[i] 跟 dequeue 的最后一个值(实际是index对应位置的值)比较</span></span><br><span class="line"><span class="comment">如果小于 nums[i]，那么就 pop_back()，直到遇到比 nums[i] 大的</span></span><br><span class="line"><span class="comment">这个操作保证了 dequeue 中的数值一定是递减数列</span></span><br><span class="line"><span class="comment">此时 de.front() 对应的值就是位置 i(含) 之前 k 个值中最大的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">dq 中保存的是 index，所以第8行和第10行用 nums[dq.back()], nums[dq.front()].</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">心得体会</span></span><br><span class="line"><span class="comment">我发现这个用 stack(0456) 或者queue存储 maximum/minimum 的技巧，</span></span><br><span class="line"><span class="comment">对于比较大小或者 max/min 的题目很有效啊。</span></span><br><span class="line"><span class="comment">主要就是 stack/queue 的“两端”是对应的是 current maximum/minimum</span></span><br><span class="line"><span class="comment">可以用O(1)直接找到并作比较。</span></span><br><span class="line"><span class="comment">如果直接在一个范围内找 max 作比较，那就需要 O(n) 去找了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">答案里分析 time complexity 的时候都提到了 amotized O(n)，</span></span><br><span class="line"><span class="comment">这个是因为 for loop 里面那个 while 的次数是变得，可能为 O(1) ，也可能为 O(n).</span></span><br><span class="line"><span class="comment">换个角度，每个元素最多被添加一次pop一次，因此算法复杂度是 amotized O(n).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/leetcode-数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/04/leetcode-数组/" itemprop="url">leetcode 数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-04T21:39:38-08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/04/leetcode-数组/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/04/leetcode-数组/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><pre><code>查找和排序
    二分查找: 貌似都可以使用或者不使用递归！
    元素交换
    排序，中位数
    归并
    位运算
    前缀和的应用
动态规划
排列组合
</code></pre><h1 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h1><h1 id="python-list"><a href="#python-list" class="headerlink" title="python list"></a>python list</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse()</span></span><br><span class="line"><span class="comment"># list_a[::-1]    # 二者都可以让列表反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list_a.sort()    # 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于字典，字符串等数据结构，必须用 sorted 函数</span></span><br><span class="line"><span class="comment"># sorted(iterable[, cmp[, key[, reverse]]])</span></span><br><span class="line">dict_a = &#123;<span class="string">'a'</span> : <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line">sorted(dict_a, key = <span class="keyword">lambda</span> d: d[<span class="number">0</span>])    <span class="comment"># 按照 key 排序，换成 d[1] 就按照 value 排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="局部极小值-leetcode-162"><a href="#局部极小值-leetcode-162" class="headerlink" title="局部极小值 leetcode 162"></a>局部极小值 leetcode 162</h2><p>一个给定的不包含相同元素的整数数组，每个局部极小值的定义是一个值比左右相邻的（如果存在）都小的值。求它的一个局部极小值。</p>
<pre><code>分析：首先要问清楚边界条件如何处理，在这里假定边界条件是比它大的。

这里规定用数组下标 a[1, ..., n]表示那 n 个整数，定义 a[0] = a[n+1] = 无穷大。

递归的思路是，如果子数组 a[p, q] 满足条件 a[p] &lt; a[p-1], a[q] &lt; a[q+1]，则它包含一个局部极小值。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：不使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：使用递归思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[m+<span class="number">1</span>]) <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, m+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数值等于下标的元素"><a href="#数值等于下标的元素" class="headerlink" title="数值等于下标的元素"></a>数值等于下标的元素</h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<p>样例<br>输入：[-3, -1, 1, 3, 5]<br>输出：3</p>
<p>注意:如果不存在，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环有序数组查找元素-leetcode-153"><a href="#循环有序数组查找元素-leetcode-153" class="headerlink" title="循环有序数组查找元素 leetcode 153"></a>循环有序数组查找元素 leetcode 153</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1</p>
<p>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：二分法</span></span><br><span class="line"><span class="comment">找中间一个元素，因为数组有 shift，所以中间元素只有两种可能：</span></span><br><span class="line"><span class="comment">要么在左半段，中间元素数值大于两端的数值；</span></span><br><span class="line"><span class="comment">要么在右半段，中间元素数值小于两端的数值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，有个特殊情况就是如果 shift=0，那么只有一个左半段存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == j) <span class="keyword">return</span> min(nums[i], nums[j]);</span><br><span class="line">        <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, m, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="循环有序数组查找元素-leetcode-154"><a href="#循环有序数组查找元素-leetcode-154" class="headerlink" title="循环有序数组查找元素 leetcode 154"></a>循环有序数组查找元素 leetcode 154</h2><p>TODO</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>【思路】<br>就是动态规划！注意空间复杂度可以不用建立二维数组，只使用两个一维向量就可以了。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>【思路】</p>
<ul>
<li>方法一：其实这一题可以转换为最长公共子序列的问题<ul>
<li>先对数组进行排序</li>
<li>计算排序后数组和原来数组的最长公共子序列，这个就是最长递增的子序列</li>
<li>复杂度为排序的复杂度 = O(nlogn)</li>
</ul>
</li>
<li>方法二：直接用动态规划<ul>
<li>方法很直接</li>
<li>时间复杂度是 O(n^2)</li>
</ul>
</li>
</ul>
<p>[方法三 贪心的算法]<br>这个方法比较难想出来，也难以表达清楚。这里先给出过程如下。</p>
<p>假设原来的序列是 3 4 5 1 2 3 4</p>
<p>逐个考察这些数</p>
<ul>
<li>考察 3 得到 [3]</li>
<li>考察 4 比 3 大，放到后面，得到 [3, 4]</li>
<li>考察 5 比 4 大，放到后面，得到 [3, 4, 5]</li>
<li>考察 1 比 3 还小，替换掉 3, 得到 [1, 4, 5]</li>
<li>考察 2 比 4 还小，替换掉 4， 得到 [1, 2, 5]</li>
<li>考察 3 比 5 还小，替换掉 5， 得到 [1, 2, 3]</li>
<li>考察 4 比 3 大，放到后面，得到 [1, 2, 3, 4]</li>
<li>最终得到的数组长度为 4，那么就代表最长的递增子序列长度为 4.</li>
</ul>
<p><mark>[上面构造的数组的意义]</mark><br>数组 temp 中第 i 个位置的数组 temp[i] 代表原数组中当前能够找到的，长度为 i 的递增子序列中末尾数子最小的是 temp[i].</p>
<p>比如考虑到上面考察到 2 的时候，得到的 temp 数组是 [1, 2, 5].</p>
<ul>
<li>这个 temp 数组中数字 1 表示长度为 1 的递增子序列中末尾数字最小的是 1</li>
<li>这个 temp 数组中数字 2 表示长度为 2 的递增子序列中末尾数字最小的是 2</li>
<li>这个 temp 数组中数字 5 表示长度为 3 的递增子序列中末尾数字最小的是 5</li>
</ul>
<h2 id="第一个缺失的正整数-leetcode-41"><a href="#第一个缺失的正整数-leetcode-41" class="headerlink" title="第一个缺失的正整数 leetcode 41"></a>第一个缺失的正整数 leetcode 41</h2><p>[题目]<br>给一个数组，找到从 1 开始第一个不在里面的正整数。</p>
<p>[例如]<br>输入：[3, 4, -1, 1]<br>输出：2.</p>
<p><mark>循环不变式</mark></p>
<ul>
<li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则钙元素即为所求。</li>
<li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li>
</ul>
<p><mark>利用循环不变式设计算法</mark><br>假定前 i-1 个数已经找到，并且依次存放在 A[1,2,…,i-1]中，继续考察 A[i]:</p>
<ul>
<li>若 A[i]<i 且="" a[i]="">=1, 则 A[i] 在 A[1,2,…,i-1] 中已经出现过，可以直接丢弃。<ul>
<li>若 A[i] 为负，则更应该丢弃它</li>
</ul>
</i></li>
<li>若 A[i]&gt;i 且 A[i] &lt;= N, 则 A[i] 应该位于后面的位置上，则将 A[A[i]] 和 A[i] 交换。<ul>
<li>若 A[i]&gt;=N, 由于缺失数据一定小于 N, 则 A[i] 丢弃</li>
</ul>
</li>
<li>若 A[i]=i, 则 A[i] 位于正确的位置上，则 i 加 1，循环不变式扩大，继续比较后面的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">分析：数组下标从 0 开始，</span><br><span class="line">我们得目的是让 a[i] == i + 1</span><br><span class="line">每次循环</span><br><span class="line">	1. 要么 i+1</span><br><span class="line">	2. 要么 n-1</span><br><span class="line">	3. 要么有一个数被放到正确的位置</span><br><span class="line"></span><br><span class="line">有一点要记住！一旦一个元素被放到正确的位置以后，那么它的位置就不会改变了！</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt; A, int n)&#123;</span><br><span class="line">    	for(int i = 0; i &lt; n; )&#123;</span><br><span class="line">    		if(A[i] == i + 1)&#123;  // A[i]刚好位置正确</span><br><span class="line">    			++i;</span><br><span class="line">    		&#125; else if ((A[i] &lt;= i) || (A[i] &gt; n) || (A[A[i] - 1] == A[i]))&#123;  // 当前元素可以丢掉了！</span><br><span class="line">    			A[i] = A[--n];  // 快速丢弃 A[i]，就是把最后一个元素移过来，同时长度减去一。</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">    			swap(A[i], A[A[i] - 1]);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return n+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元素最大间距-leetcode-164-“maximum-Gap”"><a href="#元素最大间距-leetcode-164-“maximum-Gap”" class="headerlink" title="元素最大间距 leetcode 164 “maximum Gap”"></a>元素最大间距 leetcode 164 “maximum Gap”</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:<br>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.</p>
<p>Example 2:<br>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.</p>
<p>Note:<br>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值x, 最小值y，如果 x==y 答案是0.</span></span><br><span class="line"><span class="comment">把数放进 n+1 个桶。</span></span><br><span class="line"><span class="comment">	每个桶大小是 d = (x-y)/(n+1) 浮点数</span></span><br><span class="line"><span class="comment">	每个桶区间是 [y + i*d, y + (i+1) * d) (i=0, 1, 2, ..., n)</span></span><br><span class="line"><span class="comment">		注意是左闭右开的区间，最后一个桶是双闭区间。</span></span><br><span class="line"><span class="comment">		最小的数在 0 号桶里，最大的数在 n 号桶里。</span></span><br><span class="line"><span class="comment">		第一个桶非空，最后一个桶非空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	【鸽笼原理】中间有空桶，空桶左右两侧肯定有元素。</span></span><br><span class="line"><span class="comment">	最大间隙出现在一个非空桶的最大值和下一个非空桶的最小值之间。</span></span><br><span class="line"><span class="comment">	如何判断数 r 出现在哪个桶里</span></span><br><span class="line"><span class="comment">		(r-y)*(n+1)/(x-y) （整数运算，注意 r==x 时候，答案取 n）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">code is from: https://leetcode.com/problems/maximum-gap/discuss/50644/Pigeon-hole-principle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxE = *max_element(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">int</span> minE = *min_element(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxA(n,INT_MIN);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minA(n,INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">        maxA[index] = max(maxA[index],nums[i]);</span><br><span class="line">        minA[index] = min(minA[index],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        gap = max(gap,minA[i]-prev);</span><br><span class="line">        prev = maxA[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出现一次的数"><a href="#出现一次的数" class="headerlink" title="出现一次的数"></a>出现一次的数</h2><h2 id="出现-3-次的数-leetcode-137"><a href="#出现-3-次的数-leetcode-137" class="headerlink" title="出现 3 次的数 leetcode 137"></a>出现 3 次的数 leetcode 137</h2><p>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,3,2]<br>Output: 3<br>Example 2:</p>
<p>Input: [0,1,0,1,0,1,99]<br>Output: 99</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个思路是最直接，最清晰的！就是把每一个 bit 位分开来看。</span></span><br><span class="line"><span class="comment">把当前 bit 位出现的 1 的总次数除以 3，如果可以整除，</span></span><br><span class="line"><span class="comment">那么最终结果在这个 bit 位上就是 0，如果不能整除，最终结果在这个 bit 位上就是 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To solve this problem using only constant space, you have to rethink how the numbers are being represented in computers -- using bits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you sum the ith bit of all numbers and mod 3, it must be either 0 or 1 due to the constraint of this problem where each number must appear either three times or once. This will be the ith bit of that "single number".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We can improve this based on the previous solution using three bitmask variables:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. ones as a bitmask to represent the ith bit had appeared once.</span></span><br><span class="line"><span class="comment">2. twos as a bitmask to represent the ith bit had appeared twice.</span></span><br><span class="line"><span class="comment">3. threes as a bitmask to represent the ith bit had appeared three times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">When the ith bit had appeared for the third time, clear the ith bit of both ones and twos to 0. The final answer will be the value of ones.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];</span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举一反三的思考"><a href="#举一反三的思考" class="headerlink" title="举一反三的思考"></a>举一反三的思考</h3><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers" target="_blank" rel="external">这里</a> 对于这类题目做了一个 generalization 的总结。</p>
<p>generalization 后题目变成：一个数组里面除了一个数字出现了 p 次，其他所有数字都出现了 k 次，那么请找出这个出现了 p 次的数字。</p>
<p>其思想也是对于每个 bit 位单独考虑，看看 1 出现了多少次保存在 count 中。并且保证 1 在出现了 k 次之后，count 会归零。</p>
<p>对于单独的一个 bit 位置来说<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 32-bit 的数字来说<br><img src="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png" alt="haha"></p>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 2, p = 1</span></span><br><span class="line"><span class="comment">k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 3, p = 1</span></span><br><span class="line"><span class="comment">k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = '11', then k1 = 1, k2 = 1, so we have mask = ~(x1 &amp; x2). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; x2);</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. </span></span><br><span class="line">                    <span class="comment">// If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 5, p = 3</span></span><br><span class="line"><span class="comment">k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = '101', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, x3  = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x3 ^= x2 &amp; x1 &amp; i;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">            x3 &amp;= mask;</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. </span></span><br><span class="line">                    <span class="comment">// If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2 | x3).</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-100-缺少的两个数"><a href="#1-100-缺少的两个数" class="headerlink" title="1-100 缺少的两个数"></a>1-100 缺少的两个数</h2><p>解方程？ 位运算？</p>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>找出超过一半的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">分析：众数出现的次数大于其他所有数出现次数之和。</span><br><span class="line">	每次扔掉两个不同的数，众数不变</span><br><span class="line">		如果扔掉一个众数，和一个非众数</span><br><span class="line">		如果扔掉两个非众数</span><br><span class="line">	如何实现？和 x 不同就扔掉</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int count = 0, x;</span><br><span class="line">for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">	if (count == 0) &#123;</span><br><span class="line">		x = a[i];</span><br><span class="line">		count = 1;</span><br><span class="line">	&#125; else if (x == a[i]) &#123;</span><br><span class="line">		++count;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		--count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意有的题目要数一下 x 出现次数是否确实超过一半（众数可能不存在）。</span><br></pre></td></tr></table></figure>
<p>TODO:<br>思考题：如何找到所有出现次数严格大于总数 1/k 的数？<br>提示：保存(k - 1)个数。<br>如何查找？hash? map?</p>
<h2 id="几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><a href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240" class="headerlink" title="几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240"></a>几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</h2><h3 id="leetcode-0011"><a href="#leetcode-0011" class="headerlink" title="leetcode 0011"></a>leetcode 0011</h3><p>题目：<br>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>
<p>分析：<br>这一题的解法比较巧妙，想通了后就特别简单。</p>
<p>绝妙的思路：<br>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.<br>In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.<br>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by —).</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p><mark>注意：上面划线部分没有细说，但是你必须要搞懂。<br>事实上，如果 2 3 4 5 的高度超过 1，那么由于 1 的高度的限制，水桶的整体高度不会超过 1 的高度。<br>同时又由于 2 3 4 5 距离 1 相对于 6 距离 1 更近，<br>所以<br>(1,2) (1,3) (1,4) (1,5) 肯定小于 (1,6)<br>另一种情形，如果 2 3 4 5 的高度小于 1，那么<br>(1,2) (1,3) (1,4) (1,5) 更小于 (1,6) 了。<br>因此这四种情形都不用计算了！！！！</mark></p>
<p> we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<h3 id="leetcode-0167-Two-Sum-2-Input-array-is-sorted"><a href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted" class="headerlink" title="leetcode 0167 Two Sum 2 Input array is sorted"></a>leetcode 0167 Two Sum 2 Input array is sorted</h3><p>题目：<br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>思路分析：<br>For those of you who are wondering how this works, here is a quick explanation:<br>Each sum is characterized by two indices (i, j), where 0 &lt;= i &lt; j &lt; n with n the length of the input array. If we were to compute them explicitly, we end up with an n-by-n matrix.<br>If the input array is not sorted, to search for the target, there is no good way but comparing it with elements from the above matrix one by one. This is the naive O(n^2) solution. Of course you can use a HashMap to memorize visited elements and cut down the time to O(n) so we have the classic space-time tradeoff.<br>Now if the input array is sorted, the n-by-n summation matrix will have the following properties:<br>Integers in each row are sorted in ascending order from left to right.<br>Integers in each column are sorted in ascending order from top to bottom.<br>To find the target, we do not have to scan the whole matrix now since it exhibits some partial order. We may start from the top-right (or bottom-left) corner, then proceed to the next row or previous column depending on the relationship between the matrix element and the target until either it is found or all rows and columns are exhausted. The key here is that we can get rid of a whole row or column due to the two properties of the matrix specified above.<br>If you have finished leetcode problem “240. Search a 2D Matrix II”, you will find that this is exactly the same problem, except now of the two indices, the first has to be smaller than the second. Time complexity for “leetcode 240” is O(m + n), while for this problem we have m = n, plus the indices constraint so the time complexity will be O(n). Also we do not need the HashMap now so space complexity will be O(1).</p>
<h3 id="leetcode-240-Search-a-2D-Matrix-II"><a href="#leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="leetcode 240 Search a 2D Matrix II"></a>leetcode 240 Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,<br>Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>Given target = 5, return true.<br>Given target = 20, return false.</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We start search the matrix from top right corner, initialize the current position to top right corner, </span></span><br><span class="line"><span class="comment">if the target is greater than the value in current position, then the target can not be in entire row </span></span><br><span class="line"><span class="comment">of current position because the row is sorted, if the target is less than the value in current position, </span></span><br><span class="line"><span class="comment">then the target can not in the entire column because the column is sorted too. </span></span><br><span class="line"><span class="comment">We can rule out one row or one column each time, so the time complexity is O(m+n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; matrix.size() &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[m][n])&#123;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[m][n])&#123;</span><br><span class="line">                --n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p>其实对于二维的也可以分治啊！二维矩阵的中心点把矩阵分成了：左上 A, 右上 B，左下 C，右下 D 这四个小矩阵。</p>
<ol>
<li>根据中心元素 m 和 target 的比较情况<ol>
<li>如果 m &lt; target, 则 target 不可能在 A</li>
<li>如果 m &gt; target, 则 target 不可能在 B</li>
</ol>
</li>
<li>时间复杂度<ol>
<li>T(N) = T(N/2) + T(N/4) +O(1)</li>
<li>不好分析，可能在O(N^0.5) - O(N) 之间，这里 N 是全部的数组元素</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>((x1 &gt; x2) || (y1 &gt; y2))&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> midx = (x1 + x2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> midy = (y1 + y2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(a[midx][midy] == target)&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> (target &lt; a[midx][midy]) ?</span><br><span class="line">    	(find(a, x1, y1, midx - <span class="number">1</span>, y2, target) || find(a, midx, y1, x2, midy - <span class="number">1</span>, target)) :</span><br><span class="line">    	(find(a, x1, midy + <span class="number">1</span>, x2, y2, target) || find(a, midx + <span class="number">1</span>, y1, x2, midy, target)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> m = matrix.size, n = matrix[<span class="number">0</span>].size();</span><br><span class="line">    	<span class="keyword">return</span> find(matrix, <span class="number">0</span>, <span class="number">0</span>, m<span class="number">-1</span>, n<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些题目的 算法复杂度优化 都是转化为矩阵分析。<br>本来要考虑的情况是矩阵的所有元素 O(m * n)，<br>但是每次计算其中一个元素，并做了比较以后，<br>可以排除一整行或者一整列的元素，<br>因此变成了 O(m + n) 的算法。</p>
<h2 id="Trapping-Rain-Water-leetcode-0042"><a href="#Trapping-Rain-Water-leetcode-0042" class="headerlink" title="Trapping Rain Water leetcode 0042"></a>Trapping Rain Water leetcode 0042</h2><p>题目：<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water"></p>
<p>分析：<br>我本来想的是这些水只能 trap 在两个“峰”中间，<br>所以我们可以从左到右找这些峰，<br>然后分别计算中间trap了多少水。<br>这个算法的复杂度也算是O(n),<br>但是实现起来应该比较复杂，<br>主要是在于山峰的寻找上。<br>比如说山峰的判断可以是当前高度大于左右两边，<br>但是如果有当前高度等于左边或者右边怎么办？<br>如果山峰在边界怎么办？<br>都不太好处理。</p>
<p>discuss forum 里面有个好算法<br>没有通过寻找山峰<br>就是分别看每个 bin<br>计算每个 bin 能存储的水量<br>为了达到这个目的<br>算法需要两个变量来记录 maxleft 和 maxright。<br>在保证右边有更高的 bin 的时候，<br>左边每个 bin 保存的水量等于 maxleft 减去 当前高度。<br>同理，<br>在保证左边有更高的 bin 的时候，<br>右边每个 bin 保存的水量等于 maxright 减去当前高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size()<span class="number">-1</span>, res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt;= height[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[left] &gt;= maxleft)&#123;</span><br><span class="line">                    maxleft = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxleft - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right] &gt;= maxright)&#123;</span><br><span class="line">                    maxright = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxright - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中第 10 行和第 17 行对 res 做了改变。</span></span><br><span class="line"><span class="comment">我好奇的是第 10 行用 maxleft 减，</span></span><br><span class="line"><span class="comment">如果 maxleft 大于 maxright的话，不应该拿 maxright 来减吗？？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事实上，maxleft 大于 maxright 的话，</span></span><br><span class="line"><span class="comment">left pointer 肯定指向了 maxleft，</span></span><br><span class="line"><span class="comment">这个时候程序按照逻辑，</span></span><br><span class="line"><span class="comment">会进入到 else 语句（14到19行），</span></span><br><span class="line"><span class="comment">所以达到目的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><mark><br>第 10 行运行的时候 maxleft 一定是小于 maxright，准确说是小于 right pointer 指向的位置的高度 ,<br>第 17 行运行的时候 maxright 一定小于 maxleft，准确说是小于 left pointer 指向的位置的高度。<br>left 或者 right pointer 有一个肯定位于目前浏览到的所有 bin 的最高的那一个，然后保持不动，另外一个 pointer 移动.<br></mark></p>
<h2 id="数组中连续一段和，绝对值最小"><a href="#数组中连续一段和，绝对值最小" class="headerlink" title="数组中连续一段和，绝对值最小"></a>数组中连续一段和，绝对值最小</h2><p>思路：先计算前缀和，然后排序。整体复杂度就是排序的复杂度 O(nlogn).</p>
<h2 id="最大子数组和-leetcode-53"><a href="#最大子数组和-leetcode-53" class="headerlink" title="最大子数组和 leetcode 53"></a>最大子数组和 leetcode 53</h2><p>[题目]<br>一个整数数组，一个非空的子数组（连续一段数），使得它的和最大。</p>
<p>[思路一]<br>暴利枚举。枚举子数组的起点 i，终点 j，计算 [i…j] 的和，时间复杂度为 O(N^3)。</p>
<p>[思路二]<br>聪明枚举。对于每一个起点 i，让 j 从 i+1 开始枚举，一遍枚举一边求和，时间复杂度为 O(N^2)。</p>
<p>[思路三]<br>分治</p>
<ol>
<li>Divide the given array in two halves</li>
<li>Return the maximum of following three<ol>
<li>Maximum subarray sum in left half (Make a recursive call)</li>
<li>Maximum subarray sum in right half (Make a recursive call)</li>
<li>Maximum subarray sum such that the subarray crosses the midpoint</li>
</ol>
</li>
</ol>
<p>The lines 2.1 and 2.2 are simple recursive calls. How to find maximum subarray sum such that the subarray crosses the midpoint? We can easily find the crossing sum in linear time.<br>Suppose the current range is [l, r] and the mid point is “m”.<br>The idea is simple, find the maximum sum starting from mid point “m” and ending at some point on left of mid, then find the maximum sum starting from “m + 1” and ending with sum point on right of “m + 1”. Finally, combine the two and return.</p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr.size() == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> helper(arr, <span class="number">0</span>, arr.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr[l];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = max(helper(arr, l, m), helper(arr, m+<span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">int</span> now = arr[m], may = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">    	may = max(may, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now = may + arr[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">2</span>; i &lt; r; i++)&#123;</span><br><span class="line">    	now = now + arr[i];</span><br><span class="line">    	may = max(may, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(ans, may);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[思路四-DP]</p>
<ol>
<li>dp[i] 表示以 a[i] 结尾的最大子数组的和</li>
<li>dp[i] = max(dp[i-1] + a[i], a[i])</li>
<li>初值 dp[0] = a[0]</li>
<li>答案是 dp 数组里面最大的那个</li>
<li>时间复杂度 O(n)，空间复杂度 O(n)</li>
<li>空间优化：不需要把 dp 数组存储下来<ol>
<li>endHere = max(endHere + a[i], a[i])</li>
<li>answer = max(endHere, answer)</li>
</ol>
</li>
</ol>
<p>[思路五：前缀和]</p>
<ol>
<li>计算前缀和 preSum</li>
<li>i 从 0 遍历到 n-1，保存 preSum[0…i-1] 这 i 个数的最小值 currentMin，当前的 preSum[i] - currentMin</li>
<li>整体的思想就类似于买卖股票一次，求最大的 gain 那道题</li>
<li>时间复杂度跟 DP 一样，都是 O(n).</li>
<li>空间优化：也可以一边求 preSum 一边做第二步，这样子就不需要保存 preSum 这个数组了。</li>
</ol>
<h2 id="Cantor-数组"><a href="#Cantor-数组" class="headerlink" title="Cantor 数组"></a>Cantor 数组</h2><p>[题目]</p>
<p>[思路]</p>
<ul>
<li>观察第一个元素，你就能知道思路了</li>
<li>第一个元素是 3，说明后面的元素中有三个小于这个元素，那么第一个元素只可能是 4 啊！！！</li>
<li>然后依次找到第二个，三个，。。。元素就可以了</li>
</ul>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; CantorRecovery(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); i++)&#123;</span><br><span class="line">		temp.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); j++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(temp[j] &gt; <span class="number">0</span>) k--;</span><br><span class="line">        	<span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        		res.push_back(temp[j]);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="subset-sum"><a href="#subset-sum" class="headerlink" title="subset sum"></a>subset sum</h2><p>[题目]<br>Given a set of positive integers and an integer s, is there any non-empty subset whose sum is s.</p>
<p>[ref]<br><a href="https://www.techiedelight.com/subset-sum-problem/" target="_blank" rel="external">https://www.techiedelight.com/subset-sum-problem/</a></p>
<p>[代码]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">	<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">	<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">	<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">	<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return true if we can get subset by including or excluding the</span></span><br><span class="line">	<span class="comment">// current item</span></span><br><span class="line">	<span class="keyword">return</span> include || exclude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>带记忆的算法代码</mark></p>
<ul>
<li>这里记忆的是：前面 n 个数里面能不能凑出来一个 sum.</li>
<li>算法是从右往前逐个看是否包括每个元素的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a map to store solutions of subproblems</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">	<span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct a unique map key from dynamic elements of the input</span></span><br><span class="line">	<span class="built_in">string</span> key = to_string(n) + <span class="string">"|"</span> + to_string(sum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if sub-problem is seen for the first time, solve it and</span></span><br><span class="line">	<span class="comment">// store its result in a map</span></span><br><span class="line">	<span class="keyword">if</span> (lookup.find(key) == lookup.end())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">		<span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">		<span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">		<span class="comment">// remaining items (n - 1)</span></span><br><span class="line">		<span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// assign true if we can get subset by including or excluding the</span></span><br><span class="line">		<span class="comment">// current item</span></span><br><span class="line">		lookup[key] = include || exclude;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return solution to current sub-problem</span></span><br><span class="line">	<span class="keyword">return</span> lookup[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Input: set of items and a sum</span></span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// number of items</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/30/leetcode-string/" itemprop="url">leetcode string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T00:29:46-08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/30/leetcode-string/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/30/leetcode-string/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-string-用法"><a href="#C-string-用法" class="headerlink" title="C++ string 用法"></a>C++ string 用法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br></pre></td></tr></table></figure>
<h2 id="特性描述"><a href="#特性描述" class="headerlink" title="特性描述"></a>特性描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;    <span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">s.substr(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// "bcd"</span></span><br><span class="line"></span><br><span class="line">s.append(<span class="string">"h"</span>);    <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.find(<span class="string">"cd"</span>);    <span class="comment">// 返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br><span class="line"></span><br><span class="line">s.rfind(<span class="string">"cd"</span>);    <span class="comment">// 从后往前找，还是返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)    <span class="comment">// val 转换成 string</span></span><br><span class="line"></span><br><span class="line">stoi(s,p,b)    <span class="comment">// 把字符串s从p开始转换成b进制的int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">os &lt;&lt; i;    <span class="comment">// 把 int 类型传递给 output string stream</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the data is "</span> + os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(<span class="string">"12"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">is &gt;&gt; i;    <span class="comment">// 把 input string steam 传递给 int 类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="Python-string-用法"><a href="#Python-string-用法" class="headerlink" title="Python string 用法"></a>Python string 用法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str()    # 数字转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int()    # 浮点数转 int 或者整数字符串转 int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0xA1'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isalpha()    # 判断字符串是否全为字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdigit()    # 判断字符串是否全是数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is_integer()    # 判断浮点数是否为整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># join()    # separator.join(str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.count(substr, start, end)    # 计算 substr 在范围内出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.upper()    # 转大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.lower()    # 转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str[::-1]    # 以让列表反转</span></span><br></pre></td></tr></table></figure>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0516-最长回文子序列"><a href="#0516-最长回文子序列" class="headerlink" title="0516 最长回文子序列"></a>0516 最长回文子序列</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p>“bbbab”<br>Output:<br>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划： dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) </span></span><br><span class="line"><span class="comment">otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.size();</span><br><span class="line">        <span class="keyword">if</span>(s.size() == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mat(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; i++)</span><br><span class="line">            mat[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; s.size(); k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt; s.size(); i++)&#123;</span><br><span class="line">                mat[i][i+k] = max(s[i] == s[i+k]? <span class="number">2</span> + mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>] : mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>], max(mat[i][i+k<span class="number">-1</span>], mat[i+<span class="number">1</span>][i+k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][s.size()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0151-翻转单词"><a href="#0151-翻转单词" class="headerlink" title="0151 翻转单词"></a>0151 翻转单词</h2><p>Given an input string, reverse the string word by word.</p>
<p>Example 1:</p>
<p>Input: “the sky is blue”<br>Output: “blue is sky the”</p>
<p>Example 2:</p>
<p>Input: “  hello world!  “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p>
<p>Example 3:</p>
<p>Input: “a good   example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一：使用 stringstream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is &gt;&gt; temp)&#123;</span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vec.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">int</span>(vec.size())<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            os&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=os.str();</span><br><span class="line">        ans.resize(ans.size()<span class="number">-1</span>);    <span class="comment">// 小技巧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：保证不开辟额外的 vector 来保存各个 word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以先把 leading, trailing 的零和中间过多的 0 给去除掉</span></span><br><span class="line"><span class="comment">然后 resize</span></span><br><span class="line"><span class="comment">然后左右翻转，这个容易，但是这时候每个单词本身也左右翻转了。</span></span><br><span class="line"><span class="comment">需要对每个单词本身左右翻转一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之后呢</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="字符替换和复制"><a href="#字符替换和复制" class="headerlink" title="字符替换和复制"></a>字符替换和复制</h2><p>删除一个字符串所有的 a, 并且复制所有的 b. 注意，字符数组足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析：先删除 a, 可以利用原来字符串的空间。</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[i] != <span class="string">'a'</span>)&#123;</span><br><span class="line">		s[n++] = s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)&#123;</span><br><span class="line">		++numb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再复制 b, 注意字符串要加长。</span></span><br><span class="line"><span class="comment">//     先计算字符串里有几个 b，得到复制后的长度。</span></span><br><span class="line"><span class="comment">//     然后“倒着”复制 --- 管用技巧。</span></span><br><span class="line"><span class="keyword">int</span> newLength = n + numb;</span><br><span class="line">s[newLength] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = newLength - <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">	s[i--] = s[j];</span><br><span class="line">	<span class="keyword">if</span>(s[j] == <span class="string">'b'</span>)&#123;</span><br><span class="line">		s[i--] = <span class="string">'b'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0796-rotate-string"><a href="#0796-rotate-string" class="headerlink" title="0796 rotate string"></a>0796 rotate string</h2><p>We are given two strings, A and B.</p>
<p>A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是个巧妙地解法。避免了尝试去分析到底字符串 A 平移了多少个位置才得到 B.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rotateString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (A+A).find(B) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>剑指offer: 表示数值的字符串<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0010-regular-expression-matching-正则表达式"><a href="#0010-regular-expression-matching-正则表达式" class="headerlink" title="0010 regular expression matching 正则表达式"></a>0010 regular expression matching 正则表达式</h2><h2 id="0044-wildcard-matching-通配符匹配"><a href="#0044-wildcard-matching-通配符匹配" class="headerlink" title="0044 wildcard matching 通配符匹配"></a>0044 wildcard matching 通配符匹配</h2><h2 id="字符串全排列-permutation"><a href="#字符串全排列-permutation" class="headerlink" title="字符串全排列 permutation"></a>字符串全排列 permutation</h2><p>[题目]<br>给定字符串 S, 设计算法，枚举 S 的全排列。</p>
<p>[代码]<br>当字符串里面的字符互不相等的时候。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == size<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++)&#123;    <span class="comment">// 依次拿 n 之后每个字符与 n 位置交换</span></span><br><span class="line">		swap(a[i], a[n]);    <span class="comment">// 把后面 i 位置上的字符与当前 n 位置字符交换。</span></span><br><span class="line">		Permutation(a, size, n+<span class="number">1</span>);</span><br><span class="line">		swap(a[i], a[n]);    <span class="comment">// 恢复回来。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> S = <span class="string">"abcde"</span>;</span><br><span class="line">	Permutation(S, S.size(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有重复字符的时候的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDuplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(n &lt; t)&#123;</span><br><span class="line">		<span class="keyword">if</span>(S[n] == S[t]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; S, <span class="keyword">int</span> size, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == size<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isDuplicate(S, n, i)) <span class="keyword">continue</span>;  <span class="comment">// 检查范围 [n,i) 中是否有元素与 S[i] 一样。</span></span><br><span class="line">		swap(a[i], a[n]);</span><br><span class="line">		Permutation(a, size, n+<span class="number">1</span>);</span><br><span class="line">		swap(a[i], a[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> S = <span class="string">"abbccde"</span>;</span><br><span class="line">	Permutation(S, S.size(), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark>非递归算法</mark><br>参考 leetcode O(n) time complexity 一文中介绍的 next permutation 题目</p>
<p>[思路]<br>将给定的字符串 S 首先升序排序，然后依次调用 std::next_permutation 直到返回 false, 即完成了非递归的全排列算法。</p>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>【目的】字符串查找！给定文本串 text 和模式串 pattern, 从文本串 text 中找到模式串 pattern 第一次出现的位置。</li>
<li>【复杂度】KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。</li>
<li>【解释】因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</li>
</ul>
<h3 id="BF与KMP区别"><a href="#BF与KMP区别" class="headerlink" title="BF与KMP区别"></a>BF与KMP区别</h3><ul>
<li>假设当前文本串 text 匹配到 i 位置，模式串 pattern 匹配到 j 位置（模式串的开头与 text 串的 i 位置对齐）。</li>
<li>BF算法做法<ul>
<li>如果当前字符匹配成功，即 text[i+j] == pattern[j]，另 i++, j++, 继续匹配下一个字符；</li>
<li>如果字符匹配失败，即 text[i+j] != pattern[j], 另 i++, j=0, 即失败的情况下，模式串 pattern 相对于文本串 text 向右移动了一位。</li>
</ul>
</li>
<li>KMP 算法做法<ul>
<li>如果当前字符匹配成功，同上，i++, j++, 继续匹配下一个字符</li>
<li>如果匹配失败，另 i 不变，j=next<a href="此处 next[j]&lt;=j-1">j</a>, 即模式串 pattern 相对于文本串 text 向右移动了至少一位(移动的实际位数 j-next[j]&gt;=1)</li>
</ul>
</li>
</ul>
<h3 id="字符串比较机制"><a href="#字符串比较机制" class="headerlink" title="字符串比较机制"></a>字符串比较机制</h3><p>我们的想法是：不要出现回溯！如果已经匹配到了 text 串的 i+j 位置，即使没有匹配成功，接下来也要继续从当前位置匹配下去，不能回溯到 i+1 位置重新开始匹配！</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg" alt="Screen Shot 2019-12-22 at 11.22.19.png"></p>
<p><mark>如上图所示，pattern 串的绿色位置和 text 串的黄色字符不匹配，这个时候我们把 pattern 串往右移动，让 C 那个位置去和 text 串的黄色(就是上面提到的 i+j 位置)去比较！而这么比较的前提是，B 方块与 A 方块一样！这就是说 pattern 串在 d 之前的那一部分的 前缀串A 与 后缀串B 相同！</mark></p>
<h3 id="最大k前缀与k后缀"><a href="#最大k前缀与k后缀" class="headerlink" title="最大k前缀与k后缀"></a>最大k前缀与k后缀</h3><p>因此，问题就转化为如下问题</p>
<ul>
<li>对于模式串 pattern 的位置 j，考察 <mark>p[0]p[1]…p[j-2]p[j-1]</mark>，查找其<mark>最大相等的 k前缀 和 k后缀</mark>。<ul>
<li>注意！计算 next[j] 的时候，考察的字符串是模式串的前 j-1 个字符，与 p[j] 无关。</li>
</ul>
</li>
<li>即：查找满足条件的最大的 k，使得 <mark>p[0]p[1]…p[k-1] = p[j-k]p[j-k+1]…p[j-1]</mark></li>
</ul>
<p>[一个具体的例子如下]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg" alt="Screen Shot 2019-12-22 at 11.45.00.png"></p>
<h3 id="next的递推关系"><a href="#next的递推关系" class="headerlink" title="next的递推关系"></a>next的递推关系</h3><ul>
<li>对于模式串的位置 j, 有 next[j]=k, 即 p[0]p[1]…p[k-1]=p[j-k]p[j-k+1]p[j-1]</li>
<li>则，对于模式串的位置 j+1, 考察 p[j]</li>
<li>若 p[k]==p[j]<ul>
<li>则 next[j+1] = next[j]+1</li>
</ul>
</li>
<li>反之若 p[k]!=p[j]<ul>
<li>记 h=next[k]; 如果 p[h]==p[j], 则 next[j+1]=h+1, 否则重复此过程</li>
</ul>
</li>
</ul>
<p>[相等时候]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg" alt="Screen Shot 2019-12-22 at 11.58.12.png"></p>
<p>[不相等时候的递推]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg" alt="Screen Shot 2019-12-22 at 11.59.13.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 Next 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = p.size();</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">		<span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">			++j;</span><br><span class="line">			++k;</span><br><span class="line">			next[j] = k;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = pattern.size();</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j == <span class="number">-1</span> || text[i] == pattern[j])&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">			ans = i - n;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进一步分析-next"><a href="#进一步分析-next" class="headerlink" title="进一步分析 next"></a>进一步分析 next</h3><ul>
<li>文本串匹配到 i，模式串匹配到 j，此刻若 text[i] != pattern[j]，即失败的情况</li>
<li>若 next[j]=k, 说明模式串应该从 j 滑动到 k 位置；</li>
<li>若此时满足 pattern[j] == pattern[k], 因为 text[i] != pattern[j], 所以 text[i] != pattern[k]<ul>
<li>即 i 和 k 没有匹配，应该继续滑动到 next[k]</li>
<li>换句话，在原始的 next 数组中，若 next[j]=k 并且 pattern[j] == pattern[k], next[j] 可以直接等于 next[k].</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg" alt="Screen Shot 2019-12-22 at 12.37.22.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext2</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = p.size();</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">		<span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">			++j;</span><br><span class="line">			++k;</span><br><span class="line">			<span class="keyword">if</span>(p[j] == p[k])&#123;</span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			    next[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[例子]</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<h3 id="KMP-时间复杂度"><a href="#KMP-时间复杂度" class="headerlink" title="KMP 时间复杂度"></a>KMP 时间复杂度</h3><ul>
<li>考察模式串的”串头”和主串的对应位置，也就是暴力算法中的 i</li>
<li>不匹配：串头后移，保证尽快结束算法</li>
<li>匹配：串头保持不动，i++, j++, 但一旦发现不匹配，会跳过匹配过的字符(next[j])</li>
<li>最坏的情况，当串头位于 N-M 的位置时候算法才结束</li>
<li>因此，匹配的时间复杂度为 O(N)，算上计算 next 的O(M) 时间，整体时间复杂度 O(M+N)，其实一般就认为是 O(N) 了。</li>
<li>最好情况：当模式串的首字符和其他字符都不相等时，模式串不存在相等的 k前缀和 k后缀，next 数组全为 -1<ul>
<li>一旦匹配失败，模式串直接跳过已经比较的字符。比较次数为 N</li>
</ul>
</li>
<li>最差情况：当模式串的首字符和其他字符全都相等时候，模式串存在最长的 k 前缀和 k后缀，next 数组呈现递增样式: -1, 0, 1, 2, …<ul>
<li>每个周期中 m 1 1 1 …</li>
<li>周期 n/m</li>
<li>总次数：(2 - 1/M) * N &lt; 2N</li>
<li><mark>此时变种KMP 的运行情况比较总次数依然为 N.</mark></li>
</ul>
</li>
</ul>
<h3 id="一个应用-PowerString-问题"><a href="#一个应用-PowerString-问题" class="headerlink" title="一个应用 PowerString 问题"></a>一个应用 PowerString 问题</h3><p>[题目]<br>给定一个长度为 n 的字符串 S，如果存在一个字符串 T，重复若干次 T 能够得到 S，那么，S 叫做周期串，T 叫做 S 的一个周期。请设计一个算法，计算 S 的最小周期。如果不存在周期，返回空串。</p>
<p>[Examples]<br>字符串 abababab 是周期串，abab 和 ab 都是它的周期，其中 ab 是它的最小周期。</p>
<p>[思路]<br>使用 next，限行时间解决问题</p>
<ul>
<li>计算 S 的 next 数组<ul>
<li>记 k = next[length], p = length - k</li>
<li>若 len%p==0，则 p 为最小周期长度，前 p 个字符就是最小周期。</li>
</ul>
</li>
<li>说明<ul>
<li>使用的是经典 KMP 的 next 算法，不是变种的 next 算法</li>
<li>要”多”计算到 length, 即 next[length]</li>
</ul>
</li>
<li>思考：如何证明？<ul>
<li>考察字符串 S 的 k前缀 head 和 k后缀 tail</li>
<li>head 和 tail 的前 p 个字符</li>
<li>head 和 tail 的前 2p 个字符</li>
<li>head 和 tail 的前 3p 个字符</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg" alt="Screen Shot 2019-12-22 at 13.14.24.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPeriod</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);  <span class="comment">// 仿照KMP 求伪 next, next[0] = -1 是哨兵，串首标志</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(k==<span class="number">-1</span> || p[j+<span class="number">1</span>] == p[k])&#123;</span><br><span class="line">    		++k;</span><br><span class="line">    		++j;</span><br><span class="line">    		next[j] = k;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		k = next[k];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 恢复成逻辑上的 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLast = next[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n % (n-nLast) == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> n-nLast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><ul>
<li>KMP 的 next，实际上是建立了 DFA</li>
<li>DFA: Deterministic Finite Automaton</li>
<li>以当前位置为 DFA 的状态，以模式串的字符为 DFA 的转移条件，建立确定有穷自动机。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg" alt="Screen Shot 2019-12-22 at 13.00.57.png"></p>
<p>具体算法细节请参考：</p>
<p><a href="http://note.youdao.com/noteshare?id=dda1246716d3e1f321ee1b637ad2b413" target="_blank" rel="external">KMP算法</a><br><a href="http://note.youdao.com/noteshare?id=13fe90f9adddde21b0d5f8f7880ebc1f" target="_blank" rel="external">史上最清楚的 KMP 算法介绍</a></p>
<h2 id="Boyer-Moore-算法-了解"><a href="#Boyer-Moore-算法-了解" class="headerlink" title="Boyer Moore 算法 (了解)"></a>Boyer Moore 算法 (了解)</h2><p>1977年由德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明的字符串匹配算法。BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</p>
<p>效率很高，构思巧妙，拥有在最坏情况下 O(N) 的时间复杂度。实践中比 KMP 算法的实际效能高。</p>
<h2 id="Manacher-算法-了解"><a href="#Manacher-算法-了解" class="headerlink" title="Manacher 算法 (了解)"></a>Manacher 算法 (了解)</h2><h3 id="重心扩展算法"><a href="#重心扩展算法" class="headerlink" title="重心扩展算法"></a>重心扩展算法</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg" alt="Palindrom"></p>
<p>不过要注意，因为字符串可能是奇数长度或者偶数长度，所以我们要考虑的字符串重心有 n+n-1 个。</p>
<h3 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h3><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg" alt="undefined"></p>
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg" alt="undefined"></p>
<h3 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h3><p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p>
<p>例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p>
<h3 id="求每个-P-i"><a href="#求每个-P-i" class="headerlink" title="求每个 P[i]"></a>求每个 P[i]</h3><p>接下来是算法的关键了，它充分利用了回文串的对称性。</p>
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p>
<p>让我们考虑求 P [ i ] 的时候，如下图。</p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg" alt="undefined"></p>
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p>
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p>
<h4 id="超出了-R"><a href="#超出了-R" class="headerlink" title="超出了 R"></a>超出了 R</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg" alt="undefined"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<h4 id="P-i-mirror-遇到了原字符串的左边界"><a href="#P-i-mirror-遇到了原字符串的左边界" class="headerlink" title="P[i_mirror] 遇到了原字符串的左边界"></a>P[i_mirror] 遇到了原字符串的左边界</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<h4 id="i-等于-R"><a href="#i-等于-R" class="headerlink" title="i 等于 R"></a>i 等于 R</h4><p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p>
<h3 id="考虑-C-和-R-的更新"><a href="#考虑-C-和-R-的更新" class="headerlink" title="考虑 C 和 R 的更新"></a>考虑 C 和 R 的更新</h3><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 P 的最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = P[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">//最开始讲的求原字符串下标</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><ul>
<li>另有两个孩子，1 个孩子，0 个孩子的节点个数分别为 n2, n1, n0</li>
<li>所有节点的出度为 2<em>n2+1</em>n1+0*n0</li>
<li>除了根节点，其他所有节点的入度都是 1，从而所有节点的入度为 (n0+n1+n2)-1</li>
<li>总入度等于总出度，2<em>n2+1</em>n1+0*n0 = n2+n1+n0-1</li>
<li>化简得到 n0 - n2 = 1</li>
<li>也就是说二叉树叶子节点数目比拥有两个孩子的节点数目多 1</li>
</ul>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><ul>
<li>无损压缩编码方案</li>
<li>概率高的字符使用较短的编码，概率低的使用较长的编码，从而使得编码后的字符串长度期望最小</li>
<li>Huffman 编码是一种贪心算法：每次总选择两个最小概率的字符节点合并<ul>
<li>称字符出现的次数为频数，则概率约等于频数除以字符总长；因此概率可以用频数代替</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg" alt="Screen Shot 2019-12-22 at 15.13.26.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用数组来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(<span class="keyword">int</span> *pWeight, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; code)</span></span>&#123;</span><br><span class="line">    <span class="comment">// code 传进来时候是空的 vector&lt;vector&lt;char&gt;&gt; 引用，后面会修改。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (N&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">2</span> * N - <span class="number">1</span>;  <span class="comment">// N个节点的 Huffman 树需要 2N-1 个节点</span></span><br><span class="line">	HuffmanNode* pHuffmanTree = <span class="keyword">new</span> HuffmanNode[m];  <span class="comment">// 在动态内存空间里建立这个 vector</span></span><br><span class="line">	<span class="keyword">int</span> s1, s2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 建立叶子节点</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		pHuffmanTree[i].nWeight = pWeight[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每次选择权值最小的两个节点，建树</span></span><br><span class="line">	<span class="keyword">for</span>(i = N; i &lt; m; i++)&#123;</span><br><span class="line">		SelectNode(pHuffmanTree, i, s1, s2);  <span class="comment">// 在前 i 个 nodes 里面找到权值最小的两个节点。用过的节点不会被再用。因为用过的节点有 nParent 信息了。</span></span><br><span class="line">		pHuffmanTree[s1].nParent = pHuffmanTree[s2].nParent = i;  <span class="comment">// s1 和 s2 的父节点是 i 节点</span></span><br><span class="line">		pHuffmanTree[i].nLeft = s1;</span><br><span class="line">		pHuffmanTree[i].nRight = s2;</span><br><span class="line">		pHuffmanTree[i].nWeight = pHuffmanTree[s1].nWeight + pHuffmanTree[s2].nWeight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据建好的 Huffman 树从叶子到根计算每个叶节点的编码</span></span><br><span class="line">	<span class="keyword">int</span> node, nParent;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="comment">// code[i] 就是 node i 的编码！</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; cur = code[i];    <span class="comment">// 此时还是空的 vector</span></span><br><span class="line">		node = i;</span><br><span class="line">		nParent = pHuffmanTree[node].nParent;</span><br><span class="line">		<span class="keyword">while</span>(nParent != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pHuffmanTree[nParent].nLeft == node)&#123;</span><br><span class="line">				cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			node = nParent;</span><br><span class="line">			nParent = pHuffmanTree[node].nParent;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(cur.begin(), cur.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用指针来实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to allocate a new tree node</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node* left, Node* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">	node-&gt;ch = ch;</span><br><span class="line">	node-&gt;freq = freq;</span><br><span class="line">	node-&gt;left = left;</span><br><span class="line">	node-&gt;right = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparison object to be used to order the heap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* l, Node* r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// highest priority item has lowest frequency</span></span><br><span class="line">		<span class="keyword">return</span> l-&gt;freq &gt; r-&gt;freq;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line"><span class="comment">// in a map.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node* root, <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;huffmanCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// found a leaf node</span></span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">		huffmanCode[root-&gt;ch] = str;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	encode(root-&gt;left, str + <span class="string">"0"</span>, huffmanCode);</span><br><span class="line">	encode(root-&gt;right, str + <span class="string">"1"</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and decode the encoded string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root, <span class="keyword">int</span> &amp;index, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// found a leaf node</span></span><br><span class="line">	<span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; root-&gt;ch;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	index++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (str[index] ==<span class="string">'0'</span>)</span><br><span class="line">		decode(root-&gt;left, index, str);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		decode(root-&gt;right, index, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builds Huffman Tree and decode given input text</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHuffmanTree</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// count frequency of appearance of each character</span></span><br><span class="line">	<span class="comment">// and store it in a map</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch: text) &#123;</span><br><span class="line">		freq[ch]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a priority queue to store live nodes of</span></span><br><span class="line">	<span class="comment">// Huffman tree;</span></span><br><span class="line">	priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a leaf node for each character and add it</span></span><br><span class="line">	<span class="comment">// to the priority queue.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pair: freq) &#123;</span><br><span class="line">		pq.push(getNode(pair.first, pair.second, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do till there is more than one node in the queue</span></span><br><span class="line">	<span class="keyword">while</span> (pq.size() != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Remove the two nodes of highest priority</span></span><br><span class="line">		<span class="comment">// (lowest frequency) from the queue</span></span><br><span class="line">		Node *left = pq.top(); pq.pop();</span><br><span class="line">		Node *right = pq.top();	pq.pop();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a new internal node with these two nodes</span></span><br><span class="line">		<span class="comment">// as children and with frequency equal to the sum</span></span><br><span class="line">		<span class="comment">// of the two nodes' frequencies. Add the new node</span></span><br><span class="line">		<span class="comment">// to the priority queue.</span></span><br><span class="line">		<span class="keyword">int</span> sum = left-&gt;freq + right-&gt;freq;</span><br><span class="line">		pq.push(getNode(<span class="string">'\0'</span>, sum, left, right));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// root stores pointer to root of Huffman Tree</span></span><br><span class="line">	Node* root = pq.top();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line">	<span class="comment">// in a map. Also prints them</span></span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; huffmanCode;</span><br><span class="line">	encode(root, <span class="string">""</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> pair: huffmanCode) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nOriginal string was :\n"</span> &lt;&lt; text &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print encoded string</span></span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch: text) &#123;</span><br><span class="line">		str += huffmanCode[ch];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// traverse the Huffman Tree again and this time</span></span><br><span class="line">	<span class="comment">// decode the encoded string</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDecoded string is: \n"</span>;</span><br><span class="line">	<span class="keyword">while</span> (index &lt; (<span class="keyword">int</span>)str.size() - <span class="number">2</span>) &#123;</span><br><span class="line">		decode(root, index, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huffman coding algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> text = <span class="string">"Huffman coding is a data compression algorithm."</span>;</span><br><span class="line"></span><br><span class="line">	buildHuffmanTree(text);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Huffman总结：前缀编码"><a href="#Huffman总结：前缀编码" class="headerlink" title="Huffman总结：前缀编码"></a>Huffman总结：前缀编码</h3><ul>
<li>Huffman编码是<mark>不等长编码</mark><ul>
<li>字符的编码长度不完全相等</li>
</ul>
</li>
<li>不等长编码如果需要译码，必须满足<mark>前缀编码</mark>的条件<ul>
<li>任何一个字符的编码都不是另外一个字符编码的前缀</li>
</ul>
</li>
<li>从Huffman树的角度考虑，就是<mark>所有的待编码元素都位于叶子节点上</mark>！</li>
</ul>
<p>[思考]</p>
<ul>
<li>Huffman 编码是如何解决前缀编码问题的？</li>
<li>实际算法是由多个”小算法”堆砌而成<ul>
<li>空格压缩问题</li>
<li>取数组最大/小的两个数</li>
</ul>
</li>
<li>代码实现中并非直接使用指针形成的二叉树节点，而是实现开辟足够大的缓冲空间(2n+1)，每次从缓冲区获取一个节点，使用数组代替二叉树<ul>
<li>在堆排序，双数组 Trie 树结构等问题中会再次遇到</li>
</ul>
</li>
<li>最后，由于 Huffman 树的节点权值（频数）可能相等，因此对某些文本，Huffman 编码不唯一。<ul>
<li>左赋 1，右赋 0 或者 左赋 0，右赋 1 都可以。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/算法leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/算法leetcode/" itemprop="url">算法leetcode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-25T17:40:02-08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/25/算法leetcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/25/算法leetcode/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h1><h2 id="按数据结构"><a href="#按数据结构" class="headerlink" title="按数据结构"></a>按数据结构</h2><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h3><p><a href="https://zheng-xing.github.io/2019/11/30/leetcode-string/" target="_blank" rel="external">https://zheng-xing.github.io/2019/11/30/leetcode-string/</a></p>
<h3 id="vector-数组"><a href="#vector-数组" class="headerlink" title="vector 数组"></a>vector 数组</h3><h3 id="stack-amp-heap-栈和队列"><a href="#stack-amp-heap-栈和队列" class="headerlink" title="stack &amp; heap 栈和队列"></a>stack &amp; heap 栈和队列</h3><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><h3 id="tree-amp-graph-树和图"><a href="#tree-amp-graph-树和图" class="headerlink" title="tree &amp; graph 树和图"></a>tree &amp; graph 树和图</h3><h2 id="按算法"><a href="#按算法" class="headerlink" title="按算法"></a>按算法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h3 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h3><h3 id="bfs-amp-dfs"><a href="#bfs-amp-dfs" class="headerlink" title="bfs &amp; dfs"></a>bfs &amp; dfs</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h2 id="misc-杂"><a href="#misc-杂" class="headerlink" title="misc 杂"></a>misc 杂</h2><h3 id="bit-操作"><a href="#bit-操作" class="headerlink" title="bit 操作"></a>bit 操作</h3><h3 id="O-N-时间"><a href="#O-N-时间" class="headerlink" title="O(N) 时间"></a>O(N) 时间</h3><h3 id="O-1-空间"><a href="#O-1-空间" class="headerlink" title="O(1) 空间"></a>O(1) 空间</h3><h1 id="按题目"><a href="#按题目" class="headerlink" title="按题目"></a>按题目</h1><table>
<thead>
<tr>
<th>题目序号</th>
<th>tag</th>
<th>link</th>
</tr>
</thead>
<tbody>
<tr>
<td>0005</td>
<td>string</td>
<td><a href="https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9" target="_blank" rel="external">https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9</a></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0516</td>
<td>string, dp</td>
<td>???</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-02T16:40:40-07:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/02/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/08/02/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Deal-with-formula"><a href="#Deal-with-formula" class="headerlink" title="Deal with formula"></a>Deal with formula</h3><ol>
<li>For centered formulae, use \\[ and \\] </li>
<li>For inline formular, use \\( and \\).</li>
</ol>
<p>For example, \\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \\] gives: </p>
<p>\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \]</p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Some-useful-sites"><a href="#Some-useful-sites" class="headerlink" title="Some useful sites"></a>Some useful sites</h3><ol>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">Start Instruction 1</a></li>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="external">Start Instruction 2</a></li>
<li><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="external">Additional Functionalities</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">Additional Functionalities 2</a></li>
<li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">Theme Yelee</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Theme next</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/bit-manipulation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/bit-manipulation/" itemprop="url">bit_manipulation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-26T00:44:58-07:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/26/bit-manipulation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/07/26/bit-manipulation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="WIKI"><a href="#WIKI" class="headerlink" title="WIKI"></a>WIKI</h2><p>Bit manipulation is the act of algorithmically manipulating bits or other pieces of data shorter than a word. Computer programming tasks that require bit manipulation include low-level device control, error detection and correction algorithms, data compression, encryption algorithms, and optimization. For most other tasks, modern programming languages allow the programmer to work directly with abstractions instead of bits that represent those abstractions. Source code that does bit manipulation makes use of the bitwise operations: AND, OR, XOR, NOT, and bit shifts.</p>
<p>Bit manipulation, in some cases, can obviate or reduce the need to loop over a data structure and can give many-fold speed ups, as bit manipulations are processed in parallel, but the code can become more difficult to write and maintain.</p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>At the heart of bit manipulation are the bit-wise operators &amp; (and), | (or), ~ (not) and ^ (exclusive-or, xor) and shift operators a &lt;&lt; b and a &gt;&gt; b.</p>
<pre><code>There is no boolean operator counterpart to bitwise exclusive-or, but there is a simple explanation. 
The exclusive-or operation takes two inputs and returns a 1 if either one or the other of the inputs is a 1, but not if both are. 
That is, if both inputs are 1 or both inputs are 0, it returns 0. 
Bitwise exclusive-or, with the operator of a caret, ^, performs the exclusive-or operation on each pair of bits. 
Exclusive-or is commonly abbreviated XOR.
</code></pre><ol>
<li>Set union A | B</li>
<li>Set intersection A &amp; B</li>
<li>Set subtraction A &amp; ~B</li>
<li>Set negation ALL_BITS ^ A or ~A</li>
<li>Set bit A |= 1 &lt;&lt; bit</li>
<li>Clear bit A &amp;= ~(1 &lt;&lt; bit)</li>
<li>Test bit (A &amp; 1 &lt;&lt; bit) != 0</li>
<li>Extract last bit A&amp;-A or A&amp;~(A-1) or x^(x&amp;(x-1))</li>
<li>Remove last bit A&amp;(A-1)</li>
<li>Get all 1-bits ~0</li>
</ol>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><h2 id="Count-the-number-of-ones-in-the-binary-representation-of-the-given-number"><a href="#Count-the-number-of-ones-in-the-binary-representation-of-the-given-number" class="headerlink" title="Count the number of ones in the binary representation of the given number"></a>Count the number of ones in the binary representation of the given number</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_one</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark>一个牛逼的分治思路</mark></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/ScreenShot-20200101132310.png" alt="ScreenShot-20200101132310.png"></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/ScreenShot-20200101132320.png" alt="ScreenShot-20200101132320.png"></p>
<p>我来解释一下思路！</p>
<ol>
<li>如果原始数字是一个 4 位的二进制数，假设是 1110.</li>
<li>那么我们先用 0101 与它做与操作，得到从右边数第一和第三个位置上的数字是 1 的数量，结果是 0100，表示右数第一个位置上有 0 个 1，右数第三个位置上有 1 个 1.</li>
<li>然后用 1010 与它做与操作，得到从右边数第二和第四个位置上数字是 1 的数量，结果是 1010, 表示右数第二个位置上有 1 个 1，右数第四个位置上有 1 个 1. 把这个 1010 向右 shift 一个位子，得到 0101，然后与上面的 0100 相加，得到 1001. </li>
<li>对 1001 的解释<ol>
<li>前面一半 “10” 代表原始数字的 4 个 bit 中前面两个含有 2 个 1， 后面一半 “01” 表示后面两个 bit 位置上含有 1 个 1.</li>
</ol>
</li>
<li>继续递归，我们需要把 “10” 和 “01” 相加得到 4 个 bit 中一共有多少个 1.</li>
</ol>
<p>[代码二]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HammingWeight</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Is-power-of-four-actually-map-checking-iterative-and-recursive-methods-can-do-the-same"><a href="#Is-power-of-four-actually-map-checking-iterative-and-recursive-methods-can-do-the-same" class="headerlink" title="Is power of four (actually map-checking, iterative and recursive methods can do the same)"></a>Is power of four (actually map-checking, iterative and recursive methods can do the same)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n&amp;(n<span class="number">-1</span>)) &amp;&amp; (n&amp;<span class="number">0x55555555</span>);</span><br><span class="line">    <span class="comment">//check the 1-bit location;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tricks"><a href="#tricks" class="headerlink" title="^ tricks"></a>^ tricks</h2><ol>
<li>Use ==^== to remove even exactly same numbers and save the odd, or save the distinct bits and remove the same.</li>
<li>Use ==^== and ==&amp;== to add two integers</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>? a:getSum(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>); <span class="comment">//be careful about the terminating condition;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者不用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> carry = a &amp; b;</span><br><span class="line">            a = a^b; </span><br><span class="line">            b = carry &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example, Given nums = [0, 1, 3] return 2. (Of course, you can do this by math.)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ret ^= i;</span><br><span class="line">        ret ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret^=nums.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tricks-1"><a href="#tricks-1" class="headerlink" title="| tricks"></a>| tricks</h2><p>Keep as many 1-bits as possible</p>
<p>Find the largest power of 2 (most significant bit in binary form), which is less than or equal to the given number N.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">largest_power</span><span class="params">(<span class="keyword">long</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//changing all right side bits to 1.</span></span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">2</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">4</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">8</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> (N+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="amp-tricks"><a href="#amp-tricks" class="headerlink" title="&amp; tricks"></a>&amp; tricks</h2><p>Just selecting certain bits</p>
<p>Reversing the bits in integer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = ((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((x &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m != n)</span><br><span class="line">    &#123;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m&lt;&lt;a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DNA-Application"><a href="#DNA-Application" class="headerlink" title="DNA Application"></a>DNA Application</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<pre><code>For example,
Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,
Return: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(sLen &lt; <span class="number">11</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">char</span> keyMap[<span class="number">1</span>&lt;&lt;<span class="number">21</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hashKey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) hashKey = (hashKey&lt;&lt;<span class="number">2</span>) | (s[i]-<span class="string">'A'</span>+<span class="number">1</span>)%<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &lt; sLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(keyMap[hashKey = ((hashKey&lt;&lt;<span class="number">2</span>)|(s[i]-<span class="string">'A'</span>+<span class="number">1</span>)%<span class="number">5</span>)&amp;<span class="number">0xfffff</span>]++ == <span class="number">1</span>)</span><br><span class="line">                v.push_back(s.substr(i<span class="number">-9</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>But the above solution can be invalid when repeated sequence appears too many times, in which case we should use ==unordered_map<int, int=""> keyMap== to replace ==char keyMap[1&lt;&lt;21]{0}== here.</int,></p>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. (bit-counting as a usual way, but here we actually also can adopt sorting and Moore Voting Algorithm)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">8</span>, size = nums.size();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, mask = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j)</span><br><span class="line">            <span class="keyword">if</span>(mask &amp; nums[j]) count++;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; size/<span class="number">2</span>) ret |= mask;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Given an array of integers, every element appears three times except for one. Find that single one. (Still this type can be solved by bit-counting easily.) But we are going to solve it by ==digital logic design==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inspired by logical circuit design and boolean algebra;</span></span><br><span class="line"><span class="comment">//counter - unit of 3;</span></span><br><span class="line"><span class="comment">//current   incoming  next</span></span><br><span class="line"><span class="comment">//a b            c    a b</span></span><br><span class="line"><span class="comment">//0 0            0    0 0</span></span><br><span class="line"><span class="comment">//0 1            0    0 1</span></span><br><span class="line"><span class="comment">//1 0            0    1 0</span></span><br><span class="line"><span class="comment">//0 0            1    0 1</span></span><br><span class="line"><span class="comment">//0 1            1    1 0</span></span><br><span class="line"><span class="comment">//1 0            1    0 0</span></span><br><span class="line"><span class="comment">//a = a&amp;~b&amp;~c + ~a&amp;b&amp;c;</span></span><br><span class="line"><span class="comment">//b = ~a&amp;b&amp;~c + ~a&amp;~b&amp;c;</span></span><br><span class="line"><span class="comment">//return a|b since the single number can appear once or twice;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (a&amp;~b&amp;~nums[i]) | (~a&amp;b&amp;nums[i]);</span><br><span class="line">        b = (~a&amp;b&amp;~nums[i]) | (~a&amp;~b&amp;nums[i]);</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a | b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>atttention</p>
<ol>
<li>result after shifting left(or right) too much is undefined</li>
<li>right shifting operations on negative values are undefined</li>
<li>right operand in shifting should be non-negative, otherwise the result is undefined</li>
<li>The &amp; and | operators have lower precedence than comparison operators</li>
</ol>
<h2 id="SETS"><a href="#SETS" class="headerlink" title="SETS"></a>SETS</h2><p>All the subsets</p>
<p>A big advantage of bit manipulation is that it is trivial to iterate over all the subsets of an N-element set: every N-bit value represents some subset. Even better, ==if A is a subset of B then the number representing A is less than that representing B==, which is convenient for some dynamic programming solutions.</p>
<p>It is also possible to iterate over all the subsets of a particular subset (represented by a bit pattern), provided that you don’t mind visiting them in reverse order (if this is problematic, put them in a list as they’re generated, then walk the list backwards). The trick is similar to that for finding the lowest bit in a number. If we subtract 1 from a subset, then the lowest set element is cleared, and every lower element is set. However, we only want to set those lower elements that are in the superset. So the iteration step is just ==i = (i - 1) &amp; superset==.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line">    <span class="keyword">int</span> size = nums.size(); </span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> vv;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span> &lt;&lt; size;</span><br><span class="line">    vv.resize(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j)</span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j) &amp; i) vv[i].push_back(nums[j]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actually there are two more methods to handle this using recursion and iteration respectively.</p>
<h2 id="BITSET"><a href="#BITSET" class="headerlink" title="BITSET"></a>BITSET</h2><p>A bitset stores bits (elements with only two possible values: 0 or 1, true or false, …).<br>The class emulates an array of bool elements, but optimized for space allocation: generally, each element occupies only one bit (which, on most systems, is eight times less than the smallest elemental type: char).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitset::count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;         // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;         // std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; foo (<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"10110011"</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="string">" has "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo.count() &lt;&lt; <span class="string">" ones and "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (foo.size()-foo.count()) &lt;&lt; <span class="string">" zeros.\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bitwise-AND-of-Numbers-Range-leetcode-0201"><a href="#bitwise-AND-of-Numbers-Range-leetcode-0201" class="headerlink" title="bitwise AND of Numbers Range leetcode 0201"></a>bitwise AND of Numbers Range leetcode 0201</h2><p>题目描述:<br>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.<br>For example, given the range [5, 7], you should return 4.</p>
<p>分析：<br>这一题实际上就是在找 两个 integer 二进制写法的公共 prefix</p>
<p>The hardest part of this problem is to find the regular pattern.<br>For example, for number 26 to 30<br>Their binary form are:<br>1 1 0 1 0<br>1 1 0 1 1<br>1 1 1 0 0　　<br>1 1 1 0 1　　<br>1 1 1 1 0<br>Because we are trying to find bitwise AND, so if any bit there are at least one 0 and one 1, it always 0. In this case, it is 11000.<br>So we are go to cut all these bit that they are different. In this case we cut the right 3 bit.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字出现三次"><a href="#数字出现三次" class="headerlink" title="数字出现三次"></a>数字出现三次</h2><p>参考文章 “leetcode 数组” 里面的例题 “出现 3 次的数 leetcode 137”</p>
<h3 id="引申题-老鼠喝药"><a href="#引申题-老鼠喝药" class="headerlink" title="引申题 老鼠喝药"></a>引申题 老鼠喝药</h3><p>[题目]<br>有 100 瓶液体，编号 1 到 100，其中有 99 瓶水和 1 瓶毒药。<br>如果老鼠喝了毒药，那么会在一周后死亡。请问你最少用几只老鼠可以最快的检测出哪一瓶是毒药？</p>
<p>[思路]<br>这一引申题的思路跟上面的一个按位置计算的解法非常相似。这里也是按照 bit 位来看的。</p>
<p>我们把这编号 1 到 100 一共 100 个数字用二进制写出来，每个数字都写成长度为 7 位的二进制数 (2^7 = 128 &gt; 100)，左边补零如果不够七位。</p>
<p>现在我们让七只老鼠，第一只老鼠去喝最左边的 bit 位上是 1 的那些瓶的液体，第二只老鼠喝左数第二 bit 位上是 1 的那些瓶子的液体，以此类推。</p>
<p>一周以后，如果第一只老鼠死了，那么有毒药的那瓶液体的编号在最左边 bit 位一定是 1，反之是 0. 同理可以得到 7 个 bit 位上是 1 还是 0.</p>
<p><mark>[其他思考]</mark></p>
<ol>
<li>如果没有时间限制的话，就直接是二分考虑了。先让一只老鼠喝编号 1-50 的那些瓶液体，如果死了，就递归找第二只老鼠喝 1-25 瓶液体，如果没死就找第二只老鼠喝 51-75 那些瓶液体。同样的，也是最多需要 7 只老鼠就可以发现。</li>
<li>我其实对于上面的解法有点疑惑就是为啥非得用 2 进制来表示数字呢？如果用 3 进制来表示的话，那么对于每一个 bit 位 我们需要找 2 只老鼠，一只老鼠喝最左边 bit 位是 1 的液体，一个老鼠喝 最左边 bit 位是 2 的液体，根据它们两个老鼠是否死亡的信息，可以判断最左边 bit 位上是 0，1，还是 2.<ol>
<li>好像想清楚了！如果是三进制，那么每一个 bit 位上一个老鼠是否死亡只能排除掉 1/3 的可能。而使用二进制的话则可以排除掉 50% 的可能。因为老鼠是否死亡只有两种可能，因此使用二进制已经是最佳的方案了！！！<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1></li>
</ol>
</li>
<li><a href="https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently" target="_blank" rel="external">https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/乒乓球/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/乒乓球/" itemprop="url">乒乓球.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-04T23:24:22-07:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hobby/" itemprop="url" rel="index">
                    <span itemprop="name">hobby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/04/乒乓球/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/04/乒乓球/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接发球"><a href="#接发球" class="headerlink" title="接发球"></a>接发球</h1><ol>
<li><p>张继科逆旋转发球四种旋转</p>
<div class="video-container"><br> <!-- <iframe width="1280" height="720" src="https://www.youtube.com/watch?v=uKLTkFGCxSo" frameborder="0" allowfullscreen>
 </iframe> --><br> <iframe width="560" height="315" src="https://www.youtube.com/embed/uKLTkFGCxSo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><br></div>
</li>
<li><p>如何发好逆旋转侧下旋<br>两个要点：<br>第一，要注意球拍的摆放，一定要往下压平一点。这样才能摩擦球的下部。<br>第二，要注意发力的动作。很多时候球友只注意了侧向的摩擦，这个会造成只有侧旋。一定要有球拍往前送的动作，这样子才会造成下旋。</p>
<div class="video-container"><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2rruw3rld5E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><br></div>
</li>
<li><p>急长下旋球<br>要点：<br>第一，触球的中下位置，不仅要有摩擦，还要有向前推送/弹击得感觉。<br>第二，第一个落点在靠近自己的位置。</p>
<div class="video-container"><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6QHF_wv5BhU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><br></div>
</li>
<li><p>直板发纯下旋球<br>一定要体会兜底的感觉！</p>
<div class="video-container"><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HUMVoIDuLMQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><br></div>
</li>
<li><p>勾手的上旋球<br>这个动作的欺骗性很强：第一个是因为看起来好像往前摩擦球的下面，有点下旋；第二个再加上球的弧线很低，就容易产生“嗯，确实是下旋的错觉”，然后就冒高了。</p>
<div class="video-container"><br><iframe width="560" height="315" src="https://www.youtube.com/embed/F_rKsfAJX3I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe><br></div>

</li>
</ol>
<h1 id="技战术"><a href="#技战术" class="headerlink" title="技战术"></a>技战术</h1><h1 id="器材篇"><a href="#器材篇" class="headerlink" title="器材篇"></a>器材篇</h1><h2 id="底板"><a href="#底板" class="headerlink" title="底板"></a>底板</h2><p>目前我用的装备是斯蒂卡纳米OC，其特点描述如下：</p>
<ol>
<li>轻量级5层全能型底板，具有出色的手感和控制力。基于经典轻量级进攻型OC系列的升级款，快攻下的全方位控制力，为现代科技乒乓设计。NCT科技在实现了更强击打力量的同时保证控制力不减。世界冠军许昕曾用。</li>
<li>与一般的纯木板有所不同，纳米OFFENSIVE WOOD有着超乎寻常的出球速度。<br>特别是当你发力达到一定程度后，出球弧线骤然降低，出球速度大幅提升，以迅雷不及掩耳之势撕开对手的防线。<br>使用它，你甚至可以用相当柔和的手法把一片没有灌过胶的狂飙轻松打透，并令其发出振聋发聩的声响。<br>既易于上手又易于发力的特性，必将使其成为业余与专业选手无机时代最有力的得分武器。</li>
</ol>
<p>而传统的OC是最能够代表乒乓球弧圈时代的经典底板。球拍受冲击后产生的大幅形变，使选手有充分的时间对球进行摩擦。形变产生的储能，使球具有强烈的冲击性。使OC成为中远台冲高进攻选手的青睐。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/29/ML-DL-basic-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/29/ML-DL-basic-knowledge/" itemprop="url">ML_DL_basic_knowledge</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-29T20:45:54-07:00">
                2018-08-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/29/ML-DL-basic-knowledge/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/29/ML-DL-basic-knowledge/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="">L1 and L2 的意义</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/29/Algorithms-Questions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/29/Algorithms-Questions/" itemprop="url">Algorithms Questions</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-29T20:45:14-07:00">
                2018-08-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/29/Algorithms-Questions/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/08/29/Algorithms-Questions/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="">Leetcode 0001</a><br><a href="">Leetcode 0002</a><br><a href="">Leetcode 0003</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
