<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="//page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zheng Xing">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com///page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-10T23:34:42-08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/10/排序算法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://7xsnb0.com1.z0.glb.clouddn.com/2016-07-15_%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<h1 id="几个重要的排序法讲解"><a href="#几个重要的排序法讲解" class="headerlink" title="几个重要的排序法讲解"></a>几个重要的排序法讲解</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序由于<mark>排序效率在同为O(N * logN)的几种排序方法中效率较高</mark>，因此经常被采用，再加上快速排序思想<mark>分治法</mark>也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。</p>
<p>总的说来，要直接默写出快速排序还是有一定难度的，因为本人就自己的理解对快速排序作了下白话解释，希望对大家理解有帮助，达到快速排序，快速搞定.</p>
<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<p>该方法的基本思想是：</p>
<ol>
<li>先从数列中取出一个数作为基准数。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p>对挖坑填数进行总结</p>
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
<p>2．j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
<p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p>
<h2 id="Shell-排序"><a href="#Shell-排序" class="headerlink" title="Shell 排序"></a>Shell 排序</h2><p><img src="http://bubkoo.qiniudn.com/shell-sort-animation.gif" alt=""></p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ol>
<p>算法思路：</p>
<ol>
<li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d2(d2 &lt; d1)</li>
<li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</li>
</ol>
<p>假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：<br><img src="http://bubkoo.qiniudn.com/shell-sort-step1.1.png" alt=""><br>然后分别对 4 个小组进行插入排序，排序后的结果为：</p>
<p>然后，取 d2 = 2，将原数组分为 2 小组，如下图：</p>
<p>然后分别对 2 个小组进行插入排序，排序后的结果为：</p>
<p>最后，取 d3 = 1，进行插入排序后得到最终结果：</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆概念"><a href="#堆概念" class="headerlink" title="堆概念"></a>堆概念</h3><ol>
<li>堆：满足堆有序的完全二叉树</li>
<li>堆有序：一棵二叉树的所有父节点大于等于（最大堆）或者小于等于（最小堆）其全部子节点</li>
<li>堆的高度：假设有 n 个节点，那么树的高度为 h = floor(log n)</li>
</ol>
<h3 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a>堆排序的过程</h3><p>用数组存储堆，这里以最大堆为例。如果数组从下标 0 开始算，那么节点 k 的父节点为 floor((k-1) / 2)，节点 k 的左右子节点为 2k+1 和 2k+2.</p>
<p>对于一个未排序的初始化数组，</p>
<ol>
<li>第一步是建堆：从其<mark>最后一个父节点</mark>开始往前进行堆调整，即可建立最大堆。</li>
<li>第二步：建好最大堆之后，每次取其根节点作为最大值，把最后一个节点作为新的根节点对堆进行调整，反复进行上述操作直到堆只有一个根节点。</li>
</ol>
<h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><p>这个代码做的操作就是把 index 位置的节点调整，然后被变动的子节点再向下调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heapArr, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heapArr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> largest = index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑左孩子</span></span><br><span class="line">    <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &amp;&amp; heapArr[index * <span class="number">2</span> + <span class="number">1</span>] &gt; heapArr[largest])&#123;</span><br><span class="line">        largest = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑右孩子</span></span><br><span class="line">    <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span> &lt;= n<span class="number">-1</span>) &amp;&amp; heapArr[index * <span class="number">2</span> + <span class="number">2</span>] &gt; heapArr[largest])&#123;</span><br><span class="line">        largest = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(largest != index)&#123;</span><br><span class="line">        swap(heapArr[largest], heapArr[index]);</span><br><span class="line">        maxHeapify(heapArr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立最大堆"><a href="#建立最大堆" class="headerlink" title="建立最大堆"></a>建立最大堆</h3><p>建立最大堆就是从一个完全二叉树的最后一个父节点开始往前进行堆调整。<br>若最后一个节点为 n - 1，那么其父节点，也就是最后一个父节点，为 floor(((n-1)-1)/2).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; maxHeap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = maxHeap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> lastFatherIndex = (n<span class="number">-1</span><span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lastFatherIndex; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        maxHeapify(maxHeap, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[时间复杂度]<br><mark>这里要注意时间复杂度不是 O(NlogN)的，而是 O(N).<br>因为倒数第二层的父节点只需要往下沉一层，倒数第三层的节点需要往下沉两层，以此类推。</mark></p>
<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>所谓堆排序就是每次取堆的根节点为最大值，然后将最后一个节点作为根节点，进行堆调整。<br>堆排序的时间等于建堆和进行堆调整的时间，所以堆排序的时间复杂度是 O(N logN + N) = O(N logN)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; maxHeap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = maxHeap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(maxHeap[<span class="number">0</span>], maxHeap[i]);    <span class="comment">// 根节点和最后一个节点交换</span></span><br><span class="line">        maxHeapify(maxHeap, <span class="number">0</span>);    <span class="comment">// ”根“位置的元素是错的，需要把它从”根“位置往下沉！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="各种排序算法的C-代码"><a href="#各种排序算法的C-代码" class="headerlink" title="各种排序算法的C++代码"></a>各种排序算法的C++代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"><span class="comment">//                    Author: qianghaohao(Xqiang)</span></span><br><span class="line"><span class="comment">//                    Mail: qiang.timothy@qq.com</span></span><br><span class="line"><span class="comment">//****************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  直接插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 stl 里面的函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = start; i != <span class="built_in">end</span>; ++i)</span><br><span class="line">    <span class="built_in">std</span>::rotate(<span class="built_in">std</span>::upper_bound(start, i, *i), i, <span class="built_in">std</span>::next(i));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  折半插入排序</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = a[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  二分法找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  希尔排序:</span></span><br><span class="line"><span class="comment">//  a:数组  d:分组间距 n:元素个数</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(2^1.5)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> d, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d; i &lt; n; i++) &#123;</span><br><span class="line">            key = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span>; j -= d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (key &lt; a[j]) &#123;</span><br><span class="line">                    a[j+d] = a[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+d] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        d -= <span class="number">2</span>;   <span class="comment">//最终要保证d为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            swap(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 选择排序 selectionSort</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">std</span>::min_element(a.<span class="built_in">begin</span>() + i, a.<span class="built_in">end</span>());  <span class="comment">//选最小值</span></span><br><span class="line">      swap(a[i], a[it - a.<span class="built_in">begin</span>()]);  <span class="comment">//最小值和a[i]交换</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//// 快速排序</span></span><br><span class="line"><span class="comment">//// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//// 稳定性:不稳定</span></span><br><span class="line"><span class="comment">//void QuickSort(vector&lt;int&gt; &amp;a, int low, int high) &#123;</span></span><br><span class="line"><span class="comment">//    int i = low;</span></span><br><span class="line"><span class="comment">//    int j = high;</span></span><br><span class="line"><span class="comment">//    if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//        while (i &lt; j) &#123;   //i == j跳出循环</span></span><br><span class="line"><span class="comment">//            //支点为i</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //支点为j</span></span><br><span class="line"><span class="comment">//            while (i &lt; j &amp;&amp; a[i] &lt;= a[j]) &#123;</span></span><br><span class="line"><span class="comment">//                i++;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (i &lt; j) &#123;</span></span><br><span class="line"><span class="comment">//                swap(a[i], a[j]);</span></span><br><span class="line"><span class="comment">//                j--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//       QuickSort(a, low, i-1);</span></span><br><span class="line"><span class="comment">//     QuickSort(a, i+1, high);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 快速排序(改进版--避免了交换支点的开销)</span></span><br><span class="line"><span class="comment">/* 时间复杂度:平均是 O(nlogn)，最坏情况和插入排序相同，也是O(n^2)。</span></span><br><span class="line"><span class="comment">比如一个序列5,4,3,2,1，要排为1,2,3,4,5。</span></span><br><span class="line"><span class="comment">或者是序列1，2，3，4，5，虽然已经是排好顺序的了。</span></span><br><span class="line"><span class="comment">但是，按照快速排序方法，每次只会有一个数据进入正确顺序，</span></span><br><span class="line"><span class="comment">不能把数据分成大小相当的两份。</span></span><br><span class="line"><span class="comment">很明显，排序的过程就成了一个歪脖子树，树的深度为n，那时间复杂度就成了O(n^2)。</span></span><br><span class="line"><span class="comment">尽管如此，需要排序的情况几乎都是乱序的，自然性能就保证了。</span></span><br><span class="line"><span class="comment">据书上的测试图来看，在数据量小于20的时候，插入排序具有最好的性能。</span></span><br><span class="line"><span class="comment">当大于20时，快速排序具有最好的性能，归并(merge sort)和堆排序(heap sort)也望尘莫及，</span></span><br><span class="line"><span class="comment">尽管复杂度都为nlog2(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 稳定性:不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[i];  <span class="comment">//保存支点(最左边的数字)</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;   <span class="comment">//只可能在 i == j 时跳出循环，不会出现 i&gt;j</span></span><br><span class="line">            <span class="comment">//支点为i, 从右边开始找一个小于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pivot &lt;= a[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个数字填到 i 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//支点为j，再从左边开始找一个大于pivot的数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个大于 pivot 的数字填到 j 处</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                a[j] = a[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// while 里面的复杂度是 O(n)</span></span><br><span class="line">        <span class="comment">// 循环结束后，说明 i==j，此时左边的值都小于pivot，右边的值都大于pivot</span></span><br><span class="line">        <span class="comment">// 这个时候把 pivot 填写到 i==j 处</span></span><br><span class="line">        <span class="comment">// 之后对左右两边都分别递归做 quicksort</span></span><br><span class="line">       a[i] = pivot;  <span class="comment">//i==j时填入支点</span></span><br><span class="line">       QuickSort(a, low, i<span class="number">-1</span>);</span><br><span class="line">       QuickSort(a, i+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意，while 里面的复杂度固定是 O(n)，</span></span><br><span class="line"><span class="comment">因为每次比较都会把左指针右移一位或者右指针左移一位。</span></span><br><span class="line"><span class="comment">因此快速排序算法的关键就是减少 while 循环的次数。</span></span><br><span class="line"><span class="comment">那就必须使得每一次while 循环都能保证 pivot 跑到了中间位置。</span></span><br><span class="line"><span class="comment">这个数组被大致等分。</span></span><br><span class="line"><span class="comment">这样子整个算法复杂度就是经典的 divide and conqure 的复杂度 O(nlogn).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用这个代码，更有 C++ 范儿</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">FwdIt</span>, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(FwdIt first, FwdIt last, Compare cmp = Compare&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> N = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> pivot = <span class="built_in">std</span>::next(first, N/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::nth_element(first, pivot, last, cmp);</span><br><span class="line">    quickSort(first, pivot, cmp);</span><br><span class="line">    quickSort(pivot, last, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  堆排 heapsort</span></span><br><span class="line"><span class="comment">//  时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">//  空间复杂度:O(1)</span></span><br><span class="line"><span class="comment">//  稳定性:不稳定</span></span><br><span class="line"><span class="comment">//  不适合在元素个数太少的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  调整堆为最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = (n - <span class="number">1</span>) / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">//(n-1)/2:最后一个有孩子节点的编号</span></span><br><span class="line">        j = <span class="number">2</span>*i;  <span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= n<span class="number">-1</span>) &#123;  <span class="comment">//左右孩子都有</span></span><br><span class="line">            <span class="keyword">if</span> (a[j+<span class="number">1</span>] &gt; a[j]) &#123;  <span class="comment">//选取左右孩子中较大的</span></span><br><span class="line">                j = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="comment">// 交换--较大的元素调整到根节点</span></span><br><span class="line">        <span class="comment">// 在此也可以用a[0]当作中间变量来交换</span></span><br><span class="line">        <span class="comment">// 相当于temp,因为a[0]在整个排序过程中</span></span><br><span class="line">        <span class="comment">// 没有使用</span></span><br><span class="line">        <span class="comment">//******************************************</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            swap(a[i], a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用AdjustHeap进行堆排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        AdjustHeap(a, n - i);</span><br><span class="line">        swap(a[<span class="number">1</span>], a[n<span class="number">-1</span>-i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//  归并排序</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度:O(n)</span></span><br><span class="line"><span class="comment">// 稳定性:稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src中low-mid 和 mid-high两部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;src, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;des)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid;  <span class="comment">//前半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = mid + <span class="number">1</span>;  <span class="comment">//后半部分</span></span><br><span class="line">    <span class="keyword">int</span> n = high;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j &amp;&amp; m &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src[i] &lt; src[m]) &#123;</span><br><span class="line">            des[k++] = src[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            des[k++] = src[m++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  合并可能剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        des[k++] = src[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n) &#123;</span><br><span class="line">        des[k++] = src[m++];</span><br><span class="line">    &#125;</span><br><span class="line">    swap_ranges(src.<span class="built_in">begin</span>() + low, src.<span class="built_in">begin</span>() + high + <span class="number">1</span>, des.<span class="built_in">begin</span>());  <span class="comment">//  合并后放回原数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  temp:临时向量,保存合并后的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid;</span><br><span class="line">   <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">      mid = first + ((last - first) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      MergeSort(a, first, mid, temp);</span><br><span class="line">      MergeSort(a, mid + <span class="number">1</span>, last, temp);</span><br><span class="line">      MergeArray(a, first, mid, last, temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="comment">//  测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(arr.<span class="built_in">size</span>())</span></span>;  <span class="comment">//merge sort test</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; arr = &#123;0, 9, 8, 7, 6, 5, 4, 4, 4, 6, 6, 6&#125;;  //heap sort test</span></span><br><span class="line"><span class="comment">// InsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// BinaryInsertSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// ShellSort(arr, 5, arr.size());</span></span><br><span class="line"><span class="comment">// BubbleSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// SelectSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// QuickSort(arr, 0, arr.size()-1);</span></span><br><span class="line"><span class="comment">// HeapSort(arr, arr.size());</span></span><br><span class="line"><span class="comment">// copy(arr.begin() + 1, arr.end(), ostream_iterator&lt;int&gt;(cout, " "));  //heap sort test</span></span><br><span class="line">   MergeSort(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>, temp);</span><br><span class="line">   copy(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快排为什么快"><a href="#快排为什么快" class="headerlink" title="快排为什么快"></a>快排为什么快</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="noopener">http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/</a></li>
<li><a href="https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ" target="_blank" rel="noopener">https://groups.google.com/forum/#!msg/pongba/KKw54CIr7PI/Z_1N6y-hWvkJ</a></li>
<li><a href="http://www.inference.org.uk/mackay/sorting/sorting.html" target="_blank" rel="noopener">http://www.inference.org.uk/mackay/sorting/sorting.html</a></li>
</ul>
<h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><p>我们先来玩一个猜数字游戏：我心里默念一个1<del>64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1</del>32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。</p>
<p>我们再来回顾一下这个游戏所蕴含的本质：为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1<del>10之间，那么一旦发现不是在1</del>10之间的话就会剩下比N/2更多的可能性需要去考察了。</p>
<p>徐宥在讨论中提到，这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。</p>
<h2 id="称球"><a href="#称球" class="headerlink" title="称球"></a>称球</h2><p>12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。</p>
<p>这个问题是一道流传已久的智力题。网络上也有很多讲解，还有泛化到N个球的情况下的严格证明。也有零星的一些地方提到从信息论的角度来看待最优解法。本来我一直认为这道题目除了试错之外没有其它高妙的思路了，只能一个个方法试，并尽量从结果中寻找信息，然后看看哪种方案最少。</p>
<p>然而，实际上它的确有其它的思路，一个更本质的思路，而且根本用不着信息论这么拗口的知识。</p>
<p>我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。</p>
<p>如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。</p>
<p>为了更清楚的看待这个问题，我们不妨假设有6个球，来考虑一下3、3称和2、2称的区别：</p>
<p>在未称之前，一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后，不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）：1重、2重、3重、4轻、5轻、6轻。即这种称法能排除一半可能性。</p>
<p>现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！我们充分利用了“天平的结果状态可能有三种”这个条件来三等分所有可能性，而不是二等分。</p>
<p>说到这里，剩下的事情就实在很简单了：第二步称法，只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。</p>
<p>MacKay在他的书《Information Theory: Inference and Learning Algorithms》（作者开放免费电子书）里面4.1节专门讲了这个称球问题，还画了一张不错的图，我就照抄了：</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6qe45peoj20d40d875m.jpg" alt="23131201.jpg"></p>
<p>图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现a&lt;b的话剩下的排列可能性就变成N!/2，如果发现a&gt;b也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持a&lt;b的排列一共有N!/2个，支持a&gt;b的也是N!/2个，换言之，a&lt;b的概率等于a&gt;b的概率。</p>
<p>我们希望每次在比较a和b的时候，a&lt;b和a&gt;b的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。</p>
<p>一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。</p>
<h3 id="为什么堆排比快排慢"><a href="#为什么堆排比快排慢" class="headerlink" title="为什么堆排比快排慢"></a>为什么堆排比快排慢</h3><p>回顾一下堆排的过程：</p>
<ol>
<li><p>建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子… 以此类推）</p>
</li>
<li><p>将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。</p>
</li>
<li><p>重复第2步。</p>
</li>
</ol>
<p>这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到——原本剩下多少可能性还是剩下多少可能性。</p>
<p>在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。</p>
<p>这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。</p>
<p>MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了。具体参考这里。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/leetcode-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/leetcode-tree/" itemprop="url">leetcode tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T20:20:05-08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/leetcode-tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/leetcode-tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识总结"><a href="#基础知识总结" class="headerlink" title="基础知识总结"></a>基础知识总结</h1><p>数的基本操作有</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>查找</li>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    tagSTreeNode* left;</span><br><span class="line">    tagSTreeNode* right;</span><br><span class="line"></span><br><span class="line">    tagSTreeNode(<span class="keyword">int</span> v): val(v), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125; STreeNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    STreeNode* m_root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(STreeNode* root)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> _Insert(STreeNode* root, <span class="keyword">int</span> val);    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">bool</span> _Insert2(<span class="keyword">int</span> val);</span><br><span class="line">    <span class="keyword">void</span> _PreOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">void</span> _PreOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder(STreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited);  <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder2(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _InOrder3(<span class="keyword">int</span> val) <span class="keyword">const</span>;    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">void</span> _PostOrder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算节点个数"><a href="#计算节点个数" class="headerlink" title="计算节点个数"></a>计算节点个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于任何的树，算法复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root-&gt;left) + countNodes(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Iterative 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* BinaryTree::Find(int v) const &#123;</span><br><span class="line">    if(!m_root) return nullptr;</span><br><span class="line"></span><br><span class="line">    TreeNode* res &#x3D; m_root;</span><br><span class="line">    while(res)&#123;</span><br><span class="line">        if(v &lt; res-&gt;val)&#123;</span><br><span class="line">            res &#x3D; res-&gt;left;</span><br><span class="line">        &#125; else if (v &gt; res-&gt;val) &#123;</span><br><span class="line">            res &#x3D; res-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加一个节点"><a href="#添加一个节点" class="headerlink" title="添加一个节点"></a>添加一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Insert: BST的插入过程是一个递归过程，如果插入结点值比插入位置结点值小，则插入到左子树。反之则插入到右子树中。若插入位置结点的左子树或者右子树为空，则直接插入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BinaryTree::Insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Insert(m_root, val);    <span class="comment">// 递归算法</span></span><br><span class="line">    <span class="comment">// return _Insert2(val);        // 非递归算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert(TreeNode* root, <span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; node-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> _Insert(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// val 已经在 tree 里面了，插入失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BinaryTree::_Insert2(<span class="keyword">int</span> val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root)&#123;</span><br><span class="line">        m_root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* pnode = m_root, pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exhausively 找到待插入的位置(nullptr)</span></span><br><span class="line">    <span class="comment">// 此时 pnode 就是那个 nullptr, pcur 是此节点的父节点。</span></span><br><span class="line">    <span class="keyword">while</span>(pnode)&#123;</span><br><span class="line">        pcur = pnode;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pnode-&gt;val)&#123;</span><br><span class="line">            pnode = pnode-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// while 执行完后 pnode = nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &lt; pcur-&gt;val)&#123;</span><br><span class="line">        pcur-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; pcur-&gt;val) &#123;</span><br><span class="line">        pcur-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除一个节点</span><br><span class="line"></span><br><span class="line">思想就是：</span><br><span class="line">    递归寻找待删除的 node</span><br><span class="line">    找到以后</span><br><span class="line">    如果node 没有左子树，就把右子树提上来</span><br><span class="line">    如果node 没有右子树，就把左子树提上来</span><br><span class="line">    如果node 既有左子树，又有右子树，这个情况比较复杂</span><br><span class="line">        可以把左子树最大的数字拿过来，也可以把右子树最小的拿过来！</span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    /*<br>    方法一：左子树的最右边的 node 替换上来！！！<br>    */</p>
<pre><code>TreeNode* deleteNode(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* maxNode = findMax(root-&gt;left);
        root-&gt;val = maxNode-&gt;val;
        root-&gt;left = deleteNode(root-&gt;left, root-&gt;val);
    }

    return root;
}

TreeNode* findMax(TreeNode* node){
    while(node-&gt;right)
        node = node-&gt;right;
    return node;
}


/* 
方法二：右子树的最左边的 node 替换上来
*/

TreeNode* deleteNode_way2(TreeNode* root, int key) {
    if(!root) return root;

    if(key &lt; root-&gt;val){
        root-&gt;left = deleteNode(root-&gt;left, key);
    } else if(key &gt; root-&gt;val){
        root-&gt;right = deleteNode(root-&gt;right, key);
    } else{
        if(!root-&gt;left) return root-&gt;right;
        else if(!root-&gt;right) return root-&gt;left;

        TreeNode* minNode = findMin(root-&gt;right);
        root-&gt;val = minNode-&gt;val;
        root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
    }

    return root;
}

TreeNode* findMin(TreeNode* node){
    while(node-&gt;left)
        node = node-&gt;left;
    return node;
}
*/</code></pre><p>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 树的3种遍历(include iterative and recursive)</span><br><span class="line">1. 下面四种情况中，只有 2 和 3 能唯一决定一棵树。More generally, if a node has only one child, preorder and postorder do not contain enough information to determine whether that child is a left child or a right child.</span><br><span class="line">    1. preorder and postorder</span><br><span class="line">    2. inorder and postorder</span><br><span class="line">    3. preorder and inorder</span><br><span class="line">    4. level order and postorder</span><br><span class="line"></span><br><span class="line">技巧</span><br><span class="line">1. 二叉搜索树的 in-order traversal 输出一个 sorted array</span><br><span class="line">2. 二叉搜索树的 pre-order traversal 输出一个 array，这个 array 不是 sorted，但是它有个特点就是，右子树的值肯定都大于当前节点。(leetcode-255, verify pre-order sequence of Binary Search Tree)</span><br><span class="line"></span><br><span class="line">### 前序遍历</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">void BinaryTree::PreOrder(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    _PreOrder(m_root, visited);</span><br><span class="line">    &#x2F;&#x2F;_PreOrder2(visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归思想去做前序遍历</span><br><span class="line">void BinaryTree::_PreOrder(TreeNode* root, vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!root) return;</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _PreOrder(root-&gt;left, visited);</span><br><span class="line">    _PreOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归方法的前序遍历</span><br><span class="line">void BinaryTree::_PreOrder2(vector&lt;int&gt;&amp; visited)&#123;</span><br><span class="line">    if(!m_root) return;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(m_root);</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    while(!s.empty())&#123;</span><br><span class="line">        pcur &#x3D; s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        visited.push_back(pcur-&gt;val);</span><br><span class="line">        if(pcur-&gt;right) s.push(pcur-&gt;right);</span><br><span class="line">        if(pcur-&gt;left) s.push(pcur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二插查找树中序遍历的结果是升序的排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::InOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _InOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _InOrder2(visited);</span></span><br><span class="line">    <span class="comment">// _InOrder3(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _InOrder(root-&gt;left, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">    _InOrder(root-&gt;right, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历</span></span><br><span class="line"><span class="comment">  注意，这一个不是按照上面的思路！每次拿出一个节点，把右放进去，再放自己，再放左。</span></span><br><span class="line"><span class="comment">  这样子需要额外记录一下节点是不是第一次访问的信息，写起来麻烦！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这里的解决思路是每次弹出一个节点，需要一直找左子树，</span></span><br><span class="line"><span class="comment">  走到头，把过程中碰到的节点都压入栈。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* pcur = m_root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pcur || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(pcur)&#123;        <span class="comment">// 找最左孩子</span></span><br><span class="line">            s.push(pcur);</span><br><span class="line">            pcur = pcur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            pcur = s.top();    <span class="comment">// 访问左海子为空的节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">            pcur = pcur-&gt;right;    <span class="comment">// 转向右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的中序遍历 第二种思路</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放自己，再放左子树节点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::PostOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">    _PostOrder(m_root, visited);</span><br><span class="line">    <span class="comment">// _PostOrder2(visited);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归思想去做中序遍历</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_PostOrder(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    _PostOrder(root-&gt;left, visited);</span><br><span class="line">    _PostOrder(root-&gt;right, visited);</span><br><span class="line">    visited.push_back(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  非递归方法的后序遍历（与中序遍历的第三个方法代码区别就只有一行！）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  这个思路就跟前序遍历的那个一直了！拿到一个节点，</span></span><br><span class="line"><span class="comment">  先把右子树节点放进栈，再放左子树节点，再放自己。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  只不过这里需要加上一个额外的信息看当前节点是不是第一次被压入栈！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> BinaryTree::_InOrder2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt; pair&lt;TreeNode*, <span class="keyword">int</span>&gt; &gt; s;</span><br><span class="line">    s.push(make_pair(m_root, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    TreeNode* pcur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        pcur = s.top().first;</span><br><span class="line">        times = s.top().second;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 对于叶子节点，从栈顶拿出来以后</span></span><br><span class="line">        <span class="comment">// 进入到 if 语句</span></span><br><span class="line">        <span class="comment">// 什么都干不了，会再次被压入栈</span></span><br><span class="line">        <span class="comment">// while 下一次执行时候会被再次拿出来</span></span><br><span class="line">        <span class="comment">// 然后进入 else 语句把 val 放入 visited 数组</span></span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>)&#123;              <span class="comment">// 第一次压栈</span></span><br><span class="line">            s.push(make_pair(pcur, <span class="number">1</span>));    <span class="comment">// 第二次压栈</span></span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;right)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;right, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;left)&#123;</span><br><span class="line">                s.push(make_pair(pcur-&gt;left, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visited.push_back(pcur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据前序中序，计算后续"><a href="#根据前序中序，计算后续" class="headerlink" title="根据前序中序，计算后续"></a>根据前序中序，计算后续</h3><p>[例如]<br>前序遍历: GDAFEMHZ<br>中序遍历: ADEFGHMZ</p>
<p>[思路]<br>两个步骤</p>
<ul>
<li>根据前序中序，构造二叉树</li>
<li>后序遍历二叉树</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InPre2Post</span><span class="params">(<span class="built_in">string</span> InOrder, <span class="built_in">string</span> PreOrder)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> n1 = InOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n2 = PreOrder.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> helper(InOrder, <span class="number">0</span>, n1 - <span class="number">1</span>, PreOrder, <span class="number">0</span>, n2 - <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span>&amp; InOrder, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span>&amp; PreOrder, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; i) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        res.push_back(InOrder[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = i;</span><br><span class="line">    <span class="keyword">while</span>(InOrder[k] != PreOrder[p])&#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    helper(InOrder, i, k<span class="number">-1</span>, PreOrder, p+<span class="number">1</span>, p+k-i, res);</span><br><span class="line">    helper(InOrder, k+<span class="number">1</span>, j, PreOrder, p+<span class="number">1</span>+k-i, q, res);</span><br><span class="line">    res.push_back(PreOrder[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据后续和中序，计算前序"><a href="#根据后续和中序，计算前序" class="headerlink" title="根据后续和中序，计算前序"></a>根据后续和中序，计算前序</h3><p>思路跟上面的 InPre2Post 基本一模一样。只不过：</p>
<ul>
<li>一个是 InOrder 的第一个元素作为根节点，</li>
<li>一个是 PostOrder 的末尾元素作为根节点。</li>
</ul>
<h3 id="前序遍历是否合法-leetcode-331"><a href="#前序遍历是否合法-leetcode-331" class="headerlink" title="前序遍历是否合法 leetcode 331"></a>前序遍历是否合法 leetcode 331</h3><p>[题目]</p>
<p>[分析]</p>
<ul>
<li>如何还原这个树？</li>
<li>建立每个节点<ul>
<li>顺着树往“左”走</li>
<li>遇到叶子(#)就回退，往右走</li>
</ul>
</li>
<li>维护每个节点的孩子</li>
<li>更巧的方法<ul>
<li>不需要知道“父子关系”</li>
<li>当前节点插入空位</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> space = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[i] == <span class="string">','</span>) preorder[i] = <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">s</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(s &gt;&gt; temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--space &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="string">"#"</span>)&#123;</span><br><span class="line">                space += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (space == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的写法有问题，一定要先减去一，再考虑是否要加上2</span></span><br><span class="line">    <span class="comment">/*bool isValidSerialization(string preorder) &#123;</span></span><br><span class="line"><span class="comment">        int space = 1;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 0) return true;</span></span><br><span class="line"><span class="comment">        if(preorder.size() == 1) return (preorder[0] == '#');</span></span><br><span class="line"><span class="comment">        if(preorder[0] == '#') return false;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; preorder.size(); i++)&#123;</span></span><br><span class="line"><span class="comment">            if(preorder[i] == ',') preorder[i] = ' ';</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        stringstream s(preorder);</span></span><br><span class="line"><span class="comment">        string temp;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        while(s &gt;&gt; temp)&#123;</span></span><br><span class="line"><span class="comment">            if(temp == "#")&#123;</span></span><br><span class="line"><span class="comment">                space--;</span></span><br><span class="line"><span class="comment">                if(space &lt; 0) return false;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                space++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; space;</span></span><br><span class="line"><span class="comment">        return (space == 0);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="复杂的树结构"><a href="#复杂的树结构" class="headerlink" title="复杂的树结构"></a>复杂的树结构</h2><ul>
<li>AVL 树：最早的平衡二叉树之一。应用相对其他数据结构比较少。Windows 对进程地址空间的管理使用到了 AVL 树。</li>
<li>红黑树：平衡二叉树，广泛用在 C++ 的 STL 中。如 map 和 set 都是用红黑树实现的。</li>
<li>B/B+ 树：用在磁盘文件组织，数据索引，和数据库索引。</li>
<li>Trie树（字典树）：用在统计和排序大量字符串，如自动机。</li>
</ul>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><h3 id="红黑树-RB-Tree"><a href="#红黑树-RB-Tree" class="headerlink" title="红黑树 RB-Tree"></a>红黑树 RB-Tree</h3><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><ol>
<li>Trie 树是一种哈希多叉树，又称字典树、单词查找树、或者前缀树，用于在大量字符串中快速检索。<ol>
<li>英文字母的字典树是一个 26 叉树。</li>
<li>数字的字典树是一个 10 叉树。</li>
</ol>
</li>
<li>典型应用<ol>
<li>统计和排序大量的字符串（但不仅限于字符串），经常被文字处理系统用于文本词频统计。</li>
<li>优点：利用字符串的公共前缀来节约存储空间，最大限度地减少无畏的字符串比较，查询效率比哈希表高。</li>
<li>缺点：如果存在大量字符串且这些字符串基本没有公共前缀，则相应的 Trie 树将非常消耗内存。</li>
</ol>
</li>
<li>基本性质<ol>
<li>根节点不包含字符。除根节点以外每一个节点都只包含一个字符。每个节点有 26 个指针指向子节点，同时自身还有个 bool 变量用来记录当前位置是否可以作为一个字符串的结束位置！</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该根节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
</li>
</ol>
<p>[题目]<br>给定一棵边的权值都是正整数的数，求某两个节点间的路径，使得该路径所包含的所有边权的异或值最大。</p>
<p>[例子]<br>中心点 B 有三个无向边指向 A, C, D，权值分别为 3, 4, 6<br>那么最优的答案就是路径 A-B-D，结果就是 3^4 = 7</p>
<p>[思路]</p>
<ol>
<li>思路一：朴素解法<ol>
<li>枚举所有节点对，求得所有路径异或权。时间复杂度O(n^2).</li>
</ol>
</li>
<li>思路二：<ol>
<li>问题分析<ol>
<li>异或的性质: a^b = (a^c)^(b^c)</li>
<li>因此可以选择一个点作为根节点建立一个数。然后任意两个节点之间的路径的权重的异或值，等于两个节点分别到跟节点的路径的权重异或值，这两个结果再异或一下就可以了。</li>
<li>从根节点到每个节点的异或值可以通过一次深度优先搜索解决，时间复杂度 O(n)</li>
<li><mark>问题转化为求 n 个数中异或值最大的两个数字。</mark></li>
</ol>
</li>
<li>利用 Trie 树的解法<ol>
<li>将数字看成二进制的 0/1 串，先将所有数字从最高位起放入一个二叉 Trie 数中 (这里如果数字的长度不一样，可以使用最大的数字的有效长度，比如最大的数字是 100，那么用 7 个 bit 位就可以表示了。其他的数字也都用 7 个 bit 位表示，不到的话左边补 0)</li>
<li>枚举每个数字 a，从最高位开始，寻找尽量与 a 对应位不同的数字；时间复杂度 O(len)</li>
<li>总体时间复杂度 O(N * len)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/Screen%20Shot%202020-01-04%20at%2013.58.39.png" alt=""></p>
<p>[总结]</p>
<ol>
<li>Trie 树逻辑结构清晰简练，在海量数据中查找某数据，和海量数据规模无关，只和待查找数据长度本身有关，时间复杂度为 O(len)，常认为是 O(1)。<ol>
<li>可以看做是以数据元素为关键字的多 Hash 结构</li>
<li>海量数据的复杂度分析未考虑内存调度问题。</li>
</ol>
</li>
<li>双数组的存储结构比较难，增删困难。实践中，往往离线将海量数据建立 Trie 树双数组结构，少量删除时可以继续使用。若大量删除，则离线建立新的 Trie 树双数组结构，适时替换。</li>
</ol>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#0117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="0117 Populating Next Right Pointers in Each Node II"></a>0117 Populating Next Right Pointers in Each Node II</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一题实际上就是 level order traversal</span></span><br><span class="line"><span class="comment">使用 queue 就很好做了</span></span><br><span class="line"><span class="comment">但是 queue 的空间复杂度是 O(n)</span></span><br><span class="line"><span class="comment">而题目要求是 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决的关键就在于 每一个 node 里都有一个 next pointer</span></span><br><span class="line"><span class="comment">它的存在使得我们没有必要用queue 记录一层所有的 nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法关键：</span></span><br><span class="line"><span class="comment">    在扫描当前level的节点的 children nodes 时候</span></span><br><span class="line"><span class="comment">    更新这些 children nodes 的 next 指针</span></span><br><span class="line"><span class="comment">    这样子，在扫描下一个 level的时候，</span></span><br><span class="line"><span class="comment">    就可以使用这些 next pointer 了！！！</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">二刷关键：</span></span><br><span class="line"><span class="comment">    引入一个 dummy node 可以使得代码更简洁！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">        TreeLinkNode *cur; <span class="comment">// cur 指针扫描下一层 的节点;</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;                          <span class="comment">// root 指针用于扫描当前 level</span></span><br><span class="line">            cur = dummy;                        <span class="comment">// cur 指针扫描下一层 的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root) &#123;                       <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;left;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;next = root-&gt;right;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            root = dummy-&gt;next;                <span class="comment">// root 指针跳到下一层的 dummy 后面第一个有效节点</span></span><br><span class="line">            dummy-&gt;next = <span class="literal">nullptr</span>;             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 一刷的代码，不够简洁</span></span><br><span class="line"><span class="comment">    void connect(TreeLinkNode *root) &#123;</span></span><br><span class="line"><span class="comment">        TreeLinkNode *cur = root;         //current node of current level</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while (cur) &#123;</span></span><br><span class="line"><span class="comment">            TreeLinkNode *head = NULL;   // head of the next level</span></span><br><span class="line"><span class="comment">            TreeLinkNode *prev = NULL;   //the leading node on the next level</span></span><br><span class="line"><span class="comment">            while(cur) &#123;       //iterate on the current level</span></span><br><span class="line"><span class="comment">                if (cur-&gt;left) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev  = cur-&gt;left;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                if (cur-&gt;right) &#123;</span></span><br><span class="line"><span class="comment">                    if (head == NULL) &#123;</span></span><br><span class="line"><span class="comment">                        head = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        prev-&gt;next = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    prev = cur-&gt;right;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                //move to next node           </span></span><br><span class="line"><span class="comment">                cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //move to next level</span></span><br><span class="line"><span class="comment">            cur = head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Find-k-th-smallest-number-of-binary-search-tree"><a href="#Find-k-th-smallest-number-of-binary-search-tree" class="headerlink" title="Find k-th smallest number of binary search tree"></a>Find k-th smallest number of binary search tree</h2><p>==适用于binary search tree 的递归的方法==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elements;</span><br><span class="line">        recurse(root, elements, k);</span><br><span class="line">        <span class="keyword">return</span> elements[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; elements, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(elements.<span class="built_in">size</span>() == k) <span class="keyword">return</span>;        <span class="comment">// 技巧，提前停止</span></span><br><span class="line">        recurse(root-&gt;left, elements, k);</span><br><span class="line">        elements.push_back(root-&gt;val);</span><br><span class="line">        recurse(root-&gt;right, elements, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==适用于BST的非递归，使用stack的方法！！！（这个非常棒！！！）==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; mystack;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr || !mystack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr)</span><br><span class="line">            &#123;</span><br><span class="line">                mystack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr = mystack.top();</span><br><span class="line">                mystack.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE BEGIN</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> curr-&gt;val;</span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                <span class="comment">// VISIT NODE END</span></span><br><span class="line">                <span class="comment">// ---------------------------------------</span></span><br><span class="line">                </span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>==适用于任何的二叉树(binary tree, not necessarily BST)：先输出所有点(iterative 或 recursive)到array，然后找第 k 个==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 iterative 的方法，输出所有点到 array</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode*&gt; dq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    dq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span>(!dq.empty())&#123;</span><br><span class="line">        TreeNode* temp = dq.front();</span><br><span class="line">        myvec.push_back(temp-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left) dq.push_back(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right) dq.push_back(temp-&gt;right);</span><br><span class="line">        dq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 recursive 的方法，输出所有点到array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest_not_optimized_version</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvec;</span><br><span class="line">    helper(root, myvec);</span><br><span class="line">    <span class="comment">//auto it = myvec.begin() + k - 1;                     // O(n)的复杂度</span></span><br><span class="line">    <span class="comment">//nth_element(myvec.begin(), it, myvec.end());</span></span><br><span class="line">    sort(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>());                      <span class="comment">// O(nlogn) 的复杂度</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span>  myvec[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.push_back(root-&gt;<span class="keyword">int</span>);</span><br><span class="line">    helper(root-&gt;left, vec);</span><br><span class="line">    helper(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Common-Ancester-总结"><a href="#Common-Ancester-总结" class="headerlink" title="Common Ancester 总结"></a>Common Ancester 总结</h2><p>注意</p>
<ol>
<li>这些题目的有些解法对问题的定义实际上是做了修改的！但是却巧妙地得到了正确答案。</li>
<li>注意经常犯的把问题复杂化的一个习惯是分别对如下情况考虑<ol>
<li>root 的左右子树分别含有 p 和 q</li>
<li>p 是 root, 子节点立面有 q</li>
<li>q 为根的子树里面有 p</li>
</ol>
</li>
</ol>
<h3 id="leetcode-0235"><a href="#leetcode-0235" class="headerlink" title="leetcode 0235"></a>leetcode 0235</h3><p>[题目]</p>
<ol>
<li>p 和 q 节点不相同，且一定存在！</li>
<li>BST 节点里的数值互不相同。</li>
</ol>
<p>[思路]</p>
<ol>
<li>[不好的思路]<ol>
<li>如上所述，对几种情况分别考虑，代码很长，时间也不低。</li>
</ol>
</li>
<li>好的思路，充分利用 BST 树的性质来做。<ol>
<li>其 LCA 节点的值一定在给定的两个节点的值中间。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursive 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; maxVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; minVal) <span class="keyword">return</span> lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterative 解法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; maxVal)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; minVal)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;    <span class="comment">// 这一句不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="leetcode-0236"><a href="#leetcode-0236" class="headerlink" title="leetcode 0236"></a>leetcode 0236</h3><p>[题目]</p>
<ol>
<li>本题的变化是树不再是 BST 了</li>
<li>同样的，仍然有<ol>
<li>所有节点的值都不相同</li>
<li>p 和 q 不同，且一定存在</li>
</ol>
</li>
</ol>
<p>[分析]</p>
<ol>
<li>递归解法一个核心的思想是: <mark>我们找到一个节点 p 后，就不需要再递归找另一个 q 了，直接返回这个 p 就行！因为如果节点 q 在下面的话，那么二者的 LCA 一定是 p</mark>.</li>
<li>在这个前提条件下，我们的判断条件是，左子树上找到了一个点，右子树上找到了一个点，那么当前 root 就是 LCA.</li>
<li>为啥说这个解法对题目做了修改呢，因为我们没有去直接找两个点，而是找到一个就返回了！但是判断条件决定了我们可以找到正确的答案。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncester</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncester(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncester(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lintcode-578"><a href="#lintcode-578" class="headerlink" title="lintcode 578"></a>lintcode 578</h3><p>[题目]</p>
<ol>
<li>主要区别是两个节点有可能不在这个树上！！</li>
</ol>
<p>[思路一]</p>
<ol>
<li>可以先遍历一遍看看两个节点是否在树上啊！！！</li>
<li>然后就可以使用上面的代码了哎！</li>
</ol>
<p>[思路一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasNode</span><span class="params">(TreeNode* root, TreeNode* p, <span class="keyword">bool</span>&amp; flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hasNode(root-&gt;left, p, flag);</span><br><span class="line">    hasNode(root-&gt;right, p, flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasP = <span class="literal">false</span>, hasQ = <span class="literal">false</span>;</span><br><span class="line">    hasNode(root, p, hasP);</span><br><span class="line">    hasNode(root, q, hasQ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个节点至少有一个不存在</span></span><br><span class="line">    <span class="keyword">if</span>( !hasP || !hasQ ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明两个节点一定存在了</span></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestorHelper(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestorHelper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncestorHelper(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestorHelper(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：</p>
<ol>
<li>我这个代码算是一个非常好的代码！时间复杂度不高，空间复杂度 leetcode 上显示，小于百分百提交的代码！</li>
<li>我这个代码看似是遍历了三遍树，实际上每次都没有遍历完！<ol>
<li>我定义的辅助函数 hasNode 在找到节点后就停止递归了！网上有不好的实现方法是递归同时找两个节点！这样子你找到一个后不可以停止，导致必须遍历完全部的树节点才可以！</li>
<li>由于知道两个节点后才调用 lowestCommonAncestorHelper，这个函数找到一个节点后也会停止递归！</li>
<li>空间复杂度这么好是因为没有递归遍历所有的节点，导致使用的 stack memory 较少所致！</li>
</ol>
</li>
</ol>
<p>[思路二]</p>
<ol>
<li>因为可能有无效的节点，所以上面的那个解法就不 work 了，我们需要真得去找到 p 和 q 才行！</li>
</ol>
<p>[思路二代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> a_exist, b_exist;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    ResultType(<span class="keyword">bool</span> a, <span class="keyword">bool</span> b, TreeNode* n) &#123;</span><br><span class="line">        a_exist = a;</span><br><span class="line">        b_exist = b;</span><br><span class="line">        node = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ResultType rt = helper(root, p, q);</span><br><span class="line">        <span class="keyword">if</span> (rt.a_exist &amp;&amp; rt.b_exist)</span><br><span class="line">            <span class="keyword">return</span> rt.node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ResultType <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root 不存在，则 p, q 一定不在树里面。</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ResultType(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        ResultType left_rt = helper(root-&gt;left, p, q);</span><br><span class="line">        ResultType right_rt = helper(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> a_exist = left_rt.a_exist || right_rt.a_exist || root == p;</span><br><span class="line">        <span class="keyword">bool</span> b_exist = left_rt.b_exist || right_rt.b_exist || root == q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四种情况</span></span><br><span class="line">        <span class="comment">// 一：p, q 至少有一个等于 root</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二：</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span> &amp;&amp; right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 三：p, q 同属 root 的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (left_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, left_rt.node);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四：p, q 同属 root 的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (right_rt.node != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ResultType(a_exist, b_exist, right_rt.node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultType(a_exist, b_exist, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="节点含有父节点指针"><a href="#节点含有父节点指针" class="headerlink" title="节点含有父节点指针"></a>节点含有父节点指针</h3><p>[思路]</p>
<ol>
<li>面试中，面试者一般不直接告诉你树的节点是否含有父节点的指针，能否自定义树的 node，因此需要主动询问。</li>
<li>如果有指向父节点的指针的话，这道题就类似于 Y 链表那道题目。<ol>
<li>先分别求出 p 和 q 到 root 的距离，假定 p 到 root 距离是 q 到 root 距离多 N steps.<ol>
<li>当然如果 p 和 q 可能不属于同一棵树的话</li>
<li>这里可以判断两个 root 是否相等，如果不相等说明 p 和 q 来自不同的树！</li>
</ol>
</li>
<li>让 p 向上走 N steps</li>
<li>p 和 q 同时向上走，直到相遇！</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>树是最重要的数据结构，没有之一！</li>
<li>从根节点到叶子的过程，是逐渐细化精确的过程，所以，实践中往往作为海量数据索引。</li>
<li>数只是数据结构，非存储结构。实践中，可以使用数组来存储树。<ul>
<li>思考实例 Huffman 编码、堆排序、并查集等。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/leetcode-linked-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/08/leetcode-linked-list/" itemprop="url">leetcode linked list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-08T11:16:04-08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/leetcode-linked-list/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/08/leetcode-linked-list/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目总体分析"><a href="#题目总体分析" class="headerlink" title="题目总体分析"></a>题目总体分析</h1><p>哎感觉链表的题目基本上都是考你指针操作的细节的。。。<br>算法上都没有特别难的。。</p>
<h1 id="C-相关操作语法"><a href="#C-相关操作语法" class="headerlink" title="C++ 相关操作语法"></a>C++ 相关操作语法</h1><p>TODO</p>
<h1 id="Python-相关操作语法"><a href="#Python-相关操作语法" class="headerlink" title="Python 相关操作语法"></a>Python 相关操作语法</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="翻转单链表"><a href="#翻转单链表" class="headerlink" title="翻转单链表"></a>翻转单链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头开始翻</span></span><br><span class="line">ListNode *result = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line">    temp = head-&gt;next;</span><br><span class="line">    head-&gt;next = result;</span><br><span class="line">    result = head;</span><br><span class="line">    head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### TODO 思考：翻转部分链表 leetcode <span class="number">92</span></span><br><span class="line">- 如何找到第 m 个元素和第 n 个元素</span><br><span class="line">- 如何处理前面和后面</span><br><span class="line">    - 保存前面部分最后一个元素</span><br><span class="line">    - 保存后面部分第一个元素</span><br><span class="line">    - 特殊情况？</span><br><span class="line"></span><br><span class="line">### TODO 思考： 每 k 个元素翻转一次 leetcode <span class="number">25</span></span><br><span class="line">- 前面翻好的部分（小链表）</span><br><span class="line">- 要翻转的部分（K 个）</span><br><span class="line">- 后面没处理的部分（小链表）</span><br><span class="line">- 不足 k 个怎么办？</span><br><span class="line"></span><br><span class="line">## 单链表含有环 leetcode <span class="number">0141</span>, <span class="number">0142</span></span><br><span class="line"></span><br><span class="line">分析</span><br><span class="line">- 假设链表起点到圈起点距离是 a，相遇点到圈起点距离是 b</span><br><span class="line">- 那么有</span><br><span class="line">    - slow pointer 走了 a + b</span><br><span class="line">    - fast pointer 走了 a + b + k * n == <span class="number">2</span> * (a+b)</span><br><span class="line">    - 从而 a + b = k * n</span><br><span class="line">- 如何找圈的起点</span><br><span class="line">    - 相遇后，把 slow pointer 拉回链表起点，fast pointer 从相遇点继续走。</span><br><span class="line">    - 注意这个时候两个指针都一步一步的走</span><br><span class="line">    - 这个时候二者会在圈起点相遇！！！</span><br><span class="line">- 如何找圈长</span><br><span class="line">    - 相遇后，slow pointer 再走一圈并统计长度就是圈长。</span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head)&#123;</span><br><span class="line">        ListNode *p1 = head, *p2 = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((!p2) || (p2-&gt;next == <span class="literal">nullptr</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span>(p1 != p2);</span><br><span class="line">        <span class="keyword">for</span>(p1 = head; p1 != p2; p1 = p1-&gt;next, p2 = p2-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个单链表是否相交-leetcode-160"><a href="#两个单链表是否相交-leetcode-160" class="headerlink" title="两个单链表是否相交 leetcode 160"></a>两个单链表是否相交 leetcode 160</h2><p>就是检测是否是 Y 型结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tempA = headA, *tempB = headB;</span><br><span class="line">        <span class="keyword">int</span> lenA, lenB;</span><br><span class="line">        <span class="keyword">for</span>(lenA = <span class="number">0</span>; tempA; tempA = tempA-&gt;next) lenA++;</span><br><span class="line">        <span class="keyword">for</span>(lenB = <span class="number">0</span>; tempB; tempB = tempB-&gt;next) lenB++;</span><br><span class="line">        tempA = headA;</span><br><span class="line">        tempB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB; i++) tempA = tempA-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA; i++) tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tempA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempA == tempB) <span class="keyword">return</span> tempA;</span><br><span class="line">            tempA = tempA-&gt;next;</span><br><span class="line">            tempB = tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复制带随机指针的链表-leetcode-138"><a href="#复制带随机指针的链表-leetcode-138" class="headerlink" title="复制带随机指针的链表 leetcode 138"></a>复制带随机指针的链表 leetcode 138</h2><p>方法一：使用 map&lt;旧地址，新地址&gt;</p>
<p>方法二：不用 map</p>
<ul>
<li>插入：每个旧节点后面插入一个自身的“复本”</li>
<li>复制 random 指针<ul>
<li>一个旧节点 a 的复本是 a-&gt;next</li>
<li>a-&gt;ranom 的复本是 a-&gt;random-&gt;next</li>
<li>新节点的random 指针 a-&gt;next-&gt;random = a-&gt;random-&gt;next (空值单独判断)</li>
</ul>
</li>
<li>拆分<ul>
<li>旧节点链表是奇数项</li>
<li>新节点链表是偶数项<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(RandomListNode *now = head; now; )&#123;</span><br><span class="line">            RandomListNode *copy = <span class="keyword">new</span> RandomListNode(now-&gt;label);</span><br><span class="line">            copy-&gt;next = now-&gt;next;</span><br><span class="line">            now-&gt;next = copy;</span><br><span class="line">            now = copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(RandomListNode *now = head; now; now = now-&gt;next-&gt;next)&#123;</span><br><span class="line">            now-&gt;next-&gt;<span class="built_in">random</span> = (now-&gt;<span class="built_in">random</span> == <span class="literal">nullptr</span>) ? <span class="literal">nullptr</span> : now-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode *h = head-&gt;next, *t = h, *tail = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            tail = tail-&gt;next = t-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!tail)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            t = t-&gt;next = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="链表-partition-leetcode-86"><a href="#链表-partition-leetcode-86" class="headerlink" title="链表 partition leetcode 86"></a>链表 partition leetcode 86</h2><p>链表里存放整数，给定 x 把比 x 小的节点放到比 x 大的节点之前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        ListNode *h1 = <span class="literal">nullptr</span>, *t1 = <span class="literal">nullptr</span>, *h2 = <span class="literal">nullptr</span>, *t2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( ; head; head = head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t1)&#123;    <span class="comment">// 需要看一下是不是 nullptr</span></span><br><span class="line">                    t1 = t1-&gt;next = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    h1 = t1 = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t2)&#123;</span><br><span class="line">                t2 = t2-&gt;next = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h2 = t2 = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t2) t2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1) t1-&gt;next = h2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h1? h1 : h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>[题目]<br>给定一个链表，返回排序后的结果。</p>
<p>[分析]</p>
<ul>
<li>思路就是 merge sort</li>
<li>但是注意 merge sort 的空间复杂度严格上来说并不是 O(1)，而是 O(logN) 的，</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//divide the list into two parts </span></span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(sortList(head), sortList(fast));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dump</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* cur = &amp;dump;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">NULL</span>)</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除重复元素-leetcode-0082"><a href="#删除重复元素-leetcode-0082" class="headerlink" title="删除重复元素 leetcode 0082"></a>删除重复元素 leetcode 0082</h2><p>[题目]<br>删除出现两次或以上的元素，只保留只出现过一次的元素。</p>
<p>[代码]<br>使用辅助函数真的方便了很多</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        head = nextSingleElementPointer(head);</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* head2 = nextSingleElementPointer(head-&gt;next);</span><br><span class="line">        <span class="keyword">while</span>(head2)&#123;</span><br><span class="line">            cur-&gt;next = head2;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            head2 = nextSingleElementPointer(cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">nextSingleElementPointer</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;    <span class="comment">// if has duplicate</span></span><br><span class="line">            <span class="keyword">int</span> temp = head-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == temp)                           <span class="comment">// , then skip all the current values</span></span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/leetcode-stack-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/leetcode-stack-queue/" itemprop="url">leetcode stack queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-07T17:23:44-08:00">
                2019-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/leetcode-stack-queue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/07/leetcode-stack-queue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><p>TODO</p>
<h1 id="C-相关语法操作"><a href="#C-相关语法操作" class="headerlink" title="C++ 相关语法操作"></a>C++ 相关语法操作</h1><p>TODO</p>
<p>用自定义 greater 决定最大堆，最小堆。</p>
<h1 id="python-相关语法操作"><a href="#python-相关语法操作" class="headerlink" title="python 相关语法操作"></a>python 相关语法操作</h1><p>TODO</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="用两个队列实现一个栈"><a href="#用两个队列实现一个栈" class="headerlink" title="用两个队列实现一个栈"></a>用两个队列实现一个栈</h2><p>思路：用两个队列来回倒，保证一个队列是空的。<br>用空队列临时存储除队尾外所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入栈：维护一个队列是空的。时间复杂度: O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty()) q1.push(x)</span><br><span class="line">    <span class="keyword">else</span> q2.push(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">出栈：用一个队列临时存放元素。时间复杂度:O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pop():</span><br><span class="line">    <span class="keyword">if</span>(!q1.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(q1.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            q2.push(q1.front());</span><br><span class="line">            q1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q1.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类似操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用两个堆栈实现一个队列"><a href="#用两个堆栈实现一个队列" class="headerlink" title="用两个堆栈实现一个队列"></a>用两个堆栈实现一个队列</h2><p>思路：使用两个堆栈。s1 负责 push, s2 负责 pop.<br>注意这个跟上一个题目不一样，因为不是每次 pop 都需要重新翻一次数据。<br>如果负责 pop 的 s2 里面还有数据的话，可以直接 pop.<br>这样子最终的 amotized complexity is O(1).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">push(x): <span class="comment">//O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// 均摊O(1) 每个元素出入两个栈各一次。</span></span><br><span class="line">    <span class="keyword">if</span>(s2.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">            s2.push(s1.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s2.pop();</span><br></pre></td></tr></table></figure>

<h2 id="支持查找最小值的栈"><a href="#支持查找最小值的栈" class="headerlink" title="支持查找最小值的栈"></a>支持查找最小值的栈</h2><p>题目：一个堆栈除了支持 push, pop 外还要支持一个操作: getMin 得到当前堆栈里所有元素的最小值。</p>
<p>思路一：用两个堆栈，s1 正常使用，s2 在 getMin 的时候使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：用两个堆栈，s1 维护原来的值，s2 维护最小值，他们元素个数一样多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">push(x):  <span class="comment">// O(1)</span></span><br><span class="line">    s1.push(x)</span><br><span class="line">    <span class="keyword">if</span>(!s2.empty() &amp;&amp; s2.top() &lt; x) s2.push(s2.top())</span><br><span class="line">    <span class="keyword">else</span> s2.push(x)</span><br><span class="line"></span><br><span class="line">pop():  <span class="comment">// O(1)</span></span><br><span class="line">    s1.pop()</span><br><span class="line">    s2.pop()</span><br><span class="line"></span><br><span class="line">getMin:  <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> s2.top()</span><br></pre></td></tr></table></figure>

<h3 id="变型：维护最小值的-queue"><a href="#变型：维护最小值的-queue" class="headerlink" title="变型：维护最小值的 queue"></a>变型：维护最小值的 queue</h3><p>==维护队列单调性！！！==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">利用两个双端队里，记录最大值的双端队列保持单调递减性，记录最小值的双端队列保持单调递增性。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; minque;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; maxque;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que.push(val);</span><br><span class="line">    <span class="keyword">while</span> ((!minque.empty()) &amp;&amp; (minque.back() &gt; val))</span><br><span class="line">        minque.pop_back();</span><br><span class="line">    minque.push_back(val);</span><br><span class="line">    <span class="keyword">while</span> ((!maxque.empty()) &amp;&amp; (maxque.back() &lt; val))</span><br><span class="line">        maxque.pop_back();</span><br><span class="line">    maxque.push_back(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">if</span> (minque.front() == value)</span><br><span class="line">        minque.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (maxque.front() == value)</span><br><span class="line">        maxque.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minque.front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findmax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxque.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直方图中最大面积矩形-leetcode-84"><a href="#直方图中最大面积矩形-leetcode-84" class="headerlink" title="直方图中最大面积矩形 leetcode 84"></a>直方图中最大面积矩形 leetcode 84</h2><p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想还是维持一个单调的栈。</span></span><br><span class="line"><span class="comment">这里栈内元素大小是递增的。一旦来了一个小的元素，那么会把栈顶比此元素大的一个一个 pop 出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">height</span>.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>(), area = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexes.empty() &amp;&amp; <span class="built_in">height</span>[indexes.top()] &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">height</span>[indexes.top()];   <span class="comment">// 以当前栈顶值为高度的矩形，此时右边界已经确定，就是刚扫描到的 height[i]。</span></span><br><span class="line">                indexes.pop();    <span class="comment">// 而左边界就是栈里下面压着的那一个 index. 因为下面压着的 index 那个高度小于它。</span></span><br><span class="line">                <span class="keyword">int</span> l = indexes.empty() ? <span class="number">-1</span> : indexes.top();  </span><br><span class="line">                area = <span class="built_in">max</span>(area, h * (i - l - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            indexes.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="sliding-window-maximum"><a href="#sliding-window-maximum" class="headerlink" title="sliding window maximum"></a>sliding window maximum</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque 只需要保存 k 个内容就可以，这里是保存 index，</span></span><br><span class="line"><span class="comment">此处关键是 dq 保存所有的 k 个 index 吗？</span></span><br><span class="line"><span class="comment">显然不是，它只会保存有用的信息。</span></span><br><span class="line"><span class="comment">什么才是有用的信息？是那些有可能成为 maximum 的点。</span></span><br><span class="line"><span class="comment">这里的操作和之前 0456 - 132 Pattern 解法中的操作类似。</span></span><br><span class="line"><span class="comment">在考虑 num[i] 的时候，把 num[i] 跟 dequeue 的最后一个值(实际是index对应位置的值)比较</span></span><br><span class="line"><span class="comment">如果小于 nums[i]，那么就 pop_back()，直到遇到比 nums[i] 大的</span></span><br><span class="line"><span class="comment">这个操作保证了 dequeue 中的数值一定是递减数列</span></span><br><span class="line"><span class="comment">此时 de.front() 对应的值就是位置 i(含) 之前 k 个值中最大的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front();</span><br><span class="line">            <span class="keyword">while</span>(!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[dq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">dq 中保存的是 index，所以第8行和第10行用 nums[dq.back()], nums[dq.front()].</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">心得体会</span></span><br><span class="line"><span class="comment">我发现这个用 stack(0456) 或者queue存储 maximum/minimum 的技巧，</span></span><br><span class="line"><span class="comment">对于比较大小或者 max/min 的题目很有效啊。</span></span><br><span class="line"><span class="comment">主要就是 stack/queue 的“两端”是对应的是 current maximum/minimum</span></span><br><span class="line"><span class="comment">可以用O(1)直接找到并作比较。</span></span><br><span class="line"><span class="comment">如果直接在一个范围内找 max 作比较，那就需要 O(n) 去找了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">答案里分析 time complexity 的时候都提到了 amotized O(n)，</span></span><br><span class="line"><span class="comment">这个是因为 for loop 里面那个 while 的次数是变得，可能为 O(1) ，也可能为 O(n).</span></span><br><span class="line"><span class="comment">换个角度，每个元素最多被添加一次pop一次，因此算法复杂度是 amotized O(n).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/" itemprop="url">leetcode 数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-04T21:39:38-08:00">
                2019-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/04/leetcode-数组/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试题总体分析"><a href="#面试题总体分析" class="headerlink" title="面试题总体分析"></a>面试题总体分析</h1><pre><code>查找和排序
    二分查找: 貌似都可以使用或者不使用递归！
    元素交换
    排序，中位数
    归并
    位运算
    前缀和的应用
动态规划
排列组合</code></pre><h1 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h1><h1 id="python-list"><a href="#python-list" class="headerlink" title="python list"></a>python list</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reverse()</span></span><br><span class="line"><span class="comment"># list_a[::-1]    # 二者都可以让列表反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list_a.sort()    # 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于字典，字符串等数据结构，必须用 sorted 函数</span></span><br><span class="line"><span class="comment"># sorted(iterable[, cmp[, key[, reverse]]])</span></span><br><span class="line">dict_a = &#123;<span class="string">'a'</span> : <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line">sorted(dict_a, key = <span class="keyword">lambda</span> d: d[<span class="number">0</span>])    <span class="comment"># 按照 key 排序，换成 d[1] 就按照 value 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 1D list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1d = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2d = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>


<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="局部极小值-leetcode-162"><a href="#局部极小值-leetcode-162" class="headerlink" title="局部极小值 leetcode 162"></a>局部极小值 leetcode 162</h2><p>一个给定的不包含相同元素的整数数组，每个局部极小值的定义是一个值比左右相邻的（如果存在）都小的值。求它的一个局部极小值。</p>
<pre><code>分析：首先要问清楚边界条件如何处理，在这里假定边界条件是比它大的。

这里规定用数组下标 a[1, ..., n]表示那 n 个整数，定义 a[0] = a[n+1] = 无穷大。

递归的思路是，如果子数组 a[p, q] 满足条件 a[p] &lt; a[p-1], a[q] &lt; a[q+1]，则它包含一个局部极小值。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：不使用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解法二：使用递归思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">int</span> m = i + (j-i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[m+<span class="number">1</span>]) <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, m+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数值等于下标的元素"><a href="#数值等于下标的元素" class="headerlink" title="数值等于下标的元素"></a>数值等于下标的元素</h2><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。<br>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组[-3, -1, 1, 3, 5]中，数字3和它的下标相等。</p>
<p>样例<br>输入：[-3, -1, 1, 3, 5]<br>输出：3</p>
<p>注意:如果不存在，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="循环有序数组查找元素-leetcode-153"><a href="#循环有序数组查找元素-leetcode-153" class="headerlink" title="循环有序数组查找元素 leetcode 153"></a>循环有序数组查找元素 leetcode 153</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1</p>
<p>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：二分法</span></span><br><span class="line"><span class="comment">找中间一个元素，因为数组有 shift，所以中间元素只有两种可能：</span></span><br><span class="line"><span class="comment">要么在左半段，中间元素数值大于两端的数值；</span></span><br><span class="line"><span class="comment">要么在右半段，中间元素数值小于两端的数值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意，有个特殊情况就是如果 shift=0，那么只有一个左半段存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span> || nums[<span class="number">0</span>] &lt; nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == j) <span class="keyword">return</span> <span class="built_in">min</span>(nums[i], nums[j]);</span><br><span class="line">        <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> helper(nums, m, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="循环有序数组查找元素-leetcode-154"><a href="#循环有序数组查找元素-leetcode-154" class="headerlink" title="循环有序数组查找元素 leetcode 154"></a>循环有序数组查找元素 leetcode 154</h2><p>TODO</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>【思路】<br>就是动态规划！注意空间复杂度可以不用建立二维数组，只使用两个一维向量就可以了。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>【思路】</p>
<ul>
<li>方法一：其实这一题可以转换为最长公共子序列的问题<ul>
<li>先对数组进行排序</li>
<li>计算排序后数组和原来数组的最长公共子序列，这个就是最长递增的子序列</li>
<li>复杂度为排序的复杂度 = O(nlogn)</li>
</ul>
</li>
<li>方法二：直接用动态规划<ul>
<li>方法很直接</li>
<li>时间复杂度是 O(n^2)</li>
</ul>
</li>
</ul>
<p>[方法三 贪心的算法]<br>这个方法比较难想出来，也难以表达清楚。这里先给出过程如下。</p>
<p>假设原来的序列是 3 4 5 1 2 3 4</p>
<p>逐个考察这些数</p>
<ul>
<li>考察 3 得到 [3]</li>
<li>考察 4 比 3 大，放到后面，得到 [3, 4]</li>
<li>考察 5 比 4 大，放到后面，得到 [3, 4, 5]</li>
<li>考察 1 比 3 还小，替换掉 3, 得到 [1, 4, 5]</li>
<li>考察 2 比 4 还小，替换掉 4， 得到 [1, 2, 5]</li>
<li>考察 3 比 5 还小，替换掉 5， 得到 [1, 2, 3]</li>
<li>考察 4 比 3 大，放到后面，得到 [1, 2, 3, 4]</li>
<li>最终得到的数组长度为 4，那么就代表最长的递增子序列长度为 4.</li>
</ul>
<p><mark>[上面构造的数组的意义]</mark><br>数组 temp 中第 i 个位置的数组 temp[i] 代表原数组中当前能够找到的，长度为 i 的递增子序列中末尾数子最小的是 temp[i].</p>
<p>比如考虑到上面考察到 2 的时候，得到的 temp 数组是 [1, 2, 5].</p>
<ul>
<li>这个 temp 数组中数字 1 表示长度为 1 的递增子序列中末尾数字最小的是 1</li>
<li>这个 temp 数组中数字 2 表示长度为 2 的递增子序列中末尾数字最小的是 2</li>
<li>这个 temp 数组中数字 5 表示长度为 3 的递增子序列中末尾数字最小的是 5</li>
</ul>
<h2 id="第一个缺失的正整数-leetcode-41"><a href="#第一个缺失的正整数-leetcode-41" class="headerlink" title="第一个缺失的正整数 leetcode 41"></a>第一个缺失的正整数 leetcode 41</h2><p>[题目]<br>给一个数组，找到从 1 开始第一个不在里面的正整数。</p>
<p>[例如]<br>输入：[3, 4, -1, 1]<br>输出：2.</p>
<p><mark>循环不变式</mark></p>
<ul>
<li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则钙元素即为所求。</li>
<li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li>
</ul>
<p><mark>利用循环不变式设计算法</mark><br>假定前 i-1 个数已经找到，并且依次存放在 A[1,2,…,i-1]中，继续考察 A[i]:</p>
<ul>
<li>若 A[i]&lt;i 且 A[i]&gt;=1, 则 A[i] 在 A[1,2,…,i-1] 中已经出现过，可以直接丢弃。<ul>
<li>若 A[i] 为负，则更应该丢弃它</li>
</ul>
</li>
<li>若 A[i]&gt;i 且 A[i] &lt;= N, 则 A[i] 应该位于后面的位置上，则将 A[A[i]] 和 A[i] 交换。<ul>
<li>若 A[i]&gt;=N, 由于缺失数据一定小于 N, 则 A[i] 丢弃</li>
</ul>
</li>
<li>若 A[i]=i, 则 A[i] 位于正确的位置上，则 i 加 1，循环不变式扩大，继续比较后面的元素。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：数组下标从 0 开始，</span><br><span class="line">我们得目的是让 a[i] &#x3D;&#x3D; i + 1</span><br><span class="line">每次循环</span><br><span class="line">    1. 要么 i+1</span><br><span class="line">    2. 要么 n-1</span><br><span class="line">    3. 要么有一个数被放到正确的位置</span><br><span class="line"></span><br><span class="line">有一点要记住！一旦一个元素被放到正确的位置以后，那么它的位置就不会改变了！</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt; A, int n)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; )&#123;</span><br><span class="line">            if(A[i] &#x3D;&#x3D; i + 1)&#123;  &#x2F;&#x2F; A[i]刚好位置正确</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; else if ((A[i] &lt;&#x3D; i) || (A[i] &gt; n) || (A[A[i] - 1] &#x3D;&#x3D; A[i]))&#123;  &#x2F;&#x2F; 当前元素可以丢掉了！</span><br><span class="line">                A[i] &#x3D; A[--n];  &#x2F;&#x2F; 快速丢弃 A[i]，就是把最后一个元素移过来，同时长度减去一。</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                swap(A[i], A[A[i] - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素最大间距-leetcode-164-“maximum-Gap”"><a href="#元素最大间距-leetcode-164-“maximum-Gap”" class="headerlink" title="元素最大间距 leetcode 164 “maximum Gap”"></a>元素最大间距 leetcode 164 “maximum Gap”</h2><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:<br>Input: [3,6,9,1]<br>Output: 3<br>Explanation: The sorted form of the array is [1,3,6,9], either<br>             (3,6) or (6,9) has the maximum difference 3.</p>
<p>Example 2:<br>Input: [10]<br>Output: 0<br>Explanation: The array contains less than 2 elements, therefore return 0.</p>
<p>Note:<br>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br>Try to solve it in linear time/space.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大值x, 最小值y，如果 x==y 答案是0.</span></span><br><span class="line"><span class="comment">把数放进 n+1 个桶。</span></span><br><span class="line"><span class="comment">    每个桶大小是 d = (x-y)/(n+1) 浮点数</span></span><br><span class="line"><span class="comment">    每个桶区间是 [y + i*d, y + (i+1) * d) (i=0, 1, 2, ..., n)</span></span><br><span class="line"><span class="comment">        注意是左闭右开的区间，最后一个桶是双闭区间。</span></span><br><span class="line"><span class="comment">        最小的数在 0 号桶里，最大的数在 n 号桶里。</span></span><br><span class="line"><span class="comment">        第一个桶非空，最后一个桶非空。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    【鸽笼原理】中间有空桶，空桶左右两侧肯定有元素。</span></span><br><span class="line"><span class="comment">    最大间隙出现在一个非空桶的最大值和下一个非空桶的最小值之间。</span></span><br><span class="line"><span class="comment">    如何判断数 r 出现在哪个桶里</span></span><br><span class="line"><span class="comment">        (r-y)*(n+1)/(x-y) （整数运算，注意 r==x 时候，答案取 n）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">code is from: https://leetcode.com/problems/maximum-gap/discuss/50644/Pigeon-hole-principle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxE = *max_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> minE = *min_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxA</span><span class="params">(n,INT_MIN)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minA</span><span class="params">(n,INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">        maxA[index] = <span class="built_in">max</span>(maxA[index],nums[i]);</span><br><span class="line">        minA[index] = <span class="built_in">min</span>(minA[index],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        gap = <span class="built_in">max</span>(gap,minA[i]-prev);</span><br><span class="line">        prev = maxA[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="出现一次的数"><a href="#出现一次的数" class="headerlink" title="出现一次的数"></a>出现一次的数</h2><h2 id="出现-3-次的数-leetcode-137"><a href="#出现-3-次的数-leetcode-137" class="headerlink" title="出现 3 次的数 leetcode 137"></a>出现 3 次的数 leetcode 137</h2><p>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<p>Input: [2,2,3,2]<br>Output: 3<br>Example 2:</p>
<p>Input: [0,1,0,1,0,1,99]<br>Output: 99</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个思路是最直接，最清晰的！就是把每一个 bit 位分开来看。</span></span><br><span class="line"><span class="comment">把当前 bit 位出现的 1 的总次数除以 3，如果可以整除，</span></span><br><span class="line"><span class="comment">那么最终结果在这个 bit 位上就是 0，如果不能整除，最终结果在这个 bit 位上就是 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To solve this problem using only constant space, you have to rethink how the numbers are being represented in computers -- using bits.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">If you sum the ith bit of all numbers and mod 3, it must be either 0 or 1 due to the constraint of this problem where each number must appear either three times or once. This will be the ith bit of that "single number".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A straightforward implementation is to use an array of size 32 to keep track of the total count of ith bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We can improve this based on the previous solution using three bitmask variables:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. ones as a bitmask to represent the ith bit had appeared once.</span></span><br><span class="line"><span class="comment">2. twos as a bitmask to represent the ith bit had appeared twice.</span></span><br><span class="line"><span class="comment">3. threes as a bitmask to represent the ith bit had appeared three times.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">When the ith bit had appeared for the third time, clear the ith bit of both ones and twos to 0. The final answer will be the value of ones.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];</span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举一反三的思考"><a href="#举一反三的思考" class="headerlink" title="举一反三的思考"></a>举一反三的思考</h3><p><a href="https://leetcode.com/problems/single-number-ii/discuss/43295/Detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers" target="_blank" rel="noopener">这里</a> 对于这类题目做了一个 generalization 的总结。</p>
<p>generalization 后题目变成：一个数组里面除了一个数字出现了 p 次，其他所有数字都出现了 k 次，那么请找出这个出现了 p 次的数字。</p>
<p>其思想也是对于每个 bit 位单独考虑，看看 1 出现了多少次保存在 count 中。并且保证 1 在出现了 k 次之后，count 会归零。</p>
<p>对于单独的一个 bit 位置来说</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">    xm ^= (xm<span class="number">-1</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    xm<span class="number">-1</span> ^= (xm<span class="number">-2</span> &amp; ... &amp; x1 &amp; i);</span><br><span class="line">    .....</span><br><span class="line">    x1 ^= i;</span><br><span class="line">    </span><br><span class="line">    mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj <span class="keyword">if</span> kj = <span class="number">1</span>, <span class="keyword">and</span> yj = ~xj <span class="keyword">if</span> kj = <span class="number">0</span> (j = <span class="number">1</span> to m).</span><br><span class="line"></span><br><span class="line">    xm &amp;= mask;</span><br><span class="line">    ......</span><br><span class="line">    x1 &amp;= mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 32-bit 的数字来说<br><img src="https://discuss.leetcode.com/assets/uploads/files/1510941017203-137.single-number-ii-resized.png" alt="haha"></p>
<p>Here is a list of few quick examples to show how the algorithm works (you can easily come up with other examples):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 2, p = 1</span></span><br><span class="line"><span class="comment">k is 2, then m = 1, we need only one 32-bit integer (x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 3, p = 1</span></span><br><span class="line"><span class="comment">k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = '11', then k1 = 1, k2 = 1, so we have mask = ~(x1 &amp; x2). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; x2);</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 1, in binary form p = '01', then p1 = 1, so we should return x1. </span></span><br><span class="line">                    <span class="comment">// If p = 2, in binary form p = '10', then p2 = 1, and we should return x2.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2).</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k = 5, p = 3</span></span><br><span class="line"><span class="comment">k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = '101', then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, x3  = <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            x3 ^= x2 &amp; x1 &amp; i;</span><br><span class="line">            x2 ^= x1 &amp; i;</span><br><span class="line">            x1 ^= i;</span><br><span class="line">            mask = ~(x1 &amp; ~x2 &amp; x3);</span><br><span class="line">            x3 &amp;= mask;</span><br><span class="line">            x2 &amp;= mask;</span><br><span class="line">            x1 &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x1;  <span class="comment">// Since p = 3, in binary form p = '011', then p1 = p2 = 1, so we can return either x1 or x2. </span></span><br><span class="line">                    <span class="comment">// If p = 4, in binary form p = '100', only p3 = 1, which implies we can only return x3.</span></span><br><span class="line">                    <span class="comment">// Or alternatively we can simply return (x1 | x2 | x3).</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-100-缺少的两个数"><a href="#1-100-缺少的两个数" class="headerlink" title="1-100 缺少的两个数"></a>1-100 缺少的两个数</h2><p>解方程？ 位运算？</p>
<h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>找出超过一半的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">分析：众数出现的次数大于其他所有数出现次数之和。</span><br><span class="line">    每次扔掉两个不同的数，众数不变</span><br><span class="line">        如果扔掉一个众数，和一个非众数</span><br><span class="line">        如果扔掉两个非众数</span><br><span class="line">    如何实现？和 x 不同就扔掉</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">int count &#x3D; 0, x;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">    if (count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        x &#x3D; a[i];</span><br><span class="line">        count &#x3D; 1;</span><br><span class="line">    &#125; else if (x &#x3D;&#x3D; a[i]) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意有的题目要数一下 x 出现次数是否确实超过一半（众数可能不存在）。</span><br></pre></td></tr></table></figure>

<p>TODO:<br>思考题：如何找到所有出现次数严格大于总数 1/k 的数？<br>提示：保存(k - 1)个数。<br>如何查找？hash? map?</p>
<h2 id="几个O-n-时间复杂度的题目-leetcode-0011-0167-0240"><a href="#几个O-n-时间复杂度的题目-leetcode-0011-0167-0240" class="headerlink" title="几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240"></a>几个O(n)时间复杂度的题目 leetcode 0011, 0167, 0240</h2><h3 id="leetcode-0011"><a href="#leetcode-0011" class="headerlink" title="leetcode 0011"></a>leetcode 0011</h3><p>题目：<br>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.<br>Note: You may not slant the container and n is at least 2.</p>
<p>分析：<br>这一题的解法比较巧妙，想通了后就特别简单。</p>
<p>绝妙的思路：<br>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.<br>In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.<br>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by —).</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p><mark>注意：上面划线部分没有细说，但是你必须要搞懂。<br>事实上，如果 2 3 4 5 的高度超过 1，那么由于 1 的高度的限制，水桶的整体高度不会超过 1 的高度。<br>同时又由于 2 3 4 5 距离 1 相对于 6 距离 1 更近，<br>所以<br>(1,2) (1,3) (1,4) (1,5) 肯定小于 (1,6)<br>另一种情形，如果 2 3 4 5 的高度小于 1，那么<br>(1,2) (1,3) (1,4) (1,5) 更小于 (1,6) 了。<br>因此这四种情形都不用计算了！！！！</mark></p>
<p> we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>o</td>
</tr>
<tr>
<td>2</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td>o</td>
</tr>
<tr>
<td>3</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>4</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
<td>-</td>
</tr>
<tr>
<td>5</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody></table>
<h3 id="leetcode-0167-Two-Sum-2-Input-array-is-sorted"><a href="#leetcode-0167-Two-Sum-2-Input-array-is-sorted" class="headerlink" title="leetcode 0167 Two Sum 2 Input array is sorted"></a>leetcode 0167 Two Sum 2 Input array is sorted</h3><p>题目：<br>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>思路分析：<br>For those of you who are wondering how this works, here is a quick explanation:<br>Each sum is characterized by two indices (i, j), where 0 &lt;= i &lt; j &lt; n with n the length of the input array. If we were to compute them explicitly, we end up with an n-by-n matrix.<br>If the input array is not sorted, to search for the target, there is no good way but comparing it with elements from the above matrix one by one. This is the naive O(n^2) solution. Of course you can use a HashMap to memorize visited elements and cut down the time to O(n) so we have the classic space-time tradeoff.<br>Now if the input array is sorted, the n-by-n summation matrix will have the following properties:<br>Integers in each row are sorted in ascending order from left to right.<br>Integers in each column are sorted in ascending order from top to bottom.<br>To find the target, we do not have to scan the whole matrix now since it exhibits some partial order. We may start from the top-right (or bottom-left) corner, then proceed to the next row or previous column depending on the relationship between the matrix element and the target until either it is found or all rows and columns are exhausted. The key here is that we can get rid of a whole row or column due to the two properties of the matrix specified above.<br>If you have finished leetcode problem “240. Search a 2D Matrix II”, you will find that this is exactly the same problem, except now of the two indices, the first has to be smaller than the second. Time complexity for “leetcode 240” is O(m + n), while for this problem we have m = n, plus the indices constraint so the time complexity will be O(n). Also we do not need the HashMap now so space complexity will be O(1).</p>
<h3 id="leetcode-240-Search-a-2D-Matrix-II"><a href="#leetcode-240-Search-a-2D-Matrix-II" class="headerlink" title="leetcode 240 Search a 2D Matrix II"></a>leetcode 240 Search a 2D Matrix II</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,<br>Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>Given target = 5, return true.<br>Given target = 20, return false.</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We start search the matrix from top right corner, initialize the current position to top right corner, </span></span><br><span class="line"><span class="comment">if the target is greater than the value in current position, then the target can not be in entire row </span></span><br><span class="line"><span class="comment">of current position because the row is sorted, if the target is less than the value in current position, </span></span><br><span class="line"><span class="comment">then the target can not in the entire column because the column is sorted too. </span></span><br><span class="line"><span class="comment">We can rule out one row or one column each time, so the time complexity is O(m+n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; matrix.<span class="built_in">size</span>() &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; matrix[m][n])&#123;</span><br><span class="line">                ++m;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[m][n])&#123;</span><br><span class="line">                --n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p>其实对于二维的也可以分治啊！二维矩阵的中心点把矩阵分成了：左上 A, 右上 B，左下 C，右下 D 这四个小矩阵。</p>
<ol>
<li>根据中心元素 m 和 target 的比较情况<ol>
<li>如果 m &lt; target, 则 target 不可能在 A</li>
<li>如果 m &gt; target, 则 target 不可能在 B</li>
</ol>
</li>
<li>时间复杂度<ol>
<li>T(N) = T(N/2) + T(N/4) +O(1)</li>
<li>不好分析，可能在O(N^0.5) - O(N) 之间，这里 N 是全部的数组元素</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x1 &gt; x2) || (y1 &gt; y2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midx = (x1 + x2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midy = (y1 + y2) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[midx][midy] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (target &lt; a[midx][midy]) ?</span><br><span class="line">        (<span class="built_in">find</span>(a, x1, y1, midx - <span class="number">1</span>, y2, target) || <span class="built_in">find</span>(a, midx, y1, x2, midy - <span class="number">1</span>, target)) :</span><br><span class="line">        (<span class="built_in">find</span>(a, x1, midy + <span class="number">1</span>, x2, y2, target) || <span class="built_in">find</span>(a, midx + <span class="number">1</span>, y1, x2, midy, target)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>, n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(matrix, <span class="number">0</span>, <span class="number">0</span>, m<span class="number">-1</span>, n<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些题目的 算法复杂度优化 都是转化为矩阵分析。<br>本来要考虑的情况是矩阵的所有元素 O(m * n)，<br>但是每次计算其中一个元素，并做了比较以后，<br>可以排除一整行或者一整列的元素，<br>因此变成了 O(m + n) 的算法。</p>
<h2 id="Trapping-Rain-Water-leetcode-0042"><a href="#Trapping-Rain-Water-leetcode-0042" class="headerlink" title="Trapping Rain Water leetcode 0042"></a>Trapping Rain Water leetcode 0042</h2><p>题目：<br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water"></p>
<p>分析：<br>我本来想的是这些水只能 trap 在两个“峰”中间，<br>所以我们可以从左到右找这些峰，<br>然后分别计算中间trap了多少水。<br>这个算法的复杂度也算是O(n),<br>但是实现起来应该比较复杂，<br>主要是在于山峰的寻找上。<br>比如说山峰的判断可以是当前高度大于左右两边，<br>但是如果有当前高度等于左边或者右边怎么办？<br>如果山峰在边界怎么办？<br>都不太好处理。</p>
<p>discuss forum 里面有个好算法<br>没有通过寻找山峰<br>就是分别看每个 bin<br>计算每个 bin 能存储的水量<br>为了达到这个目的<br>算法需要两个变量来记录 maxleft 和 maxright。<br>在保证右边有更高的 bin 的时候，<br>左边每个 bin 保存的水量等于 maxleft 减去 当前高度。<br>同理，<br>在保证左边有更高的 bin 的时候，<br>右边每个 bin 保存的水量等于 maxright 减去当前高度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>, res = <span class="number">0</span>, maxleft = <span class="number">0</span>, maxright = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>[left] &lt;= <span class="built_in">height</span>[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[left] &gt;= maxleft)&#123;</span><br><span class="line">                    maxleft = <span class="built_in">height</span>[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxleft - <span class="built_in">height</span>[left];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[right] &gt;= maxright)&#123;</span><br><span class="line">                    maxright = <span class="built_in">height</span>[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res += maxright - <span class="built_in">height</span>[right];</span><br><span class="line">                &#125;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中第 10 行和第 17 行对 res 做了改变。</span></span><br><span class="line"><span class="comment">我好奇的是第 10 行用 maxleft 减，</span></span><br><span class="line"><span class="comment">如果 maxleft 大于 maxright的话，不应该拿 maxright 来减吗？？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">事实上，maxleft 大于 maxright 的话，</span></span><br><span class="line"><span class="comment">left pointer 肯定指向了 maxleft，</span></span><br><span class="line"><span class="comment">这个时候程序按照逻辑，</span></span><br><span class="line"><span class="comment">会进入到 else 语句（14到19行），</span></span><br><span class="line"><span class="comment">所以达到目的了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<mark>
第 10 行运行的时候 maxleft 一定是小于 maxright，准确说是小于 right pointer 指向的位置的高度 ,
第 17 行运行的时候 maxright 一定小于 maxleft，准确说是小于 left pointer 指向的位置的高度。
left 或者 right pointer 有一个肯定位于目前浏览到的所有 bin 的最高的那一个，然后保持不动，另外一个 pointer 移动.
</mark>


<h2 id="数组中连续一段和，绝对值最小"><a href="#数组中连续一段和，绝对值最小" class="headerlink" title="数组中连续一段和，绝对值最小"></a>数组中连续一段和，绝对值最小</h2><p>思路：先计算前缀和，然后排序。整体复杂度就是排序的复杂度 O(nlogn).</p>
<h2 id="最大子数组和-leetcode-53"><a href="#最大子数组和-leetcode-53" class="headerlink" title="最大子数组和 leetcode 53"></a>最大子数组和 leetcode 53</h2><p>[题目]<br>一个整数数组，一个非空的子数组（连续一段数），使得它的和最大。</p>
<p>[思路一]<br>暴利枚举。枚举子数组的起点 i，终点 j，计算 [i…j] 的和，时间复杂度为 O(N^3)。</p>
<p>[思路二]<br>聪明枚举。对于每一个起点 i，让 j 从 i+1 开始枚举，一遍枚举一边求和，时间复杂度为 O(N^2)。</p>
<p>[思路三]<br>分治</p>
<ol>
<li>Divide the given array in two halves</li>
<li>Return the maximum of following three<ol>
<li>Maximum subarray sum in left half (Make a recursive call)</li>
<li>Maximum subarray sum in right half (Make a recursive call)</li>
<li>Maximum subarray sum such that the subarray crosses the midpoint</li>
</ol>
</li>
</ol>
<p>The lines 2.1 and 2.2 are simple recursive calls. How to find maximum subarray sum such that the subarray crosses the midpoint? We can easily find the crossing sum in linear time.<br>Suppose the current range is [l, r] and the mid point is “m”.<br>The idea is simple, find the maximum sum starting from mid point “m” and ending at some point on left of mid, then find the maximum sum starting from “m + 1” and ending with sum point on right of “m + 1”. Finally, combine the two and return.</p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">max</span>(helper(arr, l, m), helper(arr, m+<span class="number">1</span>, r));</span><br><span class="line">    <span class="keyword">int</span> now = arr[m], may = now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">        may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now = may + arr[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m+<span class="number">2</span>; i &lt; r; i++)&#123;</span><br><span class="line">        now = now + arr[i];</span><br><span class="line">        may = <span class="built_in">max</span>(may, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans, may);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[思路四-DP]</p>
<ol>
<li>dp[i] 表示以 a[i] 结尾的最大子数组的和</li>
<li>dp[i] = max(dp[i-1] + a[i], a[i])</li>
<li>初值 dp[0] = a[0]</li>
<li>答案是 dp 数组里面最大的那个</li>
<li>时间复杂度 O(n)，空间复杂度 O(n)</li>
<li>空间优化：不需要把 dp 数组存储下来<ol>
<li>endHere = max(endHere + a[i], a[i])</li>
<li>answer = max(endHere, answer)</li>
</ol>
</li>
</ol>
<p>[思路五：前缀和]</p>
<ol>
<li>计算前缀和 preSum</li>
<li>i 从 0 遍历到 n-1，保存 preSum[0…i-1] 这 i 个数的最小值 currentMin，当前的 preSum[i] - currentMin</li>
<li>整体的思想就类似于买卖股票一次，求最大的 gain 那道题</li>
<li>时间复杂度跟 DP 一样，都是 O(n).</li>
<li>空间优化：也可以一边求 preSum 一边做第二步，这样子就不需要保存 preSum 这个数组了。</li>
</ol>
<h2 id="Cantor-数组"><a href="#Cantor-数组" class="headerlink" title="Cantor 数组"></a>Cantor 数组</h2><p>[题目]</p>
<p>[思路]</p>
<ul>
<li>观察第一个元素，你就能知道思路了</li>
<li>第一个元素是 3，说明后面的元素中有三个小于这个元素，那么第一个元素只可能是 4 啊！！！</li>
<li>然后依次找到第二个，三个，。。。元素就可以了</li>
</ul>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">CantorRecovery</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        temp.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[j] &gt; <span class="number">0</span>) k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(temp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="subset-sum"><a href="#subset-sum" class="headerlink" title="subset sum"></a>subset sum</h2><p>[题目]<br>Given a set of positive integers and an integer s, is there any non-empty subset whose sum is s.</p>
<p>[ref]<br><a href="https://www.techiedelight.com/subset-sum-problem/" target="_blank" rel="noopener">https://www.techiedelight.com/subset-sum-problem/</a></p>
<p>[代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">    <span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">    <span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">    <span class="comment">// remaining items (n - 1)</span></span><br><span class="line">    <span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return true if we can get subset by including or excluding the</span></span><br><span class="line">    <span class="comment">// current item</span></span><br><span class="line">    <span class="keyword">return</span> include || exclude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Input: set of items and a sum</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of items</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>带记忆的算法代码</mark></p>
<ul>
<li>这里记忆的是：前面 n 个数里面能不能凑出来一个 sum.</li>
<li>算法是从右往前逐个看是否包括每个元素的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a map to store solutions of subproblems</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return true if there exists a subarray of array[0..n] with given sum</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">subsetSum</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return true if sum becomes 0 (subset found)</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case: no items left or sum becomes negative</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> || sum &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a unique map key from dynamic elements of the input</span></span><br><span class="line">    <span class="built_in">string</span> key = to_string(n) + <span class="string">"|"</span> + to_string(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sub-problem is seen for the first time, solve it and</span></span><br><span class="line">    <span class="comment">// store its result in a map</span></span><br><span class="line">    <span class="keyword">if</span> (lookup.<span class="built_in">find</span>(key) == lookup.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Case 1. include current item in the subset (arr[n]) and recur</span></span><br><span class="line">        <span class="comment">// for remaining items (n - 1) with remaining sum (sum - arr[n])</span></span><br><span class="line">        <span class="keyword">bool</span> include = subsetSum(arr, n - <span class="number">1</span>, sum - arr[n]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case 2. exclude current item n from subset and recur for</span></span><br><span class="line">        <span class="comment">// remaining items (n - 1)</span></span><br><span class="line">        <span class="keyword">bool</span> exclude = subsetSum(arr, n - <span class="number">1</span>, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign true if we can get subset by including or excluding the</span></span><br><span class="line">        <span class="comment">// current item</span></span><br><span class="line">        lookup[key] = include || exclude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return solution to current sub-problem</span></span><br><span class="line">    <span class="keyword">return</span> lookup[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subset Sum Problem</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Input: set of items and a sum</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of items</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subsetSum(arr, n - <span class="number">1</span>, sum))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆序数有关"><a href="#逆序数有关" class="headerlink" title="逆序数有关"></a>逆序数有关</h2><h3 id="Count-of-Smaller-Number-After-Self-leetcode-0315"><a href="#Count-of-Smaller-Number-After-Self-leetcode-0315" class="headerlink" title="Count of Smaller Number After Self leetcode 0315"></a>Count of Smaller Number After Self leetcode 0315</h3><p>[题目]<br>给定一个数组，返回一个同样长度的数组，里面的数字表示原数组这个位置后面有多少个数字小于它。</p>
<p>[例子]</p>
<ul>
<li>Input: [5,2,6,1]</li>
<li>Output: [2, 1, 1, 0]</li>
</ul>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><ul>
<li>对每一个元素，逐个检查右边所有元素，看是否比它小</li>
<li>时间复杂度 O(N^2)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(numsSize, <span class="number">0</span>)</span></span>;<span class="comment">//用于储存nums[i]右边比它小的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">            <span class="comment">//寻找[i + 1, numsSize - 1]中小于nums[i]的元素个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    result[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改进暴力解法"><a href="#改进暴力解法" class="headerlink" title="改进暴力解法"></a>改进暴力解法</h4><ul>
<li>思路一的问题是，每次我们都要遍历右边所有的元素</li>
<li>如果我们从右往左看，看过的元素都排好序，那么可以使用二分查找来迅速找到小于每个数字的元素个数了</li>
<li>不过因为对 vector 进行插入复杂度是 O(N)，导致整体复杂度仍为 O(N^2)，但是不会出现 TLE.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s_num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = lower_bound(s_num.<span class="built_in">begin</span>(), s_num.<span class="built_in">end</span>(), nums[i]);  <span class="comment">// 二分查找比 nums[i] 小的数</span></span><br><span class="line">            <span class="keyword">int</span> pos = iter - s_num.<span class="built_in">begin</span>();</span><br><span class="line">            res.push_back(pos);             <span class="comment">// pos 就是小于 nums[i] 的元素个数</span></span><br><span class="line">            s_num.insert(iter, nums[i]);    <span class="comment">// 插入后要保持sorted_num排序，所以nums[i]插入到iter位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ul>
<li>思路二的一个问题是：虽然查找有多少元素小于 nums[i] 的时候速度很快，但是把 nums[i] 插入到当前的已经排好序的数组里这一步骤耗时间。</li>
<li>因为 <code>vector&lt;int&gt;</code> 在中间位置插入元素需要把插入位置后面的元素都整体往后移动一位以获得一个空。</li>
<li>而解决这个问题就是使用 BST，它查找时间复杂度同样是 <code>log(N)</code>，然而插入步骤只是简单地 <code>O(1)</code> 复杂度。</li>
<li>BST 有个很好的性质：左子树所有节点都比根节点小，右子树所有节点都比根节点大</li>
<li>这个方法的最坏时间复杂度是 O(n^2). 也就是给定数组是递增，或者递减序列的时候，此时 BST 长得就是一根直线。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="keyword">int</span> val, smallerCnt;</span><br><span class="line">        TreeNode* left, *right;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> v, <span class="keyword">int</span> s) : left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>), val(v), smallerCnt(s)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(len, <span class="number">0</span>)</span></span>; </span><br><span class="line">        TreeNode* root = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            root = insert(ret, nums[i], i, <span class="number">0</span>, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把 val 插入到 node 为根节点的树中；</span></span><br><span class="line"><span class="comment">    preSum 是当前已经找到的比 val 小的数字的个数了；</span></span><br><span class="line"><span class="comment">    递归终止的条件是 val 放到了正确的位置，也就是第一个 if else 条件，此时会把最终的结果放到 ret[idx];</span></span><br><span class="line"><span class="comment">    val, idx 在递归调用中保持不变；</span></span><br><span class="line"><span class="comment">    递归调用中改变的东西只有 preSum 和 *node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret, <span class="keyword">int</span> val, <span class="keyword">int</span> idx, <span class="keyword">int</span> preSum, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(val, <span class="number">0</span>);</span><br><span class="line">            ret[idx] = preSum;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val &gt; val) &#123;</span><br><span class="line">            node-&gt;smallerCnt++;</span><br><span class="line">            node-&gt;left = insert(ret, val, idx, preSum, node-&gt;left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;right = insert(ret, val, idx, preSum + node-&gt;smallerCnt + ((node-&gt;val &lt; val)? <span class="number">1</span>: <span class="number">0</span>), node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="平衡-BST"><a href="#平衡-BST" class="headerlink" title="平衡 BST"></a>平衡 BST</h4><ul>
<li>这个思路是对思路二的改进，为了让最坏情况下时间复杂度仍然是 O(NlogN)</li>
<li>需要时刻让 BST 保持平衡，也就是使用 AVL tree, RB-Tree 等数据结构。</li>
<li>此处每个节点包含以此节点为根的树的大小。</li>
<li>使用 AVL 树。</li>
<li>We traverse the array from right to left and insert all elements one by one in an AVL tree. </li>
<li>While inserting a new key in an AVL tree, we first compare the key with root. <ul>
<li>If key is greater than root, then it is greater than all the nodes in left subtree of root. </li>
<li>So we add the size of left subtree to the count of smaller element for the key being inserted. </li>
<li>We recursively follow the same approach for all nodes down the root.</li>
</ul>
</li>
</ul>
<p>代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, <span class="built_in">height</span>, <span class="built_in">size</span>, freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="keyword">this</span>-&gt;<span class="built_in">size</span> = <span class="keyword">this</span>-&gt;freq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : root-&gt;<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateNode</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;<span class="built_in">size</span> = getSize(root-&gt;left) + getSize(root-&gt;right) + root-&gt;freq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateLeft</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node *B = A-&gt;right;</span><br><span class="line">    Node *T2 = B-&gt;left;</span><br><span class="line">    A-&gt;right = T2;</span><br><span class="line">    B-&gt;left = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">rotateRight</span><span class="params">(Node *A)</span></span>&#123;</span><br><span class="line">    Node* B = A-&gt;left;</span><br><span class="line">    Node* T2 = B-&gt;right;</span><br><span class="line">    A-&gt;left = T2;</span><br><span class="line">    B-&gt;right = A;</span><br><span class="line">    updateNode(A);</span><br><span class="line">    updateNode(B);</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bf</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="number">0</span> : getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">balance</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    updateNode(root);</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;left) &gt;= <span class="number">0</span>) root = rotateRight(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;left = rotateLeft(root-&gt;left);</span><br><span class="line">            root = rotateRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bf(root) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bf(root-&gt;right) &lt;= <span class="number">0</span>) root = rotateLeft(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;right = rotateRight(root-&gt;right);</span><br><span class="line">            root = rotateLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node* root, <span class="keyword">int</span> data, <span class="keyword">int</span>&amp; count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == data)&#123;</span><br><span class="line">        root-&gt;freq++;</span><br><span class="line">        count += getSize(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; data)  root-&gt;left = insert(root-&gt;left, data, count);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        count += getSize(root-&gt;left) + root-&gt;freq;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, data, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        Node *root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) root = insert(root, nums[i], count[i]);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>[这段代码来自 geeksforgeeks]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// An AVL tree node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> key; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>; </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// size of the tree rooted with this node </span></span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get height of the tree rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">height</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to size of the tree of rooted with N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> N-&gt;<span class="built_in">size</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to get maximum of two integers </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &gt; b)? a : b; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Helper function that allocates a new node with the given key and </span></span><br><span class="line"><span class="comment">    NULL left and right pointers. */</span></span><br><span class="line"><span class="function">struct node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">node</span> = (<span class="title">struct</span> <span class="title">node</span>*) </span></span><br><span class="line"><span class="class">                        <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span> </span><br><span class="line">    node-&gt;key   = key; </span><br><span class="line">    node-&gt;left   = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;right  = <span class="literal">NULL</span>; </span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="number">1</span>;  <span class="comment">// new node is initially added at leaf </span></span><br><span class="line">    node-&gt;<span class="built_in">size</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span>(node); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to right rotate subtree rooted with y </span></span><br><span class="line"><span class="function">struct node *<span class="title">rightRotate</span><span class="params">(struct node *y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">x</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    x-&gt;right = y; </span><br><span class="line">    y-&gt;left = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update heights </span></span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A utility function to left rotate subtree rooted with x </span></span><br><span class="line"><span class="function">struct node *<span class="title">leftRotate</span><span class="params">(struct node *x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">y</span> = <span class="title">x</span>-&gt;<span class="title">right</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T2</span> = <span class="title">y</span>-&gt;<span class="title">left</span>;</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Perform rotation </span></span><br><span class="line">    y-&gt;left = x; </span><br><span class="line">    x-&gt;right = T2; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  Update heights </span></span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right))+<span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right))+<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Update sizes </span></span><br><span class="line">    x-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(x-&gt;left) + <span class="built_in">size</span>(x-&gt;right) + <span class="number">1</span>; </span><br><span class="line">    y-&gt;<span class="built_in">size</span> = <span class="built_in">size</span>(y-&gt;left) + <span class="built_in">size</span>(y-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Return new root </span></span><br><span class="line">    <span class="keyword">return</span> y; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Get Balance factor of node N </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">(struct node *N)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (N == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(N-&gt;left) - <span class="built_in">height</span>(N-&gt;right); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Inserts a new key to the tree rotted with node. Also, updates *count </span></span><br><span class="line"><span class="comment">// to contain count of smaller elements for the new key </span></span><br><span class="line"><span class="function">struct node* <span class="title">insert</span><span class="params">(struct node* node, <span class="keyword">int</span> key, <span class="keyword">int</span> *count)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">/* 1.  Perform the normal BST rotation */</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>(newNode(key)); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key) </span><br><span class="line">        node-&gt;left  = insert(node-&gt;left, key, count); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key, count); </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// UPDATE COUNT OF SMALLER ELEMENTS FOR KEY </span></span><br><span class="line">        *count = *count + <span class="built_in">size</span>(node-&gt;left) + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 2. Update height and size of this ancestor node */</span></span><br><span class="line">    node-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>; </span><br><span class="line">    node-&gt;<span class="built_in">size</span>   = <span class="built_in">size</span>(node-&gt;left) + <span class="built_in">size</span>(node-&gt;right) + <span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 3. Get the balance factor of this ancestor node to check whether </span></span><br><span class="line"><span class="comment">       this node became unbalanced */</span></span><br><span class="line">    <span class="keyword">int</span> balance = getBalance(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// If this node becomes unbalanced, then there are 4 cases </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key) </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Left Right Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;left =  leftRotate(node-&gt;left); </span><br><span class="line">        <span class="keyword">return</span> rightRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Right Left Case </span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) </span><br><span class="line">    &#123; </span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right); </span><br><span class="line">        <span class="keyword">return</span> leftRotate(node); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* return the (unchanged) node pointer */</span></span><br><span class="line">    <span class="keyword">return</span> node; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The following function updates the countSmaller array to contain count of </span></span><br><span class="line"><span class="comment">// smaller elements on right side. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructLowerArray</span> <span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> countSmaller[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i, j; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">root</span> = <span class="title">NULL</span>;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize all the counts in countSmaller array as 0 </span></span><br><span class="line">  <span class="keyword">for</span>  (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">     countSmaller[i] = <span class="number">0</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Starting from rightmost element, insert all elements one by one in </span></span><br><span class="line">  <span class="comment">// an AVL tree and get the count of smaller elements </span></span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">  &#123; </span><br><span class="line">     root = insert(root, arr[i], &amp;countSmaller[i]); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Utility function that prints out an array on a line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver program to test above functions </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">7</span>&#125;; </span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> *low = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); </span><br><span class="line">  </span><br><span class="line">  constructLowerArray(arr, low, n); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Following is the constructed smaller count array"</span>); </span><br><span class="line">  printArray(low, n); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，有人提议可以使用 set (如果没有重复元素)，或者 multiset (有重复元素) 来做。set 的底层实现用的就是平衡二叉树。</p>
<ol>
<li>averse the array element from i=len-1 to 0 and insert every element in a set.</li>
<li>Find the first element that is lower than A[i] using lower_bound function.</li>
<li>Find the distance between above found element and the beginning of the set using distance function.</li>
<li>Store the distance in another array Lets say CountSmaller.</li>
<li>Print that array .</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSmallerRight</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="keyword">int</span> countSmaller[len]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        s.insert(A[i]); </span><br><span class="line">        <span class="keyword">auto</span> it = s.lower_bound(A[i]); </span><br><span class="line">        countSmaller[i] = distance(s.<span class="built_in">begin</span>(), it); </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; countSmaller[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); </span><br><span class="line">    countSmallerRight(A, len); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>但是，这里跟上面的解法不一样的是：这里使用的 <code>std::distance()</code> 函数的时间复杂度为 O(size)，因此整体的复杂度是 O(N^2)，虽然 set 底层也用得平衡二叉树。</li>
<li>不过这个解法让我们学习了 STL algrorithm 的用法，而且写得很简洁，不错！</li>
<li>如果存在重复元素，只需要改成 multiset 就可以了！</li>
</ol>
<h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><ul>
<li>在 merge sort 的过程中多记录一些额外的东西。</li>
<li>例如考虑这个数组: <code>6 4 1 8 7 5 2 9</code></li>
<li>因为是递归调用，所以两个子数组是 <code>6 4 1 8</code> 和 <code>7 5 2 9</code></li>
<li>假定两个子数组分别处理好了<ul>
<li>第一个子数组处理结果是 <code>1(0) 4(1) 6(2) 8(0)</code></li>
<li>第二个子数组处理结果是 <code>2(0) 5(1) 7(2) 9(0)</code></li>
<li>括号里的数字表示当前子数组里面，排序前位置在右边的并且小于自己的数字有多少个。</li>
<li>比如 <code>4(1)</code> 就表示原来的第一个子数组中位置在 <code>4</code> 右边，并且值小于 <code>4</code> 的数字有 <code>1</code> 个。</li>
</ul>
</li>
<li>现在需要合并两个子数组了, 用 rightcount 来记录右边的子数组中拿出来多少个数字了，并初始化为 0.<ul>
<li>先从左边子数组中拿出 1(0 + rightcount) = 1(0)</li>
<li>再从右边子数组中拿出 2(0)，同时 rightcount = 0 + 1 = 1</li>
<li>再从左边子数组中拿出 4(1 + rightcount) = 4(1+1) = 4(2)</li>
<li>再从右边子数组中拿出 5(1), 同时 rightcount = 1 + 1 = 2</li>
<li>再从左边子数组中拿出 6(2+rightcount) = 6(2+2) = 6(4)</li>
<li>再从右边子数组中拿出 7(2), 同时 rightcount = 2 + 1 = 3</li>
<li>再从左边子数组中拿出 8(0 + rightcount) = 8(0+3) = 8(3)</li>
<li>再从右边子数组中拿出 9(0)</li>
</ul>
</li>
<li>可以看出来，我们只需要更新左边子数组中括号里面的个数记录</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Pii;</span><br><span class="line">    <span class="keyword">typedef</span> Pii::iterator Pit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">Pii <span class="title">nums_</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            nums_[i] = &#123;nums[i], i&#125;;</span><br><span class="line">        merge(nums_.<span class="built_in">begin</span>(), nums_.<span class="built_in">end</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Pit <span class="built_in">begin</span>, Pit <span class="built_in">end</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span> - <span class="built_in">begin</span> &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        merge(<span class="built_in">begin</span>, mid, res);</span><br><span class="line">        merge(mid, <span class="built_in">end</span>, res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="built_in">begin</span>, j = mid; i != mid; ++i)&#123; <span class="comment">// 对于每一个 i</span></span><br><span class="line">            <span class="keyword">while</span>(j != <span class="built_in">end</span> &amp;&amp; i-&gt;first &gt; j-&gt;first)   <span class="comment">// 把 j 往右移动到最后一个满足条件: i-&gt;first 大于 j-&gt;first</span></span><br><span class="line">                ++j;                                 <span class="comment">// 此时相当于 merge 时候把右边的子数组中到 j 位置的所有元素</span></span><br><span class="line">            res[i-&gt;second] += j - mid;               <span class="comment">// 都移动到汇总数组里面了，下一个就是把 i 位置元素放到汇总数组里。</span></span><br><span class="line">        &#125;</span><br><span class="line">        inplace_merge(<span class="built_in">begin</span>, mid, <span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="离散化-分桶"><a href="#离散化-分桶" class="headerlink" title="离散化 分桶"></a>离散化 分桶</h4><ul>
<li>离散化：数字绝对大小没有意义，转化为 0 - (n-1) 之间, 这一步骤复杂度 O(NlogN)</li>
<li>如何分桶<ol>
<li>桶大小 bucketSize = sqrt(n)</li>
<li>桶个数 (n + bucketSize - 1) / bucketSize</li>
<li>例如 n = 11<ol>
<li>分成 4 个桶 [0,1,2], [3,4,5], [6,7,8], [9,10]</li>
</ol>
</li>
<li>数 x 所在桶的编号为 <code>x / bucketSize</code></li>
<li>把所有数 倒着 放入桶里<ol>
<li>统计每个数出现的次数</li>
<li>每个桶包含的数的个数</li>
</ol>
</li>
<li>桶自然有序（区间）</li>
<li>如何计数<ol>
<li>和 x 在同一个桶里的数，暴力循环 O(sqrt(N))</li>
<li>x 之前桶里的数通过每个桶里数的个数累加 O(sqrt(N))</li>
</ol>
</li>
<li>总复杂度 O(N^1.5)</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ++save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t = save.<span class="built_in">begin</span>(); t != save.<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">            t-&gt;second = m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bucketSize = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(m);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bucket</span><span class="params">((n + bucketSize - <span class="number">1</span>) / bucketSize)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">have</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = save[nums[i]];</span><br><span class="line">            <span class="keyword">int</span> id = x / bucketSize;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = id - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                answer[i] += bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = id * bucketSize; j &lt; x; ++j)&#123;</span><br><span class="line">                answer[i] += have[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ++have[x];</span><br><span class="line">            ++bucket[id];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="离散化方法二"><a href="#离散化方法二" class="headerlink" title="离散化方法二"></a>离散化方法二</h4><ol>
<li>从二进制入手</li>
<li>比如 x = 10110</li>
<li>比 x 小的数 (类似字典序，前缀) — 3 个集合不想交<ol>
<li>0xxxx, 100xx, 1010x</li>
</ol>
</li>
<li>枚举每一位，倒着循环，计算每个”前缀”出现的次数，如果 nums[i] 在该位为 1，累加在它右边，前缀相同，在该位为 0 的所有数的个数。</li>
<li>每个比它小的数只会被累加一次(在最高不同位时)</li>
<li>技巧：位运算，右移位，异或</li>
<li>时间复杂度 O(NlogN)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ++save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t = save.<span class="built_in">begin</span>(); t != save.<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">            t-&gt;second = m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums[i] = save[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一直到这里，上面全是预处理！把 nums 数组变成 rank 数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">bool</span> next = <span class="literal">true</span>; next; )&#123;    <span class="comment">// 总循环次数为数字个数用二进制表示的位数，相当于循环看每一个 bit 位了。</span></span><br><span class="line">            next = <span class="literal">false</span>;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cal</span><span class="params">(m, <span class="number">0</span>)</span></span>;    <span class="comment">// m 是最大的 rank + 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;    <span class="comment">// 对每个 bit 位都扫描一遍全部的数组元素</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i])&#123;</span><br><span class="line">                    next = <span class="literal">true</span>;    <span class="comment">// 只要数组里面有一个数字不是 0，next 就被改成 true</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &amp; <span class="number">1</span>)&#123;    <span class="comment">// nums[i] 最后一位是 1，那么看最后一位是 0 的数字出现了多少次，它们都小于当前元素。</span></span><br><span class="line">                        answer[i] += cal[nums[i] ^ <span class="number">1</span>];  <span class="comment">// 每次循环只找出来既小于它，还满足一定条件的数！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ++cal[nums[i]];</span><br><span class="line">                nums[i] &gt;&gt;= <span class="number">1</span>;    <span class="comment">// 外层循环每执行一次，rank 数组所有元素都右移一位！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="Binary-Index-Tree"><a href="#Binary-Index-Tree" class="headerlink" title="Binary Index Tree"></a>Binary Index Tree</h4><ul>
<li>也叫做 Fenwick Tree，中文是“树状数组”</li>
<li>BIT 的介绍参考<ul>
<li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">这里</a></li>
<li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees" target="_blank" rel="noopener">这里</a></li>
</ul>
</li>
<li>BIT 方法与下面的 Segment tree 方法相比，都是 log n 时间复杂度，然后需要的空间更小，更容易写代码。</li>
</ul>
<h5 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h5><p>[问题背景]</p>
<ol>
<li>树状数组的提出主要是为了较好的平衡计算前缀和，以及修改某项的值这两个操作。<ol>
<li>如果你使用普通的数组保存每项的值，那么计算前缀和的复杂度就是 O(N), 而修改某项的值这个操作复杂度是 O(1)；</li>
<li>如果你使用的数组里面保存得是前缀和，那么计算前缀和复杂度为 O(1), 修改值变成了 O(N).</li>
<li>而 binary index tree 可以使得这两个操作的复杂度都是 O(logN).</li>
</ol>
</li>
</ol>
<p>[初始化]</p>
<ol>
<li>\(nums[i] = arr[i]\)</li>
<li>\(BIT[i] = \sum_{k = i - lowestbit(i) + 1}^{i} arr[k]\)</li>
<li>注意，上面的 <code>lowestbit(i)</code> 是指将 <code>i</code> 转为二进制后，最后一个 <code>1</code> 的位置所代表的数值。如 <code>lowestbit(1) = 1</code>, <code>lowestbit(6) = 2</code>, 具体的实现可以通过 <code>(i &amp; -i)</code> 获取。</li>
<li>代码可以参考本文例题 Leetcode 0307 里面的 Python 代码。</li>
</ol>
<p>[一个好图胜过千言万语！！！]<br><mark>下图即为初始化后的情况，横轴为数组的下标（记为 i）,纵轴为下表数值对应的 <code>lowestbit (i &amp; -i)</code>, 长方形表示 <code>BIT[i]</code> 涵盖的求和范围。</mark></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp_fenwick_tree_binary_index_tree.jpg" alt="Binary Index Tree"></p>
<p>从图中可以看到:</p>
<ol>
<li>每一个 <code>BIT[i]</code> 覆盖的范围都是 2 的指数！即要么只覆盖自身，要么覆盖两个，四个，8个元素！</li>
<li>图中描黑的那些节点在形态上构成了一棵树的形状，这也是为什么这个算法被叫做 Binary Index Tree 的原因。</li>
<li>对于每个下表的 lowestbit 表示成的 tree node 有以下特性<ol>
<li><mark>假如 i 是左子节点，那么其父节点下标为 <code>i + lowestbit(i)</code></mark></li>
<li><mark>假如 i 是右子节点，那么其父节点下标为 <code>i - lowestbit(i)</code></mark></li>
</ol>
</li>
<li>算法思想<ol>
<li><mark>update i 的过程就是从 i 一直找 <code>i + lowestbit(i)</code> 去更新；</mark></li>
<li><mark>getSum(i) 的过程就是从 i 一直找 <code>i - lowestbit(i)</code> 去求和！</mark></li>
</ol>
</li>
</ol>
<p>[更新一个数值]<br>假如要修改原始数组中下标为 i 的值，那么需要修改 <code>nums</code> 数组中对应下标的值。除此之外还要修改 <code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值。结合上图可以知道，<code>BIT</code> 数组中涵盖了 <code>arr[i]</code> 的值为下标 i 及其所有的父节点（它在父节点的左边）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    BIT[i] = BIT[i] + new_value</span><br><span class="line">    i = i + (i &amp; -i)</span><br></pre></td></tr></table></figure>

<p>[求前缀和]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    count = count + BIT[i]</span><br><span class="line">    i = i - (i &amp; -i)</span><br></pre></td></tr></table></figure>


<p>[理解]</p>
<ol>
<li>树状数组的构造过程是这样的<ol>
<li>对于一段序列 A[1…n]，把所有奇数项偶数项分开得到数组 P Q，</li>
<li>偶数项每项加上其左边的奇数项得到 (P + Q)，偶数项求一遍树状数组得到 T(P + Q)，</li>
<li>最后把 P 和 T(P + Q) 交替排列出来。</li>
</ol>
</li>
<li>举例：<ol>
<li>1 3 5 6 8</li>
<li>3   6    分离偶数项</li>
<li>4   11   每个偶数项加上其左边的奇数项</li>
<li>4   15   递归求树状数组</li>
<li>1 4 5 15 8 把奇数项交替排列回去</li>
</ol>
</li>
<li>树状数组一个数 n 能当偶数项 k 次，进入 k 次递归中，那么 n 的二进制最后有 k 个 0，因为每“当”一次偶数项，它所管辖的区间就会加倍，所以它的值就是原数组里以 n 结尾长度为 2^k 的一段区间。注意到 lowbit(n) = 2^k。如果区间写成左开右闭的，那么树状数组里第 n 项就是原数组 (n - lowbit(n), n] 的和。</li>
<li>举例。要查询前 10 个数的前缀和，二进制是 1010，我们可以将其拆成如下两个区间：(8, 10] 和 (0, 8]。</li>
<li>（2017-01-21 接近半夜，修改了修改操作的解释）</li>
<li>修改的话，观察构造树状数组的过程，观察原数组的某下标上如果被加上了一个变化量 d，那么这个 d 会怎样传播。</li>
<li>在某一层，如果这个下标 n 是偶数项，那么它左边的奇数项被加过来，这两项原本应该是 a 和 a + b 的，变成了 a 和 a + b + d，恰好就是第 n 位被改了；但是如果是奇数项的话，a 和 a + b 要变成 a + d 和 a + d + b，也就是说 d 被传播到了 n 右边的偶数项。当然影响是要传递的。所以我们修改的下标 n 在某一层作为奇数项的时候，它影响到了它在这一层右边的偶数项 n’，n’ 又会影响到 n’’，以此类推。</li>
<li>举例：10 在第 2 层的时候，它在这层的编号是 5，很不幸地影响到了这层编号是 6，即原编号 12 的元素。</li>
<li>我们来看一下二进制表示。10 = 1010 在第 2 层是 5 = 101，影响到的是 5 + 1 = 6 = 110。（此处感谢 UOJ 用户 rabbit_lb 提醒修改）在第 2 层，加的这个1，应该对应原数组上的 1 * 2^1 = 2，就是 lowbit(10)！</li>
<li>这是为什么呢？因为一个二进制最后有 k 个 0 的下标 n 会在第 k + 1 层，作为 n / 2^k 影响到 1 + n / 2^k，在原数组上的下标就是 n 影响到 2^k + n = lowbit(n) + n。</li>
<li>当然影响是要传递的，所以修改的时候就是不停加 lowbit 改就行了</li>
</ol>
<h5 id="本题的代码"><a href="#本题的代码" class="headerlink" title="本题的代码"></a>本题的代码</h5><p>为什么一个用来快速计算 range sum 的数据结构可以用来解决目前的这个问题呢？</p>
<p>主要是因为一个巧妙地转换：</p>
<ol>
<li>第一步先把数组中数字转换成 rank <ol>
<li>比如 [2, 5, -3, 6, 2, 4] 变成 rank 就变成了 [2, 4, 1, 5, 2, 3]</li>
<li>原数组里面 2 出现了两次，在 rank 数组里面它们的 rank 都是 2 (-3 是最小的数字)</li>
</ol>
</li>
<li>接下来就是关键的了，新定义一个数组 freq (长度为 n+1, 所有元素初始化为 0) 用来记录每个 rank 出现的数字的次数，然后从右到左扫描 rank 数组<ol>
<li>最先碰到的是 3, 此时我们把 freq[3]++，代表 rank=3 的数字碰到了一个, 而此时 freq[1] = freq[2] == 0，因此 freq[3] 左边的数字求和为 0， 代表原数组中 4 右边有 0 个数字比它值小。</li>
<li>接下来碰到 2，此时把 freq[2]++，而 freq[1] == 0，所以原数组中倒数第二个数字 2 后面有 0 个元素比它小。</li>
<li>接下来碰到 5，此时把 freq[5]++, 而 freq 数组中 freq[5] 前面有 freq[2] = freq[3] = 1, 因此说明原数组的 6 右边有两个元素比它小。</li>
</ol>
</li>
<li>思路还是很清晰的<ol>
<li>因为我们是从右往左遍历 rank 数组</li>
<li>如果右边数字的 rank 小于左边某个数字的 rank，也就是说原来的数组中右边的数字小于左边的数字了。</li>
<li>同时！右边先被遍历，也保证了如果右边有 rank 小的数字，freq[右边数字的 rank] 会更新，这样子再扫到左边的数字的时候，我们就可以直接把 freq[左边数字的 rank] 左边的数字全部加起来，这个和就是左边数字有多少个小于它的数字在右边！</li>
</ol>
</li>
</ol>
<p>下图也有个例子<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-leetcode-315-binary-index-tree.png.png" alt=""></p>
<p>代码参考<a href="https://zxi.mytechroad.com/blog/algorithms/array/leetcode-315-count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">这里</a></p>
<p>注意这里的 Fenwick Tree 不是用原来的数组构建的，也不是用 rank 数组构建的。因此可以初始化为 0 数组。<br>然后只需要实现 update 和 query 两个函数就行！<br>之后再随着从右往左扫描 rank 数组，不停地 update 数组并 query 结果！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> &#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n): sums_(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sums_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sums_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sums_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Sort the unique numbers</span></span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sorted</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Map the number to its rank</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ranks;</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> num : sorted)</span><br><span class="line">            ranks[num] = ++rank;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="function">FenwickTree <span class="title">tree</span><span class="params">(ranks.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="comment">// Scan the numbers in reversed order</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// Chechk how many numbers are smaller than the current number.</span></span><br><span class="line">            ans.push_back(tree.query(ranks[nums[i]] - <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// Increse the count of the rank of current number.</span></span><br><span class="line">            tree.update(ranks[nums[i]], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::reverse(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>下面的代码来自 geeksforgeeks，可以得到右边小的数字个数或者左边大的数字个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ implementation of the approach </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to return the sum of arr[0..index] </span></span><br><span class="line"><span class="comment">// This function assumes that the array is preprocessed </span></span><br><span class="line"><span class="comment">// and partial sums of array elements are stored in BITree[] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// Initialize result </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse ancestors of BITree[index] </span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// Add current element of BITree to sum </span></span><br><span class="line">        sum += BITree[index]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move index to parent node in getSum View </span></span><br><span class="line">        index -= index &amp; (-index); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Updates a node in Binary Index Tree (BITree) at given index </span></span><br><span class="line"><span class="comment">// in BITree. The given value 'val' is added to BITree[i] and </span></span><br><span class="line"><span class="comment">// all of its ancestors in tree. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBIT</span><span class="params">(<span class="keyword">int</span> BITree[], <span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Traverse all ancestors and add 'val' </span></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= n) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add 'val' to current node of BI Tree </span></span><br><span class="line">        BITree[index] += val; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update index to that of parent in update View </span></span><br><span class="line">        index += index &amp; (-index); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Converts an array to an array with values from 1 to n </span></span><br><span class="line"><span class="comment">// and relative order of smaller and greater elements remains </span></span><br><span class="line"><span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line"><span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Create a copy of arrp[] in temp and sort the temp array </span></span><br><span class="line">    <span class="comment">// in increasing order </span></span><br><span class="line">    <span class="keyword">int</span> temp[n]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        temp[i] = arr[i]; </span><br><span class="line">    sort(temp, temp + n); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse all array elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="comment">// lower_bound() Returns pointer to the first element </span></span><br><span class="line">        <span class="comment">// greater than or equal to arr[i] </span></span><br><span class="line">        arr[i] = lower_bound(temp, temp + n, arr[i]) - temp + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to find smaller_right array </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findElements</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Convert arr[] to an array with values from 1 to n and </span></span><br><span class="line">    <span class="comment">// relative order of smaller and greater elements remains </span></span><br><span class="line">    <span class="comment">// same. For example, &#123;7, -90, 100, 1&#125; is converted to </span></span><br><span class="line">    <span class="comment">// &#123;3, 1, 4, 2 &#125; </span></span><br><span class="line">    convert(arr, n); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a BIT with size equal to maxElement+1 (Extra </span></span><br><span class="line">    <span class="comment">// one is used so that elements can be directly be </span></span><br><span class="line">    <span class="comment">// used as index) </span></span><br><span class="line">    <span class="keyword">int</span> BIT[n + <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// To store smaller elements in right side </span></span><br><span class="line">    <span class="comment">// and greater elements on left side </span></span><br><span class="line">    <span class="keyword">int</span> smaller_right[n], greater_left[n]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse all elements from right. </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get count of elements smaller than arr[i] </span></span><br><span class="line">        smaller_right[i] = getSum(BIT, arr[i] - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add current element to BIT </span></span><br><span class="line">        updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Smaller right: "</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print smaller_right array </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; smaller_right[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        BIT[i] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all left side greater elements </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get count of elements greater than arr[i] </span></span><br><span class="line">        greater_left[i] = i - getSum(BIT, arr[i]); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add current element to BIT </span></span><br><span class="line">        updateBIT(BIT, n, arr[i], <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Greater left: "</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print greater_left array </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; greater_left[i] &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">4</span> &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function call </span></span><br><span class="line">    findElements(arr, n); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">Smaller right: 6 1 1 1 0 1 0 </span></span><br><span class="line"><span class="comment">Greater left: 0 1 1 1 4 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="Segment-Tree-线段树"><a href="#Segment-Tree-线段树" class="headerlink" title="Segment Tree 线段树"></a>Segment Tree 线段树</h4><h5 id="线段树定义"><a href="#线段树定义" class="headerlink" title="线段树定义"></a>线段树定义</h5><ol>
<li>线段树（segment tree），顾名思义，是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。</li>
<li>与树状数组（binary indexed tree）相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。</li>
<li>与树状数组不同的是，线段树不止可以用于区间求和的查询，也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或者区间异或值的查询。</li>
<li>对应于树状数组，线段树进行更新（update）的操作为O(logn)，进行区间查询（range query）的操作也为O(logn)。</li>
</ol>
<p>从数据结构的角度来说，就是用一个完全二叉树来存储对应于其每一个区间(segment)的数据</p>
<h5 id="自下而上的线段树"><a href="#自下而上的线段树" class="headerlink" title="自下而上的线段树"></a>自下而上的线段树</h5><p><mark>这种自下而上的线段树不仅写起来简单，而且运行速度还快得飞起！！！<br>比 naive 自上而下的递归写法高明多了！！！</mark></p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><ol>
<li>自底向上进行：从每一个叶子节点开始，也就是原数组中的每一个元素。沿从叶子节点到根节点的路径向上按层构建。</li>
<li>在构建的每一步中，对应两个子节点的数据将被用来构建应当存储于它们父节点中的值。</li>
<li>每一个中间节点代表它的左右两个子节点对应区间融合过后的大区间所对应的值。</li>
<li>这个融合信息的过程可能依所需要处理的问题不同而不同<ol>
<li>对于保存区间最小值的线段树来说，merge 的过程应为 <code>min()</code> 函数</li>
</ol>
</li>
<li>注意此处我们对于 <code>segTree</code> 数组的索引从 1 开始算起。这样子做，对于数组中的任意节点 <code>i</code>, 其左子节点为 <code>2*i</code>, 右子节点为 <code>2*i + 1</code>, 其父节点为 <code>i/2</code>.</li>
</ol>
<p>算法描述如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">construct(arr):</span><br><span class="line">    n &#x3D; length(arr)</span><br><span class="line">    segTree &#x3D; new int[2*n]     # 新建数组长度为 2*N, 其中第一个位置不会被使用。</span><br><span class="line">    for i from n to 2*n-1:     # 先把原数组放到最后的 N 个位置上。</span><br><span class="line">        segTree[i] &#x3D; arr[i - n]</span><br><span class="line">    for i from n-1 to 1:       # 注意这里 i 最小到 1，因为整个树的根节点的 index 为 1.</span><br><span class="line">        segTree[i] &#x3D; merge(segTree[2*i], segTree[2*i+1])</span><br></pre></td></tr></table></figure>

<p>例如给定一个输入数组 <code>[1, 5, 3, 7, 3, 2, 5, 7]</code>，其对应的最小值线段树如下图所示<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-1.png" alt=""></p>
<p>上图所示线段树每一个节点代表的区间如下图所示:<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-2.png" alt=""></p>
<p>用数组表示来说，数组 <code>segTree</code> 中每一个位置代表的区间如下:</p>
<blockquote>
<p>segmentTree[1] = arr[0:8)<br>segmentTree[2] = arr[0:4)<br>segmentTree[3] = arr[4:8)<br>segmentTree[4] = arr[0:2)<br>segmentTree[5] = arr[2:4)<br>segmentTree[6] = arr[4:6)<br>segmentTree[7] = arr[6:8)<br>segmentTree[8] = arr[0]<br>segmentTree[9] = arr[1]<br>segmentTree[10] = arr[2]<br>segmentTree[11] = arr[3]<br>segmentTree[12] = arr[4]<br>segmentTree[13] = arr[5]<br>segmentTree[14] = arr[6]<br>segmentTree[15] = arr[7]</p>
</blockquote>
<h6 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h6><p>更新一个线段树的过程与上述构造线段树的过程相同。当输入数组中位于i位置的元素被更新时，我们只需从这一元素对应的叶子结点开始，沿二叉树的路径向上更新至更结点即可。显然，这一过程是一个O(logn)的操作。其算法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update(i, value):</span><br><span class="line">    i &#x3D; i + n</span><br><span class="line">    segTree[i] &#x3D; value</span><br><span class="line">    while(i &gt; 1):</span><br><span class="line">        i &#x3D; i &#x2F; 2</span><br><span class="line">        segTree[i] &#x3D; merge(segTree[2 * i], segTree[2 * i + 1])</span><br></pre></td></tr></table></figure>

<h6 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h6><p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-1.png" alt=""></p>
<p>对照着上面的图来思考。<br>假设查询的范围是 <code>[left, right]</code> 区间：</p>
<ol>
<li>先把 <code>left</code> 和 <code>right</code> 各自加上 <code>n</code> 变成数组 <code>segTree</code> 的 index.</li>
<li>考虑 <code>left</code> 节点<ol>
<li>如果 <code>left</code> 是奇数，就意味着 <code>left</code> 是其父节点的右子节点，那么我们只能考虑 <code>left</code> 的信息，不能继续查看 <code>left</code> 父节点，因其父节点的左子节点不在范围内。故考虑完 <code>left</code> 信息后可将 <code>left++</code>。</li>
<li>如果 <code>left</code> 是其父节点的左子节点，那么我们不用考虑 <code>left</code> 的信息了，直接查看其父节点信息即可。</li>
</ol>
</li>
<li>考虑 <code>right</code> 节点<ol>
<li>如果 <code>right</code> 是偶数，就意味着 <code>right</code> 是其父节点的左子节点，我们只能考虑 <code>right</code> 的信息，不能继续查看 <code>right</code> 父节点，因其父节点的右子节点不在范围内。故考虑完 <code>right</code> 信息后可将 <code>right--</code>.</li>
</ol>
</li>
<li>上面两部考察完以后，让 <code>left</code> 和 <code>right</code> 分别指向其父节点。然后迭代这三步！</li>
</ol>
<p>以求最小值为例，算法如下，注意这里的区间是双闭区间，即 <code>left</code> 和 <code>right</code> 节点都在范围内，要考虑进去！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">minimum(left, right):</span><br><span class="line">    left &#x3D; left + n</span><br><span class="line">    right &#x3D; right + n</span><br><span class="line">    minimum &#x3D; Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">    while left &lt;&#x3D; right:</span><br><span class="line">        if left is odd:</span><br><span class="line">            minimum &#x3D; min(minimum, segTree[left])</span><br><span class="line">            left &#x3D; left + 1</span><br><span class="line">        if right is even:</span><br><span class="line">            minimum &#x3D; min(minimum, segTree[right])</span><br><span class="line">            right &#x3D; right - 1</span><br><span class="line">        &#x2F;&#x2F; move left and right one level up</span><br><span class="line">        left &#x3D; left &#x2F; 2</span><br><span class="line">        right &#x3D; right &#x2F; 2</span><br></pre></td></tr></table></figure>

<h6 id="n不是2的指数次怎么办"><a href="#n不是2的指数次怎么办" class="headerlink" title="n不是2的指数次怎么办"></a>n不是2的指数次怎么办</h6><p>上面举的例子中 <code>n = 8 = 2^3</code>，形成的二叉树刚好是一个满二叉树。那么当 n 不是 2 的次方时，该如何处理呢？</p>
<p>事实上：</p>
<ol>
<li>这个算法思路适用于所有的 n</li>
<li>当 n 不是 2 的 次方时候，造成的后果仅仅是对应原来数组元素的那些节点不在同一高度而已</li>
<li>而放置原来数组元素的那些节点仍然是叶子节点！</li>
<li>整个树也是一个<mark>完全二叉树</mark>, 注意！不是<mark>满二叉树</mark>。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-3.png" alt=""></p>
<p>在上图的例子中，你可以自己计算一下 <code>sum(nums[0,1,2,3,4])</code> 和 <code>sum(nums[1,2,3,4])</code> 就可以发现，上面的算法也可以用于这种情况！</p>
<h5 id="自上而下的线段树"><a href="#自上而下的线段树" class="headerlink" title="自上而下的线段树"></a>自上而下的线段树</h5><p>这个方法介绍来自<a href="https://www.acwing.com/blog/content/372/" target="_blank" rel="noopener">这里</a>.</p>
<p>这个时候仍然是使用数组来存储，这个写法跟自下而上的线段树比起来，写起来复杂一点，运行稍慢。</p>
<p>注意这里我们把根节点的 index 当做 0，而之前是从 1 开始 (index=0 的点没用)。这就导致了</p>
<ol>
<li>left = 2 * node + 1</li>
<li>right = 2 * node + 2</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-4.png" alt=""></p>
<h6 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立范围为a[start]~a[end] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node<span class="comment">/*当前节点*/</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界(即遇到叶子节点时) </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="comment">//直接存储a数组中的值 </span></span><br><span class="line">        tree[node] = a[start];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将建立的区间分成两半 </span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;<span class="comment">//左子节点的下标 </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;<span class="comment">//右子节点的下标 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出左子节点的值(即从节点left开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, left,  start, mid);</span><br><span class="line">        <span class="comment">//求出右子节点的值(即从节点right开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点的职位左子节点的值加上右子节点的值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//从根节点(即节点0)开始建树,建树范围为a[0]~a[size-1]</span></span><br><span class="line">    build(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-5.png" alt=""></p>
<h6 id="update-操作"><a href="#update-操作" class="headerlink" title="update 操作"></a>update 操作</h6><ul>
<li>确定需要改的分支，向下寻找需要修改的节点，再向上修改节点值。</li>
<li>与建树的函数相比，update 函数增加了两个参数 x，val，即把 a[x] 改为 val。</li>
</ul>
<p>例：把a[x]改为 6（代码实现）</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-6.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找到a[x],修改值 </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        a[x] = val;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= start &amp;&amp; x &lt;= mid) &#123;<span class="comment">//如果x在左分支 </span></span><br><span class="line">            update(a, tree, start, mid, x, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果x在右分支 </span></span><br><span class="line">            update(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, x, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上更新值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在主函数中调用：</span><br><span class="line"><span class="comment">//把a[x]改成6</span></span><br><span class="line">update(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-7.png" alt=""></p>
<h6 id="query-操作"><a href="#query-操作" class="headerlink" title="query 操作"></a>query 操作</h6><ul>
<li>向下依次寻找包含在目标区间中的区间，并累加。</li>
<li>与建树的函数相比，queryquery函数增加了两个参数 L，R 即把求 a 的区间 [L,R] 的和。</li>
</ul>
<p>例：求 a[2] + a[3] + … + a[5] 的值（代码实现）</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/cpp-algorithm-segment-tree-8.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若目标区间与当时区间没有重叠,结束递归返回0 </span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; R || <span class="built_in">end</span> &lt; L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标区间包含当时区间,直接返回节点值 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;=start &amp;&amp; <span class="built_in">end</span> &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_left  = query(a, tree, left,  start, mid, L, R);</span><br><span class="line">        <span class="comment">//计算右边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_right = query(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相加即为答案 </span></span><br><span class="line">        <span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在主函数中调用：</span><br><span class="line"><span class="comment">//求区间[2,5]的和</span></span><br><span class="line"><span class="keyword">int</span> ans = query(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ans = %d"</span>, ans);</span><br></pre></td></tr></table></figure>

<p>运行结果是:<br>ans = 29</p>
<h6 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立范围为a[start]~a[end] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node<span class="comment">/*当前节点*/</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界(即遇到叶子节点时) </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="comment">//直接存储a数组中的值 </span></span><br><span class="line">        tree[node] = a[start];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将建立的区间分成两半 </span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;<span class="comment">//左子节点的下标 </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;<span class="comment">//右子节点的下标 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出左子节点的值(即从节点left开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, left,  start, mid);</span><br><span class="line">        <span class="comment">//求出右子节点的值(即从节点right开始,建立范围为a[start]~a[mid])</span></span><br><span class="line">        build(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点的职位左子节点的值加上右子节点的值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">//找到a[x],修改值 </span></span><br><span class="line">    <span class="keyword">if</span> (start == <span class="built_in">end</span>)&#123;</span><br><span class="line">        a[x] = val;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= start &amp;&amp; x &lt;= mid) &#123;<span class="comment">//如果x在左分支 </span></span><br><span class="line">            update(a, tree, left, start, mid, x, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果x在右分支 </span></span><br><span class="line">            update(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, x, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上更新值 </span></span><br><span class="line">        tree[node] = tree[left] + tree[right]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求a[L]~a[R]的区间和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> tree[], <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若目标区间与当时区间没有重叠,结束递归返回0 </span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; R || <span class="built_in">end</span> &lt; L)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若目标区间包含当时区间,直接返回节点值 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L &lt;=start &amp;&amp; <span class="built_in">end</span> &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">2</span> * node + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * node + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_left  = query(a, tree, left,  start, mid, L, R);</span><br><span class="line">        <span class="comment">//计算右边区间的值 </span></span><br><span class="line">        <span class="keyword">int</span> sum_right = query(a, tree, right, mid+<span class="number">1</span>, <span class="built_in">end</span>, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相加即为答案 </span></span><br><span class="line">        <span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//从根节点(即节点0)开始建树,建树范围为a[0]~a[size-1]</span></span><br><span class="line">    build(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把a[x]改成6</span></span><br><span class="line">    update(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">4</span>, <span class="number">6</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"tree[%d] = %d\n"</span>, i, tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间[2,5]的和</span></span><br><span class="line">    <span class="keyword">int</span> ans = query(a, tree, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">size</span><span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ans = %d"</span>, ans); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="本题的线段树解法"><a href="#本题的线段树解法" class="headerlink" title="本题的线段树解法"></a>本题的线段树解法</h5><p>代码来自<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/412478/3-Solutions-or-Segment-Tree-or-BIT-or-AVL" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> idx, <span class="keyword">int</span> val, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        idx += n;</span><br><span class="line">        tree[idx] += val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=idx; i&gt;<span class="number">1</span>; i&gt;&gt;=<span class="number">1</span>) tree[i&gt;&gt;<span class="number">1</span>] = tree[i] + tree[i^<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> *tree, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (l+=n, r+=n+<span class="number">1</span>; l&lt;r; l&gt;&gt;=<span class="number">1</span>, r&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) sum += tree[l++];</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) sum += tree[--r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> temp[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) temp[i] = a[i];</span><br><span class="line">        sort(temp, temp+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) a[i] = lower_bound(temp, temp+n, a[i]) - temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), N = n+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> result;</span><br><span class="line">        compress(nums);</span><br><span class="line">        <span class="keyword">int</span> tree[N&lt;&lt;<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = query(tree, <span class="number">0</span>, nums[i]<span class="number">-1</span>, N);</span><br><span class="line">            update(tree, nums[i], <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>note:</p>
<ol>
<li>这里的 <code>compress</code> 算法跟之前树状数组的解法那里处理不太一样，这里相同的元素会占用多个 rank, 比如第二名有两个元素，那么下一个就是第四名。而树状数组那里的处理是，相同的元素只会占用一个 rank。</li>
<li></li>
</ol>
<h4 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h4><ul>
<li>TODO: 参考<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76630/Evolve-from-brute-force-to-optimal-a-review-of-all-solutions" target="_blank" rel="noopener">这里</a>的解法6，和<a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76729/onlogn-divide-and-conquer-java-solution-based-on-bit-by-bit-comparison" target="_blank" rel="noopener">这里</a>的思路解释</li>
</ul>
<h3 id="Reverse-Pairs-Leetcode-0493"><a href="#Reverse-Pairs-Leetcode-0493" class="headerlink" title="Reverse Pairs Leetcode 0493"></a>Reverse Pairs Leetcode 0493</h3><h3 id="Count-of-Range-Sum-Leetcode-0327"><a href="#Count-of-Range-Sum-Leetcode-0327" class="headerlink" title="Count of Range Sum Leetcode 0327"></a>Count of Range Sum Leetcode 0327</h3><p>[使用 Binary Index Tree 方法]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.nums = nums[:]</span><br><span class="line">        self.count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            self.initialize(i, nums[i])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(self.nums)+<span class="number">1</span>:</span><br><span class="line">            self.count[i] += val</span><br><span class="line">            i += (i &amp; -i)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        diff = val - self.nums[i]</span><br><span class="line">        self.nums[i] = val</span><br><span class="line">        self.initialize(i, diff)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_sum</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            total += self.count[i]</span><br><span class="line">            i -= (i &amp; -i)</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        sum of elements nums[i..j], inclusive.</span></span><br><span class="line"><span class="string">        :type i: int</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.left_sum(j) - self.left_sum(i<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># numArray = NumArray(nums)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(0, 1)</span></span><br><span class="line"><span class="comment"># numArray.update(1, 10)</span></span><br><span class="line"><span class="comment"># numArray.sumRange(1, 2)</span></span><br></pre></td></tr></table></figure>

<p>[C++ using Binary Index Tree]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _nums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">bit</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">lower_bit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i&amp;-i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=<span class="built_in">bit</span>[i];</span><br><span class="line">                i-=lower_bit(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;<span class="built_in">bit</span>.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">bit</span>[i]+=val;</span><br><span class="line">                i+=lower_bit(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) : _nums(nums) &#123;</span><br><span class="line">            <span class="built_in">bit</span>.resize(nums.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                add(i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val!=_nums[i])&#123;</span><br><span class="line">                add(i, val-_nums[i]);</span><br><span class="line">                _nums[i]=val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> query(j)-query(i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>[使用 Segment Tree C++]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        _segTree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>*n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span>*n; i++)&#123;    # 把 nums 数组的 n 个元素依次放到 _segTree 数组的后面 n 个位置</span><br><span class="line">            _segTree[i] = nums[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;    # 自下而上依次填满前面的 n<span class="number">-1</span> 个位置。</span><br><span class="line">            _segTree[i] = _segTree[<span class="number">2</span> * i] + _segTree[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i = i + n;</span><br><span class="line">        <span class="keyword">int</span> dif = val - _segTree[i];</span><br><span class="line">        _segTree[i] = val;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            _segTree[i] += dif;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        j += n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;    <span class="meta"># i 是奇数</span></span><br><span class="line">                res += _segTree[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;    <span class="meta"># j 是偶数</span></span><br><span class="line">                res += _segTree[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            i = i&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            j = j&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _segTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj-&gt;update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/30/leetcode-string/" itemprop="url">leetcode string</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T00:29:46-08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/30/leetcode-string/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/30/leetcode-string/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C-string-用法"><a href="#C-string-用法" class="headerlink" title="C++ string 用法"></a>C++ string 用法</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;<span class="comment">//默认初始化，一个空字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"ssss"</span>)</span></span>;<span class="comment">//s1是字面值“ssss”的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=s2;<span class="comment">//s3是s2的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//把s4初始化</span></span><br><span class="line"><span class="built_in">string</span> s5=<span class="string">"hiya"</span>;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> s6=<span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);<span class="comment">//拷贝初始化，生成一个初始化好的对象，拷贝给s6</span></span><br></pre></td></tr></table></figure>

<h2 id="特性描述"><a href="#特性描述" class="headerlink" title="特性描述"></a>特性描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;    <span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abcdefg"</span>;</span><br><span class="line">s.substr(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// "bcd"</span></span><br><span class="line"></span><br><span class="line">s.append(<span class="string">"h"</span>);    <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="string">"cd"</span>);    <span class="comment">// 返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br><span class="line"></span><br><span class="line">s.rfind(<span class="string">"cd"</span>);    <span class="comment">// 从后往前找，还是返回出现的位置 2, 没找到则返回 std::string::npos</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">to_string(val)    <span class="comment">// val 转换成 string</span></span><br><span class="line"></span><br><span class="line">stoi(s,p,b)    <span class="comment">// 把字符串s从p开始转换成b进制的int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">os &lt;&lt; i;    <span class="comment">// 把 int 类型传递给 output string stream</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"the data is "</span> + os.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(<span class="string">"12"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">is &gt;&gt; i;    <span class="comment">// 把 input string steam 传递给 int 类型</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Python-string-用法"><a href="#Python-string-用法" class="headerlink" title="Python string 用法"></a>Python string 用法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str()    # 数字转字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int()    # 浮点数转 int 或者整数字符串转 int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">1.2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0xA1'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">161</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isalpha()    # 判断字符串是否全为字母</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdigit()    # 判断字符串是否全是数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is_integer()    # 判断浮点数是否为整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># join()    # separator.join(str)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.count(substr, start, end)    # 计算 substr 在范围内出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.upper()    # 转大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.lower()    # 转小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str[::-1]    # 以让列表反转</span></span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="0516-最长回文子序列"><a href="#0516-最长回文子序列" class="headerlink" title="0516 最长回文子序列"></a>0516 最长回文子序列</h2><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:</p>
<p>“bbbab”<br>Output:<br>4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">动态规划： dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) </span></span><br><span class="line"><span class="comment">otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> s[<span class="number">0</span>] == s[<span class="number">1</span>] ? <span class="number">2</span>:<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mat</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            mat[i][i+<span class="number">1</span>] = (s[i] == s[i+<span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; s.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + k &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                mat[i][i+k] = <span class="built_in">max</span>(s[i] == s[i+k]? <span class="number">2</span> + mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>] : mat[i+<span class="number">1</span>][i+k<span class="number">-1</span>], <span class="built_in">max</span>(mat[i][i+k<span class="number">-1</span>], mat[i+<span class="number">1</span>][i+k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0151-翻转单词"><a href="#0151-翻转单词" class="headerlink" title="0151 翻转单词"></a>0151 翻转单词</h2><p>Given an input string, reverse the string word by word.</p>
<p>Example 1:</p>
<p>Input: “the sky is blue”<br>Output: “blue is sky the”</p>
<p>Example 2:</p>
<p>Input: “  hello world!  “<br>Output: “world! hello”<br>Explanation: Your reversed string should not contain leading or trailing spaces.</p>
<p>Example 3:</p>
<p>Input: “a good   example”<br>Output: “example good a”<br>Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一：使用 stringstream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is &gt;&gt; temp)&#123;</span><br><span class="line">            vec.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">int</span>(vec.<span class="built_in">size</span>())<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">            os&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=os.str();</span><br><span class="line">        ans.resize(ans.<span class="built_in">size</span>()<span class="number">-1</span>);    <span class="comment">// 小技巧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法二：保证不开辟额外的 vector 来保存各个 word</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以先把 leading, trailing 的零和中间过多的 0 给去除掉</span></span><br><span class="line"><span class="comment">然后 resize</span></span><br><span class="line"><span class="comment">然后左右翻转，这个容易，但是这时候每个单词本身也左右翻转了。</span></span><br><span class="line"><span class="comment">需要对每个单词本身左右翻转一下。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">之后呢</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符替换和复制"><a href="#字符替换和复制" class="headerlink" title="字符替换和复制"></a>字符替换和复制</h2><p>删除一个字符串所有的 a, 并且复制所有的 b. 注意，字符数组足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析：先删除 a, 可以利用原来字符串的空间。</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, numb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] != <span class="string">'a'</span>)&#123;</span><br><span class="line">        s[n++] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        ++numb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再复制 b, 注意字符串要加长。</span></span><br><span class="line"><span class="comment">//     先计算字符串里有几个 b，得到复制后的长度。</span></span><br><span class="line"><span class="comment">//     然后“倒着”复制 --- 管用技巧。</span></span><br><span class="line"><span class="keyword">int</span> newLength = n + numb;</span><br><span class="line">s[newLength] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = newLength - <span class="number">1</span>, j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">    s[i--] = s[j];</span><br><span class="line">    <span class="keyword">if</span>(s[j] == <span class="string">'b'</span>)&#123;</span><br><span class="line">        s[i--] = <span class="string">'b'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0796-rotate-string"><a href="#0796-rotate-string" class="headerlink" title="0796 rotate string"></a>0796 rotate string</h2><p>We are given two strings, A and B.</p>
<p>A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = ‘abcde’, then it will be ‘bcdea’ after one shift on A. Return True if and only if A can become B after some number of shifts on A.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是个巧妙地解法。避免了尝试去分析到底字符串 A 平移了多少个位置才得到 B.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">rotateString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (A+A).<span class="built_in">find</span>(B) != <span class="built_in">string</span>::npos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h2><p>剑指offer: 表示数值的字符串<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length;</span><br><span class="line">        <span class="keyword">boolean</span> sign = <span class="keyword">false</span>, decimal = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!sign &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(sign &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sign = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(hasE)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasE || decimal)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="0316-删除重复字符"><a href="#0316-删除重复字符" class="headerlink" title="0316 删除重复字符"></a>0316 删除重复字符</h2><p>[题目]</p>
<ul>
<li>给定一个仅有小写字母的字符串，只能删除一些字符而不能修改字符顺序；</li>
<li>任务是最终的字符串中原先的每种字符只出现一次，并且结果字典序最小。</li>
</ul>
<p>[分析]</p>
<ul>
<li>如果有 ‘a’, 但是 ‘a’ 的左右两边都存在 ‘b’，那么为了字典序较小，我们肯定是保留 ‘a’ 右侧的 ‘a’</li>
<li>但是如果只有 ‘a’ 的左侧有 ‘b’，那么没办法，只能保留左侧的 ‘b’</li>
</ul>
<p>[解法一：贪心法]</p>
<ul>
<li>延缓决定每种字符的位置，让每个位置字符尽可能小<ul>
<li>某字符在原始字符串中最后出现在位置 p, 它必须出现在结果中了</li>
<li>p 位置及其左边有“更小”的字符，则优先选取它们！</li>
</ul>
</li>
<li>细节<ul>
<li>有多个“最小值”，取最左边的，这样子给右边足够的空间</li>
<li>时间复杂度，大于 O(n)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>;    <span class="comment">// 记录每个字符在不在结果中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ) &#123;    <span class="comment">// 没有自动 i++, 需要在函数体里执行这一句</span></span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>( (num[c] == <span class="number">1</span>) &amp;&amp; (!in[c]) )&#123;    <span class="comment">// 这是字符 s[i] 最后一次出现了！并且它还不在 answer 中</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找到双闭区间 s[last...i] 中最小的那个字符，如果有多个，则是最左边那个</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = last; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( (!in[s[j] - <span class="string">'a'</span>]) &amp;&amp; ((x &lt; <span class="number">0</span>) || (s[j] &lt; s[x])) )&#123;</span><br><span class="line">                        x = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                answer += s[x];</span><br><span class="line">                in[s[x] - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[x] == s[i])&#123;    <span class="comment">// 只有当 s[i] 前面所有的不大于它的字符(包括自己喽)都加进去后，才会 i++</span></span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                last = x + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --num[c];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二：优化？]</p>
<ul>
<li>反思<ul>
<li>我们之所以不敢加一个字符，是怕后面出现了比它还小的字符，并且那个小字符的后面还有这个字符</li>
<li>但是如果我们不加，后面没有这个字符了咋办</li>
</ul>
</li>
<li>可以引入“后悔”</li>
<li>用一个“堆栈”临时保存结果字符串<ul>
<li>从栈底到栈顶 对应从左到右</li>
<li>一个字符如果右边还有，可以自由弹出堆栈</li>
<li>一个字符如果右边没有，<mark>卡住堆栈，它以及被它压住的那些元素均不能弹出</mark></li>
<li>字符 x 入栈前，把堆栈里可以弹出的比它大的字符弹出</li>
</ul>
</li>
<li>时间复杂度 O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 动态变化的，记录子串 s[i:] 中每个字符出现的次数！</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">in</span><span class="params">(<span class="number">26</span>, <span class="keyword">bool</span>)</span></span>; </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            ++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            --num[c];</span><br><span class="line">            <span class="keyword">if</span>(!in[c])&#123;</span><br><span class="line">                <span class="keyword">while</span>( (!st.empty()) &amp;&amp; (st.top() &gt; s[i]) &amp;&amp; (num[st.top() - <span class="string">'a'</span>] &gt; <span class="number">0</span>) )&#123;</span><br><span class="line">                    in[st.top() - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                    st.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(s[i]);</span><br><span class="line">                in[c] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; !st.empty(); st.pop())&#123;</span><br><span class="line">            answer = st.top() + answer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号系列"><a href="#括号系列" class="headerlink" title="括号系列"></a>括号系列</h2><h3 id="0032-最长有效括号"><a href="#0032-最长有效括号" class="headerlink" title="0032 最长有效括号"></a>0032 最长有效括号</h3><p>[题目]</p>
<ul>
<li>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</li>
<li>Example 1<ul>
<li>输入：”(()”</li>
<li>输出：2</li>
</ul>
</li>
<li>Example 2<ul>
<li>输入：”)()())”</li>
<li>输出：4 , 因为最长的子串为 “()()”</li>
</ul>
</li>
</ul>
<p>[方法一：使用 stack]</p>
<ul>
<li>这个题目相当于是 LeetCode 第 20 题 有效的括号 的升级版。</li>
<li>于是可以尝试借助 栈 这个数据结构去解决。</li>
<li>括号相关的问题首先可以尝试使用 栈 这个数据结构去解决，至于原因，想一想应该不难理解，如果进来一个右括号，也就是 ‘)’，它会和之前 最后一次遍历到的左括号 匹配，栈的 先进后出 的特性保证了这一要求。</li>
<li>对于这道题目，因为我们要求的是子串的长度，因此<mark>我们可以考虑在栈中保存 index，这样子我们不仅可以通过 index 找到对应的括号，还可以借此来求长度</mark></li>
<li>我们的思路可以分为下面几步：<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，意味着这并不能和前面遍历过的部分组成合法答案，此时我们只需要把当前 index 入栈即可</li>
<li>如果遇到的是 ‘)’，这时我们就要看栈顶保存的元素了，这里就会有几种情况：<ol>
<li>栈顶保存的是 ‘(‘<ol>
<li>表示当前元素和栈顶元素可以配对，这个时候我们需要把栈顶元素弹出栈，</li>
<li>记录答案则记录当前 index 和弹出配对元素后的新栈顶 index 之间的距离，</li>
<li>这个地方是重点，如果不理解，你可以思考下面两个例子：</li>
<li>“((()()”</li>
<li>“((())”</li>
</ol>
</li>
<li>栈顶保存的是 ‘)’，<ol>
<li>如果是这种情况，表示前面没有可配对的  ‘(‘，我们此时还是需要把当前 index 入栈，原因是</li>
<li>我们确定距离需要知道边界，如果不理解，还是有两个例子供你参考：</li>
<li>“))(())”</li>
<li>“())()()”</li>
</ol>
</li>
<li>栈是空的<ol>
<li>当然在第一种情况中，你弹出栈顶元素后也会使得栈变空，</li>
<li>为了避免这种情况，我们可以在最开始的时候推一个 -1 入栈，这样可以节省我们的判断次数，</li>
<li>并且当栈中的没有元素的时候，我们也可以用这个 -1 来计算当前子串的长度，你可以参考下面这两个例子：</li>
<li>“()”</li>
<li>“()(())”</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>[方法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mystack;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>.push(<span class="number">-1</span>);    <span class="comment">// -1 用于处理边界条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// mystack.size() &gt; 1 表示栈不为空，而且我们必须保证栈顶元素是 '('</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; mystack.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[mystack.top()] == <span class="string">'('</span>)&#123;</span><br><span class="line">            mystack.pop();    <span class="comment">// 配对的 '(' 出栈</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, i - mystack.top());  <span class="comment">// 记录长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mystack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[方法二：动态规划]<br><mark>这个方法不是很容易理解！要好好体会! 感觉思想很类似求解回文子串的马拉车算法！</mark></p>
<p>我们可以<mark>定义 dp[i] 表示以 s[i] 结尾的最长的括号子串的长度</mark>，思路如下：</p>
<ol>
<li>从左到右遍历输入的字符串</li>
<li>如果遇到的是 ‘(‘，因为有效的括号串只能以 ‘)’ 结尾，所以 dp[i] = 0</li>
<li>如果遇到的是 ‘)’，要分情况讨论：<ol>
<li>如果 str[i - 1] 是 ‘(‘，<ol>
<li>那么 dp[i] = dp[i - 2] + 2</li>
</ol>
</li>
<li>如果 str[i - 1] 是 ‘)’，<ol>
<li>则我们需要看以 str[i - 1] 结尾的最长有效括号串 (很明显，它的长度为 dp[i-1])</li>
<li>然后我们要跳过这个括号串，找到它左边那个没有被匹配的字符 s[i - dp[i - 1] - 1]<ol>
<li>如果这个没有被匹配的字符是左括号，那么 s[i] 可以与它搭配成一个左右括号对，因此 <code>dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]</code> <ol>
<li>公式里面的 <code>2</code> 来自于 s[i] 和 s[i - dp[i-1] -1] 形成的括号对</li>
<li>公式右边第三项来自于: 看看当前的序列是否可以和之前匹配的序列链接起来，也就是加上 dp[i - dp[i - 1] - 2]</li>
</ol>
</li>
<li><mark>如果这个没有被匹配的字符是右括号，那么 s[i] 不能与它搭配成一个括号对，dp[i] = 0<ol>
<li>这个结论并没有很明显，你会怀疑，那不能与它搭配就不可以在与之前的搭配吗？</li>
<li>它是个右括号呀！我们跳过以它结尾的最长有效括号串，再找到左边的字符看看是左括号不行吗？？？</li>
<li>不行！！！</li>
<li>为什么呢？因为如果有以 s[i - dp[i-1] - 1] 结尾的最长有效括号串，那么这个括号串一定会和刚才跳过的那个以 s[i-1] 结尾的有效括号串连接起来形成一个更长的有效括号串！</li>
<li>换句话说，因为 dp[i-1] 表示的是以 s[i-1] 结尾的最长的有效括号串，那么我们跳过它之后，左边如果碰到了右括号，那么以这个右括号结尾的最长有效括号串长度为 0，不存在！</li>
<li>不需要再往左边查看了，直接让 dp[i] = 0 即可</mark></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sArr[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 只需要考虑右括号，左括号对应位置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (sArr[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    <span class="comment">// 前一个位置是 '('，直接配对</span></span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;                      <span class="comment">// 前一个位置是 ')'</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 需要跳过以 sArr[i-1] 结尾的最长的有效括号串找到第一个没有被匹配的位置</span></span><br><span class="line">                <span class="comment">// 如果那个位置是 '('，则可以与 sArr[i] 进行匹配</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; sArr[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;    </span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt;= <span class="number">2</span>) &#123;    <span class="comment">// 没有越界的话就加上</span></span><br><span class="line">                        dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者更简洁的 C++ 代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">longest</span><span class="params">(s.<span class="built_in">size</span>(),<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">')'</span> &amp;&amp; i-longest[i<span class="number">-1</span>]<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; s[i-longest[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">                longest[i] = longest[i<span class="number">-1</span>] + <span class="number">2</span> + ((i-longest[i<span class="number">-1</span>]<span class="number">-2</span> &gt;= <span class="number">0</span>)?longest[i-longest[i<span class="number">-1</span>]<span class="number">-2</span>]:<span class="number">0</span>);</span><br><span class="line">                curMax = <span class="built_in">max</span>(longest[i],curMax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>[思路三：双指针法]</p>
<ol>
<li>使用了两个变量 Left 和 Right，分别用来记录到当前位置时左括号和右括号的出现次数。</li>
<li>当遇到左括号时，Left 自增 1，右括号时 Right 自增1。</li>
<li>对于最长有效的括号的子串，一定是左括号等于右括号的情况，此时就可以更新结果 res 了，一旦右括号数量超过左括号数量了，说明当前位置不能组成合法括号子串，Left 和 Right 重置为 0。</li>
<li>但是对于这种情况 “(()” 时，在遍历结束时左右子括号数都不相等，此时没法更新结果 res，但其实正确答案是 2，怎么处理这种情况呢？</li>
<li>答案是再 反向遍历一遍 ，采取类似的机制，稍有不同的是此时若 Left 大于 Right 了，则重置 0，这样就可以涵盖所有情况。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0301-最长合法括号系列"><a href="#0301-最长合法括号系列" class="headerlink" title="0301 最长合法括号系列"></a>0301 最长合法括号系列</h3><p>[题目]<br>给定一个括号序列（可能包括非括号），删除尽可能少的括号，使得剩余括号序列合法，求所有合法最长序列。</p>
<p>[Example]</p>
<ul>
<li>Input: “()())()”</li>
<li>Output: [“()()()”, “(())()”]</li>
</ul>
<p>[解法一思路]</p>
<ul>
<li>动态规划</li>
<li>前 i 个字符，左括号个数比右括号个数多 j 个的最长合法括号序列长度定义为 <code>dp[i][j]</code><ul>
<li>这里的“合法”啥意思？</li>
<li>长度不是指左右括号匹配的长度，而是左括号比右括号多 j 个的括号序列的长度</li>
</ul>
</li>
<li>递归<ul>
<li><code>dp[i][j]</code> = <ul>
<li><code>max(dp[i-1][j], dp[i-1][j-1] + 1) if s[i] == &quot;(&quot;</code>    第二项加 1 是因为要把 s[i] 也包括进来</li>
<li><code>max(dp[i-1][j], dp[i-1][j+1] + 1) if s[i] == &quot;)&quot;</code>    同上！</li>
<li><code>dp[i-1][j] + 1  if s[i] == 其他非括号字母</code></li>
</ul>
</li>
</ul>
</li>
<li>初值<ul>
<li><code>dp[0][0] = 0</code></li>
<li><code>dp[0][x&gt;0] = -infinity</code></li>
</ul>
</li>
<li>“偷懒”记路径<ul>
<li><code>set&lt;string&gt;</code> 记录所有中间字符串</li>
<li>同一个集合里所有的串长度相同</li>
</ul>
</li>
<li>空间优化<ul>
<li><code>dp[i][.]</code> 只与 <code>dp[i-1][.]</code> 有关</li>
<li>滚动数组</li>
</ul>
</li>
</ul>
<p>[解法一代码]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">better</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; a, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(b.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> &gt; b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>())&#123;    <span class="comment">// a 元素长度 + 1 大于 b 中元素长度时候，b 被清空</span></span><br><span class="line">            b.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>() + <span class="number">1</span> == b.<span class="built_in">begin</span>()-&gt;<span class="built_in">size</span>();  <span class="comment">// 此时 a 和 b 要 merge 到一起, 因为答案要全部的结果！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">have</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        have[<span class="number">0</span>].insert(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j<span class="number">-1</span>], have[j])) &#123;    <span class="comment">// better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j<span class="number">-1</span>].<span class="built_in">begin</span>(); it != have[j<span class="number">-1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">"("</span>);  <span class="comment">// have[j-1]</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(better(have[j + <span class="number">1</span>], have[j])) &#123;  <span class="comment">// // better 函数会处理 have[j], 有可能会清空</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[j+<span class="number">1</span>].<span class="built_in">begin</span>(); it != have[j+<span class="number">1</span>].<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">                            have[j].insert(*it + <span class="string">")"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">                    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator t = have[j].<span class="built_in">begin</span>(); t != have[j].<span class="built_in">end</span>(); ++t)&#123;</span><br><span class="line">                        temp.insert(*t + s[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    have[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; answer;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = have[<span class="number">0</span>].<span class="built_in">begin</span>(); it != have[<span class="number">0</span>].<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            answer.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法二: BFS]</p>
<ul>
<li>先把原来的字符串(长度 n)放入一个队列中</li>
<li>每一次循环，从队列中取出一个字符串(长度为 k)，检查其是否合法<ul>
<li>如果合法，则将依次检查队列中剩下的所有元素，看其是否合法</li>
<li>如果不合法，则把这个字符串每个括号位置字符删掉后的结果(一共是 k 个长度为 k-1 的字符串)加到队列中，然后看下一个字符串</li>
</ul>
</li>
<li>所以此处 BFS 的思想是扫完全部的长度为 n 的后，再扫完全部的长度为 n-1 的字符串，etc.</li>
<li><font color="red">TODO: 有一点没有想明白就是它一旦找到一个合法的字符串，就会停止加入新的字符串，并且会把队列当中剩下的所有的合法的字符串放到结果中！我的问题是，它怎么保证结果里面不会同时含有长度为 max_len 的字符串和 max_len-1 的字符串呢？</font><ul>
<li><font color="red">看了 leetcode 讨论区才意识到，确实不会出现这种情况。因为 BFS 的每一层都比上一层的字符串少一个括号！如果你找到了一个结果之后，那么就意味着当前这一层的左括号与右括号匹配，意味着括号数量是偶数！那么队列中存在的下一层的字符串含有的括号数量是奇数！绝对不可能是答案！</font></li>
<li>其实也可以找到答案的时候把长度记录下来，然后队列里的元素拿出来的时候先判断一下长度是否符合，如果不符合，就不需要调用 <code>isValid()</code> 函数了。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(t)) &#123;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] != <span class="string">'('</span> &amp;&amp; t[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">string</span> str = t.substr(<span class="number">0</span>, i) + t.substr(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (!visited.count(str)) &#123;</span><br><span class="line">                    q.push(str);</span><br><span class="line">                    visited.insert(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者是使用 <code>unordered_set</code> 的数据结构，可以解决我上面的疑问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; cur&#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!cur.empty()) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isValid</span>(a)) res.push_back(a);</span><br><span class="line">                <span class="keyword">if</span> (!res.empty()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] != <span class="string">'('</span> &amp;&amp; a[i] != <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    next.insert(a.substr(<span class="number">0</span>, i) + a.substr(i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty()) <span class="keyword">return</span> res;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[解法三:递归，DFS]</p>
<ul>
<li>这种解法首先统计了<font color="red">多余的</font>半括号的数量，用 cnt1 表示多余的左括号，cnt2 表示多余的右括号。<mark>“多余的”意味着需要把它们删掉，也就是说我们的目标是: 让 cnt1 和 cnt2 降为 0.</mark></li>
<li>因为给定字符串左右括号要么一样多，要么左括号多，要么右括号多，也可能左右括号都多，比如 “)(“。</li>
<li>所以 cnt1 和 cnt2 要么都为0，要么都大于0，要么一个为0，另一个大于0。</li>
<li>好，下面进入递归函数<ul>
<li>首先判断，如果当 cnt1 和 cnt2 都为0时，说明此时左右括号个数相等了，调用 isValid 子函数来判断是否正确，正确的话加入结果 res 中并返回即可。</li>
<li>否则从 start 开始遍历<ul>
<li>这里的变量 start 表示当前递归开始的位置，不需要每次都从头开始，会有大量重复计算。</li>
<li>而且对于多个相同的半括号在一起，只删除第一个，比如 “())”，这里有两个右括号，不管删第一个还是删第二个右括号都2会得到 “()”，没有区别，所以只用算一次就行了，通过和上一个字符比较，如果不相同，说明是第一个右括号，如果相同则直接跳过。</li>
</ul>
</li>
<li>此时来看如果 cnt1 大于0，说明此时左括号多，而如果当前字符正好是左括号的时候，可以删掉当前左括号，继续调用递归，此时 cnt1 的值就应该减1，因为已经删掉了一个左括号。</li>
<li>同理，如果 cnt2 大于0，说明此时右括号多，而如果当前字符正好是右括号的时候，可以删掉当前右括号，继续调用递归，此时 cnt2 的值就应该减1，因为已经删掉了一个右括号，参见代码如下：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                cnt1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt1 == <span class="number">0</span>) cnt2++;</span><br><span class="line">                <span class="keyword">else</span> cnt1--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, cnt1, cnt2, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt1, <span class="keyword">int</span> cnt2, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s)) res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt1 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) &#123;    <span class="comment">// 删除左括号以使得 cnt1 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1 - <span class="number">1</span>, cnt2, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt2 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>) &#123;    <span class="comment">// 删除右括号以使得 cnt2 减小</span></span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i) + s.substr(i + <span class="number">1</span>), i, cnt1, cnt2 - <span class="number">1</span>, res);  <span class="comment">// 下一次迭代 start = i，避免重复</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我的思考：</p>
<ol>
<li>这里的思路还是很明确的，计算 cnt1, cnt2 然后想办法删除左右括号来降低 cnt1, cnt2 使得它们都变成 0.</li>
<li>这里其实有一些删除是无意义的，多做了。比如 “(())))((“ 这里 <code>cnt1 = cnt2 = 2</code>，算法会从字符串最左边开始，发现是左括号，然后此时 <code>cnt1=2&gt;0</code> 所以会进入下一层 DFS! 但是这里的 cnt1 =  2 实际上是来自于最右边的两个左括号啊！你删除最左边的没有意义！</li>
<li>所以算法里面实际上是有一些多余的操作的。不过貌似也没有什么好办法去避免这些无意义的操作。</li>
</ol>
<p>[解法四：递归 DFS]</p>
<ul>
<li>本解法跟解法三一样都是 DFS 的思想，但是上面提到，解法三里面有不少操作是没有意义的多余操作</li>
<li>而这里的解法每一步的递归都会得到一个有效的结果！不存在无意义的递归！</li>
<li>思路解析：<ul>
<li>We all know how to check a string of parentheses is valid using a stack. Or even simpler use a counter. The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.</li>
<li>To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s = ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourself to remove the first ) in a series of concecutive )s.</li>
<li>After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.</li>
<li>For this, we keep tracking the last removal position and only remove ‘)’ after that.</li>
<li>Now one may ask. What about ‘(‘? What if s = ‘(()(()’ in which we need remove ‘(‘?<ul>
<li>The answer is: do the same from right to left.</li>
<li>However a cleverer idea is: reverse the string and reuse the code!</li>
</ul>
</li>
</ul>
</li>
<li>我的理解：<ul>
<li>为啥这个算法每次的递归都会产生一个有意义的结果呢？你看它的思路是，从左往右扫，一旦 stack 不满足大于等于 0 的时候（也就是 stack = -1 嘛）会从左边的 prefix 里面删除一个右括号，这样子左边的 prefix 就是一个有意义的结果了啊！</li>
<li>并且它删的时候也特别注意，对于每一段连续的右括号只会删除第一个右括号，保证了不会有重复的结果产生。</li>
<li>它还有一个技巧使用了 {‘(‘, ‘)’} 也特别惊艳！并且它是在 helper 函数最后这么用的，保证了对任何一个子串都会考虑这两种情况！</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> last_i, <span class="keyword">int</span> last_j, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = last_i; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[<span class="number">0</span>]) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == p[<span class="number">1</span>]) --cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = last_j; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == p[<span class="number">1</span>] &amp;&amp; (j == last_j || s[j] != s[j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="comment">// Recursion: last_i = i 因为 i 左边的 prefix 正好是完全匹配的了。</span></span><br><span class="line">                    <span class="comment">// last_j = j 避免产生重复的结果。</span></span><br><span class="line">                    helper(s.substr(<span class="number">0</span>, j) + s.substr(j + <span class="number">1</span>), i, j, p, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              不要小看这个 return.</span></span><br><span class="line"><span class="comment">              能到这里，说明这个字符串 s 在从左往右扫的时候，出现了右括号多于左括号的情况。</span></span><br><span class="line"><span class="comment">              你递归后就会去处理剩下的那部分了，因此不需要再继续往后执行了。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> rev = <span class="built_in">string</span>(s.rbegin(), s.rend());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">'('</span>) helper(rev, <span class="number">0</span>, <span class="number">0</span>, &#123;<span class="string">')'</span>, <span class="string">'('</span>&#125;, res);</span><br><span class="line">        <span class="keyword">else</span> res.push_back(rev);    <span class="comment">// 能到这一步说明这里的 s 是原来的 s 翻转得到的，而这里的 rev 是 s 的翻转，所以就是与原来的顺序相同了！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*上面的两行可以稍微优化一下*/</span></span><br><span class="line">        <span class="comment">// if(cnt == 0)&#123;</span></span><br><span class="line">        <span class="comment">//     res.push_back(p[0] == '(' ? s : rev);</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     if(p[0] == '(') helper(rev, 0, 0, &#123;')', '('&#125;, res);</span></span><br><span class="line">        <span class="comment">//     else res.push_back(rev);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>我突然发现这个算法是最适合没有计算机的时候，如果让你拿一支笔一张纸如何得到所有的结果！我自己试验了一下，真得非常棒！</li>
<li>一个例子 “()())()”<ol>
<li>第一次调用 helper, s = “()())()”</li>
<li>上面的调用会在内层 for loop 里面产生两次调用，一个传递 s = “(())()”，一个传递 “()()()”。并且不会执行外层 for loop 下面的任何语句了。即<ol>
<li>要么不分裂,cnt一直大于等于 0，会跑到外层 for loop 后面语句执行。</li>
<li>要么分裂了，产生了几个递归后直接返回，不会执行外层 for loop 后面的任何语句。</li>
</ol>
</li>
</ol>
</li>
<li>另外我发现上面的算法有一些多余的步骤，所以我修改了一点，参见上面的代码最后。<ol>
<li>主要就是如果 s 刚好是完美匹配了，即不需要删除任何东西，此时 cnt 等于 0，可以直接返回 s 或者 rev.</li>
<li>按照作者的思路，即使完美匹配了，还是会继续对 rev 来一遍操作(虽然操作只是简单地从头到尾遍历了一下每个字符，改变了cnt 的值，但是复杂度也是 O(N) 啊！此处 N 为字符串长度。)</li>
</ol>
</li>
</ol>
<h2 id="字符串全排列-permutation"><a href="#字符串全排列-permutation" class="headerlink" title="字符串全排列 permutation"></a>字符串全排列 permutation</h2><p>[题目]ku<br>给定字符串 S, 设计算法，枚举 S 的全排列。</p>
<p>[代码]<br>当字符串里面的字符互不相等的时候。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;    <span class="comment">// 依次拿 n 之后每个字符与 n 位置交换</span></span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 把后面 i 位置上的字符与当前 n 位置字符交换。</span></span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);    <span class="comment">// 恢复回来。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abcde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有重复字符的时候的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDuplicate</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &lt; t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S[n] == S[t]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="built_in">size</span><span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isDuplicate(S, n, i)) <span class="keyword">continue</span>;  <span class="comment">// 检查范围 [n,i) 中是否有元素与 S[i] 一样。</span></span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">        Permutation(a, <span class="built_in">size</span>, n+<span class="number">1</span>);</span><br><span class="line">        swap(a[i], a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> S = <span class="string">"abbccde"</span>;</span><br><span class="line">    Permutation(S, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>非递归算法</mark><br>参考 leetcode O(n) time complexity 一文中介绍的 next permutation 题目</p>
<p>[思路]<br>将给定的字符串 S 首先升序排序，然后依次调用 std::next_permutation 直到返回 false, 即完成了非递归的全排列算法。</p>
<h2 id="0040-Wildcard-Matching"><a href="#0040-Wildcard-Matching" class="headerlink" title="0040 Wildcard Matching"></a>0040 Wildcard Matching</h2><p>[题目]</p>
<ul>
<li>判断字符串 s 是否与含有通配符 <code>?</code> 和 <code>*</code> 的串 p 匹配。<ul>
<li>其中 <code>?</code> 可以匹配任何的字母</li>
<li>而 <code>*</code> 可以匹配任意长的字母串（包括空串）。</li>
</ul>
</li>
</ul>
<p>[思路一: DP]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    二维DP。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态表示：</span></span><br><span class="line"><span class="comment">    res[i][j] records whether the first i characters of s can be matched by the first j characters of p.</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    状态转移方程：</span></span><br><span class="line"><span class="comment">    res[i][j] = </span></span><br><span class="line"><span class="comment">      1) if p[j] == '?', then res[i][j] = res[i-1][j-1]</span></span><br><span class="line"><span class="comment">      2) if p[j] == '*'  then res[i][j] = true (if exist k in (0,1,...,i) for res[k][j-1]=true, 即p的前j-1个字符可以match某个长度的 s)</span></span><br><span class="line"><span class="comment">                                        = false (if no exist k ...)</span></span><br><span class="line"><span class="comment">      3) if p[j] is small letter, then res[i][j] == res[i-1][j-1] &amp;&amp; (s[i] == p[j]).</span></span><br><span class="line"><span class="comment">                                          </span></span><br><span class="line"><span class="comment">    优化：</span></span><br><span class="line"><span class="comment">    滚动数组方法</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[i] record whether the first i characters of s can be matched.</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个为啥置为 true 呢，因为初始的 res 数组 res[i] 代表 p 的前面 0 个字符能否 match s 的前 i 个字符。</span></span><br><span class="line">        <span class="comment">// res[0] = true 因为 p 的前面 0 个字符可以匹配 s 的前面 0 个字符。</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="literal">true</span>;                        </span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; p.<span class="built_in">size</span>(); col++)&#123;   <span class="comment">// loop the char of p, each time updates the whole res array</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = (<span class="keyword">int</span>)s.<span class="built_in">size</span>(); row &gt; <span class="number">0</span>; row--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[col] == <span class="string">'?'</span>)</span><br><span class="line">                    res[row] = res[row<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[col] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt;= row; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res[k]) &#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res[row] = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    res[row] = (res[row<span class="number">-1</span>] &amp;&amp; p[col] == s[row<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要 p 当中出现了不是星号的时候，res[0] 就必须改成 false 了</span></span><br><span class="line">            <span class="comment">// 因为此时 p 的前 col+1 个字符就不能匹配上 s 的前 0 个字符了。</span></span><br><span class="line">            <span class="keyword">if</span>(p[col] != <span class="string">'*'</span>)</span><br><span class="line">                res[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个时间复杂度很慢，耗时 500ms, 超过了 5.53% 的提交</li>
<li>可以改成 int array 来实现，速度提高到耗时 160ms, 超过 11.28% 的提交。</li>
</ol>
<p>[思路二：贪心，有点 DFS 思想]</p>
<ul>
<li>这个问题的难点就在于星号的处理，它可以匹配 0 个，1 个，2 个，etc</li>
<li>此处的思路就是，我们先考虑星号匹配 0 个字符的情况，即跳过星号，接着进行匹配。如果发现不行了，就回溯检查，让星号匹配 1 个字符，以此类推。<ul>
<li>可以看出来有点 DFS 思想，和贪心的思想。</li>
</ul>
</li>
<li>代码里面 last_match 实际是表示 <code>s[last_match] == p[starj + 1]</code>, 即 last_match 指向的字符与 starj + 1 指向的字符分别作为开头进行的匹配。它们前面的 prefix 是匹配好的。<ul>
<li>如果 i 和 j 对应的字符不匹配了，就需要把 i 回溯到 last_match + 1 (last_match 同时也加一), 同时 j 也回溯到 lastj + 1</li>
</ul>
</li>
<li>平均时间复杂度可能是 O(M+N)</li>
<li>最坏的时间复杂度为 O(MN)<ul>
<li>eg. s = “aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”, p = <code>&quot;*aaaaaab&quot;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">    <span class="keyword">int</span> last_match = <span class="number">-1</span>, starj = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m)&#123;</span><br><span class="line">        <span class="comment">// 把两个指针都往前移动一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">'?'</span>))&#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发现 '*' 则，只把 p 的指针前移一位。注意如果是多个星号连续出现，则会在这一步移动到最后一个星号。</span></span><br><span class="line">        <span class="comment">// 毕竟连续的星号作用也只相当于一个星号！因此可以只考虑最后一个！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            starj = j;</span><br><span class="line">            j++;</span><br><span class="line">            last_match = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (starj != <span class="number">-1</span>)&#123;</span><br><span class="line">            j = starj + <span class="number">1</span>;</span><br><span class="line">            last_match++;</span><br><span class="line">            i = last_match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 p 剩下的字符是否都是 *</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; p[j] == <span class="string">'*'</span>) j++;</span><br><span class="line">    <span class="keyword">return</span> j == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>本来我有个疑问，万一有两个星号怎么办？<ol>
<li>我们只有一个 lastj 记录星号的位置，万一第一个星号我们考虑它匹配 3 个字符，然后后面匹配过程中碰到了第二个星号，我们让 lastj 指向了第二个星号。</li>
<li>这个时候我们没有办法再回到第一个星号考虑让它匹配 4 个，5 个，等字符的情况了啊？</li>
<li>万一正确答案是第一个星号匹配 6 个字符的情况咋办？</li>
</ol>
</li>
<li>举个例子<ol>
<li>s = <code>&quot;abxyzcdecdeijkmn&quot;</code></li>
<li>p = <code>&quot;ab*cde*kmn&quot;</code></li>
</ol>
</li>
<li>事实上，代码是没有问题的<ol>
<li>上面的例子中，我本来是想让第一个星号匹配 “xyzcde”, 第二个星号匹配 “ij”的。</li>
<li>但是，按照代码里面的话，第一个星号在匹配了 “xyz” 后，就走到了第二个星号了，然后把 lastj 指向第二个星号了。这个看起来会有问题，但是代码实际上还是 return true. 即得到了正确的结果！<ul>
<li>为什么呢？</li>
<li>因为这种情况下是存在多解的！</li>
<li>第一个星号可以只匹配 “xyz”，然后第二个星号匹配 “cdeij”。程序找到的就是这个解，因此返回 true.</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="0010-Regular-Expression-Matching"><a href="#0010-Regular-Expression-Matching" class="headerlink" title="0010 Regular Expression Matching"></a>0010 Regular Expression Matching</h2><p>[题目]</p>
<ul>
<li>实现正则表达式匹配<ul>
<li>支持 ‘.’: matches any single character</li>
<li>支持 <code>&#39;*&#39;</code>: matches 0 or more of the preceding element</li>
</ul>
</li>
<li>字符串 s 可能为空，并且只含有小写字母</li>
<li>模式串 p 可能为空，只含有小写字母，<code>.</code> 或者 <code>*</code></li>
<li>原理参见<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Leetcode</a></li>
</ul>
<p><font color='red'>[思路一：分治 Divide and Conquer]</font></p>
<ul>
<li>分治作为一种经典和重要的算法设计思路，是很多解题的出发点，练习分治的能力很重要！</li>
<li>考虑一般 p 和 s 都不为空的情况，从 p 和 s 的头观察：<ul>
<li>如果 p 的第二个字母不是 <code>*</code>，那么<ul>
<li>需要 (1) p[0] 和 s[0] 匹配, 此时 p[0] 可以是 <code>.</code> 或者字母</li>
<li>以及 (2) s.substr(1) 与 p.substr(1) 匹配</li>
</ul>
</li>
<li>如果 p 的第二个字符是 <code>*</code>，需要满足如下两个条件<ul>
<li>一是，p 去掉头两个字符剩下的 p.substr(2) 可以和 s 的某个后缀匹配</li>
<li>二是，p 的前两个字符能匹配 s 剩下的前缀 </li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 空的 p 只能匹配空字符串</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个字符为 '*'</span></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举所有能匹配前两个字符的前缀，剩下的部分是子问题</span></span><br><span class="line">        <span class="comment">// 这里用 do-while 而不是 while loop 是为了处理好 match empty prefix 的情况</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s.substring(k), p.substring(<span class="number">2</span>)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (k &lt; s.length() &amp;&amp; isMatch(s[k++], p[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>分治的方法不难理解，但是运行效率较慢</li>
<li>假设s的长度是n，p的长度是m，最坏情况下每一层recursion会产生O(n)个递归调用，而recursion的深度是O(m)，按照DFS的复杂度分析公式，时间复杂度高达O(n^m)</li>
</ol>
<p><font color='red'>[思路二：改进分治]</font></p>
<ol>
<li>在分治的过程中，核心的部分是 induction rule 的构建，而对于同一个分治的定义，是可以有不同的 induction rule 的，不同的 induction rule 带来的效率也是不同的。</li>
<li>对于 <code>*</code> 的情况，我们也可以只分成两种情况讨论：匹配空前缀，或者匹配非空前缀。<ol>
<li>如果 <code>*</code> 匹配空前缀，且 s 匹配 p.substr(2)，则 s 与 p 匹配。</li>
<li>如果 <code>*</code> 匹配非空前缀，且 s.substr(1) 匹配 p, 则 s 与 p 匹配。<ol>
<li>注意这种情况下没有改变 p 就传给了子问题，可以进一步匹配 s.substr(1) 的前缀（可为空）。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> s.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !s.empty() &amp;&amp; isMatch(s[<span class="number">0</span>], p[<span class="number">0</span>]) &amp;&amp; dfs(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p == <span class="string">'.'</span> ? <span class="literal">true</span> : p == c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>改进后的分治每一层 dfs 最多可以产生两个递归调用，时间复杂度减少到了 O(2^m).</li>
</ol>
<p><font color='red'>[方法三：记忆化搜索]</font></p>
<ol>
<li>通过观察现有解决方案来找到效率不高的地方，继续利用对常见数据结构和算法的理解进行优化，是系统解决问题的过程中能够体现出的重要能力之一。</li>
<li>注意到 dfs 在搜索过程中有可能会对完全一样的参数（相同的子问题）计算多次。对于同样的参数，dfs 的计算过程和结果都是完全一致的，所以没有必要做重复的计算。避免重复的计算的方法就是把计算的结果按照 dfs 的参数存下来，这样以后遇到之前计算过得 dfs 时候可以直接放回上一次计算的结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="built_in">string</span> p, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; memo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> i == s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; p.<span class="built_in">size</span>() &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            memo[i][j] = helper(s, i, p, j+<span class="number">2</span>, visited, memo) || (i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j, visited, memo));</span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"haha2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        memo[i][j] = i &lt; s.<span class="built_in">size</span>() &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; helper(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>, visited, memo);</span><br><span class="line">        visited[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  <span class="title">visited</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">memo</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, p, <span class="number">0</span>, visited, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>记忆化搜索只需要对代码做简单的改进，然而运行时间却有巨大的提升（leetcode ~12-20ms）.不同子问题的个数总共有 O(mn) 个，每个子问题只计算一遍。每个子问题的开销不包含任何循环，所以只有 O(1).</li>
<li>总的时间复杂度变成了 O(mn). 这是一个很好地空间换时间的策略。</li>
</ol>
<p><font color='red'>[思路四: 动态规划]</font></p>
<ol>
<li>上述三种方法里<ol>
<li>分治法本质上是在一个图上做一个深度优先搜索</li>
<li>而记忆化搜索本质上是按照这个图的拓扑顺序 (topological order) 的逆序填表。</li>
</ol>
</li>
<li>如果我们能用简单的循环描述出图的拓扑顺序，那么就可以用迭代的形式来完成填表的任务，这就是著名的动态规划。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(sLen + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(pLen + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ol>
<li>这个代码在 leetcode oj 上有 4-8ms 的时间复杂度。</li>
<li>如果使用 C array 的话时间和空间复杂度更好。有时候 leetcode oj 给出 0ms 的运行时间。</li>
</ol>
<p>[思路五：动态规划空间优化]</p>
<ol>
<li>在上面的算法里面，我们是按照一行一行的顺序填表的，每填一行的时候只需要用到下一行的值。</li>
<li>也就是说只需要保存最近 2 行的值就能够完成填表的任务了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">charMatch</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="string">'.'</span> || p == c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.<span class="built_in">size</span>(), pLen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> dp[<span class="number">2</span>][pLen + <span class="number">1</span>] &#123;&#123;<span class="literal">false</span>&#125;&#125;;             <span class="comment">// 使用 C type array; 还进行了空间优化。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sLen; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = pLen; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == pLen)&#123;</span><br><span class="line">                    dp[i % <span class="number">2</span>][j] = i == sLen;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; pLen &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = dp[i%<span class="number">2</span>][j+<span class="number">2</span>] || (i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i%<span class="number">2</span>][j] = i != sLen &amp;&amp; charMatch(s[i], p[j]) &amp;&amp; dp[(i+<span class="number">1</span>) % <span class="number">2</span>][j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>[更早的思路：递归 DFS]</p>
<ul>
<li>核心就是看看第二个字符是不是 <code>*</code></li>
<li>分如下情况：<ol>
<li>p 为空<ol>
<li>如果 s 为空，则返回 true</li>
<li>如果 s 不为空，返回 false</li>
</ol>
</li>
<li>p 长度为 1<ol>
<li>若 s 长度为 1，并且 <code>p[0] == s[0] 或者 p[0] == &#39;.&#39;</code></li>
<li>否则返回 false</li>
</ol>
</li>
<li>p[1] 即第二个字符不是 <code>*</code><ol>
<li>若此时 s 为空返回 false</li>
<li>s 不为空的话则比较 s[0] 和 p[0], 并且从各自的第二个字符开始调用递归函数匹配</li>
</ol>
</li>
<li>p[1] 第二个字符为 <code>*</code>，进行下列循环，条件是若s不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配s和去掉前两个字符的p（这样做的原因是假设此时的星号的作用是让前面的字符出现0次，验证是否匹配），若匹配返回 true，否则s去掉首字母（因为此时首字母匹配了，我们可以去掉s的首字母，而p由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。</li>
<li>返回调用递归函数匹配s和去掉前两个字符的p的结果（这么做的原因是处理星号无法匹配的内容，比如 s=”ab”, p=”a<em>b”，直接进入 while 循环后，我们发现 “ab” 和 “b” 不匹配，所以s变成 “b”，那么此时跳出循环后，就到最后的 return 来比较 “b” 和 “b” 了，返回 true。再举个例子，比如 s=””, p=”a</em>“，由于s为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (s.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(s, p.substr(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s = s.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>【目的】字符串查找！给定文本串 text 和模式串 pattern, 从文本串 text 中找到模式串 pattern 第一次出现的位置。</li>
<li>【复杂度】KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。</li>
<li>【解释】因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</li>
</ul>
<h3 id="BF与KMP区别"><a href="#BF与KMP区别" class="headerlink" title="BF与KMP区别"></a>BF与KMP区别</h3><ul>
<li>假设当前文本串 text 匹配到 i 位置，模式串 pattern 匹配到 j 位置（模式串的开头与 text 串的 i 位置对齐）。</li>
<li>BF算法做法<ul>
<li>如果当前字符匹配成功，即 text[i+j] == pattern[j]，另 i++, j++, 继续匹配下一个字符；</li>
<li>如果字符匹配失败，即 text[i+j] != pattern[j], 另 i++, j=0, 即失败的情况下，模式串 pattern 相对于文本串 text 向右移动了一位。</li>
</ul>
</li>
<li>KMP 算法做法<ul>
<li>如果当前字符匹配成功，同上，i++, j++, 继续匹配下一个字符</li>
<li>如果匹配失败，另 i 不变，j=next[j](此处 next[j]&lt;=j-1), 即模式串 pattern 相对于文本串 text 向右移动了至少一位(移动的实际位数 j-next[j]&gt;=1)</li>
</ul>
</li>
</ul>
<h3 id="字符串比较机制"><a href="#字符串比较机制" class="headerlink" title="字符串比较机制"></a>字符串比较机制</h3><p>我们的想法是：不要出现回溯！如果已经匹配到了 text 串的 i+j 位置，即使没有匹配成功，接下来也要继续从当前位置匹配下去，不能回溯到 i+1 位置重新开始匹配！</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga642xvt9aj20ii0cm0x9.jpg" alt="Screen Shot 2019-12-22 at 11.22.19.png"></p>
<p><mark>如上图所示，pattern 串的绿色位置和 text 串的黄色字符不匹配，这个时候我们把 pattern 串往右移动，让 C 那个位置去和 text 串的黄色(就是上面提到的 i+j 位置)去比较！而这么比较的前提是，B 方块与 A 方块一样！这就是说 pattern 串在 d 之前的那一部分的 前缀串A 与 后缀串B 相同！</mark></p>
<h3 id="最大k前缀与k后缀"><a href="#最大k前缀与k后缀" class="headerlink" title="最大k前缀与k后缀"></a>最大k前缀与k后缀</h3><p>因此，问题就转化为如下问题</p>
<ul>
<li>对于模式串 pattern 的位置 j，考察 <mark>p[0]p[1]…p[j-2]p[j-1]</mark>，查找其<mark>最大相等的 k前缀 和 k后缀</mark>。<ul>
<li>注意！计算 next[j] 的时候，考察的字符串是模式串的前 j-1 个字符，与 p[j] 无关。</li>
</ul>
</li>
<li>即：查找满足条件的最大的 k，使得 <mark>p[0]p[1]…p[k-1] = p[j-k]p[j-k+1]…p[j-1]</mark></li>
</ul>
<p>[一个具体的例子如下]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64in2byhj20lw0dgwke.jpg" alt="Screen Shot 2019-12-22 at 11.45.00.png"></p>
<h3 id="next的递推关系"><a href="#next的递推关系" class="headerlink" title="next的递推关系"></a>next的递推关系</h3><ul>
<li>对于模式串的位置 j, 有 next[j]=k, 即 p[0]p[1]…p[k-1]=p[j-k]p[j-k+1]p[j-1]</li>
<li>则，对于模式串的位置 j+1, 考察 p[j]</li>
<li>若 p[k]==p[j]<ul>
<li>则 next[j+1] = next[j]+1</li>
</ul>
</li>
<li>反之若 p[k]!=p[j]<ul>
<li>记 h=next[k]; 如果 p[h]==p[j], 则 next[j+1]=h+1, 否则重复此过程</li>
</ul>
</li>
</ul>
<p>[相等时候]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64w29cejj20dg07idjh.jpg" alt="Screen Shot 2019-12-22 at 11.58.12.png"></p>
<p>[不相等时候的递推]<br><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga64wzy4gxj20jo0d60zc.jpg" alt="Screen Shot 2019-12-22 at 11.59.13.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算 Next 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP Code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || <span class="built_in">text</span>[i] == pattern[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;</span><br><span class="line">            ans = i - n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进一步分析-next"><a href="#进一步分析-next" class="headerlink" title="进一步分析 next"></a>进一步分析 next</h3><ul>
<li>文本串匹配到 i，模式串匹配到 j，此刻若 text[i] != pattern[j]，即失败的情况</li>
<li>若 next[j]=k, 说明模式串应该从 j 滑动到 k 位置；</li>
<li>若此时满足 pattern[j] == pattern[k], 因为 text[i] != pattern[j], 所以 text[i] != pattern[k]<ul>
<li>即 i 和 k 没有匹配，应该继续滑动到 next[k]</li>
<li>换句话，在原始的 next 数组中，若 next[j]=k 并且 pattern[j] == pattern[k], next[j] 可以直接等于 next[k].</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga660po260j20ha06yac8.jpg" alt="Screen Shot 2019-12-22 at 12.37.22.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext2</span><span class="params">(<span class="built_in">string</span> p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 此刻 k = next[j-1], 且 p[k] 表示前缀，p[j] 表示后缀</span></span><br><span class="line">        <span class="comment">// k==-1 表示未找到 k 前缀与 k 后缀相等，首次分析可先忽略</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span> || p[j] == p[k])&#123;</span><br><span class="line">            ++j;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == p[k])&#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// p[j]与p[k]匹配失败，则继续递归计算前缀 p[next[k]]</span></span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[例子]</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>原始next</td>
<td>-1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>新next</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
</tbody></table>
<h3 id="KMP-时间复杂度"><a href="#KMP-时间复杂度" class="headerlink" title="KMP 时间复杂度"></a>KMP 时间复杂度</h3><ul>
<li>考察模式串的”串头”和主串的对应位置，也就是暴力算法中的 i</li>
<li>不匹配：串头后移，保证尽快结束算法</li>
<li>匹配：串头保持不动，i++, j++, 但一旦发现不匹配，会跳过匹配过的字符(next[j])</li>
<li>最坏的情况，当串头位于 N-M 的位置时候算法才结束</li>
<li>因此，匹配的时间复杂度为 O(N)，算上计算 next 的O(M) 时间，整体时间复杂度 O(M+N)，其实一般就认为是 O(N) 了。</li>
<li>最好情况：当模式串的首字符和其他字符都不相等时，模式串不存在相等的 k前缀和 k后缀，next 数组全为 -1<ul>
<li>一旦匹配失败，模式串直接跳过已经比较的字符。比较次数为 N</li>
</ul>
</li>
<li>最差情况：当模式串的首字符和其他字符全都相等时候，模式串存在最长的 k 前缀和 k后缀，next 数组呈现递增样式: -1, 0, 1, 2, …<ul>
<li>每个周期中 m 1 1 1 …</li>
<li>周期 n/m</li>
<li>总次数：(2 - 1/M) * N &lt; 2N</li>
<li><mark>此时变种KMP 的运行情况比较总次数依然为 N.</mark></li>
</ul>
</li>
</ul>
<h3 id="一个应用-PowerString-问题"><a href="#一个应用-PowerString-问题" class="headerlink" title="一个应用 PowerString 问题"></a>一个应用 PowerString 问题</h3><p>[题目]<br>给定一个长度为 n 的字符串 S，如果存在一个字符串 T，重复若干次 T 能够得到 S，那么，S 叫做周期串，T 叫做 S 的一个周期。请设计一个算法，计算 S 的最小周期。如果不存在周期，返回空串。</p>
<p>[Examples]<br>字符串 abababab 是周期串，abab 和 ab 都是它的周期，其中 ab 是它的最小周期。</p>
<p>[思路]<br>使用 next，限行时间解决问题</p>
<ul>
<li>计算 S 的 next 数组<ul>
<li>记 k = next[length], p = length - k</li>
<li>若 len%p==0，则 p 为最小周期长度，前 p 个字符就是最小周期。</li>
</ul>
</li>
<li>说明<ul>
<li>使用的是经典 KMP 的 next 算法，不是变种的 next 算法</li>
<li>要”多”计算到 length, 即 next[length]</li>
</ul>
</li>
<li>思考：如何证明？<ul>
<li>考察字符串 S 的 k前缀 head 和 k后缀 tail</li>
<li>head 和 tail 的前 p 个字符</li>
<li>head 和 tail 的前 2p 个字符</li>
<li>head 和 tail 的前 3p 个字符</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6737iy1oj20mu0dmn3l.jpg" alt="Screen Shot 2019-12-22 at 13.14.24.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPeriod</span><span class="params">(<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(n, <span class="number">-1</span>)</span></span>;  <span class="comment">// 仿照KMP 求伪 next, next[0] = -1 是哨兵，串首标志</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || p[j+<span class="number">1</span>] == p[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 恢复成逻辑上的 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nLast = next[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(n % (n-nLast) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-nLast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><ul>
<li>KMP 的 next，实际上是建立了 DFA</li>
<li>DFA: Deterministic Finite Automaton</li>
<li>以当前位置为 DFA 的状态，以模式串的字符为 DFA 的转移条件，建立确定有穷自动机。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga66p8zqirj20kq0cqq9r.jpg" alt="Screen Shot 2019-12-22 at 13.00.57.png"></p>
<p>具体算法细节请参考：</p>
<p><a href="http://note.youdao.com/noteshare?id=dda1246716d3e1f321ee1b637ad2b413" target="_blank" rel="noopener">KMP算法</a><br><a href="http://note.youdao.com/noteshare?id=13fe90f9adddde21b0d5f8f7880ebc1f" target="_blank" rel="noopener">史上最清楚的 KMP 算法介绍</a></p>
<h2 id="Robin-Karp-字符串匹配算法"><a href="#Robin-Karp-字符串匹配算法" class="headerlink" title="Robin-Karp 字符串匹配算法"></a>Robin-Karp 字符串匹配算法</h2><ul>
<li>核心思想是比较两个字符串的哈希值，而不是逐个字母进行比较。</li>
<li>需要巧妙地设计哈希函数<ul>
<li>比如使用字符串的和来做哈希值，这样就可以使用增量方法来方便计算。比如主串上右移了一位，那么就可以简单的把移调的字母值减掉，加上右移后cover到的那个字母值加上就行了！</li>
</ul>
</li>
</ul>
<h2 id="Boyer-Moore-算法-了解"><a href="#Boyer-Moore-算法-了解" class="headerlink" title="Boyer Moore 算法 (了解)"></a>Boyer Moore 算法 (了解)</h2><ol>
<li>1977年由德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明的字符串匹配算法。</li>
<li>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则<ol>
<li>即 坏字符规则 和 好后缀规则，来决定向右跳跃的距离。</li>
<li>基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。</li>
</ol>
</li>
<li>效率很高，构思巧妙，拥有在最坏情况下 O(N) 的时间复杂度。实践中比 KMP 算法的实际效能高。</li>
<li>Ref:<ol>
<li><a href="https://mp.weixin.qq.com/s/7IZTuLrPSuxvFRqsv5PiXQ" target="_blank" rel="noopener">微信公众号:帅地玩编程</a></li>
</ol>
</li>
</ol>
<h2 id="Manacher-算法-了解"><a href="#Manacher-算法-了解" class="headerlink" title="Manacher 算法 (了解)"></a>Manacher 算法 (了解)</h2><h3 id="重心扩展算法"><a href="#重心扩展算法" class="headerlink" title="重心扩展算法"></a>重心扩展算法</h3><p>我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r2kr17xj20ca076mx4.jpg" alt="Palindrom"></p>
<p>不过要注意，因为字符串可能是奇数长度或者偶数长度，所以我们要考虑的字符串重心有 n+n-1 个。</p>
<h3 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h3><p>马拉车算法 Manacher‘s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r7nxe4mj20e9020a9w.jpg" alt="undefined"></p>
<p>首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方。可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r80otw7j20gq04k0st.jpg" alt="undefined"></p>
<h3 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h3><p>用 P 的下标 i 减去 P [ i ]，再除以 2 ，就是原字符串的开头下标了。</p>
<p>例如我们找到 P[i] 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，所以原字符串的开头下标是 （6 - 5 ）/ 2 = 0 。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。</p>
<h3 id="求每个-P-i"><a href="#求每个-P-i" class="headerlink" title="求每个 P[i]"></a>求每个 P[i]</h3><p>接下来是算法的关键了，它充分利用了回文串的对称性。</p>
<p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。</p>
<p>让我们考虑求 P [ i ] 的时候，如下图。</p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9r9bfgnzj20gw059t8q.jpg" alt="undefined"></p>
<p>我们现在要求 P [ i ]， 如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p>
<p>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。</p>
<h4 id="超出了-R"><a href="#超出了-R" class="headerlink" title="超出了 R"></a>超出了 R</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9ra7gjrcj20q705f0st.jpg" alt="undefined"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<h4 id="P-i-mirror-遇到了原字符串的左边界"><a href="#P-i-mirror-遇到了原字符串的左边界" class="headerlink" title="P[i_mirror] 遇到了原字符串的左边界"></a>P[i_mirror] 遇到了原字符串的左边界</h4><p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9razyuazj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<h4 id="i-等于-R"><a href="#i-等于-R" class="headerlink" title="i 等于 R"></a>i 等于 R</h4><p>此时我们先把 P [ i ] 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。</p>
<h3 id="考虑-C-和-R-的更新"><a href="#考虑-C-和-R-的更新" class="headerlink" title="考虑 C 和 R 的更新"></a>考虑 C 和 R 的更新</h3><p>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga9rc3tj3fj20gd05l3yj.jpg" alt="undefined"></p>
<p>此时的 P [ i ] 求出来将会是 3 ，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R ，我们需要把 C 更新成 i 的值，也就是 10 ，R 更新成 13。继续下边的循环。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preProcess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = <span class="string">"^"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ret += <span class="string">"#"</span> + s.charAt(i);</span><br><span class="line">    ret += <span class="string">"#$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 马拉车算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String T = preProcess(s);</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    <span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; i) &#123;</span><br><span class="line">            P[i] = Math.min(R - i, P[i_mirror]);<span class="comment">// 防止超出 R</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P[i] = <span class="number">0</span>;<span class="comment">// 等于 R 的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> (T.charAt(i + <span class="number">1</span> + P[i]) == T.charAt(i - <span class="number">1</span> - P[i])) &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要更新 R</span></span><br><span class="line">        <span class="keyword">if</span> (i + P[i] &gt; R) &#123;</span><br><span class="line">            C = i;</span><br><span class="line">            R = i + P[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 P 的最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> centerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i] &gt; maxLen) &#123;</span><br><span class="line">            maxLen = P[i];</span><br><span class="line">            centerIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = (centerIndex - maxLen) / <span class="number">2</span>; <span class="comment">//最开始讲的求原字符串下标</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：for 循环里边套了一层 while 循环，难道不是 O(n²)？不！其实是 O(n)。不严谨的想一下，因为 while 循环访问 R 右边的数字用来扩展，也就是那些还未求出的节点，然后不断扩展，而期间访问的节点下次就不会再进入 while 了，可以利用对称得到自己的解，所以每个节点访问都是常数次，所以是 O(n)。</p>
<p>空间复杂度：O(n)。</p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h3 id="二叉树的节点"><a href="#二叉树的节点" class="headerlink" title="二叉树的节点"></a>二叉树的节点</h3><ul>
<li>另有两个孩子，1 个孩子，0 个孩子的节点个数分别为 n2, n1, n0</li>
<li>所有节点的出度为 2<em>n2+1</em>n1+0*n0</li>
<li>除了根节点，其他所有节点的入度都是 1，从而所有节点的入度为 (n0+n1+n2)-1</li>
<li>总入度等于总出度，2<em>n2+1</em>n1+0*n0 = n2+n1+n0-1</li>
<li>化简得到 n0 - n2 = 1</li>
<li>也就是说二叉树叶子节点数目比拥有两个孩子的节点数目多 1</li>
</ul>
<h3 id="编码思想"><a href="#编码思想" class="headerlink" title="编码思想"></a>编码思想</h3><ul>
<li>无损压缩编码方案</li>
<li>概率高的字符使用较短的编码，概率低的使用较长的编码，从而使得编码后的字符串长度期望最小</li>
<li>Huffman 编码是一种贪心算法：每次总选择两个最小概率的字符节点合并<ul>
<li>称字符出现的次数为频数，则概率约等于频数除以字符总长；因此概率可以用频数代替</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/6a607485gy1ga6aj3zolrj20g40fa796.jpg" alt="Screen Shot 2019-12-22 at 15.13.26.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用数组来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(<span class="keyword">int</span> *pWeight, <span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; code)</span></span>&#123;</span><br><span class="line">    <span class="comment">// code 传进来时候是空的 vector&lt;vector&lt;char&gt;&gt; 引用，后面会修改。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * N - <span class="number">1</span>;  <span class="comment">// N个节点的 Huffman 树需要 2N-1 个节点</span></span><br><span class="line">    HuffmanNode* pHuffmanTree = <span class="keyword">new</span> HuffmanNode[m];  <span class="comment">// 在动态内存空间里建立这个 vector</span></span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 建立叶子节点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        pHuffmanTree[i].nWeight = pWeight[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次选择权值最小的两个节点，建树</span></span><br><span class="line">    <span class="keyword">for</span>(i = N; i &lt; m; i++)&#123;</span><br><span class="line">        SelectNode(pHuffmanTree, i, s1, s2);  <span class="comment">// 在前 i 个 nodes 里面找到权值最小的两个节点。用过的节点不会被再用。因为用过的节点有 nParent 信息了。</span></span><br><span class="line">        pHuffmanTree[s1].nParent = pHuffmanTree[s2].nParent = i;  <span class="comment">// s1 和 s2 的父节点是 i 节点</span></span><br><span class="line">        pHuffmanTree[i].nLeft = s1;</span><br><span class="line">        pHuffmanTree[i].nRight = s2;</span><br><span class="line">        pHuffmanTree[i].nWeight = pHuffmanTree[s1].nWeight + pHuffmanTree[s2].nWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据建好的 Huffman 树从叶子到根计算每个叶节点的编码</span></span><br><span class="line">    <span class="keyword">int</span> node, nParent;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">// code[i] 就是 node i 的编码！</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; cur = code[i];    <span class="comment">// 此时还是空的 vector</span></span><br><span class="line">        node = i;</span><br><span class="line">        nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        <span class="keyword">while</span>(nParent != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHuffmanTree[nParent].nLeft == node)&#123;</span><br><span class="line">                cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            node = nParent;</span><br><span class="line">            nParent = pHuffmanTree[node].nParent;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用指针来实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Tree node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to allocate a new tree node</span></span><br><span class="line"><span class="function">Node* <span class="title">getNode</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node* left, Node* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* node = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    node-&gt;ch = ch;</span><br><span class="line">    node-&gt;freq = freq;</span><br><span class="line">    node-&gt;left = left;</span><br><span class="line">    node-&gt;right = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparison object to be used to order the heap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* l, Node* r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// highest priority item has lowest frequency</span></span><br><span class="line">        <span class="keyword">return</span> l-&gt;freq &gt; r-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line"><span class="comment">// in a map.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node* root, <span class="built_in">string</span> str,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; &amp;huffmanCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        huffmanCode[root-&gt;ch] = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    encode(root-&gt;left, str + <span class="string">"0"</span>, huffmanCode);</span><br><span class="line">    encode(root-&gt;right, str + <span class="string">"1"</span>, huffmanCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse the Huffman Tree and decode the encoded string</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(Node* root, <span class="keyword">int</span> &amp;index, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;ch;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str[index] ==<span class="string">'0'</span>)</span><br><span class="line">        decode(root-&gt;left, index, str);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        decode(root-&gt;right, index, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builds Huffman Tree and decode given input text</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHuffmanTree</span><span class="params">(<span class="built_in">string</span> <span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// count frequency of appearance of each character</span></span><br><span class="line">    <span class="comment">// and store it in a map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        freq[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a priority queue to store live nodes of</span></span><br><span class="line">    <span class="comment">// Huffman tree;</span></span><br><span class="line">    priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a leaf node for each character and add it</span></span><br><span class="line">    <span class="comment">// to the priority queue.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: freq) &#123;</span><br><span class="line">        pq.push(getNode(pair.first, pair.second, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do till there is more than one node in the queue</span></span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the two nodes of highest priority</span></span><br><span class="line">        <span class="comment">// (lowest frequency) from the queue</span></span><br><span class="line">        Node *left = pq.top(); pq.pop();</span><br><span class="line">        Node *right = pq.top(); pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new internal node with these two nodes</span></span><br><span class="line">        <span class="comment">// as children and with frequency equal to the sum</span></span><br><span class="line">        <span class="comment">// of the two nodes' frequencies. Add the new node</span></span><br><span class="line">        <span class="comment">// to the priority queue.</span></span><br><span class="line">        <span class="keyword">int</span> sum = left-&gt;freq + right-&gt;freq;</span><br><span class="line">        pq.push(getNode(<span class="string">'\0'</span>, sum, left, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root stores pointer to root of Huffman Tree</span></span><br><span class="line">    Node* root = pq.top();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree and store Huffman Codes</span></span><br><span class="line">    <span class="comment">// in a map. Also prints them</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; huffmanCode;</span><br><span class="line">    encode(root, <span class="string">""</span>, huffmanCode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair: huffmanCode) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nOriginal string was :\n"</span> &lt;&lt; <span class="built_in">text</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print encoded string</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="built_in">text</span>) &#123;</span><br><span class="line">        str += huffmanCode[ch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the Huffman Tree again and this time</span></span><br><span class="line">    <span class="comment">// decode the encoded string</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nDecoded string is: \n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; (<span class="keyword">int</span>)str.<span class="built_in">size</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">        decode(root, index, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huffman coding algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">text</span> = <span class="string">"Huffman coding is a data compression algorithm."</span>;</span><br><span class="line"></span><br><span class="line">    buildHuffmanTree(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Huffman总结：前缀编码"><a href="#Huffman总结：前缀编码" class="headerlink" title="Huffman总结：前缀编码"></a>Huffman总结：前缀编码</h3><ul>
<li>Huffman编码是<mark>不等长编码</mark><ul>
<li>字符的编码长度不完全相等</li>
</ul>
</li>
<li>不等长编码如果需要译码，必须满足<mark>前缀编码</mark>的条件<ul>
<li>任何一个字符的编码都不是另外一个字符编码的前缀</li>
</ul>
</li>
<li>从Huffman树的角度考虑，就是<mark>所有的待编码元素都位于叶子节点上</mark>！</li>
</ul>
<p>[思考]</p>
<ul>
<li>Huffman 编码是如何解决前缀编码问题的？</li>
<li>实际算法是由多个”小算法”堆砌而成<ul>
<li>空格压缩问题</li>
<li>取数组最大/小的两个数</li>
</ul>
</li>
<li>代码实现中并非直接使用指针形成的二叉树节点，而是实现开辟足够大的缓冲空间(2n+1)，每次从缓冲区获取一个节点，使用数组代替二叉树<ul>
<li>在堆排序，双数组 Trie 树结构等问题中会再次遇到</li>
</ul>
</li>
<li>最后，由于 Huffman 树的节点权值（频数）可能相等，因此对某些文本，Huffman 编码不唯一。<ul>
<li>左赋 1，右赋 0 或者 左赋 0，右赋 1 都可以。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/%E7%AE%97%E6%B3%95leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/%E7%AE%97%E6%B3%95leetcode/" itemprop="url">算法leetcode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-25T17:40:02-08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/25/%E7%AE%97%E6%B3%95leetcode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/11/25/算法leetcode/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h1><h2 id="按数据结构"><a href="#按数据结构" class="headerlink" title="按数据结构"></a>按数据结构</h2><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h3><p><a href="https://zheng-xing.github.io/2019/11/30/leetcode-string/" target="_blank" rel="noopener">https://zheng-xing.github.io/2019/11/30/leetcode-string/</a></p>
<h3 id="vector-数组"><a href="#vector-数组" class="headerlink" title="vector 数组"></a>vector 数组</h3><h3 id="stack-amp-heap-栈和队列"><a href="#stack-amp-heap-栈和队列" class="headerlink" title="stack &amp; heap 栈和队列"></a>stack &amp; heap 栈和队列</h3><h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><h3 id="tree-amp-graph-树和图"><a href="#tree-amp-graph-树和图" class="headerlink" title="tree &amp; graph 树和图"></a>tree &amp; graph 树和图</h3><h2 id="按算法"><a href="#按算法" class="headerlink" title="按算法"></a>按算法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h3 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h3><h3 id="bfs-amp-dfs"><a href="#bfs-amp-dfs" class="headerlink" title="bfs &amp; dfs"></a>bfs &amp; dfs</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h3 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h3><p><a href="">Leetcode 0315</a></p>
<h2 id="misc-杂"><a href="#misc-杂" class="headerlink" title="misc 杂"></a>misc 杂</h2><h3 id="bit-操作"><a href="#bit-操作" class="headerlink" title="bit 操作"></a>bit 操作</h3><h3 id="O-N-时间"><a href="#O-N-时间" class="headerlink" title="O(N) 时间"></a>O(N) 时间</h3><h3 id="O-1-空间"><a href="#O-1-空间" class="headerlink" title="O(1) 空间"></a>O(1) 空间</h3><h1 id="按题目"><a href="#按题目" class="headerlink" title="按题目"></a>按题目</h1><table>
<thead>
<tr>
<th>题目序号</th>
<th>tag</th>
<th>link</th>
</tr>
</thead>
<tbody><tr>
<td>0005</td>
<td>string</td>
<td><a href="https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9" target="_blank" rel="noopener">https://juejin.im/post/5b8f9aed6fb9a05d2e1b75d9</a></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0005</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>0516</td>
<td>string, dp</td>
<td>???</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-02T16:40:40-07:00">
                2019-08-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/02/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/08/02/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Deal-with-formula"><a href="#Deal-with-formula" class="headerlink" title="Deal with formula"></a>Deal with formula</h3><ol>
<li>For centered formulae, use \\[ and \\] </li>
<li>For inline formular, use \\( and \\).</li>
</ol>
<p>For example, \\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \\] gives: </p>
<p>\[ x = {-b \pm \sqrt{b^2-4ac} \over 2a} \]</p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="Some-useful-sites"><a href="#Some-useful-sites" class="headerlink" title="Some useful sites"></a>Some useful sites</h3><ol start="0">
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">Start Instruction 1</a></li>
<li><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">Start Instruction 2</a></li>
<li><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="noopener">Additional Functionalities</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">Additional Functionalities 2</a></li>
<li><a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Theme Yelee</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Theme next</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/bit-manipulation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/bit-manipulation/" itemprop="url">bit_manipulation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-26T00:44:58-07:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/26/bit-manipulation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/07/26/bit-manipulation/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="WIKI"><a href="#WIKI" class="headerlink" title="WIKI"></a>WIKI</h2><p>Bit manipulation is the act of algorithmically manipulating bits or other pieces of data shorter than a word. Computer programming tasks that require bit manipulation include low-level device control, error detection and correction algorithms, data compression, encryption algorithms, and optimization. For most other tasks, modern programming languages allow the programmer to work directly with abstractions instead of bits that represent those abstractions. Source code that does bit manipulation makes use of the bitwise operations: AND, OR, XOR, NOT, and bit shifts.</p>
<p>Bit manipulation, in some cases, can obviate or reduce the need to loop over a data structure and can give many-fold speed ups, as bit manipulations are processed in parallel, but the code can become more difficult to write and maintain.</p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>At the heart of bit manipulation are the bit-wise operators &amp; (and), | (or), ~ (not) and ^ (exclusive-or, xor) and shift operators a &lt;&lt; b and a &gt;&gt; b.</p>
<pre><code>There is no boolean operator counterpart to bitwise exclusive-or, but there is a simple explanation. 
The exclusive-or operation takes two inputs and returns a 1 if either one or the other of the inputs is a 1, but not if both are. 
That is, if both inputs are 1 or both inputs are 0, it returns 0. 
Bitwise exclusive-or, with the operator of a caret, ^, performs the exclusive-or operation on each pair of bits. 
Exclusive-or is commonly abbreviated XOR.</code></pre><ol>
<li>Set union A | B</li>
<li>Set intersection A &amp; B</li>
<li>Set subtraction A &amp; ~B</li>
<li>Set negation ALL_BITS ^ A or ~A</li>
<li>Set bit A |= 1 &lt;&lt; bit</li>
<li>Clear bit A &amp;= ~(1 &lt;&lt; bit)</li>
<li>Test bit (A &amp; 1 &lt;&lt; bit) != 0</li>
<li>Extract last bit A&amp;-A or A&amp;~(A-1) or x^(x&amp;(x-1))</li>
<li>Remove last bit A&amp;(A-1)</li>
<li>Get all 1-bits ~0</li>
</ol>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><h2 id="Count-the-number-of-ones-in-the-binary-representation-of-the-given-number"><a href="#Count-the-number-of-ones-in-the-binary-representation-of-the-given-number" class="headerlink" title="Count the number of ones in the binary representation of the given number"></a>Count the number of ones in the binary representation of the given number</h2><p>[解法一思路]</p>
<ul>
<li>就是利用 <code>n &amp; (n-1)</code> 可以消除最右边的 <code>1</code> 这个技巧</li>
<li>时间复杂度等于 <code>1</code> 的个数，算 O(k) 吧<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_one</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><mark>一个牛逼的分治思路</mark><br>说它牛逼，倒不是说它优化了多少时间，对于本题来说并没有优化很多，毕竟一般的 int 也就 32 个 bit。<br>但是它的思想确实让我很惊喜！没想到二分的思路还可以这么用！</p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/ScreenShot-20200101132310.png" alt="ScreenShot-20200101132310.png"></p>
<p><img src="https://raw.githubusercontent.com/zheng-xing/ImageStorage/master/ScreenShot-20200101132320.png" alt="ScreenShot-20200101132320.png"></p>
<p>我来解释一下思路！</p>
<ol>
<li>如果原始数字是一个 4 位的二进制数，假设是 1110.</li>
<li>那么我们先用 0101 与它做与操作，得到从右边数第一和第三个位置上的数字是 1 的数量，结果是 0100，表示右数第一个位置上有 0 个 1，右数第三个位置上有 1 个 1.</li>
<li>然后用 1010 与它做与操作，得到从右边数第二和第四个位置上数字是 1 的数量，结果是 1010, 表示右数第二个位置上有 1 个 1，右数第四个位置上有 1 个 1. 把这个 1010 向右 shift 一个位子，得到 0101，然后与上面的 0100 相加，得到 1001. </li>
<li>对 1001 的解释<ol>
<li>前面一半 “10” 代表原始数字的 4 个 bit 中前面两个含有 2 个 1， 后面一半 “01” 表示后面两个 bit 位置上含有 1 个 1.</li>
</ol>
</li>
<li>继续递归，我们需要把 “10” 和 “01” 相加得到 4 个 bit 中一共有多少个 1.</li>
</ol>
<p>[代码二]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HammingWeight</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n = (n &amp; <span class="number">0x55555555</span>) + ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x33333333</span>) + ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Is-power-of-2"><a href="#Is-power-of-2" class="headerlink" title="Is power of 2"></a>Is power of 2</h2><p>[思路]</p>
<ol>
<li>常规的操作是不断着把这个数除以 2，然后判断是否有余数，直到 n 被整除成 1.</li>
<li></li>
</ol>
<h2 id="Is-power-of-four-actually-map-checking-iterative-and-recursive-methods-can-do-the-same"><a href="#Is-power-of-four-actually-map-checking-iterative-and-recursive-methods-can-do-the-same" class="headerlink" title="Is power of four (actually map-checking, iterative and recursive methods can do the same)"></a>Is power of four (actually map-checking, iterative and recursive methods can do the same)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(n&amp;(n<span class="number">-1</span>)) &amp;&amp; (n&amp;<span class="number">0x55555555</span>);</span><br><span class="line">    <span class="comment">//check the 1-bit location;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tricks"><a href="#tricks" class="headerlink" title="^ tricks"></a>^ tricks</h2><ol>
<li>Use ==^== to remove even exactly same numbers and save the odd, or save the distinct bits and remove the same.</li>
<li>Use ==^== and ==&amp;== to add two integers</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>? a:getSum(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>); <span class="comment">//be careful about the terminating condition;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者不用递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">aplusb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> carry = a &amp; b;</span><br><span class="line">            a = a^b; </span><br><span class="line">            b = carry &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example, Given nums = [0, 1, 3] return 2. (Of course, you can do this by math.)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ret ^= i;</span><br><span class="line">        ret ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret^=nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tricks-1"><a href="#tricks-1" class="headerlink" title="| tricks"></a>| tricks</h2><p>Keep as many 1-bits as possible</p>
<p>Find the largest power of 2 (most significant bit in binary form), which is less than or equal to the given number N.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">largest_power</span><span class="params">(<span class="keyword">long</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//changing all right side bits to 1.</span></span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">2</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">4</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">8</span>);</span><br><span class="line">    N = N | (N&gt;&gt;<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> (N+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="amp-tricks"><a href="#amp-tricks" class="headerlink" title="&amp; tricks"></a>&amp; tricks</h2><p>Just selecting certain bits</p>
<p>Reversing the bits in integer</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = ((x &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>) | ((x &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xcccccccc</span>) &gt;&gt; <span class="number">2</span>) | ((x &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt; <span class="number">4</span>) | ((x &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xff00ff00</span>) &gt;&gt; <span class="number">8</span>) | ((x &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">x = ((x &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((x &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m != n)</span><br><span class="line">    &#123;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m&lt;&lt;a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DNA-Application"><a href="#DNA-Application" class="headerlink" title="DNA Application"></a>DNA Application</h2><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<pre><code>For example,
Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,
Return: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;].</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(sLen &lt; <span class="number">11</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">char</span> keyMap[<span class="number">1</span>&lt;&lt;<span class="number">21</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hashKey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) hashKey = (hashKey&lt;&lt;<span class="number">2</span>) | (s[i]-<span class="string">'A'</span>+<span class="number">1</span>)%<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &lt; sLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(keyMap[hashKey = ((hashKey&lt;&lt;<span class="number">2</span>)|(s[i]-<span class="string">'A'</span>+<span class="number">1</span>)%<span class="number">5</span>)&amp;<span class="number">0xfffff</span>]++ == <span class="number">1</span>)</span><br><span class="line">                v.push_back(s.substr(i<span class="number">-9</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>But the above solution can be invalid when repeated sequence appears too many times, in which case we should use ==unordered_map&lt;int, int&gt; keyMap== to replace ==char keyMap[1&lt;&lt;21]{0}== here.</p>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. (bit-counting as a usual way, but here we actually also can adopt sorting and Moore Voting Algorithm)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">8</span>, <span class="built_in">size</span> = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, mask = <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(mask &amp; nums[j]) count++;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="built_in">size</span>/<span class="number">2</span>) ret |= mask;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Given an array of integers, every element appears three times except for one. Find that single one. (Still this type can be solved by bit-counting easily.) But we are going to solve it by ==digital logic design==</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inspired by logical circuit design and boolean algebra;</span></span><br><span class="line"><span class="comment">//counter - unit of 3;</span></span><br><span class="line"><span class="comment">//current   incoming  next</span></span><br><span class="line"><span class="comment">//a b            c    a b</span></span><br><span class="line"><span class="comment">//0 0            0    0 0</span></span><br><span class="line"><span class="comment">//0 1            0    0 1</span></span><br><span class="line"><span class="comment">//1 0            0    1 0</span></span><br><span class="line"><span class="comment">//0 0            1    0 1</span></span><br><span class="line"><span class="comment">//0 1            1    1 0</span></span><br><span class="line"><span class="comment">//1 0            1    0 0</span></span><br><span class="line"><span class="comment">//a = a&amp;~b&amp;~c + ~a&amp;b&amp;c;</span></span><br><span class="line"><span class="comment">//b = ~a&amp;b&amp;~c + ~a&amp;~b&amp;c;</span></span><br><span class="line"><span class="comment">//return a|b since the single number can appear once or twice;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (a&amp;~b&amp;~nums[i]) | (~a&amp;b&amp;nums[i]);</span><br><span class="line">        b = (~a&amp;b&amp;~nums[i]) | (~a&amp;~b&amp;nums[i]);</span><br><span class="line">        a = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a | b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>atttention</p>
<ol>
<li>result after shifting left(or right) too much is undefined</li>
<li>right shifting operations on negative values are undefined</li>
<li>right operand in shifting should be non-negative, otherwise the result is undefined</li>
<li>The &amp; and | operators have lower precedence than comparison operators</li>
</ol>
<h2 id="SETS"><a href="#SETS" class="headerlink" title="SETS"></a>SETS</h2><p>All the subsets</p>
<p>A big advantage of bit manipulation is that it is trivial to iterate over all the subsets of an N-element set: every N-bit value represents some subset. Even better, ==if A is a subset of B then the number representing A is less than that representing B==, which is convenient for some dynamic programming solutions.</p>
<p>It is also possible to iterate over all the subsets of a particular subset (represented by a bit pattern), provided that you don’t mind visiting them in reverse order (if this is problematic, put them in a list as they’re generated, then walk the list backwards). The trick is similar to that for finding the lowest bit in a number. If we subtract 1 from a subset, then the lowest set element is cleared, and every lower element is set. However, we only want to set those lower elements that are in the superset. So the iteration step is just ==i = (i - 1) &amp; superset==.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = nums.<span class="built_in">size</span>(); </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> vv;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span> &lt;&lt; <span class="built_in">size</span>;</span><br><span class="line">    vv.resize(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">size</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j) &amp; i) vv[i].push_back(nums[j]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Actually there are two more methods to handle this using recursion and iteration respectively.</p>
<h2 id="BITSET"><a href="#BITSET" class="headerlink" title="BITSET"></a>BITSET</h2><p>A bitset stores bits (elements with only two possible values: 0 or 1, true or false, …).<br>The class emulates an array of bool elements, but optimized for space allocation: generally, each element occupies only one bit (which, on most systems, is eight times less than the smallest elemental type: char).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitset::count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;         // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;         // std::bitset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; <span class="title">foo</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"10110011"</span>))</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo &lt;&lt; <span class="string">" has "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo.count() &lt;&lt; <span class="string">" ones and "</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (foo.<span class="built_in">size</span>()-foo.count()) &lt;&lt; <span class="string">" zeros.\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitwise-AND-of-Numbers-Range-leetcode-0201"><a href="#bitwise-AND-of-Numbers-Range-leetcode-0201" class="headerlink" title="bitwise AND of Numbers Range leetcode 0201"></a>bitwise AND of Numbers Range leetcode 0201</h2><p>题目描述:<br>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.<br>For example, given the range [5, 7], you should return 4.</p>
<p>分析：<br>这一题实际上就是在找 两个 integer 二进制写法的公共 prefix</p>
<p>The hardest part of this problem is to find the regular pattern.<br>For example, for number 26 to 30<br>Their binary form are:<br>1 1 0 1 0<br>1 1 0 1 1<br>1 1 1 0 0　　<br>1 1 1 0 1　　<br>1 1 1 1 0<br>Because we are trying to find bitwise AND, so if any bit there are at least one 0 and one 1, it always 0. In this case, it is 11000.<br>So we are go to cut all these bit that they are different. In this case we cut the right 3 bit.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (m &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数字出现三次"><a href="#数字出现三次" class="headerlink" title="数字出现三次"></a>数字出现三次</h2><p>参考文章 “leetcode 数组” 里面的例题 “出现 3 次的数 leetcode 137”</p>
<h3 id="引申题-老鼠喝药"><a href="#引申题-老鼠喝药" class="headerlink" title="引申题 老鼠喝药"></a>引申题 老鼠喝药</h3><p>[题目]<br>有 100 瓶液体，编号 1 到 100，其中有 99 瓶水和 1 瓶毒药。<br>如果老鼠喝了毒药，那么会在一周后死亡。请问你最少用几只老鼠可以最快的检测出哪一瓶是毒药？</p>
<p>[思路]<br>这一引申题的思路跟上面的一个按位置计算的解法非常相似。这里也是按照 bit 位来看的。</p>
<p>我们把这编号 1 到 100 一共 100 个数字用二进制写出来，每个数字都写成长度为 7 位的二进制数 (2^7 = 128 &gt; 100)，左边补零如果不够七位。</p>
<p>现在我们让七只老鼠，第一只老鼠去喝最左边的 bit 位上是 1 的那些瓶的液体，第二只老鼠喝左数第二 bit 位上是 1 的那些瓶子的液体，以此类推。</p>
<p>一周以后，如果第一只老鼠死了，那么有毒药的那瓶液体的编号在最左边 bit 位一定是 1，反之是 0. 同理可以得到 7 个 bit 位上是 1 还是 0.</p>
<p><mark>[其他思考]</mark></p>
<ol>
<li><mark>如果没有时间限制的话，那么就可以用我们熟悉的二分思想，就跟用天平找出来一堆球里面重量跟其他不同的那个题似的。</mark><ol>
<li>先让一只老鼠喝编号 1-50 的那些瓶液体.</li>
<li>如果死了，就递归找第二只老鼠喝 1-25 瓶液体，如果没死就找第二只老鼠喝 51-75 那些瓶液体。</li>
<li>同样的，也是最多需要 7 只老鼠就可以发现。</li>
</ol>
</li>
<li>因此，这里因为有了时间上的限制，我们需要对每个 bit 位分别考虑，就可以对所有的 bit 位<mark>并行计算</mark>。没有时间限制就对所有的瓶子串行得二分计算！</li>
<li>我其实对于上面的解法有点疑惑就是为啥非得用 2 进制来表示数字呢？如果用 3 进制来表示的话，那么对于每一个 bit 位 我们需要找 2 只老鼠，一只老鼠喝最左边 bit 位是 1 的液体，一个老鼠喝 最左边 bit 位是 2 的液体，根据它们两个老鼠是否死亡的信息，可以判断最左边 bit 位上是 0，1，还是 2.<ol>
<li>好像想清楚了！如果是三进制，那么每一个 bit 位上一个老鼠是否死亡只能排除掉 1/3 的可能。而使用二进制的话则可以排除掉 50% 的可能。因为老鼠是否死亡只有两种可能，因此使用二进制已经是最佳的方案了！！！</li>
</ol>
</li>
<li>另外参考 <a href="https://zheng-xing.github.io/2019/12/04/leetcode-%E6%95%B0%E7%BB%84/" target="_blank" rel="noopener">leetcode-数组</a> 一文中 binary index tree 和 segment tree 的思想！</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/%E4%B9%92%E4%B9%93%E7%90%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zheng Xing">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/%E4%B9%92%E4%B9%93%E7%90%83/" itemprop="url">乒乓球.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-04T23:24:22-07:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hobby/" itemprop="url" rel="index">
                    <span itemprop="name">hobby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/04/%E4%B9%92%E4%B9%93%E7%90%83/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/04/乒乓球/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="接发球"><a href="#接发球" class="headerlink" title="接发球"></a>接发球</h1><ol>
<li><p>张继科逆旋转发球四种旋转</p>
<div class="video-container">
 <!-- <iframe width="1280" height="720" src="https://www.youtube.com/watch?v=uKLTkFGCxSo" frameborder="0" allowfullscreen>
 </iframe> -->
 <iframe width="560" height="315" src="https://www.youtube.com/embed/uKLTkFGCxSo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
</li>
<li><p>如何发好逆旋转侧下旋<br>两个要点：<br>第一，要注意球拍的摆放，一定要往下压平一点。这样才能摩擦球的下部。<br>第二，要注意发力的动作。很多时候球友只注意了侧向的摩擦，这个会造成只有侧旋。一定要有球拍往前送的动作，这样子才会造成下旋。</p>
<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/2rruw3rld5E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
</li>
<li><p>急长下旋球<br>要点：<br>第一，触球的中下位置，不仅要有摩擦，还要有向前推送/弹击得感觉。<br>第二，第一个落点在靠近自己的位置。</p>
<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/6QHF_wv5BhU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
</li>
<li><p>直板发纯下旋球<br>一定要体会兜底的感觉！</p>
<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/HUMVoIDuLMQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
</li>
<li><p>勾手的上旋球<br>这个动作的欺骗性很强：第一个是因为看起来好像往前摩擦球的下面，有点下旋；第二个再加上球的弧线很低，就容易产生“嗯，确实是下旋的错觉”，然后就冒高了。</p>
<div class="video-container">
<iframe width="560" height="315" src="https://www.youtube.com/embed/F_rKsfAJX3I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>

</li>
</ol>
<h1 id="技战术"><a href="#技战术" class="headerlink" title="技战术"></a>技战术</h1><h1 id="器材篇"><a href="#器材篇" class="headerlink" title="器材篇"></a>器材篇</h1><h2 id="底板"><a href="#底板" class="headerlink" title="底板"></a>底板</h2><p>目前我用的装备是斯蒂卡纳米OC，其特点描述如下：</p>
<ol>
<li>轻量级5层全能型底板，具有出色的手感和控制力。基于经典轻量级进攻型OC系列的升级款，快攻下的全方位控制力，为现代科技乒乓设计。NCT科技在实现了更强击打力量的同时保证控制力不减。世界冠军许昕曾用。</li>
<li>与一般的纯木板有所不同，纳米OFFENSIVE WOOD有着超乎寻常的出球速度。<br>特别是当你发力达到一定程度后，出球弧线骤然降低，出球速度大幅提升，以迅雷不及掩耳之势撕开对手的防线。<br>使用它，你甚至可以用相当柔和的手法把一片没有灌过胶的狂飙轻松打透，并令其发出振聋发聩的声响。<br>既易于上手又易于发力的特性，必将使其成为业余与专业选手无机时代最有力的得分武器。</li>
</ol>
<p>而传统的OC是最能够代表乒乓球弧圈时代的经典底板。球拍受冲击后产生的大幅形变，使选手有充分的时间对球进行摩擦。形变产生的储能，使球具有强烈的冲击性。使OC成为中远台冲高进攻选手的青睐。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/%5C/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/%5C/">1</a><span class="page-number current">2</span><a class="page-number" href="/%5C/page/3/">3</a><a class="page-number" href="/%5C/page/4/">4</a><a class="extend next" rel="next" href="/%5C/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Zheng Xing" />
            
              <p class="site-author-name" itemprop="name">Zheng Xing</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zheng Xing</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://githubio-2.disqus.com/count.js" async></script>
    

    

  




	





  











<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
